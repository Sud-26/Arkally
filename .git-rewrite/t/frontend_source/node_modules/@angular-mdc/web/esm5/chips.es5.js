/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { InjectionToken, Component, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, NgZone, ChangeDetectorRef, Optional, Inject, Input, Output, ContentChild, ContentChildren, forwardRef, Attribute, Directive, EventEmitter, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MdcIconRegistry, MDC_ICON_LOCATION, MdcIcon, MdcIconModule } from '@angular-mdc/web/icon';
import { __extends } from 'tslib';
import { fromEvent, Subject, merge } from 'rxjs';
import { takeUntil, startWith } from 'rxjs/operators';
import { toBoolean, Platform } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { NgForm, FormGroupDirective, NgControl } from '@angular/forms';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
var strings = {
  ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
  INTERACTION_EVENT: 'MDCChip:interaction',
  SELECTION_EVENT: 'MDCChip:selection',
  TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
  REMOVAL_EVENT: 'MDCChip:removal',
  CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
  LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
  TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
};
/** @enum {string} */

var cssClasses = {
  CHECKMARK: 'mdc-chip__checkmark',
  CHIP_EXIT: 'mdc-chip--exit',
  HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
  LEADING_ICON: 'mdc-chip__icon--leading',
  TRAILING_ICON: 'mdc-chip__icon--trailing',
  SELECTED: 'mdc-chip--selected'
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
var MDCFoundation =
/*#__PURE__*/
function () {
  _createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }
    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }
    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }
    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }
    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  _createClass(MDCFoundation, [{
    key: "init",
    value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
    }
  }, {
    key: "destroy",
    value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    }
  }]);

  return MDCFoundation;
}();

/**
 * @template F
 */

var MDCComponent =
/*#__PURE__*/
function () {
  _createClass(MDCComponent, null, [{
    key: "attachTo",

    /**
     * @param {!Element} root
     * @return {!MDCComponent}
     */
    value: function attachTo(root) {
      // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
      // returns an instantiated component with its root set to that element. Also note that in the cases of
      // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
      // from getDefaultFoundation().
      return new MDCComponent(root, new MDCFoundation());
    }
    /**
     * @param {!Element} root
     * @param {F=} foundation
     * @param {...?} args
     */

  }]);

  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.

    /** @protected {!F} */

    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  _createClass(MDCComponent, [{
    key: "initialize",
    value: function initialize()
    /* ...args */
    {} // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.

    /**
     * @return {!F} foundation
     */

  }, {
    key: "getDefaultFoundation",
    value: function getDefaultFoundation() {
      // Subclasses must override this method to return a properly configured foundation class for the
      // component.
      throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    }
  }, {
    key: "initialSyncWithDOM",
    value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
      // object. An example of this would be a form control wrapper that needs to synchronize its internal state
      // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
      // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // Subclasses may implement this method to release any resources / deregister any listeners they have
      // attached. An example of this might be deregistering a resize event from the window object.
      this.foundation_.destroy();
    }
    /**
     * Wrapper method to add an event listener to the component's root element. This is most useful when
     * listening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "listen",
    value: function listen(evtType, handler) {
      this.root_.addEventListener(evtType, handler);
    }
    /**
     * Wrapper method to remove an event listener to the component's root element. This is most useful when
     * unlistening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "unlisten",
    value: function unlisten(evtType, handler) {
      this.root_.removeEventListener(evtType, handler);
    }
    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type,
     * with the given data.
     * @param {string} evtType
     * @param {!Object} evtData
     * @param {boolean=} shouldBubble
     */

  }, {
    key: "emit",
    value: function emit(evtType, evtData) {
      var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var evt;

      if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
          detail: evtData,
          bubbles: shouldBubble
        });
      } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }

      this.root_.dispatchEvent(evt);
    }
  }]);

  return MDCComponent;
}();

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Ripple. Provides an interface for managing
 * - classes
 * - dom
 * - CSS variables
 * - position
 * - dimensions
 * - scroll position
 * - event handlers
 * - unbounded, active and disabled states
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCRippleAdapter =
/*#__PURE__*/
function () {
  function MDCRippleAdapter() {
    _classCallCheck(this, MDCRippleAdapter);
  }

  _createClass(MDCRippleAdapter, [{
    key: "browserSupportsCssVars",

    /** @return {boolean} */
    value: function browserSupportsCssVars() {}
    /** @return {boolean} */

  }, {
    key: "isUnbounded",
    value: function isUnbounded() {}
    /** @return {boolean} */

  }, {
    key: "isSurfaceActive",
    value: function isSurfaceActive() {}
    /** @return {boolean} */

  }, {
    key: "isSurfaceDisabled",
    value: function isSurfaceDisabled() {}
    /** @param {string} className */

  }, {
    key: "addClass",
    value: function addClass(className) {}
    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}
    /** @param {!EventTarget} target */

  }, {
    key: "containsEventTarget",
    value: function containsEventTarget(target) {}
    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(evtType, handler) {}
    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}
    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerDocumentInteractionHandler",
    value: function registerDocumentInteractionHandler(evtType, handler) {}
    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterDocumentInteractionHandler",
    value: function deregisterDocumentInteractionHandler(evtType, handler) {}
    /**
     * @param {!Function} handler
     */

  }, {
    key: "registerResizeHandler",
    value: function registerResizeHandler(handler) {}
    /**
     * @param {!Function} handler
     */

  }, {
    key: "deregisterResizeHandler",
    value: function deregisterResizeHandler(handler) {}
    /**
     * @param {string} varName
     * @param {?number|string} value
     */

  }, {
    key: "updateCssVariable",
    value: function updateCssVariable(varName, value) {}
    /** @return {!ClientRect} */

  }, {
    key: "computeBoundingRect",
    value: function computeBoundingRect() {}
    /** @return {{x: number, y: number}} */

  }, {
    key: "getWindowPageOffset",
    value: function getWindowPageOffset() {}
  }]);

  return MDCRippleAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$1 = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
};
var strings$1 = {
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
};
var numbers = {
  PADDING: 10,
  INITIAL_ORIGIN_SCALE: 0.6,
  DEACTIVATION_TIMEOUT_MS: 225,
  // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
  FG_DEACTIVATION_MS: 150,
  // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
 * @private {boolean|undefined}
 */
var supportsCssVariables_;
/**
 * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
 * @private {boolean|undefined}
 */

var supportsPassive_;
/**
 * @param {!Window} windowObj
 * @return {boolean}
 */

function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  var document = windowObj.document;
  var node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

  var computedStyle = windowObj.getComputedStyle(node);
  var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
  node.remove();
  return hasPseudoVarBug;
}
/**
 * @param {!Window} windowObj
 * @param {boolean=} forceRefresh
 * @return {boolean|undefined}
 */


function supportsCssVariables(windowObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var supportsCssVariables = supportsCssVariables_;

  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables;
  }

  var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

  if (!supportsFunctionPresent) {
    return;
  }

  var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari

  var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVariables = false;
  }

  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVariables;
  }

  return supportsCssVariables;
} //

/**
 * Determine whether the current browser supports passive event listeners, and if so, use them.
 * @param {!Window=} globalObj
 * @param {boolean=} forceRefresh
 * @return {boolean|!EventListenerOptions}
 */


function applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;

    try {
      globalObj.document.addEventListener('test', null, {
        get passive() {
          isSupported = true;
          return isSupported;
        }

      });
    } catch (e) {}

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ?
  /** @type {!EventListenerOptions} */
  {
    passive: true
  } : false;
}
/**
 * @param {!Object} HTMLElementPrototype
 * @return {string}
 */


function getMatchesProperty(HTMLElementPrototype) {
  /**
   * Order is important because we return the first existing method we find.
   * Do not change the order of the items in the below array.
   */
  var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
  var method = 'matches';

  for (var i = 0; i < matchesMethods.length; i++) {
    var matchesMethod = matchesMethods[i];

    if (matchesMethod in HTMLElementPrototype) {
      method = matchesMethod;
      break;
    }
  }

  return method;
}
/**
 * @param {!Event} ev
 * @param {{x: number, y: number}} pageOffset
 * @param {!ClientRect} clientRect
 * @return {{x: number, y: number}}
 */


function getNormalizedEventCoords(ev, pageOffset, clientRect) {
  var x = pageOffset.x,
      y = pageOffset.y;
  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;
  var normalizedX;
  var normalizedY; // Determine touch point relative to the ripple container.

  if (ev.type === 'touchstart') {
    ev =
    /** @type {!TouchEvent} */
    ev;
    normalizedX = ev.changedTouches[0].pageX - documentX;
    normalizedY = ev.changedTouches[0].pageY - documentY;
  } else {
    ev =
    /** @type {!MouseEvent} */
    ev;
    normalizedX = ev.pageX - documentX;
    normalizedY = ev.pageY - documentY;
  }

  return {
    x: normalizedX,
    y: normalizedY
  };
}

var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

/** @type {!Array<!EventTarget>} */

var activatedTargets = [];
/**
 * @extends {MDCFoundation<!MDCRippleAdapter>}
 */

var MDCRippleFoundation =
/*#__PURE__*/
function (_MDCFoundation) {
  _inherits(MDCRippleFoundation, _MDCFoundation);

  _createClass(MDCRippleFoundation, null, [{
    key: "cssClasses",
    get: function get() {
      return cssClasses$1;
    }
  }, {
    key: "strings",
    get: function get() {
      return strings$1;
    }
  }, {
    key: "numbers",
    get: function get() {
      return numbers;
    }
  }, {
    key: "defaultAdapter",
    get: function get() {
      return {
        browserSupportsCssVars: function browserSupportsCssVars()
        /* boolean - cached */
        {},
        isUnbounded: function isUnbounded()
        /* boolean */
        {},
        isSurfaceActive: function isSurfaceActive()
        /* boolean */
        {},
        isSurfaceDisabled: function isSurfaceDisabled()
        /* boolean */
        {},
        addClass: function addClass()
        /* className: string */
        {},
        removeClass: function removeClass()
        /* className: string */
        {},
        containsEventTarget: function containsEventTarget()
        /* target: !EventTarget */
        {},
        registerInteractionHandler: function registerInteractionHandler()
        /* evtType: string, handler: EventListener */
        {},
        deregisterInteractionHandler: function deregisterInteractionHandler()
        /* evtType: string, handler: EventListener */
        {},
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
        /* evtType: string, handler: EventListener */
        {},
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
        /* evtType: string, handler: EventListener */
        {},
        registerResizeHandler: function registerResizeHandler()
        /* handler: EventListener */
        {},
        deregisterResizeHandler: function deregisterResizeHandler()
        /* handler: EventListener */
        {},
        updateCssVariable: function updateCssVariable()
        /* varName: string, value: string */
        {},
        computeBoundingRect: function computeBoundingRect()
        /* ClientRect */
        {},
        getWindowPageOffset: function getWindowPageOffset()
        /* {x: number, y: number} */
        {}
      };
    }
  }]);

  function MDCRippleFoundation(adapter) {
    var _this;

    _classCallCheck(this, MDCRippleFoundation);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
    /** @private {number} */

    _this.layoutFrame_ = 0;
    /** @private {!ClientRect} */

    _this.frame_ =
    /** @type {!ClientRect} */
    {
      width: 0,
      height: 0
    };
    /** @private {!ActivationStateType} */

    _this.activationState_ = _this.defaultActivationState_();
    /** @private {number} */

    _this.initialSize_ = 0;
    /** @private {number} */

    _this.maxRadius_ = 0;
    /** @private {function(!Event)} */

    _this.activateHandler_ = function (e) {
      return _this.activate_(e);
    };
    /** @private {function(!Event=)} */


    _this.deactivateHandler_ = function () {
      return _this.deactivate_();
    };
    /** @private {function(!Event=)} */


    _this.focusHandler_ = function () {
      return _this.handleFocus();
    };
    /** @private {function(!Event=)} */


    _this.blurHandler_ = function () {
      return _this.handleBlur();
    };
    /** @private {!Function} */


    _this.resizeHandler_ = function () {
      return _this.layout();
    };
    /** @private {{left: number, top:number}} */


    _this.unboundedCoords_ = {
      left: 0,
      top: 0
    };
    /** @private {number} */

    _this.fgScale_ = 0;
    /** @private {number} */

    _this.activationTimer_ = 0;
    /** @private {number} */

    _this.fgDeactivationRemovalTimer_ = 0;
    /** @private {boolean} */

    _this.activationAnimationHasEnded_ = false;
    /** @private {!Function} */

    _this.activationTimerCallback_ = function () {
      _this.activationAnimationHasEnded_ = true;

      _this.runDeactivationUXLogicIfReady_();
    };
    /** @private {!Event|undefined} */


    _this.previousActivationEvent_;
    return _this;
  }
  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   * @return {boolean}
   * @private
   */


  _createClass(MDCRippleFoundation, [{
    key: "supportsPressRipple_",
    value: function supportsPressRipple_() {
      return this.adapter_.browserSupportsCssVars();
    }
    /**
     * @return {!ActivationStateType}
     */

  }, {
    key: "defaultActivationState_",
    value: function defaultActivationState_() {
      return {
        isActivated: false,
        hasDeactivationUXRun: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false,
        activationEvent: undefined,
        isProgrammatic: false
      };
    }
    /** @override */

  }, {
    key: "init",
    value: function init() {
      var _this2 = this;

      var supportsPressRipple = this.supportsPressRipple_();
      this.registerRootHandlers_(supportsPressRipple);

      if (supportsPressRipple) {
        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);

          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


            _this2.layoutInternal_();
          }
        });
      }
    }
    /** @override */

  }, {
    key: "destroy",
    value: function destroy() {
      var _this3 = this;

      if (this.supportsPressRipple_()) {
        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
        }

        if (this.fgDeactivationRemovalTimer_) {
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.fgDeactivationRemovalTimer_ = 0;
          this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
        }

        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);

          _this3.adapter_.removeClass(UNBOUNDED);

          _this3.removeCssVars_();
        });
      }

      this.deregisterRootHandlers_();
      this.deregisterDeactivationHandlers_();
    }
    /**
     * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
     * @private
     */

  }, {
    key: "registerRootHandlers_",
    value: function registerRootHandlers_(supportsPressRipple) {
      var _this4 = this;

      if (supportsPressRipple) {
        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });

        if (this.adapter_.isUnbounded()) {
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }

      this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
      this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
    }
    /**
     * @param {!Event} e
     * @private
     */

  }, {
    key: "registerDeactivationHandlers_",
    value: function registerDeactivationHandlers_(e) {
      var _this5 = this;

      if (e.type === 'keydown') {
        this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
      } else {
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
        });
      }
    }
    /** @private */

  }, {
    key: "deregisterRootHandlers_",
    value: function deregisterRootHandlers_() {
      var _this6 = this;

      ACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
      });
      this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
      this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

      if (this.adapter_.isUnbounded()) {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }
    /** @private */

  }, {
    key: "deregisterDeactivationHandlers_",
    value: function deregisterDeactivationHandlers_() {
      var _this7 = this;

      this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
      });
    }
    /** @private */

  }, {
    key: "removeCssVars_",
    value: function removeCssVars_() {
      var _this8 = this;

      var strings = MDCRippleFoundation.strings;
      Object.keys(strings).forEach(function (k) {
        if (k.indexOf('VAR_') === 0) {
          _this8.adapter_.updateCssVariable(strings[k], null);
        }
      });
    }
    /**
     * @param {!Event=} e
     * @private
     */

  }, {
    key: "activate_",
    value: function activate_(e) {
      var _this9 = this;

      if (this.adapter_.isSurfaceDisabled()) {
        return;
      }

      var activationState = this.activationState_;

      if (activationState.isActivated) {
        return;
      } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


      var previousActivationEvent = this.previousActivationEvent_;
      var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

      if (isSameInteraction) {
        return;
      }

      activationState.isActivated = true;
      activationState.isProgrammatic = e === undefined;
      activationState.activationEvent = e;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
      var hasActivatedChild = e !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
        return _this9.adapter_.containsEventTarget(target);
      });

      if (hasActivatedChild) {
        // Immediately reset activation state, while preserving logic that prevents touch follow-on events
        this.resetActivationState_();
        return;
      }

      if (e !== undefined) {
        activatedTargets.push(
        /** @type {!EventTarget} */
        e.target);
        this.registerDeactivationHandlers_(e);
      }

      activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

      if (activationState.wasElementMadeActive) {
        this.animateActivation_();
      }

      requestAnimationFrame(function () {
        // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
        activatedTargets = [];

        if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
          // If space was pressed, try again within an rAF call to detect :active, because different UAs report
          // active states inconsistently when they're called within event handling code:
          // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
          // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
          // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
          // variable is set within a rAF callback for a submit button interaction (#2241).
          activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            _this9.animateActivation_();
          }
        }

        if (!activationState.wasElementMadeActive) {
          // Reset activation state immediately if element was not made active.
          _this9.activationState_ = _this9.defaultActivationState_();
        }
      });
    }
    /**
     * @param {!Event=} e
     * @private
     */

  }, {
    key: "checkElementMadeActive_",
    value: function checkElementMadeActive_(e) {
      return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
    }
    /**
     * @param {!Event=} event Optional event containing position information.
     */

  }, {
    key: "activate",
    value: function activate(event) {
      this.activate_(event);
    }
    /** @private */

  }, {
    key: "animateActivation_",
    value: function animateActivation_() {
      var _this10 = this;

      var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
          VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
          VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
      var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
          FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
          FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal_();
      var translateStart = '';
      var translateEnd = '';

      if (!this.adapter_.isUnbounded()) {
        var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
            startPoint = _this$getFgTranslatio.startPoint,
            endPoint = _this$getFgTranslatio.endPoint;

        translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
        translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
      }

      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

      clearTimeout(this.activationTimer_);
      clearTimeout(this.fgDeactivationRemovalTimer_);
      this.rmBoundedActivationClasses_();
      this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

      this.adapter_.computeBoundingRect();
      this.adapter_.addClass(FG_ACTIVATION);
      this.activationTimer_ = setTimeout(function () {
        return _this10.activationTimerCallback_();
      }, DEACTIVATION_TIMEOUT_MS);
    }
    /**
     * @private
     * @return {{startPoint: PointType, endPoint: PointType}}
     */

  }, {
    key: "getFgTranslationCoordinates_",
    value: function getFgTranslationCoordinates_() {
      var _this$activationState = this.activationState_,
          activationEvent = _this$activationState.activationEvent,
          wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
      var startPoint;

      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords(
        /** @type {!Event} */
        activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame_.width / 2,
          y: this.frame_.height / 2
        };
      } // Center the element around the start point.


      startPoint = {
        x: startPoint.x - this.initialSize_ / 2,
        y: startPoint.y - this.initialSize_ / 2
      };
      var endPoint = {
        x: this.frame_.width / 2 - this.initialSize_ / 2,
        y: this.frame_.height / 2 - this.initialSize_ / 2
      };
      return {
        startPoint: startPoint,
        endPoint: endPoint
      };
    }
    /** @private */

  }, {
    key: "runDeactivationUXLogicIfReady_",
    value: function runDeactivationUXLogicIfReady_() {
      var _this11 = this;

      // This method is called both when a pointing device is released, and when the activation animation ends.
      // The deactivation animation should only run after both of those occur.
      var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
      var _this$activationState2 = this.activationState_,
          hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
          isActivated = _this$activationState2.isActivated;
      var activationHasEnded = hasDeactivationUXRun || !isActivated;

      if (activationHasEnded && this.activationAnimationHasEnded_) {
        this.rmBoundedActivationClasses_();
        this.adapter_.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer_ = setTimeout(function () {
          _this11.adapter_.removeClass(FG_DEACTIVATION);
        }, numbers.FG_DEACTIVATION_MS);
      }
    }
    /** @private */

  }, {
    key: "rmBoundedActivationClasses_",
    value: function rmBoundedActivationClasses_() {
      var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
      this.adapter_.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded_ = false;
      this.adapter_.computeBoundingRect();
    }
  }, {
    key: "resetActivationState_",
    value: function resetActivationState_() {
      var _this12 = this;

      this.previousActivationEvent_ = this.activationState_.activationEvent;
      this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
      // Store the previous event until it's safe to assume that subsequent events are for new interactions.

      setTimeout(function () {
        return _this12.previousActivationEvent_ = undefined;
      }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
    }
    /**
     * @private
     */

  }, {
    key: "deactivate_",
    value: function deactivate_() {
      var _this13 = this;

      var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

      if (!activationState.isActivated) {
        return;
      }

      var state =
      /** @type {!ActivationStateType} */
      Object.assign({}, activationState);

      if (activationState.isProgrammatic) {
        requestAnimationFrame(function () {
          return _this13.animateDeactivation_(state);
        });
        this.resetActivationState_();
      } else {
        this.deregisterDeactivationHandlers_();
        requestAnimationFrame(function () {
          _this13.activationState_.hasDeactivationUXRun = true;

          _this13.animateDeactivation_(state);

          _this13.resetActivationState_();
        });
      }
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.deactivate_();
    }
    /**
     * @param {!ActivationStateType} options
     * @private
     */

  }, {
    key: "animateDeactivation_",
    value: function animateDeactivation_(_ref) {
      var wasActivatedByPointer = _ref.wasActivatedByPointer,
          wasElementMadeActive = _ref.wasElementMadeActive;

      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady_();
      }
    }
  }, {
    key: "layout",
    value: function layout() {
      var _this14 = this;

      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }

      this.layoutFrame_ = requestAnimationFrame(function () {
        _this14.layoutInternal_();

        _this14.layoutFrame_ = 0;
      });
    }
    /** @private */

  }, {
    key: "layoutInternal_",
    value: function layoutInternal_() {
      var _this15 = this;

      this.frame_ = this.adapter_.computeBoundingRect();
      var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
      // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
      // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
      // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
      // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
      // `overflow: hidden`.

      var getBoundedRadius = function getBoundedRadius() {
        var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
        return hypotenuse + MDCRippleFoundation.numbers.PADDING;
      };

      this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

      this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
      this.fgScale_ = this.maxRadius_ / this.initialSize_;
      this.updateLayoutCssVars_();
    }
    /** @private */

  }, {
    key: "updateLayoutCssVars_",
    value: function updateLayoutCssVars_() {
      var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
          VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
          VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
          VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
          VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
      this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
      this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

      if (this.adapter_.isUnbounded()) {
        this.unboundedCoords_ = {
          left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
          top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
        };
        this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
        this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
      }
    }
    /** @param {boolean} unbounded */

  }, {
    key: "setUnbounded",
    value: function setUnbounded(unbounded) {
      var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

      if (unbounded) {
        this.adapter_.addClass(UNBOUNDED);
      } else {
        this.adapter_.removeClass(UNBOUNDED);
      }
    }
  }, {
    key: "handleFocus",
    value: function handleFocus() {
      var _this16 = this;

      requestAnimationFrame(function () {
        return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    }
  }, {
    key: "handleBlur",
    value: function handleBlur() {
      var _this17 = this;

      requestAnimationFrame(function () {
        return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    }
  }]);

  return MDCRippleFoundation;
}(MDCFoundation);

/**
 * @extends MDCComponent<!MDCRippleFoundation>
 */

var MDCRipple =
/*#__PURE__*/
function (_MDCComponent) {
  _inherits(MDCRipple, _MDCComponent);

  /** @param {...?} args */
  function MDCRipple() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, MDCRipple);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
    /** @type {boolean} */

    _this.disabled = false;
    /** @private {boolean} */

    _this.unbounded_;
    return _this;
  }
  /**
   * @param {!Element} root
   * @param {{isUnbounded: (boolean|undefined)}=} options
   * @return {!MDCRipple}
   */


  _createClass(MDCRipple, [{
    key: "setUnbounded_",

    /**
     * Closure Compiler throws an access control error when directly accessing a
     * protected or private property inside a getter/setter, like unbounded above.
     * By accessing the protected property inside a method, we solve that problem.
     * That's why this function exists.
     * @private
     */
    value: function setUnbounded_() {
      this.foundation_.setUnbounded(this.unbounded_);
    }
  }, {
    key: "activate",
    value: function activate() {
      this.foundation_.activate();
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.foundation_.deactivate();
    }
  }, {
    key: "layout",
    value: function layout() {
      this.foundation_.layout();
    }
    /**
     * @return {!MDCRippleFoundation}
     * @override
     */

  }, {
    key: "getDefaultFoundation",
    value: function getDefaultFoundation() {
      return new MDCRippleFoundation(MDCRipple.createAdapter(this));
    }
    /** @override */

  }, {
    key: "initialSyncWithDOM",
    value: function initialSyncWithDOM() {
      this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
    }
  }, {
    key: "unbounded",

    /** @return {boolean} */
    get: function get() {
      return this.unbounded_;
    }
    /** @param {boolean} unbounded */
    ,
    set: function set(unbounded) {
      this.unbounded_ = Boolean(unbounded);
      this.setUnbounded_();
    }
  }], [{
    key: "attachTo",
    value: function attachTo(root) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$isUnbounded = _ref.isUnbounded,
          isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

      var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

      if (isUnbounded !== undefined) {
        ripple.unbounded =
        /** @type {boolean} */
        isUnbounded;
      }

      return ripple;
    }
    /**
     * @param {!RippleCapableSurface} instance
     * @return {!MDCRippleAdapter}
     */

  }, {
    key: "createAdapter",
    value: function createAdapter(instance) {
      var MATCHES = getMatchesProperty(HTMLElement.prototype);
      return {
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return instance.unbounded;
        },
        isSurfaceActive: function isSurfaceActive() {
          return instance.root_[MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return instance.disabled;
        },
        addClass: function addClass(className) {
          return instance.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return instance.root_.classList.remove(className);
        },
        containsEventTarget: function containsEventTarget(target) {
          return instance.root_.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          return instance.root_.addEventListener(evtType, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          return instance.root_.removeEventListener(evtType, handler, applyPassive());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          return instance.root_.style.setProperty(varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return instance.root_.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return {
            x: window.pageXOffset,
            y: window.pageYOffset
          };
        }
      };
    }
  }]);

  return MDCRipple;
}(MDCComponent);
/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */


var RippleCapableSurface = function RippleCapableSurface() {
  _classCallCheck(this, RippleCapableSurface);
};
/** @protected {!Element} */


RippleCapableSurface.prototype.root_;
/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */

RippleCapableSurface.prototype.unbounded;
/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */

RippleCapableSurface.prototype.disabled;

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Chip.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Chip into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCChipAdapter =
/*#__PURE__*/
function () {
  function MDCChipAdapter() {
    _classCallCheck(this, MDCChipAdapter);
  }

  _createClass(MDCChipAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the root element.
     * @param {string} className
     */
    value: function addClass(className) {}
    /**
     * Removes a class from the root element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}
    /**
     * Returns true if the root element contains the given class.
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}
    /**
     * Adds a class to the leading icon element.
     * @param {string} className
     */

  }, {
    key: "addClassToLeadingIcon",
    value: function addClassToLeadingIcon(className) {}
    /**
     * Removes a class from the leading icon element.
     * @param {string} className
     */

  }, {
    key: "removeClassFromLeadingIcon",
    value: function removeClassFromLeadingIcon(className) {}
    /**
     * Returns true if target has className, false otherwise.
     * @param {!EventTarget} target
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "eventTargetHasClass",
    value: function eventTargetHasClass(target, className) {}
    /**
     * Emits a custom "MDCChip:interaction" event denoting the chip has been
     * interacted with (typically on click or keydown).
     */

  }, {
    key: "notifyInteraction",
    value: function notifyInteraction() {}
    /**
     * Emits a custom "MDCChip:selection" event denoting the chip has been selected or deselected.
     * @param {boolean} selected
     */

  }, {
    key: "notifySelection",
    value: function notifySelection(selected) {}
    /**
     * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
     * interacted with (typically on click or keydown).
     */

  }, {
    key: "notifyTrailingIconInteraction",
    value: function notifyTrailingIconInteraction() {}
    /**
     * Emits a custom event "MDCChip:removal" denoting the chip will be removed.
     */

  }, {
    key: "notifyRemoval",
    value: function notifyRemoval() {}
    /**
     * Returns the computed property value of the given style property on the root element.
     * @param {string} propertyName
     * @return {string}
     */

  }, {
    key: "getComputedStyleValue",
    value: function getComputedStyleValue(propertyName) {}
    /**
     * Sets the property value of the given style property on the root element.
     * @param {string} propertyName
     * @param {string} value
     */

  }, {
    key: "setStyleProperty",
    value: function setStyleProperty(propertyName, value) {}
    /**
     * Returns whether the chip has a leading icon.
     * @return {boolean}
     */

  }, {
    key: "hasLeadingIcon",
    value: function hasLeadingIcon() {}
    /**
     * Returns the bounding client rect of the root element.
     * @return {!ClientRect}
     */

  }, {
    key: "getRootBoundingClientRect",
    value: function getRootBoundingClientRect() {}
    /**
     * Returns the bounding client rect of the checkmark element or null if it doesn't exist.
     * @return {?ClientRect}
     */

  }, {
    key: "getCheckmarkBoundingClientRect",
    value: function getCheckmarkBoundingClientRect() {}
  }]);

  return MDCChipAdapter;
}();

/**
 * @extends {MDCFoundation<!MDCChipAdapter>}
 * @final
 */

var MDCChipFoundation =
/*#__PURE__*/
function (_MDCFoundation) {
  _inherits(MDCChipFoundation, _MDCFoundation);

  _createClass(MDCChipFoundation, null, [{
    key: "strings",

    /** @return enum {string} */
    get: function get() {
      return strings;
    }
    /** @return enum {string} */

  }, {
    key: "cssClasses",
    get: function get() {
      return cssClasses;
    }
    /**
     * {@see MDCChipAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCChipAdapter}
     */

  }, {
    key: "defaultAdapter",
    get: function get() {
      return (
        /** @type {!MDCChipAdapter} */
        {
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          addClassToLeadingIcon: function addClassToLeadingIcon() {},
          removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
          eventTargetHasClass: function eventTargetHasClass() {},
          notifyInteraction: function notifyInteraction() {},
          notifySelection: function notifySelection() {},
          notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {},
          notifyRemoval: function notifyRemoval() {},
          getComputedStyleValue: function getComputedStyleValue() {},
          setStyleProperty: function setStyleProperty() {},
          hasLeadingIcon: function hasLeadingIcon() {},
          getRootBoundingClientRect: function getRootBoundingClientRect() {},
          getCheckmarkBoundingClientRect: function getCheckmarkBoundingClientRect() {}
        }
      );
    }
    /**
     * @param {!MDCChipAdapter} adapter
     */

  }]);

  function MDCChipFoundation(adapter) {
    var _this;

    _classCallCheck(this, MDCChipFoundation);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCChipFoundation).call(this, Object.assign(MDCChipFoundation.defaultAdapter, adapter)));
    /**
     * Whether a trailing icon click should immediately trigger exit/removal of the chip.
     * @private {boolean}
     * */

    _this.shouldRemoveOnTrailingIconClick_ = true;
    return _this;
  }
  /**
   * @return {boolean}
   */


  _createClass(MDCChipFoundation, [{
    key: "isSelected",
    value: function isSelected() {
      return this.adapter_.hasClass(cssClasses.SELECTED);
    }
    /**
     * @param {boolean} selected
     */

  }, {
    key: "setSelected",
    value: function setSelected(selected) {
      if (selected) {
        this.adapter_.addClass(cssClasses.SELECTED);
      } else {
        this.adapter_.removeClass(cssClasses.SELECTED);
      }

      this.adapter_.notifySelection(selected);
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getShouldRemoveOnTrailingIconClick",
    value: function getShouldRemoveOnTrailingIconClick() {
      return this.shouldRemoveOnTrailingIconClick_;
    }
    /**
     * @param {boolean} shouldRemove
     */

  }, {
    key: "setShouldRemoveOnTrailingIconClick",
    value: function setShouldRemoveOnTrailingIconClick(shouldRemove) {
      this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
    }
    /** @return {!ClientRect} */

  }, {
    key: "getDimensions",
    value: function getDimensions() {
      // When a chip has a checkmark and not a leading icon, the bounding rect changes in size depending on the current
      // size of the checkmark.
      if (!this.adapter_.hasLeadingIcon() && this.adapter_.getCheckmarkBoundingClientRect() !== null) {
        var height = this.adapter_.getRootBoundingClientRect().height; // The checkmark's width is initially set to 0, so use the checkmark's height as a proxy since the checkmark
        // should always be square.

        var width = this.adapter_.getRootBoundingClientRect().width + this.adapter_.getCheckmarkBoundingClientRect().height;
        return (
          /** @type {!ClientRect} */
          {
            height: height,
            width: width
          }
        );
      } else {
        return this.adapter_.getRootBoundingClientRect();
      }
    }
    /**
     * Begins the exit animation which leads to removal of the chip.
     */

  }, {
    key: "beginExit",
    value: function beginExit() {
      this.adapter_.addClass(cssClasses.CHIP_EXIT);
    }
    /**
     * Handles an interaction event on the root element.
     * @param {!Event} evt
     */

  }, {
    key: "handleInteraction",
    value: function handleInteraction(evt) {
      if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
        this.adapter_.notifyInteraction();
      }
    }
    /**
     * Handles a transition end event on the root element.
     * @param {!Event} evt
     */

  }, {
    key: "handleTransitionEnd",
    value: function handleTransitionEnd(evt) {
      var _this2 = this;

      // Handle transition end event on the chip when it is about to be removed.
      if (this.adapter_.eventTargetHasClass(
      /** @type {!EventTarget} */
      evt.target, cssClasses.CHIP_EXIT)) {
        if (evt.propertyName === 'width') {
          this.adapter_.notifyRemoval();
        } else if (evt.propertyName === 'opacity') {
          // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
          var chipWidth = this.adapter_.getComputedStyleValue('width'); // On the next frame (once we get the computed width), explicitly set the chip's width
          // to its current pixel width, so we aren't transitioning out of 'auto'.

          requestAnimationFrame(function () {
            _this2.adapter_.setStyleProperty('width', chipWidth); // To mitigate jitter, start transitioning padding and margin before width.


            _this2.adapter_.setStyleProperty('padding', '0');

            _this2.adapter_.setStyleProperty('margin', '0'); // On the next frame (once width is explicitly set), transition width to 0.


            requestAnimationFrame(function () {
              _this2.adapter_.setStyleProperty('width', '0');
            });
          });
        }

        return;
      } // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.


      if (evt.propertyName !== 'opacity') {
        return;
      }

      if (this.adapter_.eventTargetHasClass(
      /** @type {!EventTarget} */
      evt.target, cssClasses.LEADING_ICON) && this.adapter_.hasClass(cssClasses.SELECTED)) {
        this.adapter_.addClassToLeadingIcon(cssClasses.HIDDEN_LEADING_ICON);
      } else if (this.adapter_.eventTargetHasClass(
      /** @type {!EventTarget} */
      evt.target, cssClasses.CHECKMARK) && !this.adapter_.hasClass(cssClasses.SELECTED)) {
        this.adapter_.removeClassFromLeadingIcon(cssClasses.HIDDEN_LEADING_ICON);
      }
    }
    /**
     * Handles an interaction event on the trailing icon element. This is used to
     * prevent the ripple from activating on interaction with the trailing icon.
     * @param {!Event} evt
     */

  }, {
    key: "handleTrailingIconInteraction",
    value: function handleTrailingIconInteraction(evt) {
      evt.stopPropagation();

      if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
        this.adapter_.notifyTrailingIconInteraction();

        if (this.shouldRemoveOnTrailingIconClick_) {
          this.beginExit();
        }
      }
    }
  }]);

  return MDCChipFoundation;
}(MDCFoundation);

var INTERACTION_EVENTS = ['click', 'keydown'];
/**
 * @extends {MDCComponent<!MDCChipFoundation>}
 * @final
 */

var MDCChip =
/*#__PURE__*/
function (_MDCComponent) {
  _inherits(MDCChip, _MDCComponent);

  /**
   * @param {...?} args
   */
  function MDCChip() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, MDCChip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCChip)).call.apply(_getPrototypeOf2, [this].concat(args)));
    /** @type {string} */

    _this.id;
    /** @private {?Element} */

    _this.leadingIcon_;
    /** @private {?Element} */

    _this.trailingIcon_;
    /** @private {?Element} */

    _this.checkmark_;
    /** @private {!MDCRipple} */

    _this.ripple_;
    /** @private {?function(?Event): undefined} */

    _this.handleInteraction_;
    /** @private {?function(!Event): undefined} */

    _this.handleTransitionEnd_;
    /** @private {function(!Event): undefined} */

    _this.handleTrailingIconInteraction_;
    return _this;
  }
  /**
   * @param {!Element} root
   * @return {!MDCChip}
   */


  _createClass(MDCChip, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el, foundation) {
        return new MDCRipple(el, foundation);
      };
      this.id = this.root_.id;
      this.leadingIcon_ = this.root_.querySelector(strings.LEADING_ICON_SELECTOR);
      this.trailingIcon_ = this.root_.querySelector(strings.TRAILING_ICON_SELECTOR);
      this.checkmark_ = this.root_.querySelector(strings.CHECKMARK_SELECTOR);
      var adapter = Object.assign(MDCRipple.createAdapter(this), {
        computeBoundingRect: function computeBoundingRect() {
          return _this2.foundation_.getDimensions();
        }
      });
      this.ripple_ = rippleFactory(this.root_, new MDCRippleFoundation(adapter));
    }
  }, {
    key: "initialSyncWithDOM",
    value: function initialSyncWithDOM() {
      var _this3 = this;

      this.handleInteraction_ = function (evt) {
        return _this3.foundation_.handleInteraction(evt);
      };

      this.handleTransitionEnd_ = function (evt) {
        return _this3.foundation_.handleTransitionEnd(evt);
      };

      this.handleTrailingIconInteraction_ = function (evt) {
        return _this3.foundation_.handleTrailingIconInteraction(evt);
      };

      INTERACTION_EVENTS.forEach(function (evtType) {
        _this3.root_.addEventListener(evtType, _this3.handleInteraction_);
      });
      this.root_.addEventListener('transitionend', this.handleTransitionEnd_);

      if (this.trailingIcon_) {
        INTERACTION_EVENTS.forEach(function (evtType) {
          _this3.trailingIcon_.addEventListener(evtType, _this3.handleTrailingIconInteraction_);
        });
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this4 = this;

      this.ripple_.destroy();
      INTERACTION_EVENTS.forEach(function (evtType) {
        _this4.root_.removeEventListener(evtType, _this4.handleInteraction_);
      });
      this.root_.removeEventListener('transitionend', this.handleTransitionEnd_);

      if (this.trailingIcon_) {
        INTERACTION_EVENTS.forEach(function (evtType) {
          _this4.trailingIcon_.removeEventListener(evtType, _this4.handleTrailingIconInteraction_);
        });
      }

      _get(_getPrototypeOf(MDCChip.prototype), "destroy", this).call(this);
    }
    /**
     * Returns whether the chip is selected.
     * @return {boolean}
     */

  }, {
    key: "beginExit",

    /**
     * Begins the exit animation which leads to removal of the chip.
     */
    value: function beginExit() {
      this.foundation_.beginExit();
    }
    /**
     * @return {!MDCChipFoundation}
     */

  }, {
    key: "getDefaultFoundation",
    value: function getDefaultFoundation() {
      var _this5 = this;

      return new MDCChipFoundation(
      /** @type {!MDCChipAdapter} */
      Object.assign({
        addClass: function addClass(className) {
          return _this5.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return _this5.root_.classList.remove(className);
        },
        hasClass: function hasClass(className) {
          return _this5.root_.classList.contains(className);
        },
        addClassToLeadingIcon: function addClassToLeadingIcon(className) {
          if (_this5.leadingIcon_) {
            _this5.leadingIcon_.classList.add(className);
          }
        },
        removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
          if (_this5.leadingIcon_) {
            _this5.leadingIcon_.classList.remove(className);
          }
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        notifyInteraction: function notifyInteraction() {
          return _this5.emit(strings.INTERACTION_EVENT, {
            chipId: _this5.id
          }, true
          /* shouldBubble */
          );
        },
        notifySelection: function notifySelection(selected) {
          return _this5.emit(strings.SELECTION_EVENT, {
            chipId: _this5.id,
            selected: selected
          }, true
          /* shouldBubble */
          );
        },
        notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
          return _this5.emit(strings.TRAILING_ICON_INTERACTION_EVENT, {
            chipId: _this5.id
          }, true
          /* shouldBubble */
          );
        },
        notifyRemoval: function notifyRemoval() {
          return _this5.emit(strings.REMOVAL_EVENT, {
            chipId: _this5.id,
            root: _this5.root_
          }, true
          /* shouldBubble */
          );
        },
        getComputedStyleValue: function getComputedStyleValue(propertyName) {
          return window.getComputedStyle(_this5.root_).getPropertyValue(propertyName);
        },
        setStyleProperty: function setStyleProperty(propertyName, value) {
          return _this5.root_.style.setProperty(propertyName, value);
        },
        hasLeadingIcon: function hasLeadingIcon() {
          return !!_this5.leadingIcon_;
        },
        getRootBoundingClientRect: function getRootBoundingClientRect() {
          return _this5.root_.getBoundingClientRect();
        },
        getCheckmarkBoundingClientRect: function getCheckmarkBoundingClientRect() {
          return _this5.checkmark_ ? _this5.checkmark_.getBoundingClientRect() : null;
        }
      }));
    }
    /** @return {!MDCRipple} */

  }, {
    key: "selected",
    get: function get() {
      return this.foundation_.isSelected();
    }
    /**
     * Sets selected state on the chip.
     * @param {boolean} selected
     */
    ,
    set: function set(selected) {
      this.foundation_.setSelected(selected);
    }
    /**
     * Returns whether a trailing icon click should trigger exit/removal of the chip.
     * @return {boolean}
     */

  }, {
    key: "shouldRemoveOnTrailingIconClick",
    get: function get() {
      return this.foundation_.getShouldRemoveOnTrailingIconClick();
    }
    /**
     * Sets whether a trailing icon click should trigger exit/removal of the chip.
     * @param {boolean} shouldRemove
     */
    ,
    set: function set(shouldRemove) {
      this.foundation_.setShouldRemoveOnTrailingIconClick(shouldRemove);
    }
  }, {
    key: "ripple",
    get: function get() {
      return this.ripple_;
    }
  }], [{
    key: "attachTo",
    value: function attachTo(root) {
      return new MDCChip(root);
    }
  }]);

  return MDCChip;
}(MDCComponent);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token used to provide the parent MdcChipSet component to MdcChip.
 * @type {?}
 */
var MDC_CHIPSET_PARENT_COMPONENT = new InjectionToken('MDC_CHIPSET_PARENT_COMPONENT');
/** @type {?} */
var nextUniqueId = 0;
var MdcChipCheckmark = /** @class */ (function () {
    function MdcChipCheckmark(elementRef) {
        this.elementRef = elementRef;
    }
    MdcChipCheckmark.decorators = [
        { type: Component, args: [{selector: 'mdc-chip-checkmark',
                    exportAs: 'mdcChipCheckmark',
                    template: "\n  <div class=\"mdc-chip__checkmark\">\n    <svg\n      class=\"mdc-chip__checkmark-svg\"\n      viewBox=\"-2 -3 30 30\"\n      focusable=\"false\">\n      <path class=\"mdc-chip__checkmark-path\" fill=\"none\" stroke=\"black\" d=\"M1.73,12.91 8.1,19.28 22.79,4.59\"/>\n    </svg>\n  </div>",
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    MdcChipCheckmark.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return MdcChipCheckmark;
}());
var MdcChipText = /** @class */ (function () {
    function MdcChipText(elementRef) {
        this.elementRef = elementRef;
    }
    MdcChipText.decorators = [
        { type: Directive, args: [{
                    selector: 'mdc-chip-text, [mdcChipText]',
                    host: { 'class': 'mdc-chip__text' }
                },] },
    ];
    /** @nocollapse */
    MdcChipText.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return MdcChipText;
}());
var MdcChip = /** @class */ (function () {
    function MdcChip(_platform, _ngZone, _changeDetectorRef, _ripple, elementRef, _parent) {
        this._platform = _platform;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this._ripple = _ripple;
        this.elementRef = elementRef;
        this._parent = _parent;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroyed = new Subject();
        this._id = "mdc-chip-" + nextUniqueId++;
        this._selected = false;
        this._filter = false;
        this._choice = false;
        this._input = false;
        this._primary = false;
        this._secondary = false;
        this._removable = true;
        this._disabled = false;
        this._disableRipple = false;
        /**
         * Emitted when the chip is selected or deselected.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Emitted when the chip icon is interacted with.
         */
        this.trailingIconInteraction = new EventEmitter();
        /**
         * Emitted when a chip is to be removed.
         */
        this.removed = new EventEmitter();
        this._foundation = new MDCChipFoundation(this._createAdapter());
    }
    Object.defineProperty(MdcChip.prototype, "id", {
        /** The unique ID of the chip. */
        get: /**
         * The unique ID of the chip.
         * @return {?}
         */
        function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "leadingIcon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icons.find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.leading; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () { return this._selected; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = toBoolean(value);
            this._selected = newValue;
            this._foundation.setSelected(newValue);
            if (this.filter && this.leadingIcon) {
                this.leadingIcon.elementRef.nativeElement.classList.remove(cssClasses.HIDDEN_LEADING_ICON);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "filter", {
        get: /**
         * @return {?}
         */
        function () { return this._filter; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = toBoolean(value);
            if (newValue !== this._filter) {
                this._filter = newValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "choice", {
        get: /**
         * @return {?}
         */
        function () { return this._choice; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._choice = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "input", {
        get: /**
         * @return {?}
         */
        function () { return this._input; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._input = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "primary", {
        get: /**
         * @return {?}
         */
        function () { return this._primary; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._primary = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "secondary", {
        get: /**
         * @return {?}
         */
        function () { return this._secondary; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._secondary = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "removable", {
        /** Determines whether or not the chip displays the remove styling and emits (removed) events. */
        get: /**
         * Determines whether or not the chip displays the remove styling and emits (removed) events.
         * @return {?}
         */
        function () { return this._removable; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = toBoolean(value);
            if (newValue !== this._removable) {
                this._removable = value;
                this._foundation.setShouldRemoveOnTrailingIconClick(this._removable);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "disabled", {
        /** Whether the chip is disabled. */
        get: /**
         * Whether the chip is disabled.
         * @return {?}
         */
        function () { return this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "disableRipple", {
        /** Whether the chip ripple is disabled. */
        get: /**
         * Whether the chip ripple is disabled.
         * @return {?}
         */
        function () { return this._disableRipple; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disableRipple = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChip.prototype, "value", {
        /** The value of the chip. Defaults to the content inside `<mdc-chip>` tags. */
        get: /**
         * The value of the chip. Defaults to the content inside `<mdc-chip>` tags.
         * @return {?}
         */
        function () {
            return this._value !== undefined
                ? this._value
                : this.elementRef.nativeElement.textContent;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._value = value; },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    MdcChip.prototype._createAdapter = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return {
            addClass: (/**
             * @param {?} className
             * @return {?}
             */
            function (className) { return _this._getHostElement().classList.add(className); }),
            removeClass: (/**
             * @param {?} className
             * @return {?}
             */
            function (className) { return _this._getHostElement().classList.remove(className); }),
            hasClass: (/**
             * @param {?} className
             * @return {?}
             */
            function (className) { return _this._getHostElement().classList.contains(className); }),
            addClassToLeadingIcon: (/**
             * @param {?} className
             * @return {?}
             */
            function (className) {
                if (_this.leadingIcon) {
                    _this.leadingIcon.elementRef.nativeElement.classList.add(className);
                }
            }),
            removeClassFromLeadingIcon: (/**
             * @param {?} className
             * @return {?}
             */
            function (className) {
                if (_this.leadingIcon) {
                    _this.leadingIcon.elementRef.nativeElement.classList.remove(className);
                }
            }),
            eventTargetHasClass: (/**
             * @param {?} target
             * @param {?} className
             * @return {?}
             */
            function (target, className) { return target.classList.contains(className); }),
            notifyInteraction: (/**
             * @return {?}
             */
            function () { return _this._emitSelectionChangeEvent(true); }),
            notifyTrailingIconInteraction: (/**
             * @return {?}
             */
            function () { return _this.trailingIconInteraction.emit({ detail: { chipId: _this.id } }); }),
            notifyRemoval: (/**
             * @return {?}
             */
            function () { return _this.removed.emit({ detail: { chipId: _this.id, root: _this } }); }),
            getComputedStyleValue: (/**
             * @param {?} propertyName
             * @return {?}
             */
            function (propertyName) {
                if (!_this._platform.isBrowser) {
                    return;
                }
                return window.getComputedStyle(_this._getHostElement()).getPropertyValue(propertyName);
            }),
            setStyleProperty: (/**
             * @param {?} propertyName
             * @param {?} value
             * @return {?}
             */
            function (propertyName, value) {
                return _this._getHostElement().style.setProperty(propertyName, value);
            }),
            hasLeadingIcon: (/**
             * @return {?}
             */
            function () { return !!_this.leadingIcon; }),
            getRootBoundingClientRect: (/**
             * @return {?}
             */
            function () { return _this._getHostElement().getBoundingClientRect(); }),
            getCheckmarkBoundingClientRect: (/**
             * @return {?}
             */
            function () { return _this._checkmark ?
                _this._checkmark.elementRef.nativeElement.getBoundingClientRect() : null; })
        };
    };
    /**
     * @return {?}
     */
    MdcChip.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._foundation.init();
        this._setVariantFromChipSet();
        this._initRipple();
        this._loadListeners();
    };
    /**
     * @return {?}
     */
    MdcChip.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next();
        this._destroyed.complete();
        this._ripple.destroy();
        if (this._foundation) {
            this._foundation.destroy();
        }
    };
    /** Selects the chip. */
    /**
     * Selects the chip.
     * @return {?}
     */
    MdcChip.prototype.select = /**
     * Selects the chip.
     * @return {?}
     */
    function () {
        if (!this._selected) {
            this._selected = true;
            this._emitSelectionChangeEvent();
        }
    };
    /** Deselects the chip. */
    /**
     * Deselects the chip.
     * @return {?}
     */
    MdcChip.prototype.deselect = /**
     * Deselects the chip.
     * @return {?}
     */
    function () {
        if (this._selected) {
            this._selected = false;
            this._emitSelectionChangeEvent();
        }
    };
    /** Select this chip and emit selected event */
    /**
     * Select this chip and emit selected event
     * @return {?}
     */
    MdcChip.prototype.selectViaInteraction = /**
     * Select this chip and emit selected event
     * @return {?}
     */
    function () {
        if (!this._selected) {
            this._selected = true;
            this._emitSelectionChangeEvent(true);
        }
    };
    /** Allows for programmatic focusing of the chip. */
    /**
     * Allows for programmatic focusing of the chip.
     * @return {?}
     */
    MdcChip.prototype.focus = /**
     * Allows for programmatic focusing of the chip.
     * @return {?}
     */
    function () {
        this._getHostElement().focus();
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    MdcChip.prototype._handleInteraction = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        this._selected = !this._selected;
        this._foundation.handleInteraction(evt);
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    MdcChip.prototype._handleTrailingIconInteraction = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        this._foundation.handleTrailingIconInteraction(evt);
    };
    /**
     * @private
     * @return {?}
     */
    MdcChip.prototype._initRipple = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._ripple.init({
            surface: this._getHostElement()
        }, Object.assign(this._ripple.createAdapter(), {
            isSurfaceDisabled: (/**
             * @return {?}
             */
            function () { return _this._disableRipple; }),
            computeBoundingRect: (/**
             * @return {?}
             */
            function () { return _this._foundation.getDimensions(); })
        }));
    };
    /**
     * @private
     * @return {?}
     */
    MdcChip.prototype._setVariantFromChipSet = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._parent) {
            this.input = this._parent.input;
            this.filter = this._parent.filter;
            this.choice = this._parent.choice;
            this._changeDetectorRef.detectChanges();
        }
    };
    /**
     * @private
     * @return {?}
     */
    MdcChip.prototype._loadListeners = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            return fromEvent(_this._getHostElement(), 'transitionend')
                .pipe(takeUntil(_this._destroyed))
                .subscribe((/**
             * @param {?} evt
             * @return {?}
             */
            function (evt) { return _this._ngZone.run((/**
             * @return {?}
             */
            function () { return _this._foundation.handleTransitionEnd(evt); })); }));
        }));
    };
    /** Emits the removed event. */
    /**
     * Emits the removed event.
     * @return {?}
     */
    MdcChip.prototype._emitRemovedEvent = /**
     * Emits the removed event.
     * @return {?}
     */
    function () {
        this.removed.emit({ detail: { chipId: this.id, root: this } });
    };
    /** Emits the selection change event. */
    /**
     * Emits the selection change event.
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    MdcChip.prototype._emitSelectionChangeEvent = /**
     * Emits the selection change event.
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    function (isUserInput) {
        this.selectionChange.emit({
            isUserInput: isUserInput,
            detail: { chipId: this.id, selected: this._selected, value: this._value }
        });
    };
    /** Retrieves the DOM element of the component host. */
    /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    MdcChip.prototype._getHostElement = /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    function () {
        return this.elementRef.nativeElement;
    };
    MdcChip.decorators = [
        { type: Component, args: [{selector: 'mdc-chip',
                    exportAs: 'mdcChip',
                    host: {
                        '[id]': 'id',
                        '[attr.tabindex]': 'disabled ? null : 0',
                        'class': 'mdc-chip',
                        '[class.ngx-mdc-chip--primary]': 'primary',
                        '[class.ngx-mdc-chip--secondary]': 'secondary',
                        '(click)': '_handleInteraction($event)',
                        '(keydown)': '_handleInteraction($event)'
                    },
                    template: "\n  <ng-content select=\"mdc-chip-icon[leading]\"></ng-content>\n  <mdc-chip-checkmark *ngIf=\"filter\"></mdc-chip-checkmark>\n  <div class=\"mdc-chip__text\" *ngIf=\"label\">{{label}}</div>\n  <ng-content></ng-content>",
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [MdcRipple]
                },] },
    ];
    /** @nocollapse */
    MdcChip.ctorParameters = function () { return [
        { type: Platform },
        { type: NgZone },
        { type: ChangeDetectorRef },
        { type: MdcRipple },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MDC_CHIPSET_PARENT_COMPONENT,] }] }
    ]; };
    MdcChip.propDecorators = {
        label: [{ type: Input }],
        selected: [{ type: Input }],
        filter: [{ type: Input }],
        choice: [{ type: Input }],
        input: [{ type: Input }],
        primary: [{ type: Input }],
        secondary: [{ type: Input }],
        removable: [{ type: Input }],
        disabled: [{ type: Input }],
        disableRipple: [{ type: Input }],
        value: [{ type: Input }],
        selectionChange: [{ type: Output }],
        trailingIconInteraction: [{ type: Output }],
        removed: [{ type: Output }],
        _checkmark: [{ type: ContentChild, args: [MdcChipCheckmark,] }],
        _icons: [{ type: ContentChildren, args: [forwardRef((/**
                     * @return {?}
                     */
                    function () { return MdcChipIcon; })), { descendants: true },] }]
    };
    return MdcChip;
}());
var MdcChipIcon = /** @class */ (function (_super) {
    __extends(MdcChipIcon, _super);
    function MdcChipIcon(_parentChip, elementRef, iconRegistry, ariaHidden, location) {
        var _this = _super.call(this, elementRef, iconRegistry, ariaHidden, location) || this;
        _this._parentChip = _parentChip;
        _this._leading = false;
        _this._trailing = false;
        return _this;
    }
    Object.defineProperty(MdcChipIcon.prototype, "leading", {
        get: /**
         * @return {?}
         */
        function () { return this._leading; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._leading = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChipIcon.prototype, "trailing", {
        get: /**
         * @return {?}
         */
        function () { return this._trailing; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._trailing = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdcChipIcon.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.trailing) {
            this.tabIndex = 0;
            this.role = 'button';
        }
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    MdcChipIcon.prototype._onIconInteraction = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (this.trailing) {
            this._parentChip._handleTrailingIconInteraction(evt);
            if (this._parentChip.removable && this._parentChip.input) {
                this._parentChip._emitRemovedEvent();
            }
        }
    };
    MdcChipIcon.decorators = [
        { type: Component, args: [{selector: 'mdc-chip-icon, [mdcChipIcon]',
                    exportAs: 'mdcChipIcon',
                    host: {
                        'class': 'mdc-chip__icon ngx-mdc-icon',
                        '[attr.role]': 'role',
                        '[attr.tabindex]': 'tabIndex',
                        '[class.ngx-mdc-icon--clickable]': 'clickable',
                        '[class.ngx-mdc-icon--inline]': 'inline',
                        '[class.mdc-chip__icon--leading]': 'leading',
                        '[class.mdc-chip__icon--trailing]': 'trailing',
                        '(click)': '_onIconInteraction($event)',
                        '(keydown)': '_onIconInteraction($event)'
                    },
                    template: '<ng-content></ng-content>',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    MdcChipIcon.ctorParameters = function () { return [
        { type: MdcChip },
        { type: ElementRef },
        { type: MdcIconRegistry },
        { type: String, decorators: [{ type: Attribute, args: ['aria-hidden',] }] },
        { type: undefined, decorators: [{ type: Inject, args: [MDC_ICON_LOCATION,] }] }
    ]; };
    MdcChipIcon.propDecorators = {
        leading: [{ type: Input }],
        trailing: [{ type: Input }]
    };
    return MdcChipIcon;
}(MdcIcon));

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Chip Set.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Chip Set into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCChipSetAdapter =
/*#__PURE__*/
function () {
  function MDCChipSetAdapter() {
    _classCallCheck(this, MDCChipSetAdapter);
  }

  _createClass(MDCChipSetAdapter, [{
    key: "hasClass",

    /**
     * Returns true if the root element contains the given class name.
     * @param {string} className
     * @return {boolean}
     */
    value: function hasClass(className) {}
    /**
     * Removes the chip with the given id from the chip set.
     * @param {string} chipId
     */

  }, {
    key: "removeChip",
    value: function removeChip(chipId) {}
    /**
     * Sets the selected state of the chip with the given id.
     * @param {string} chipId
     * @param {boolean} selected
     */

  }, {
    key: "setSelected",
    value: function setSelected(chipId, selected) {}
  }]);

  return MDCChipSetAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
var strings$2 = {
  CHIP_SELECTOR: '.mdc-chip'
};
/** @enum {string} */

var cssClasses$2 = {
  CHOICE: 'mdc-chip-set--choice',
  FILTER: 'mdc-chip-set--filter'
};

/**
 * @extends {MDCFoundation<!MDCChipSetAdapter>}
 * @final
 */

var MDCChipSetFoundation =
/*#__PURE__*/
function (_MDCFoundation) {
  _inherits(MDCChipSetFoundation, _MDCFoundation);

  _createClass(MDCChipSetFoundation, null, [{
    key: "strings",

    /** @return enum {string} */
    get: function get() {
      return strings$2;
    }
    /** @return enum {string} */

  }, {
    key: "cssClasses",
    get: function get() {
      return cssClasses$2;
    }
    /**
     * {@see MDCChipSetAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCChipSetAdapter}
     */

  }, {
    key: "defaultAdapter",
    get: function get() {
      return (
        /** @type {!MDCChipSetAdapter} */
        {
          hasClass: function hasClass() {},
          removeChip: function removeChip() {},
          setSelected: function setSelected() {}
        }
      );
    }
    /**
     * @param {!MDCChipSetAdapter} adapter
     */

  }]);

  function MDCChipSetFoundation(adapter) {
    var _this;

    _classCallCheck(this, MDCChipSetFoundation);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCChipSetFoundation).call(this, Object.assign(MDCChipSetFoundation.defaultAdapter, adapter)));
    /**
     * The ids of the selected chips in the set. Only used for choice chip set or filter chip set.
     * @private {!Array<string>}
     */

    _this.selectedChipIds_ = [];
    return _this;
  }
  /**
   * Returns an array of the IDs of all selected chips.
   * @return {!Array<string>}
   */


  _createClass(MDCChipSetFoundation, [{
    key: "getSelectedChipIds",
    value: function getSelectedChipIds() {
      return this.selectedChipIds_;
    }
    /**
     * Toggles selection of the chip with the given id.
     * @private
     * @param {string} chipId
     */

  }, {
    key: "toggleSelect_",
    value: function toggleSelect_(chipId) {
      if (this.selectedChipIds_.indexOf(chipId) >= 0) {
        this.deselect_(chipId);
      } else {
        this.select(chipId);
      }
    }
    /**
     * Selects the chip with the given id. Deselects all other chips if the chip set is of the choice variant.
     * @param {string} chipId
     */

  }, {
    key: "select",
    value: function select(chipId) {
      if (this.selectedChipIds_.indexOf(chipId) >= 0) {
        return;
      }

      if (this.adapter_.hasClass(cssClasses$2.CHOICE) && this.selectedChipIds_.length > 0) {
        var previouslySelectedChip = this.selectedChipIds_[0];
        this.selectedChipIds_.length = 0;
        this.adapter_.setSelected(previouslySelectedChip, false);
      }

      this.selectedChipIds_.push(chipId);
      this.adapter_.setSelected(chipId, true);
    }
    /**
     * Deselects the chip with the given id.
     * @private
     * @param {string} chipId
     */

  }, {
    key: "deselect_",
    value: function deselect_(chipId) {
      var index = this.selectedChipIds_.indexOf(chipId);

      if (index >= 0) {
        this.selectedChipIds_.splice(index, 1);
        this.adapter_.setSelected(chipId, false);
      }
    }
    /**
     * Handles a chip interaction event
     * @param {string} chipId
     */

  }, {
    key: "handleChipInteraction",
    value: function handleChipInteraction(chipId) {
      if (this.adapter_.hasClass(cssClasses$2.CHOICE) || this.adapter_.hasClass(cssClasses$2.FILTER)) {
        this.toggleSelect_(chipId);
      }
    }
    /**
     * Handles a chip selection event, used to handle discrepancy when selection state is set directly on the Chip.
     * @param {string} chipId
     * @param {boolean} selected
     */

  }, {
    key: "handleChipSelection",
    value: function handleChipSelection(chipId, selected) {
      var chipIsSelected = this.selectedChipIds_.indexOf(chipId) >= 0;

      if (selected && !chipIsSelected) {
        this.select(chipId);
      } else if (!selected && chipIsSelected) {
        this.deselect_(chipId);
      }
    }
    /**
     * Handles the event when a chip is removed.
     * @param {string} chipId
     */

  }, {
    key: "handleChipRemoval",
    value: function handleChipRemoval(chipId) {
      this.deselect_(chipId);
      this.adapter_.removeChip(chipId);
    }
  }]);

  return MDCChipSetFoundation;
}(MDCFoundation);

var idCounter = 0;
/**
 * @extends {MDCComponent<!MDCChipSetFoundation>}
 * @final
 */

var MDCChipSet =
/*#__PURE__*/
function (_MDCComponent) {
  _inherits(MDCChipSet, _MDCComponent);

  /**
   * @param {...?} args
   */
  function MDCChipSet() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, MDCChipSet);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCChipSet)).call.apply(_getPrototypeOf2, [this].concat(args)));
    /** @type {!Array<!MDCChip>} */

    _this.chips;
    /** @private {(function(!Element): !MDCChip)} */

    _this.chipFactory_;
    /** @private {?function(?Event): undefined} */

    _this.handleChipInteraction_;
    /** @private {?function(?Event): undefined} */

    _this.handleChipSelection_;
    /** @private {?function(?Event): undefined} */

    _this.handleChipRemoval_;
    return _this;
  }
  /**
   * @param {!Element} root
   * @return {!MDCChipSet}
   */


  _createClass(MDCChipSet, [{
    key: "initialize",

    /**
     * @param {(function(!Element): !MDCChip)=} chipFactory A function which
     * creates a new MDCChip.
     */
    value: function initialize() {
      var chipFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
        return new MDCChip(el);
      };
      this.chipFactory_ = chipFactory;
      this.chips = this.instantiateChips_(this.chipFactory_);
    }
  }, {
    key: "initialSyncWithDOM",
    value: function initialSyncWithDOM() {
      var _this2 = this;

      this.chips.forEach(function (chip) {
        if (chip.selected) {
          _this2.foundation_.select(chip.id);
        }
      });

      this.handleChipInteraction_ = function (evt) {
        return _this2.foundation_.handleChipInteraction(evt.detail.chipId);
      };

      this.handleChipSelection_ = function (evt) {
        return _this2.foundation_.handleChipSelection(evt.detail.chipId, evt.detail.selected);
      };

      this.handleChipRemoval_ = function (evt) {
        return _this2.foundation_.handleChipRemoval(evt.detail.chipId);
      };

      this.root_.addEventListener(MDCChipFoundation.strings.INTERACTION_EVENT, this.handleChipInteraction_);
      this.root_.addEventListener(MDCChipFoundation.strings.SELECTION_EVENT, this.handleChipSelection_);
      this.root_.addEventListener(MDCChipFoundation.strings.REMOVAL_EVENT, this.handleChipRemoval_);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.chips.forEach(function (chip) {
        chip.destroy();
      });
      this.root_.removeEventListener(MDCChipFoundation.strings.INTERACTION_EVENT, this.handleChipInteraction_);
      this.root_.removeEventListener(MDCChipFoundation.strings.SELECTION_EVENT, this.handleChipSelection_);
      this.root_.removeEventListener(MDCChipFoundation.strings.REMOVAL_EVENT, this.handleChipRemoval_);

      _get(_getPrototypeOf(MDCChipSet.prototype), "destroy", this).call(this);
    }
    /**
     * Adds a new chip object to the chip set from the given chip element.
     * @param {!Element} chipEl
     */

  }, {
    key: "addChip",
    value: function addChip(chipEl) {
      chipEl.id = chipEl.id || "mdc-chip-".concat(++idCounter);
      this.chips.push(this.chipFactory_(chipEl));
    }
    /**
     * Returns an array of the IDs of all selected chips.
     * @return {!Array<string>}
     */

  }, {
    key: "getDefaultFoundation",

    /**
     * @return {!MDCChipSetFoundation}
     */
    value: function getDefaultFoundation() {
      var _this3 = this;

      return new MDCChipSetFoundation(
      /** @type {!MDCChipSetAdapter} */
      Object.assign({
        hasClass: function hasClass(className) {
          return _this3.root_.classList.contains(className);
        },
        removeChip: function removeChip(chipId) {
          var index = _this3.findChipIndex_(chipId);

          if (index >= 0) {
            _this3.chips[index].destroy();

            _this3.chips.splice(index, 1);
          }
        },
        setSelected: function setSelected(chipId, selected) {
          var index = _this3.findChipIndex_(chipId);

          if (index >= 0) {
            _this3.chips[index].selected = selected;
          }
        }
      }));
    }
    /**
     * Instantiates chip components on all of the chip set's child chip elements.
     * @param {(function(!Element): !MDCChip)} chipFactory
     * @return {!Array<!MDCChip>}
     */

  }, {
    key: "instantiateChips_",
    value: function instantiateChips_(chipFactory) {
      var chipElements = [].slice.call(this.root_.querySelectorAll(MDCChipSetFoundation.strings.CHIP_SELECTOR));
      return chipElements.map(function (el) {
        el.id = el.id || "mdc-chip-".concat(++idCounter);
        return chipFactory(el);
      });
    }
    /**
     * Returns the index of the chip with the given id, or -1 if the chip does not exist.
     * @param {string} chipId
     * @return {number}
     */

  }, {
    key: "findChipIndex_",
    value: function findChipIndex_(chipId) {
      for (var i = 0; i < this.chips.length; i++) {
        if (this.chips[i].id === chipId) {
          return i;
        }
      }

      return -1;
    }
  }, {
    key: "selectedChipIds",
    get: function get() {
      return this.foundation_.getSelectedChipIds();
    }
  }], [{
    key: "attachTo",
    value: function attachTo(root) {
      return new MDCChipSet(root);
    }
  }]);

  return MDCChipSet;
}(MDCComponent);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MdcChipSetChange = /** @class */ (function () {
    function MdcChipSetChange(source, value) {
        this.source = source;
        this.value = value;
    }
    return MdcChipSetChange;
}());
var MdcChipSet = /** @class */ (function () {
    function MdcChipSet(_changeDetectorRef, elementRef, _parentForm, _parentFormGroup, ngControl) {
        this._changeDetectorRef = _changeDetectorRef;
        this.elementRef = elementRef;
        this.ngControl = ngControl;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroyed = new Subject();
        this._choice = false;
        this._filter = false;
        this._input = false;
        /**
         * A function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         */
        this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        function (o1, o2) { return o1 === o2; });
        this.change = new EventEmitter();
        /**
         * Function when touched
         */
        this._onTouched = (/**
         * @return {?}
         */
        function () { });
        /**
         * Function when changed
         */
        this._onChange = (/**
         * @return {?}
         */
        function () { });
        /**
         * Subscription to selection events in chips.
         */
        this._chipSelectionSubscription = null;
        /**
         * Subscription to remove changes in chips.
         */
        this._chipRemoveSubscription = null;
        /**
         * Subscription to interaction events in chips.
         */
        this._chipInteractionSubscription = null;
        this._foundation = new MDCChipSetFoundation(this._createAdapter());
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    }
    Object.defineProperty(MdcChipSet.prototype, "choice", {
        /**
        * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
        */
        get: /**
         * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
         * @return {?}
         */
        function () { return this._choice; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._choice = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChipSet.prototype, "filter", {
        /**
        * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
        */
        get: /**
         * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
         * @return {?}
         */
        function () { return this._filter; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filter = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChipSet.prototype, "input", {
        /**
        * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
        */
        get: /**
         * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
         * @return {?}
         */
        function () { return this._input; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._input = toBoolean(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChipSet.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () { return this._value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.writeValue(value);
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChipSet.prototype, "chipSelections", {
        /** Combined stream of all of the chip selection events. */
        get: /**
         * Combined stream of all of the chip selection events.
         * @return {?}
         */
        function () {
            return merge.apply(void 0, this.chips.map((/**
             * @param {?} chip
             * @return {?}
             */
            function (chip) { return chip.selectionChange; })));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChipSet.prototype, "chipInteractions", {
        /** Combined stream of all of the chip interaction events. */
        get: /**
         * Combined stream of all of the chip interaction events.
         * @return {?}
         */
        function () {
            return merge.apply(void 0, this.chips.map((/**
             * @param {?} chip
             * @return {?}
             */
            function (chip) { return chip.trailingIconInteraction; })));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdcChipSet.prototype, "chipRemoveChanges", {
        /** Combined stream of all of the chip remove events. */
        get: /**
         * Combined stream of all of the chip remove events.
         * @return {?}
         */
        function () {
            return merge.apply(void 0, this.chips.map((/**
             * @param {?} chip
             * @return {?}
             */
            function (chip) { return chip.removed; })));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._createAdapter = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return {
            hasClass: (/**
             * @param {?} className
             * @return {?}
             */
            function (className) { return _this._getHostElement().classList.contains(className); }),
            removeChip: (/**
             * @param {?} chipId
             * @return {?}
             */
            function (chipId) {
                /** @type {?} */
                var index = _this._findChipIndex(chipId);
                _this.chips.toArray().splice(index, 1);
            }),
            setSelected: (/**
             * @param {?} chipId
             * @param {?} selected
             * @return {?}
             */
            function (chipId, selected) {
                /** @type {?} */
                var chip = _this.getChipById(chipId);
                if (chip) {
                    chip.selected = selected;
                }
            })
        };
    };
    /**
     * @return {?}
     */
    MdcChipSet.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._foundation.init();
        // When chips change, re-subscribe
        this.chips.changes.pipe(startWith(null), takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            if (_this.chips.length > 0) {
                _this._resetChipSet();
                _this._initializeSelection();
            }
        }));
    };
    /**
     * @return {?}
     */
    MdcChipSet.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next();
        this._destroyed.complete();
        this._dropSubscriptions();
        if (this._chipRemoveSubscription) {
            this._chipRemoveSubscription.unsubscribe();
        }
        this._foundation.destroy();
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    MdcChipSet.prototype.writeValue = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.chips) {
            this.selectByValue(value, false);
        }
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    MdcChipSet.prototype.registerOnChange = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    MdcChipSet.prototype.registerOnTouched = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    /**
     * @return {?}
     */
    MdcChipSet.prototype.getSelectedChipIds = /**
     * @return {?}
     */
    function () {
        return this._foundation.getSelectedChipIds();
    };
    /**
     * @param {?} chipId
     * @return {?}
     */
    MdcChipSet.prototype.select = /**
     * @param {?} chipId
     * @return {?}
     */
    function (chipId) {
        this._foundation.select(chipId);
    };
    /**
     * @param {?} chipId
     * @return {?}
     */
    MdcChipSet.prototype.getChipById = /**
     * @param {?} chipId
     * @return {?}
     */
    function (chipId) {
        return this.chips.find((/**
         * @param {?} _
         * @return {?}
         */
        function (_) { return _.id === chipId; }));
    };
    /**
     * @param {?} value
     * @param {?=} isUserInput
     * @return {?}
     */
    MdcChipSet.prototype.selectByValue = /**
     * @param {?} value
     * @param {?=} isUserInput
     * @return {?}
     */
    function (value, isUserInput) {
        var _this = this;
        if (isUserInput === void 0) { isUserInput = true; }
        this.chips.forEach((/**
         * @param {?} chip
         * @return {?}
         */
        function (chip) { return chip.deselect(); }));
        if (Array.isArray(value)) {
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            function (currentValue) { return _this._selectValue(currentValue, isUserInput); }));
        }
        else {
            this._selectValue(value, isUserInput);
        }
    };
    /**
     * Finds and selects the chip based on its value.
     * @returns Chip that has the corresponding value.
     */
    /**
     * Finds and selects the chip based on its value.
     * @private
     * @param {?} value
     * @param {?=} isUserInput
     * @return {?} Chip that has the corresponding value.
     */
    MdcChipSet.prototype._selectValue = /**
     * Finds and selects the chip based on its value.
     * @private
     * @param {?} value
     * @param {?=} isUserInput
     * @return {?} Chip that has the corresponding value.
     */
    function (value, isUserInput) {
        var _this = this;
        if (isUserInput === void 0) { isUserInput = true; }
        /** @type {?} */
        var correspondingChip = this.chips.find((/**
         * @param {?} chip
         * @return {?}
         */
        function (chip) {
            return chip.value != null && _this._compareWith(chip.value, value);
        }));
        if (correspondingChip) {
            isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
        }
        return correspondingChip;
    };
    /**
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._initializeSelection = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        function () {
            if (_this.ngControl || _this._value) {
                _this.selectByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);
            }
        }));
    };
    /**
     * @private
     * @param {?} evt
     * @return {?}
     */
    MdcChipSet.prototype._propagateChanges = /**
     * @private
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        this._value = evt.detail.value;
        this.change.emit(new MdcChipSetChange(this, evt.detail));
        this._onChange(this._value);
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._resetChipSet = /**
     * @private
     * @return {?}
     */
    function () {
        this._dropSubscriptions();
        this._listenForChipSelection();
        this._listenToChipsInteraction();
        this._listenToChipsRemoved();
    };
    /**
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._dropSubscriptions = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._chipSelectionSubscription) {
            this._chipSelectionSubscription.unsubscribe();
            this._chipSelectionSubscription = null;
        }
        if (this._chipInteractionSubscription) {
            this._chipInteractionSubscription.unsubscribe();
            this._chipInteractionSubscription = null;
        }
        if (this._chipRemoveSubscription) {
            this._chipRemoveSubscription.unsubscribe();
            this._chipRemoveSubscription = null;
        }
    };
    /** Listens to selected events on each chip. */
    /**
     * Listens to selected events on each chip.
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._listenForChipSelection = /**
     * Listens to selected events on each chip.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._chipSelectionSubscription = this.chipSelections
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this._foundation.handleChipSelection(event.detail.chipId, event.detail.selected);
            if (event.isUserInput) {
                _this._propagateChanges(event);
            }
        }));
    };
    /**
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._listenToChipsInteraction = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._chipInteractionSubscription = this.chipInteractions
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            return _this._foundation.handleChipInteraction(event.detail.chipId);
        }));
    };
    /**
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._listenToChipsRemoved = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._chipRemoveSubscription = this.chipRemoveChanges
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this._foundation.handleChipRemoval(event.detail.chipId); }));
    };
    /**
     * @private
     * @param {?} chipId
     * @return {?}
     */
    MdcChipSet.prototype._findChipIndex = /**
     * @private
     * @param {?} chipId
     * @return {?}
     */
    function (chipId) {
        return this.chips.toArray().findIndex((/**
         * @param {?} _
         * @return {?}
         */
        function (_) { return _.id === chipId; }));
    };
    /** Retrieves the DOM element of the component host. */
    /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    MdcChipSet.prototype._getHostElement = /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    function () {
        return this.elementRef.nativeElement;
    };
    MdcChipSet.decorators = [
        { type: Component, args: [{selector: 'mdc-chip-set',
                    exportAs: 'mdcChipSet',
                    host: {
                        'class': 'mdc-chip-set',
                        '[class.mdc-chip-set--choice]': 'choice',
                        '[class.mdc-chip-set--filter]': 'filter',
                        '[class.mdc-chip-set--input]': 'input'
                    },
                    template: '<ng-content></ng-content>',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: MDC_CHIPSET_PARENT_COMPONENT, useExisting: MdcChipSet }]
                },] },
    ];
    /** @nocollapse */
    MdcChipSet.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] },
        { type: NgControl, decorators: [{ type: Optional }] }
    ]; };
    MdcChipSet.propDecorators = {
        choice: [{ type: Input }],
        filter: [{ type: Input }],
        input: [{ type: Input }],
        value: [{ type: Input }],
        change: [{ type: Output }],
        chips: [{ type: ContentChildren, args: [MdcChip, { descendants: true },] }]
    };
    return MdcChipSet;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CHIP_DECLARATIONS = [
    MdcChip,
    MdcChipCheckmark,
    MdcChipIcon,
    MdcChipSet,
    MdcChipText
];
var MdcChipsModule = /** @class */ (function () {
    function MdcChipsModule() {
    }
    MdcChipsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, MdcIconModule],
                    exports: CHIP_DECLARATIONS,
                    declarations: CHIP_DECLARATIONS
                },] },
    ];
    return MdcChipsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CHIP_DECLARATIONS, MdcChipsModule, MDC_CHIPSET_PARENT_COMPONENT, MdcChipCheckmark, MdcChipText, MdcChip, MdcChipIcon, MdcChipSetChange, MdcChipSet };
//# sourceMappingURL=chips.es5.js.map
