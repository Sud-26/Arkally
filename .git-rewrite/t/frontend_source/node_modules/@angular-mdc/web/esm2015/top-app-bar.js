/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { Directive, ElementRef, Component, ChangeDetectionStrategy, Input, EventEmitter, ViewEncapsulation, NgZone, ChangeDetectorRef, Output, ContentChild, ContentChildren, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject, fromEvent } from 'rxjs';
import { startWith, takeUntil } from 'rxjs/operators';
import { toBoolean, Platform } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcTopAppBarFixedAdjust {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
MdcTopAppBarFixedAdjust.decorators = [
    { type: Directive, args: [{
                selector: '[mdcTopAppBarFixedAdjust]',
                host: { 'class': 'mdc-top-app-bar--fixed-adjust' }
            },] },
];
/** @nocollapse */
MdcTopAppBarFixedAdjust.ctorParameters = () => [
    { type: ElementRef }
];
class MdcTopAppBarRow {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
MdcTopAppBarRow.decorators = [
    { type: Directive, args: [{
                selector: 'mdc-top-app-bar-row, [mdcTopAppBarRow]',
                exportAs: 'mdcTopAppBarRow',
                host: { 'class': 'mdc-top-app-bar__row' }
            },] },
];
/** @nocollapse */
MdcTopAppBarRow.ctorParameters = () => [
    { type: ElementRef }
];
class MdcTopAppBarSection {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
MdcTopAppBarSection.decorators = [
    { type: Component, args: [{selector: 'mdc-top-app-bar-section, [mdcTopAppBarSection]',
                exportAs: 'mdcTopAppBarSection',
                host: {
                    'role': 'toolbar',
                    'class': 'mdc-top-app-bar__section',
                    '[class.mdc-top-app-bar__section--align-start]': 'align === "start"',
                    '[class.mdc-top-app-bar__section--align-end]': 'align === "end"'
                },
                template: `
  <ng-content></ng-content>
  <span class="mdc-top-app-bar__title" *ngIf="title">{{title}}</span>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcTopAppBarSection.ctorParameters = () => [
    { type: ElementRef }
];
MdcTopAppBarSection.propDecorators = {
    title: [{ type: Input }],
    align: [{ type: Input }]
};
class MdcTopAppBarActionItem {
    /**
     * @param {?} elementRef
     * @param {?} _ripple
     */
    constructor(elementRef, _ripple) {
        this.elementRef = elementRef;
        this._ripple = _ripple;
        this._ripple.init({ surface: this.elementRef.nativeElement, unbounded: true });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._ripple.destroy();
    }
}
MdcTopAppBarActionItem.decorators = [
    { type: Directive, args: [{
                selector: '[mdcTopAppBarActionItem], mdc-top-app-bar-action-item',
                exportAs: 'mdcTopAppBarActionItem',
                host: {
                    'role': 'button',
                    'class': 'mdc-top-app-bar__action-item'
                },
                providers: [MdcRipple]
            },] },
];
/** @nocollapse */
MdcTopAppBarActionItem.ctorParameters = () => [
    { type: ElementRef },
    { type: MdcRipple }
];
class MdcTopAppBarNavigationIcon {
    /**
     * @param {?} elementRef
     * @param {?} _ripple
     */
    constructor(elementRef, _ripple) {
        this.elementRef = elementRef;
        this._ripple = _ripple;
        _ripple.init({ surface: this.elementRef.nativeElement, unbounded: true });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._ripple.destroy();
    }
}
MdcTopAppBarNavigationIcon.decorators = [
    { type: Directive, args: [{
                selector: '[mdcTopAppBarNavIcon], mdc-icon[mdcTopAppBarNavigationIcon]',
                exportAs: 'mdcTopAppBarNavigationIcon',
                host: {
                    'role': 'button',
                    'class': 'mdc-top-app-bar__navigation-icon'
                },
                providers: [MdcRipple]
            },] },
];
/** @nocollapse */
MdcTopAppBarNavigationIcon.ctorParameters = () => [
    { type: ElementRef },
    { type: MdcRipple }
];
class MdcTopAppBarTitle {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
MdcTopAppBarTitle.decorators = [
    { type: Directive, args: [{
                selector: 'mdc-top-app-bar-title, [mdcTopAppBarTitle]',
                exportAs: 'mdcTopAppBarTitle',
                host: { 'class': 'mdc-top-app-bar__title' },
            },] },
];
/** @nocollapse */
MdcTopAppBarTitle.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses = {
  FIXED_CLASS: 'mdc-top-app-bar--fixed',
  FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
  SHORT_CLASS: 'mdc-top-app-bar--short',
  SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
  SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed',
};

/** @enum {number} */
const numbers = {
  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
  MAX_TOP_APP_BAR_HEIGHT: 128,
};

/** @enum {string} */
const strings = {
  ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
  NAVIGATION_EVENT: 'MDCTopAppBar:nav',
  NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
  ROOT_SELECTOR: '.mdc-top-app-bar',
  TITLE_SELECTOR: '.mdc-top-app-bar__title',
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
 */
class MDCTopAppBarBaseFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings;
  }

  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses;
  }

  /** @return enum {number} */
  static get numbers() {
    return numbers;
  }

  /**
   * {@see MDCTopAppBarAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCTopAppBarAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCTopAppBarAdapter} */ ({
      hasClass: (/* className: string */) => {},
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      setStyle: (/* property: string, value: string */) => {},
      getTopAppBarHeight: () => {},
      registerNavigationIconInteractionHandler: (/* type: string, handler: EventListener */) => {},
      deregisterNavigationIconInteractionHandler: (/* type: string, handler: EventListener */) => {},
      notifyNavigationIconClicked: () => {},
      registerScrollHandler: (/* handler: EventListener */) => {},
      deregisterScrollHandler: (/* handler: EventListener */) => {},
      registerResizeHandler: (/* handler: EventListener */) => {},
      deregisterResizeHandler: (/* handler: EventListener */) => {},
      getViewportScrollY: () => /* number */ 0,
      getTotalActionItems: () => /* number */ 0,
    });
  }

  /**
   * @param {!MDCTopAppBarAdapter} adapter
   */
  constructor(/** @type {!MDCTopAppBarAdapter} */ adapter) {
    super(Object.assign(MDCTopAppBarBaseFoundation.defaultAdapter, adapter));

    this.navClickHandler_ = () => this.adapter_.notifyNavigationIconClicked();

    this.scrollHandler_ = () => {};
  }

  init() {
    this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
  }

  destroy() {
    this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
  }

  initScrollHandler() {
    this.adapter_.registerScrollHandler(this.scrollHandler_);
  }

  destroyScrollHandler() {
    this.adapter_.deregisterScrollHandler(this.scrollHandler_);
  }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @extends {MDCTopAppBarFoundation<!MDCFixedTopAppBarFoundation>}
 * @final
 */
class MDCFixedTopAppBarFoundation extends MDCTopAppBarBaseFoundation {
  /**
   * @param {!MDCTopAppBarAdapter} adapter
   */
  constructor(adapter) {
    super(adapter);
    /** State variable for the previous scroll iteration top app bar state */
    this.wasScrolled_ = false;

    this.scrollHandler_ = () => this.fixedScrollHandler_();
  }

  init() {
    super.init();
    this.adapter_.registerScrollHandler(this.scrollHandler_);
  }

  destroy() {
    super.destroy();
    this.adapter_.deregisterScrollHandler(this.scrollHandler_);
  }

  /**
   * Scroll handler for applying/removing the modifier class
   * on the fixed top app bar.
   */
  fixedScrollHandler_() {
    const currentScroll = this.adapter_.getViewportScrollY();

    if (currentScroll <= 0) {
      if (this.wasScrolled_) {
        this.adapter_.removeClass(cssClasses.FIXED_SCROLLED_CLASS);
        this.wasScrolled_ = false;
      }
    } else {
      if (!this.wasScrolled_) {
        this.adapter_.addClass(cssClasses.FIXED_SCROLLED_CLASS);
        this.wasScrolled_ = true;
      }
    }
  }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
 * @final
 */
class MDCShortTopAppBarFoundation extends MDCTopAppBarBaseFoundation {
  /**
   * @param {!MDCTopAppBarAdapter} adapter
   */
  constructor(adapter) {
    super(adapter);
    // State variable for the current top app bar state
    this.isCollapsed = false;

    this.scrollHandler_ = () => this.shortAppBarScrollHandler_();
  }

  init() {
    super.init();
    const isAlwaysCollapsed = this.adapter_.hasClass(cssClasses.SHORT_COLLAPSED_CLASS);

    if (this.adapter_.getTotalActionItems() > 0) {
      this.adapter_.addClass(cssClasses.SHORT_HAS_ACTION_ITEM_CLASS);
    }

    if (!isAlwaysCollapsed) {
      this.adapter_.registerScrollHandler(this.scrollHandler_);
      this.shortAppBarScrollHandler_();
    }
  }

  destroy() {
    super.destroy();
    this.adapter_.deregisterScrollHandler(this.scrollHandler_);
  }


  /**
   * Scroll handler for applying/removing the collapsed modifier class
   * on the short top app bar.
   * @private
   */
  shortAppBarScrollHandler_() {
    const currentScroll = this.adapter_.getViewportScrollY();

    if (currentScroll <= 0) {
      if (this.isCollapsed) {
        this.adapter_.removeClass(cssClasses.SHORT_COLLAPSED_CLASS);
        this.isCollapsed = false;
      }
    } else {
      if (!this.isCollapsed) {
        this.adapter_.addClass(cssClasses.SHORT_COLLAPSED_CLASS);
        this.isCollapsed = true;
      }
    }
  }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const INITIAL_VALUE = 0;
/**
 * @extends {MDCTopAppBarBaseFoundation<!MDCTopAppBarFoundation>}
 * @final
 */
class MDCTopAppBarFoundation extends MDCTopAppBarBaseFoundation {
  /**
   * @param {!MDCTopAppBarAdapter} adapter
   */
  constructor(adapter) {
    super(adapter);
    /**
     * Used for diffs of current scroll position vs previous scroll position
     * @private {number}
     */
    this.lastScrollPosition_ = this.adapter_.getViewportScrollY();

    /**
     * Used to verify when the top app bar is completely showing or completely hidden
     * @private {number}
     */
    this.topAppBarHeight_ = this.adapter_.getTopAppBarHeight();

    /**
     * wasDocked_ is used to indicate if the top app bar was docked in the previous
     * scroll handler iteration.
     * @private {boolean}
     */
    this.wasDocked_ = true;

    /**
     * isDockedShowing_ is used to indicate if the top app bar is docked in the fully
     * shown position.
     * @private {boolean}
     */
    this.isDockedShowing_ = true;

    /**
     * Variable for current scroll position of the top app bar
     * @private {number}
     */
    this.currentAppBarOffsetTop_ = 0;

    /**
     * Used to prevent the top app bar from being scrolled out of view during resize events
     * @private {boolean} */
    this.isCurrentlyBeingResized_ = false;

    /**
     * The timeout that's used to throttle the resize events
     * @private {number}
     */
    this.resizeThrottleId_ = INITIAL_VALUE;

    /**
     * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize
     * @private {number}
     */
    this.resizeDebounceId_ = INITIAL_VALUE;

    this.scrollHandler_ = () => this.topAppBarScrollHandler_();
    this.resizeHandler_ = () => this.topAppBarResizeHandler_();
  }

  init() {
    super.init();
    this.adapter_.registerScrollHandler(this.scrollHandler_);
    this.adapter_.registerResizeHandler(this.resizeHandler_);
  }

  destroy() {
    super.destroy();
    this.adapter_.deregisterScrollHandler(this.scrollHandler_);
    this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    this.adapter_.setStyle('top', '');
  }

  /**
   * Function to determine if the DOM needs to update.
   * @return {boolean}
   * @private
   */
  checkForUpdate_() {
    const offscreenBoundaryTop = -this.topAppBarHeight_;
    const hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
    const hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
    const partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;

    // If it's partially showing, it can't be docked.
    if (partiallyShowing) {
      this.wasDocked_ = false;
    } else {
      // Not previously docked and not partially showing, it's now docked.
      if (!this.wasDocked_) {
        this.wasDocked_ = true;
        return true;
      } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
        this.isDockedShowing_ = hasAnyPixelsOnscreen;
        return true;
      }
    }

    return partiallyShowing;
  }

  /**
   * Function to move the top app bar if needed.
   * @private
   */
  moveTopAppBar_() {
    if (this.checkForUpdate_()) {
      // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
      // so the top app bar doesn't show if the window resizes and the new height > the old height.
      let offset = this.currentAppBarOffsetTop_;
      if (Math.abs(offset) >= this.topAppBarHeight_) {
        offset = -numbers.MAX_TOP_APP_BAR_HEIGHT;
      }

      this.adapter_.setStyle('top', offset + 'px');
    }
  }

  /**
   * Scroll handler for the default scroll behavior of the top app bar.
   * @private
   */
  topAppBarScrollHandler_() {
    const currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);
    const diff = currentScrollPosition - this.lastScrollPosition_;
    this.lastScrollPosition_ = currentScrollPosition;

    // If the window is being resized the lastScrollPosition_ needs to be updated but the
    // current scroll of the top app bar should stay in the same position.
    if (!this.isCurrentlyBeingResized_) {
      this.currentAppBarOffsetTop_ -= diff;

      if (this.currentAppBarOffsetTop_ > 0) {
        this.currentAppBarOffsetTop_ = 0;
      } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
        this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
      }

      this.moveTopAppBar_();
    }
  }

  /**
   * Top app bar resize handler that throttle/debounce functions that execute updates.
   * @private
   */
  topAppBarResizeHandler_() {
    // Throttle resize events 10 p/s
    if (!this.resizeThrottleId_) {
      this.resizeThrottleId_ = setTimeout(() => {
        this.resizeThrottleId_ = INITIAL_VALUE;
        this.throttledResizeHandler_();
      }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
    }

    this.isCurrentlyBeingResized_ = true;

    if (this.resizeDebounceId_) {
      clearTimeout(this.resizeDebounceId_);
    }

    this.resizeDebounceId_ = setTimeout(() => {
      this.topAppBarScrollHandler_();
      this.isCurrentlyBeingResized_ = false;
      this.resizeDebounceId_ = INITIAL_VALUE;
    }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
  }

  /**
   * Throttled function that updates the top app bar scrolled values if the
   * top app bar height changes.
   * @private
   */
  throttledResizeHandler_() {
    const currentHeight = this.adapter_.getTopAppBarHeight();
    if (this.topAppBarHeight_ !== currentHeight) {
      this.wasDocked_ = false;

      // Since the top app bar has a different height depending on the screen width, this
      // will ensure that the top app bar remains in the correct location if
      // completely hidden and a resize makes the top app bar a different height.
      this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
      this.topAppBarHeight_ = currentHeight;
    }
    this.topAppBarScrollHandler_();
  }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Event object emitted by MdcTopAppBar navigation icon selected.
 */
class MdcTopAppBarNavSelected {
    /**
     * @param {?} source
     */
    constructor(source) {
        this.source = source;
    }
}
class MdcTopAppBar {
    /**
     * @param {?} _ngZone
     * @param {?} _platform
     * @param {?} _changeDetectorRef
     * @param {?} elementRef
     */
    constructor(_ngZone, _platform, _changeDetectorRef, elementRef) {
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._changeDetectorRef = _changeDetectorRef;
        this.elementRef = elementRef;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroyed = new Subject();
        this._isFoundationInit = false;
        this._fixed = false;
        this._prominent = false;
        this._short = false;
        this._shortCollapsed = false;
        this._dense = false;
        this._fixedAdjustElement = null;
        this._scrollTarget = this._platform.isBrowser ? this._scrollTarget || window : undefined;
        /**
         * Event emitted when the navigation icon is selected.
         */
        this.navigationSelected = new EventEmitter();
        this._scrollTargetSubscription = null;
    }
    /**
     * @return {?}
     */
    get fixed() { return this._fixed; }
    /**
     * @param {?} value
     * @return {?}
     */
    set fixed(value) {
        if (value !== this._fixed) {
            this.setFixed(value);
        }
    }
    /**
     * @return {?}
     */
    get prominent() { return this._prominent; }
    /**
     * @param {?} value
     * @return {?}
     */
    set prominent(value) {
        if (value !== this._prominent) {
            this.setProminent(value);
        }
    }
    /**
     * @return {?}
     */
    get short() { return this._short; }
    /**
     * @param {?} value
     * @return {?}
     */
    set short(value) {
        if (value !== this._short) {
            this.setShort(value);
        }
    }
    /**
     * @return {?}
     */
    get shortCollapsed() { return this._shortCollapsed; }
    /**
     * @param {?} value
     * @return {?}
     */
    set shortCollapsed(value) {
        if (value !== this._shortCollapsed) {
            this.setShortCollapsed(value);
        }
    }
    /**
     * @return {?}
     */
    get dense() { return this._dense; }
    /**
     * @param {?} value
     * @return {?}
     */
    set dense(value) {
        if (value !== this._dense) {
            this.setDense(value);
        }
    }
    /**
     * @return {?}
     */
    get fixedAdjustElement() { return this._fixedAdjustElement; }
    /**
     * @param {?} element
     * @return {?}
     */
    set fixedAdjustElement(element) {
        if (this._fixedAdjustElement !== element) {
            this._fixedAdjustElement = element;
            this._initTopAppBar();
        }
    }
    /**
     * @return {?}
     */
    get scrollTarget() { return this._scrollTarget; }
    /**
     * @param {?} target
     * @return {?}
     */
    set scrollTarget(target) {
        if (target !== this._scrollTarget) {
            this._scrollTarget = target ? target : this._platform.isBrowser ? window : undefined;
            this._initScrollHandler();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _createAdapter() {
        return {
            hasClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.contains(className)),
            addClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.add(className)),
            removeClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => {
                if (className === cssClasses.SHORT_COLLAPSED_CLASS && this.shortCollapsed) {
                    return;
                }
                this._getHostElement().classList.remove(className);
            }),
            setStyle: (/**
             * @param {?} property
             * @param {?} value
             * @return {?}
             */
            (property, value) => this._getHostElement().style.setProperty(property, value)),
            getTopAppBarHeight: (/**
             * @return {?}
             */
            () => this._getHostElement().clientHeight),
            notifyNavigationIconClicked: (/**
             * @return {?}
             */
            () => this.navigationSelected.emit({ source: this })),
            registerResizeHandler: (/**
             * @param {?} handler
             * @return {?}
             */
            (handler) => {
                if (!this._platform.isBrowser) {
                    return;
                }
                window.addEventListener('resize', handler);
            }),
            deregisterResizeHandler: (/**
             * @param {?} handler
             * @return {?}
             */
            (handler) => {
                if (!this._platform.isBrowser) {
                    return;
                }
                window.removeEventListener('resize', handler);
            }),
            getViewportScrollY: (/**
             * @return {?}
             */
            () => {
                if (!this._platform.isBrowser) {
                    return 0;
                }
                return this._scrollTarget[this._scrollTarget === window ? 'pageYOffset' : 'scrollTop'];
            }),
            getTotalActionItems: (/**
             * @return {?}
             */
            () => this.actions ? this.actions.length : 0)
        };
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.actions.changes.pipe(startWith(null), takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            if (this.short && this.actions.length) {
                this._getHostElement().classList.toggle(cssClasses.SHORT_HAS_ACTION_ITEM_CLASS);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this._isFoundationInit) {
            this._initFoundation();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        if (this._scrollTargetSubscription) {
            this._scrollTargetSubscription.unsubscribe();
        }
        this._destroyFoundation();
    }
    /**
     * Sets the top app bar to fixed or not.
     * @param {?} fixed
     * @param {?=} isUserInput
     * @return {?}
     */
    setFixed(fixed, isUserInput = true) {
        this._fixed = toBoolean(fixed);
        if (this.fixed && this.short) {
            this.setShort(false, false);
        }
        if (isUserInput) {
            this._initFoundation();
        }
    }
    /**
     * Sets the top app bar to prominent or not.
     * @param {?} prominent
     * @param {?=} isUserInput
     * @return {?}
     */
    setProminent(prominent, isUserInput = true) {
        this._prominent = toBoolean(prominent);
        if (this.prominent && this.short) {
            this.setShort(false, false);
        }
        if (isUserInput) {
            this._initFoundation();
        }
    }
    /**
     * Sets the top app bar to dense variant.
     * @param {?} dense
     * @param {?=} isUserInput
     * @return {?}
     */
    setDense(dense, isUserInput = true) {
        this._dense = toBoolean(dense);
        if (this.dense && this.short) {
            this.setShort(false, false);
        }
        if (isUserInput) {
            this._initFoundation();
        }
    }
    /**
     * Sets the top app bar to short or not.
     * @param {?} short
     * @param {?=} isUserInput
     * @return {?}
     */
    setShort(short, isUserInput = true) {
        this._short = toBoolean(short);
        if (this.short) {
            this.setProminent(false, false);
            this.setDense(false, false);
            this.setFixed(false, false);
        }
        else {
            this.setShortCollapsed(false, false);
        }
        if (isUserInput) {
            this._initFoundation();
        }
    }
    /**
     * Sets the top app bar to short-collapsed or not.
     * @param {?} shortCollapsed
     * @param {?=} isUserInput
     * @return {?}
     */
    setShortCollapsed(shortCollapsed, isUserInput = true) {
        this._shortCollapsed = toBoolean(shortCollapsed);
        if (this.shortCollapsed && !this.short) {
            this.setShort(true, false);
        }
        if (isUserInput) {
            this._initFoundation();
        }
    }
    /**
     * @return {?}
     */
    isCollapsed() {
        return this._getHostElement().classList.contains(cssClasses.SHORT_COLLAPSED_CLASS);
    }
    /**
     * @private
     * @return {?}
     */
    _initFoundation() {
        this._destroyFoundation();
        this._getHostElement().style.top = '0px';
        this._resetFixedShort();
        if (this.short) {
            this._foundation = new MDCShortTopAppBarFoundation(this._createAdapter());
        }
        else if (this.fixed) {
            this._foundation = new MDCFixedTopAppBarFoundation(this._createAdapter());
        }
        else {
            this._foundation = new MDCTopAppBarFoundation(this._createAdapter());
        }
        this._foundation.init();
        this._isFoundationInit = true;
        this._initTopAppBar();
        this._initScrollHandler();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    _resetFixedShort() {
        this._getHostElement().classList.remove(cssClasses.SHORT_HAS_ACTION_ITEM_CLASS);
        this._getHostElement().classList.remove(cssClasses.SHORT_COLLAPSED_CLASS);
        this._getHostElement().classList.remove(cssClasses.FIXED_SCROLLED_CLASS);
    }
    /**
     * @private
     * @return {?}
     */
    _initTopAppBar() {
        if (!this.fixed) {
            this._getHostElement().classList.remove(cssClasses.FIXED_SCROLLED_CLASS);
        }
        if (this.fixed && this._getScrollOffset() > 0) {
            this._getHostElement().classList.add(cssClasses.FIXED_SCROLLED_CLASS);
        }
        if (!this.short) {
            this._getHostElement().classList.remove(cssClasses.SHORT_HAS_ACTION_ITEM_CLASS);
            this._getHostElement().classList.remove(cssClasses.SHORT_COLLAPSED_CLASS);
        }
        if (this.short && this._getScrollOffset() > 0) {
            this._getHostElement().classList.add(cssClasses.SHORT_COLLAPSED_CLASS);
        }
        if (this.shortCollapsed) {
            this._getHostElement().classList.add(cssClasses.SHORT_COLLAPSED_CLASS);
        }
        if (this.fixedAdjustElement) {
            this._removeFixedAdjustClasses();
            this._addFixedAdjustClass();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _removeFixedAdjustClasses() {
        (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--short-fixed-adjust');
        (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--fixed-adjust');
        (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--dense-fixed-adjust');
        (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--prominent-fixed-adjust');
        (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--dense-prominent-fixed-adjust');
    }
    /**
     * @private
     * @return {?}
     */
    _addFixedAdjustClass() {
        if (this._short) {
            (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--short-fixed-adjust');
        }
        else if (this._dense && this._prominent) {
            (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--dense-prominent-fixed-adjust');
        }
        else if (this._dense) {
            (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--dense-fixed-adjust');
        }
        else if (this._prominent) {
            (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--prominent-fixed-adjust');
        }
        else {
            (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--fixed-adjust');
        }
    }
    /**
     * @private
     * @return {?}
     */
    _destroyFoundation() {
        if (this._foundation) {
            this._foundation.destroy();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _initScrollHandler() {
        if (this._scrollTargetSubscription) {
            this._scrollTargetSubscription.unsubscribe();
        }
        if (!this._platform.isBrowser) {
            return;
        }
        this._scrollTargetSubscription = this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => fromEvent(this.scrollTarget || window, 'scroll')
            .subscribe((/**
         * @return {?}
         */
        () => this._ngZone.run((/**
         * @return {?}
         */
        () => {
            if (this.fixed) {
                this._foundation.fixedScrollHandler_();
            }
            else if (this.short) {
                this._foundation.shortAppBarScrollHandler_();
            }
            else {
                this._foundation.topAppBarScrollHandler_();
            }
        }))))));
    }
    /**
     * @private
     * @return {?}
     */
    _getScrollOffset() {
        if (!this._platform.isBrowser) {
            return 0;
        }
        return this.scrollTarget ? this.scrollTarget.scrollTop : window.pageYOffset;
    }
    /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcTopAppBar.decorators = [
    { type: Component, args: [{
                selector: 'mdc-top-app-bar, [mdc-top-app-bar]',
                exportAs: 'mdcTopAppBar',
                host: {
                    'class': 'mdc-top-app-bar',
                    '[class.mdc-top-app-bar--prominent]': 'prominent',
                    '[class.mdc-top-app-bar--dense]': 'dense',
                    '[class.mdc-top-app-bar--short]': 'short',
                    '[class.mdc-top-app-bar--fixed]': 'fixed'
                },
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcTopAppBar.ctorParameters = () => [
    { type: NgZone },
    { type: Platform },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
MdcTopAppBar.propDecorators = {
    fixed: [{ type: Input }],
    prominent: [{ type: Input }],
    short: [{ type: Input }],
    shortCollapsed: [{ type: Input }],
    dense: [{ type: Input }],
    fixedAdjustElement: [{ type: Input }],
    scrollTarget: [{ type: Input }],
    navigationSelected: [{ type: Output }],
    navigationIcon: [{ type: ContentChild, args: [MdcTopAppBarNavigationIcon,] }],
    actions: [{ type: ContentChildren, args: [MdcTopAppBarActionItem, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TOP_APP_BAR_DECLARATIONS = [
    MdcTopAppBar,
    MdcTopAppBarActionItem,
    MdcTopAppBarFixedAdjust,
    MdcTopAppBarNavigationIcon,
    MdcTopAppBarRow,
    MdcTopAppBarSection,
    MdcTopAppBarTitle
];
class MdcTopAppBarModule {
}
MdcTopAppBarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: TOP_APP_BAR_DECLARATIONS,
                declarations: TOP_APP_BAR_DECLARATIONS
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MdcTopAppBarModule, MdcTopAppBarFixedAdjust, MdcTopAppBarRow, MdcTopAppBarSection, MdcTopAppBarActionItem, MdcTopAppBarNavigationIcon, MdcTopAppBarTitle, MdcTopAppBarNavSelected, MdcTopAppBar };
//# sourceMappingURL=top-app-bar.js.map
