/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { EventEmitter, ChangeDetectorRef, NgZone, Optional, ElementRef, Input, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, Directive, NgModule } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { toBoolean, Platform } from '@angular-mdc/web/common';

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @type {string|undefined} */
let storedTransformPropertyName_;

/**
 * Returns the name of the correct transform property to use on the current browser.
 * @param {!Window} globalObj
 * @param {boolean=} forceRefresh
 * @return {string}
 */
function getTransformPropertyName(globalObj, forceRefresh = false) {
  if (storedTransformPropertyName_ === undefined || forceRefresh) {
    const el = globalObj.document.createElement('div');
    const transformPropertyName = ('transform' in el.style ? 'transform' : 'webkitTransform');
    storedTransformPropertyName_ = transformPropertyName;
  }

  return storedTransformPropertyName_;
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses = {
  ANCHOR: 'mdc-menu-surface--anchor',
  ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
  ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
  FIXED: 'mdc-menu-surface--fixed',
  OPEN: 'mdc-menu-surface--open',
  ROOT: 'mdc-menu-surface',
};

/** @enum {string} */
const strings = {
  CLOSED_EVENT: 'MDCMenuSurface:closed',
  OPENED_EVENT: 'MDCMenuSurface:opened',
  FOCUSABLE_ELEMENTS: 'button:not(:disabled), [href]:not([aria-disabled="true"]), input:not(:disabled), ' +
  'select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])',
};

/** @enum {number} */
const numbers = {
  // Total duration of menu-surface open animation.
  TRANSITION_OPEN_DURATION: 120,
  // Total duration of menu-surface close animation.
  TRANSITION_CLOSE_DURATION: 75,
  // Margin left to the edge of the viewport when menu-surface is at maximum possible height.
  MARGIN_TO_EDGE: 32,
  // Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning.
  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
};

/**
 * Enum for bits in the {@see Corner) bitmap.
 * @enum {number}
 */
const CornerBit = {
  BOTTOM: 1,
  CENTER: 2,
  RIGHT: 4,
  FLIP_RTL: 8,
};

/**
 * Enum for representing an element corner for positioning the menu-surface.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 *
 * @enum {number}
 */
const Corner = {
  TOP_LEFT: 0,
  TOP_RIGHT: CornerBit.RIGHT,
  BOTTOM_LEFT: CornerBit.BOTTOM,
  BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
  TOP_START: CornerBit.FLIP_RTL,
  TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
  BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
  BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL,
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @extends {MDCFoundation<!MDCMenuSurfaceAdapter>}
 */
class MDCMenuSurfaceFoundation extends MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    return cssClasses;
  }

  /** @return enum{string} */
  static get strings() {
    return strings;
  }

  /** @return enum {number} */
  static get numbers() {
    return numbers;
  }

  /** @return enum{number} */
  static get Corner() {
    return Corner;
  }

  /**
   * {@see MDCMenuSurfaceAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCMenuSurfaceAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCMenuSurfaceAdapter} */ ({
      addClass: () => {},
      removeClass: () => {},
      hasClass: () => false,
      hasAnchor: () => false,
      notifyClose: () => {},
      notifyOpen: () => {},
      isElementInContainer: () => false,
      isRtl: () => false,
      setTransformOrigin: () => {},
      isFocused: () => false,
      saveFocus: () => {},
      restoreFocus: () => {},
      isFirstElementFocused: () => {},
      isLastElementFocused: () => {},
      focusFirstElement: () => {},
      focusLastElement: () => {},
      getInnerDimensions: () => ({}),
      getAnchorDimensions: () => ({}),
      getWindowDimensions: () => ({}),
      getBodyDimensions: () => ({}),
      getWindowScroll: () => ({}),
      setPosition: () => {},
      setMaxHeight: () => {},
    });
  }

  /** @param {!MDCMenuSurfaceAdapter} adapter */
  constructor(adapter) {
    super(Object.assign(MDCMenuSurfaceFoundation.defaultAdapter, adapter));

    /** @private {boolean} */
    this.isOpen_ = false;
    /** @private {number} */
    this.openAnimationEndTimerId_ = 0;
    /** @private {number} */
    this.closeAnimationEndTimerId_ = 0;
    /** @private {number} */
    this.animationRequestId_ = 0;
    /** @private {!{ width: number, height: number }} */
    this.dimensions_;
    /** @private {!Corner} */
    this.anchorCorner_ = Corner.TOP_START;
    /** @private {!AnchorMargin} */
    this.anchorMargin_ = {top: 0, right: 0, bottom: 0, left: 0};
    /** @private {?AutoLayoutMeasurements} */
    this.measures_ = null;
    /** @private {boolean} */
    this.quickOpen_ = false;
    /** @private {boolean} */
    this.hoistedElement_ = false;
    /** @private {boolean} */
    this.isFixedPosition_ = false;
    /** @private {!{x: number, y: number}} */
    this.position_ = {x: 0, y: 0};
  }

  init() {
    const {ROOT, OPEN} = MDCMenuSurfaceFoundation.cssClasses;

    if (!this.adapter_.hasClass(ROOT)) {
      throw new Error(`${ROOT} class required in root element.`);
    }

    if (this.adapter_.hasClass(OPEN)) {
      this.isOpen_ = true;
    }
  }

  destroy() {
    clearTimeout(this.openAnimationEndTimerId_);
    clearTimeout(this.closeAnimationEndTimerId_);
    // Cancel any currently running animations.
    cancelAnimationFrame(this.animationRequestId_);
  }

  /**
   * @param {!Corner} corner Default anchor corner alignment of top-left menu surface corner.
   */
  setAnchorCorner(corner) {
    this.anchorCorner_ = corner;
  }

  /**
   * @param {!AnchorMargin} margin set of margin values from anchor.
   */
  setAnchorMargin(margin) {
    this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
    this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
    this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
    this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
  }

  /**
   * Used to indicate if the menu-surface is hoisted to the body.
   * @param {boolean} isHoisted
   */
  setIsHoisted(isHoisted) {
    this.hoistedElement_ = isHoisted;
  }

  /**
   * Used to set the menu-surface calculations based on a fixed position menu.
   * @param {boolean} isFixedPosition
   */
  setFixedPosition(isFixedPosition) {
    this.isFixedPosition_ = isFixedPosition;
  }

  /**
   * Sets the menu-surface position on the page.
   * @param {number} x
   * @param {number} y
   */
  setAbsolutePosition(x, y) {
    this.position_.x = this.typeCheckisFinite_(x) ? x : 0;
    this.position_.y = this.typeCheckisFinite_(y) ? y : 0;
  }

  /** @param {boolean} quickOpen */
  setQuickOpen(quickOpen) {
    this.quickOpen_ = quickOpen;
  }

  /**
   * Handle clicks and close if not within menu-surface element.
   * @param {!Event} evt
   */
  handleBodyClick(evt) {
    const el = evt.target;

    if (this.adapter_.isElementInContainer(el)) {
      return;
    }

    this.close();
  };

  /**
   * Handle keys that close the surface.
   * @param {!Event} evt
   */
  handleKeydown(evt) {
    const {keyCode, key, shiftKey} = evt;

    const isEscape = key === 'Escape' || keyCode === 27;
    const isTab = key === 'Tab' || keyCode === 9;

    if (isEscape) {
      this.close();
    } else if (isTab) {
      if (this.adapter_.isLastElementFocused() && !shiftKey) {
        this.adapter_.focusFirstElement();
        evt.preventDefault();
      } else if (this.adapter_.isFirstElementFocused() && shiftKey) {
        this.adapter_.focusLastElement();
        evt.preventDefault();
      }
    }
  }

  /**
   * @return {!AutoLayoutMeasurements} Measurements used to position menu surface popup.
   */
  getAutoLayoutMeasurements_() {
    let anchorRect = this.adapter_.getAnchorDimensions();
    const viewport = this.adapter_.getWindowDimensions();
    const bodyDimensions = this.adapter_.getBodyDimensions();
    const windowScroll = this.adapter_.getWindowScroll();

    if (!anchorRect) {
      anchorRect = /** @type {ClientRect} */ ({
        x: this.position_.x,
        y: this.position_.y,
        top: this.position_.y,
        bottom: this.position_.y,
        left: this.position_.x,
        right: this.position_.x,
        height: 0,
        width: 0,
      });
    }

    return {
      viewport,
      bodyDimensions,
      windowScroll,
      viewportDistance: {
        top: anchorRect.top,
        right: viewport.width - anchorRect.right,
        left: anchorRect.left,
        bottom: viewport.height - anchorRect.bottom,
      },
      anchorHeight: anchorRect.height,
      anchorWidth: anchorRect.width,
      surfaceHeight: this.dimensions_.height,
      surfaceWidth: this.dimensions_.width,
    };
  }

  /**
   * Computes the corner of the anchor from which to animate and position the menu surface.
   * @return {!Corner}
   * @private
   */
  getOriginCorner_() {
    // Defaults: open from the top left.
    let corner = Corner.TOP_LEFT;

    const {viewportDistance, anchorHeight, anchorWidth, surfaceHeight, surfaceWidth} = this.measures_;
    const isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
    const availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom
      : viewportDistance.top + this.anchorMargin_.top;
    const availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom
      : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;

    const topOverflow = surfaceHeight - availableTop;
    const bottomOverflow = surfaceHeight - availableBottom;
    if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
      corner |= CornerBit.BOTTOM;
    }

    const isRtl = this.adapter_.isRtl();
    const isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
    const avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
    const isAlignedRight = (avoidHorizontalOverlap && !isRtl) ||
      (!avoidHorizontalOverlap && isFlipRtl && isRtl);
    const availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right :
      viewportDistance.left + this.anchorMargin_.left;
    const availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right :
      viewportDistance.right + anchorWidth - this.anchorMargin_.left;

    const leftOverflow = surfaceWidth - availableLeft;
    const rightOverflow = surfaceWidth - availableRight;

    if ((leftOverflow < 0 && isAlignedRight && isRtl) ||
        (avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0) ||
        (rightOverflow > 0 && leftOverflow < rightOverflow)) {
      corner |= CornerBit.RIGHT;
    }

    return /** @type {Corner} */ (corner);
  }

  /**
   * @param {!Corner} corner Origin corner of the menu surface.
   * @return {number} Horizontal offset of menu surface origin corner from corresponding anchor corner.
   * @private
   */
  getHorizontalOriginOffset_(corner) {
    const {anchorWidth} = this.measures_;
    // isRightAligned corresponds to using the 'right' property on the surface.
    const isRightAligned = Boolean(corner & CornerBit.RIGHT);
    const avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);

    if (isRightAligned) {
      const rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;

      // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
      // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
      // the right property is correct.
      if (this.hoistedElement_ || this.isFixedPosition_) {
        return rightOffset - (this.measures_.viewport.width - this.measures_.bodyDimensions.width);
      }

      return rightOffset;
    }

    return avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
  }

  /**
   * @param {!Corner} corner Origin corner of the menu surface.
   * @return {number} Vertical offset of menu surface origin corner from corresponding anchor corner.
   * @private
   */
  getVerticalOriginOffset_(corner) {
    const {anchorHeight} = this.measures_;
    const isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
    const avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
    let y = 0;

    if (isBottomAligned) {
      y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
    } else {
      y = avoidVerticalOverlap ? (anchorHeight + this.anchorMargin_.bottom) : this.anchorMargin_.top;
    }
    return y;
  }

  /**
   * @param {!Corner} corner Origin corner of the menu surface.
   * @return {number} Maximum height of the menu surface, based on available space. 0 indicates should not be set.
   * @private
   */
  getMenuSurfaceMaxHeight_(corner) {
    let maxHeight = 0;
    const {viewportDistance} = this.measures_;
    const isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
    const {MARGIN_TO_EDGE} = MDCMenuSurfaceFoundation.numbers;

    // When maximum height is not specified, it is handled from css.
    if (isBottomAligned) {
      maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;
      if (!(this.anchorCorner_ & CornerBit.BOTTOM)) {
        maxHeight += this.measures_.anchorHeight;
      }
    } else {
      maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measures_.anchorHeight - MARGIN_TO_EDGE;
      if (this.anchorCorner_ & CornerBit.BOTTOM) {
        maxHeight -= this.measures_.anchorHeight;
      }
    }

    return maxHeight;
  }

  /** @private */
  autoPosition_() {
    // Compute measurements for autoposition methods reuse.
    this.measures_ = this.getAutoLayoutMeasurements_();

    const corner = this.getOriginCorner_();
    const maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
    const verticalAlignment = (corner & CornerBit.BOTTOM) ? 'bottom' : 'top';
    let horizontalAlignment = (corner & CornerBit.RIGHT) ? 'right' : 'left';
    const horizontalOffset = this.getHorizontalOriginOffset_(corner);
    const verticalOffset = this.getVerticalOriginOffset_(corner);
    let position = {
      [horizontalAlignment]: horizontalOffset ? horizontalOffset : '0',
      [verticalAlignment]: verticalOffset ? verticalOffset : '0',
    };
    const {anchorWidth, surfaceWidth} = this.measures_;
    // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.
    if (anchorWidth / surfaceWidth > numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
      horizontalAlignment = 'center';
    }

    // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element
    if (this.hoistedElement_ || this.isFixedPosition_) {
      position = this.adjustPositionForHoistedElement_(position);
    }

    for (const prop in position) {
      if (position.hasOwnProperty(prop) && position[prop] !== '0') {
        position[prop] = `${parseInt(position[prop], 10)}px`;
      }
    }

    this.adapter_.setTransformOrigin(`${horizontalAlignment} ${verticalAlignment}`);
    this.adapter_.setPosition(position);
    this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');

    // Clear measures after positioning is complete.
    this.measures_ = null;
  }

  /**
   * Calculates the offsets for positioning the menu-surface when the menu-surface has been
   * hoisted to the body.
   * @param {!{
   *   top: (string|undefined),
   *   right: (string|undefined),
   *   bottom: (string|undefined),
   *   left: (string|undefined)
   * }} position
   * @return {!{
   *   top: (string|undefined),
   *   right: (string|undefined),
   *   bottom: (string|undefined),
   *   left: (string|undefined)
   * }} position
   * @private
   */
  adjustPositionForHoistedElement_(position) {
    const {windowScroll, viewportDistance} = this.measures_;

    for (const prop in position) {
      if (position.hasOwnProperty(prop)) {
        // Hoisted surfaces need to have the anchor elements location on the page added to the
        // position properties for proper alignment on the body.
        if (viewportDistance.hasOwnProperty(prop)) {
          position[prop] = parseInt(position[prop], 10) + viewportDistance[prop];
        }

        // Surfaces that are absolutely positioned need to have additional calculations for scroll
        // and bottom positioning.
        if (!this.isFixedPosition_) {
          if (prop === 'top') {
            position[prop] = parseInt(position[prop], 10) + windowScroll.y;
          } else if (prop === 'bottom') {
            position[prop] = parseInt(position[prop], 10) - windowScroll.y;
          } else if (prop === 'left') {
            position[prop] = parseInt(position[prop], 10) + windowScroll.x;
          } else if (prop === 'right') {
            position[prop] = parseInt(position[prop], 10) - windowScroll.x;
          }
        }
      }
    }

    return position;
  }

  /**
   * Open the menu surface.
   */
  open() {
    this.adapter_.saveFocus();

    if (!this.quickOpen_) {
      this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
    }

    this.animationRequestId_ = requestAnimationFrame(() => {
      this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
      this.dimensions_ = this.adapter_.getInnerDimensions();
      this.autoPosition_();
      if (this.quickOpen_) {
        this.adapter_.notifyOpen();
      } else {
        this.openAnimationEndTimerId_ = setTimeout(() => {
          this.openAnimationEndTimerId_ = 0;
          this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
          this.adapter_.notifyOpen();
        }, numbers.TRANSITION_OPEN_DURATION);
      }
    });
    this.isOpen_ = true;
  }

  /**
   * Closes the menu surface.
   */
  close() {
    if (!this.quickOpen_) {
      this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
    }

    requestAnimationFrame(() => {
      this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
      if (this.quickOpen_) {
        this.adapter_.notifyClose();
      } else {
        this.closeAnimationEndTimerId_ = setTimeout(() => {
          this.closeAnimationEndTimerId_ = 0;
          this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
          this.adapter_.notifyClose();
        }, numbers.TRANSITION_CLOSE_DURATION);
      }
    });

    this.isOpen_ = false;
    this.maybeRestoreFocus_();
  }

  /**
   * The last focused element when the menu surface was opened should regain focus, if the user is
   * focused on or within the menu surface when it is closed.
   * @private
   */
  maybeRestoreFocus_() {
    if (this.adapter_.isFocused() || this.adapter_.isElementInContainer(document.activeElement)) {
      this.adapter_.restoreFocus();
    }
  }

  /** @return {boolean} */
  isOpen() {
    return this.isOpen_;
  }

  /**
   * isFinite that doesn't force conversion to number type.
   * Equivalent to Number.isFinite in ES2015, but is not included in IE11.
   * @param {number} num
   * @return {boolean}
   * @private
   */
  typeCheckisFinite_(num) {
    return typeof num === 'number' && isFinite(num);
  }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ANCHOR_CORNER_MAP = {
    bottomEnd: Corner.BOTTOM_END,
    bottomStart: Corner.BOTTOM_START,
    topEnd: Corner.TOP_END,
    topStart: Corner.TOP_START
};
/**
 * @abstract
 */
class MdcMenuSurfaceBase {
    /**
     * @param {?} changeDetectorRef
     * @param {?} platform
     * @param {?} _ngZone
     * @param {?} elementRef
     */
    constructor(changeDetectorRef, platform, _ngZone, elementRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.platform = platform;
        this._ngZone = _ngZone;
        this.elementRef = elementRef;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this._previousFocus = null;
        this._firstFocusableElement = null;
        this._lastFocusableElement = null;
        this._open = false;
        this._anchorElement = null;
        this._anchorCorner = 'topStart';
        this._quickOpen = false;
        this._fixed = false;
        this._coordinates = { x: 0, y: 0 };
        this._anchorMargin = {};
        this._hoistToBody = false;
        /**
         * Emits an event whenever the menu surface is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits an event whenever the menu surface is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Subscription to interaction events in menu-surface.
         */
        this._windowClickSubscription = null;
        this._foundation = new MDCMenuSurfaceFoundation(this._createSurfaceAdapter());
    }
    /**
     * @return {?}
     */
    get open() { return this._open; }
    /**
     * @param {?} value
     * @return {?}
     */
    set open(value) {
        this._open = toBoolean(value);
        this.setOpen();
    }
    /**
     * @return {?}
     */
    get anchorElement() { return this._anchorElement; }
    /**
     * @param {?} element
     * @return {?}
     */
    set anchorElement(element) {
        this._anchorElement = element;
    }
    /**
     * @return {?}
     */
    get anchorCorner() { return this._anchorCorner; }
    /**
     * @param {?} value
     * @return {?}
     */
    set anchorCorner(value) {
        this._anchorCorner = value || 'topStart';
        this._foundation.setAnchorCorner([ANCHOR_CORNER_MAP[this._anchorCorner]]);
    }
    /**
     * @return {?}
     */
    get quickOpen() { return this._quickOpen; }
    /**
     * @param {?} value
     * @return {?}
     */
    set quickOpen(value) {
        this._quickOpen = toBoolean(value);
        this._foundation.setQuickOpen(this._quickOpen);
    }
    /**
     * @return {?}
     */
    get fixed() { return this._fixed; }
    /**
     * @param {?} value
     * @return {?}
     */
    set fixed(value) {
        this._fixed = toBoolean(value);
        this._fixed ? this._getHostElement().classList.add('mdc-menu-surface--fixed') :
            this._getHostElement().classList.remove('mdc-menu-surface--fixed');
        this._foundation.setFixedPosition(this._fixed);
    }
    /**
     * @return {?}
     */
    get coordinates() { return this._coordinates; }
    /**
     * @param {?} value
     * @return {?}
     */
    set coordinates(value) {
        this._coordinates = value;
        this._foundation.setAbsolutePosition(value.x, value.y);
    }
    /**
     * @return {?}
     */
    get anchorMargin() { return this._anchorMargin; }
    /**
     * @param {?} value
     * @return {?}
     */
    set anchorMargin(value) {
        this._anchorMargin = value;
        this._foundation.setAnchorMargin(this._anchorMargin);
    }
    /**
     * @return {?}
     */
    get hoistToBody() { return this._hoistToBody; }
    /**
     * @param {?} value
     * @return {?}
     */
    set hoistToBody(value) {
        this._hoistToBody = toBoolean(value);
        if (this._hoistToBody) {
            this.setHoistToBody();
        }
    }
    /**
     * @protected
     * @return {?}
     */
    _createSurfaceAdapter() {
        return Object.assign({
            addClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.add(className)),
            removeClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.remove(className)),
            hasClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.contains(className)),
            hasAnchor: (/**
             * @return {?}
             */
            () => !!this.anchorElement),
            notifyClose: (/**
             * @return {?}
             */
            () => {
                this.closed.emit();
                this._deregisterWindowClickListener();
            }),
            notifyOpen: (/**
             * @return {?}
             */
            () => {
                this.opened.emit();
                this._registerWindowClickListener();
            }),
            isElementInContainer: (/**
             * @param {?} el
             * @return {?}
             */
            (el) => this._getHostElement() === el || this._getHostElement().contains(el)),
            isRtl: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return;
                }
                return window.getComputedStyle(this._getHostElement()).getPropertyValue('direction') === 'rtl';
            }),
            setTransformOrigin: (/**
             * @param {?} origin
             * @return {?}
             */
            (origin) => {
                if (!this.platform.isBrowser) {
                    return;
                }
                this._getHostElement().style[(/** @type {?} */ (`${getTransformPropertyName(window)}-origin`))] = origin;
            })
        }, this._getFocusAdaptermethods(), this._getDimensionAdapterMethods());
    }
    /**
     * @private
     * @return {?}
     */
    _getFocusAdaptermethods() {
        return {
            isFocused: (/**
             * @return {?}
             */
            () => this.platform.isBrowser ? (/** @type {?} */ (document.activeElement)) === this._getHostElement() : false),
            saveFocus: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return;
                }
                this._previousFocus = (/** @type {?} */ (document.activeElement));
            }),
            restoreFocus: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return;
                }
                if (this._getHostElement().contains((/** @type {?} */ (document.activeElement)))) {
                    if (this._previousFocus && ((/** @type {?} */ (this._previousFocus))).focus) {
                        ((/** @type {?} */ (this._previousFocus))).focus();
                    }
                }
            }),
            isFirstElementFocused: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return false;
                }
                return this._firstFocusableElement && this._firstFocusableElement === (/** @type {?} */ (document.activeElement));
            }),
            isLastElementFocused: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return false;
                }
                return this._lastFocusableElement && this._lastFocusableElement === (/** @type {?} */ (document.activeElement));
            }),
            focusFirstElement: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return;
                }
                if (this._firstFocusableElement) {
                    ((/** @type {?} */ (this._firstFocusableElement))).focus();
                }
            }),
            focusLastElement: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return;
                }
                if (this._lastFocusableElement) {
                    ((/** @type {?} */ (this._lastFocusableElement))).focus();
                }
            })
        };
    }
    /**
     * @private
     * @return {?}
     */
    _getDimensionAdapterMethods() {
        return {
            getInnerDimensions: (/**
             * @return {?}
             */
            () => {
                return { width: this._getHostElement().offsetWidth, height: this._getHostElement().offsetHeight };
            }),
            getAnchorDimensions: (/**
             * @return {?}
             */
            () => {
                if (!this.platform.isBrowser) {
                    return;
                }
                return this._anchorElement && this._anchorElement.getBoundingClientRect();
            }),
            getWindowDimensions: (/**
             * @return {?}
             */
            () => {
                return {
                    width: this.platform.isBrowser ? window.innerWidth : 0,
                    height: this.platform.isBrowser ? window.innerHeight : 0
                };
            }),
            getBodyDimensions: (/**
             * @return {?}
             */
            () => {
                return {
                    width: this.platform.isBrowser ? (/** @type {?} */ (document.body)).clientWidth : 0,
                    height: this.platform.isBrowser ? (/** @type {?} */ (document.body)).clientHeight : 0
                };
            }),
            getWindowScroll: (/**
             * @return {?}
             */
            () => {
                return {
                    x: this.platform.isBrowser ? window.pageXOffset : 0,
                    y: this.platform.isBrowser ? window.pageYOffset : 0
                };
            }),
            setPosition: (/**
             * @param {?} position
             * @return {?}
             */
            (position) => {
                this._getHostElement().style.left = 'left' in position ? position.left : null;
                this._getHostElement().style.right = 'right' in position ? position.right : null;
                this._getHostElement().style.top = 'top' in position ? position.top : null;
                this._getHostElement().style.bottom = 'bottom' in position ? position.bottom : null;
            }),
            setMaxHeight: (/**
             * @param {?} height
             * @return {?}
             */
            (height) => this._getHostElement().style.maxHeight = height)
        };
    }
    /**
     * @protected
     * @return {?}
     */
    initMenuSurface() {
        this._foundation.init();
        this._registerKeydownListener();
    }
    /**
     * @protected
     * @return {?}
     */
    destroyMenuSurface() {
        this._destroy.next();
        this._destroy.complete();
        this._deregisterWindowClickListener();
        // add platform check due to use of cancelAnimationFrame inside destroy()
        if (this.platform.isBrowser) {
            this._foundation.destroy();
        }
        if (this.hoistToBody) {
            (/** @type {?} */ (document.body)).removeChild(this._getHostElement());
        }
    }
    /**
     * @protected
     * @return {?}
     */
    setOpen() {
        if (this._open) {
            /** @type {?} */
            const focusableElements = this._getHostElement().querySelectorAll(strings.FOCUSABLE_ELEMENTS);
            this._firstFocusableElement = focusableElements.length > 0 ? focusableElements[0] : null;
            this._lastFocusableElement = focusableElements.length > 0 ?
                focusableElements[focusableElements.length - 1] : null;
            this._foundation.open();
        }
        else {
            this._foundation.close();
        }
    }
    /**
     * Removes the menu-surface from it's current location and appends it to the
     * body to overcome any overflow:hidden issues.
     * @protected
     * @return {?}
     */
    setHoistToBody() {
        if (!this.platform.isBrowser) {
            return;
        }
        /** @type {?} */
        const parentEl = this._getHostElement().parentElement;
        if (parentEl) {
            (/** @type {?} */ (document.body)).appendChild(parentEl.removeChild(this._getHostElement()));
            this._foundation.setIsHoisted(true);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _registerKeydownListener() {
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => fromEvent(this._getHostElement(), 'keydown').pipe(takeUntil(this._destroy))
            .subscribe((/**
         * @param {?} evt
         * @return {?}
         */
        evt => this._ngZone.run((/**
         * @return {?}
         */
        () => this._foundation.handleKeydown(evt)))))));
    }
    /**
     * @private
     * @return {?}
     */
    _registerWindowClickListener() {
        if (!this.platform.isBrowser) {
            return;
        }
        this._windowClickSubscription =
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => fromEvent(window, 'click')
                .subscribe((/**
             * @param {?} evt
             * @return {?}
             */
            evt => this._ngZone.run((/**
             * @return {?}
             */
            () => {
                this._foundation.handleBodyClick(evt);
                this._open = this._foundation.isOpen();
            }))))));
    }
    /**
     * @private
     * @return {?}
     */
    _deregisterWindowClickListener() {
        if (this._windowClickSubscription) {
            this._windowClickSubscription.unsubscribe();
        }
    }
    /**
     * Retrieves the DOM element of the component host.
     * @protected
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
/** @nocollapse */
MdcMenuSurfaceBase.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Platform },
    { type: NgZone, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
MdcMenuSurfaceBase.propDecorators = {
    open: [{ type: Input }],
    anchorElement: [{ type: Input }],
    anchorCorner: [{ type: Input }],
    quickOpen: [{ type: Input }],
    fixed: [{ type: Input }],
    coordinates: [{ type: Input }],
    anchorMargin: [{ type: Input }],
    hoistToBody: [{ type: Input }],
    opened: [{ type: Output }],
    closed: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcMenuSurface extends MdcMenuSurfaceBase {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initMenuSurface();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyMenuSurface();
    }
}
MdcMenuSurface.decorators = [
    { type: Component, args: [{selector: 'mdc-menu-surface',
                exportAs: 'mdcMenuSurface',
                host: { 'class': 'mdc-menu-surface' },
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcMenuSurfaceAnchor {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
MdcMenuSurfaceAnchor.decorators = [
    { type: Directive, args: [{
                selector: '[mdcMenuSurfaceAnchor], mdc-menu-surface-anchor',
                host: { 'class': 'mdc-menu-surface--anchor' }
            },] },
];
/** @nocollapse */
MdcMenuSurfaceAnchor.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MENU_SURFACE_DECLARATIONS = [
    MdcMenuSurface,
    MdcMenuSurfaceAnchor
];
class MdcMenuSurfaceModule {
}
MdcMenuSurfaceModule.decorators = [
    { type: NgModule, args: [{
                exports: [MENU_SURFACE_DECLARATIONS],
                declarations: [MENU_SURFACE_DECLARATIONS]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MdcMenuSurfaceModule, MdcMenuSurface, MdcMenuSurfaceBase, MdcMenuSurfaceAnchor };
//# sourceMappingURL=menu-surface.js.map
