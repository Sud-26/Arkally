/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { Component, ElementRef, Injectable, defineInjectable, ChangeDetectionStrategy, ViewEncapsulation, Input, ViewChild, ChangeDetectorRef, NgZone, ContentChild, ContentChildren, NgModule } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import { startWith, takeUntil } from 'rxjs/operators';
import { toBoolean } from '@angular-mdc/web/common';
import { CommonModule } from '@angular/common';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const cssClasses = {
  ROOT: 'mdc-text-field-character-counter',
};

/** @enum {string} */
const strings = {
  ROOT_SELECTOR: `.${cssClasses.ROOT}`,
};

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldCharacterCounterAdapter>}
 * @final
 */
class MDCTextFieldCharacterCounterFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses;
  }

  /** @return enum {string} */
  static get strings() {
    return strings;
  }

  /**
   * {@see MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCTextFieldCharacterCounterAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCTextFieldCharacterCounterAdapter} */ ({
      setContent: () => {},
    });
  }

  /**
   * @param {!MDCTextFieldCharacterCounterAdapter} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCTextFieldCharacterCounterFoundation.defaultAdapter, adapter));
  }

  /**
   * @param {number} currentLength
   * @param {number} maxLength
   */
  setCounterValue(currentLength, maxLength) {
    currentLength = Math.min(currentLength, maxLength);
    this.adapter_.setContent(`${currentLength} / ${maxLength}`);
  }
}

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcCharacterCounter {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    getDefaultFoundation() {
        /** @type {?} */
        const adapter = {
            setContent: (/**
             * @param {?} content
             * @return {?}
             */
            (content) => this.elementRef.nativeElement.textContent = content)
        };
        return new MDCTextFieldCharacterCounterFoundation(adapter);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.getDefaultFoundation().destroy();
    }
}
MdcCharacterCounter.decorators = [
    { type: Component, args: [{selector: '[mdcCharacterCounter]',
                exportAs: 'mdcCharacterCounter',
                host: { 'class': 'mdc-text-field-character-counter' },
                template: '<ng-content></ng-content>'
            },] },
];
/** @nocollapse */
MdcCharacterCounter.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Mixin to augment a directive with updateErrorState method.
 * For component with `errorState` and need to update `errorState`.
 * @template T
 * @param {?} base
 * @return {?}
 */
function mixinErrorState(base) {
    return class extends base {
        /**
         * @param {...?} args
         */
        constructor(...args) {
            super(...args);
            /**
             * Whether the component is in an error state.
             */
            this.errorState = false;
            this.required = false;
        }
        /**
         * @return {?}
         */
        updateErrorState() {
            /** @type {?} */
            const oldState = this.errorState;
            /** @type {?} */
            const parent = this._parentFormGroup || this._parentForm;
            /** @type {?} */
            const matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;
            /** @type {?} */
            const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
            /** @type {?} */
            const newState = matcher.isErrorState(control, parent);
            if (newState !== oldState) {
                this.errorState = newState;
            }
            // Currently there isn't a great way to determine if Validators.required
            // has been added to the control since form validators are combined into
            // an aggregate function at initialization.
            if (control && !this.required) {
                this.required = control.hasError('required');
            }
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Provider that defines how form controls behave with regards to displaying error messages.
 */
class ErrorStateMatcher {
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
}
ErrorStateMatcher.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
/** @nocollapse */ ErrorStateMatcher.ngInjectableDef = defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class MdcFormFieldControl {
    constructor() {
        /**
         * The value of the control.
         */
        this.value = null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcHelperText {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.characterCounter = false;
        this._persistent = false;
        this._validation = false;
    }
    /**
     * @return {?}
     */
    get persistent() { return this._persistent; }
    /**
     * @param {?} value
     * @return {?}
     */
    set persistent(value) {
        this._persistent = toBoolean(value);
        if (this._foundation) {
            this._foundation.setPersistent(this._persistent);
        }
    }
    /**
     * @return {?}
     */
    get validation() { return this._validation; }
    /**
     * @param {?} value
     * @return {?}
     */
    set validation(value) {
        this._validation = toBoolean(value);
        if (this._foundation) {
            this._foundation.setValidation(this._validation);
        }
    }
    /**
     * Sets the validity of the helper text based on inputIsValid.
     * @param {?} inputIsValid
     * @return {?}
     */
    setValidity(inputIsValid) {
        this._foundation.setValidity(inputIsValid);
    }
    /**
     * Makes the helper text visible to the screen reader.
     * @return {?}
     */
    showToScreenReader() {
        this._foundation.showToScreenReader();
    }
    /**
     * @param {?} foundation
     * @return {?}
     */
    init(foundation) {
        this._foundation = new foundation(this._createAdapter());
        this._foundation.setPersistent(this.persistent);
        this._foundation.setValidation(this.validation);
    }
    /**
     * @param {?} className
     * @return {?}
     */
    addHelperTextClass(className) {
        (/** @type {?} */ (this._helperTextElement)).nativeElement.classList.add(`${className}-helper-text`);
    }
    /**
     * @private
     * @return {?}
     */
    _createAdapter() {
        return {
            addClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => (/** @type {?} */ (this._helperTextElement)).nativeElement.classList.add(className)),
            removeClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => (/** @type {?} */ (this._helperTextElement)).nativeElement.classList.remove(className)),
            hasClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => (/** @type {?} */ (this._helperTextElement)).nativeElement.classList.contains(className)),
            setAttr: (/**
             * @param {?} attr
             * @param {?} value
             * @return {?}
             */
            (attr, value) => (/** @type {?} */ (this._helperTextElement)).nativeElement.setAttribute(attr, value)),
            removeAttr: (/**
             * @param {?} attr
             * @return {?}
             */
            (attr) => (/** @type {?} */ (this._helperTextElement)).nativeElement.removeAttribute(attr))
        };
    }
}
MdcHelperText.decorators = [
    { type: Component, args: [{selector: `mdc-helper-text, [mdcHelperText],
  mdc-text-field-helper-text, [mdcTextFieldHelperText], [mdcSelectHelperText]`,
                exportAs: 'mdcHelperText, mdcSelectHelperText',
                host: { 'class': 'mdc-text-field-helper-line' },
                template: `<div #helperText><ng-content></ng-content></div>
  <div mdcCharacterCounter *ngIf="characterCounter"></div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcHelperText.ctorParameters = () => [
    { type: ElementRef }
];
MdcHelperText.propDecorators = {
    id: [{ type: Input }],
    persistent: [{ type: Input }],
    validation: [{ type: Input }],
    _helperTextElement: [{ type: ViewChild, args: ['helperText',] }],
    _characterCounterElement: [{ type: ViewChild, args: [MdcCharacterCounter,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcFormField {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _ngZone
     * @param {?} elementRef
     */
    constructor(_changeDetectorRef, _ngZone, elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this.elementRef = elementRef;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this._fluid = false;
        this._alignEnd = false;
    }
    /**
     * @return {?}
     */
    get fluid() { return this._fluid; }
    /**
     * @param {?} value
     * @return {?}
     */
    set fluid(value) {
        this._fluid = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get alignEnd() { return this._alignEnd; }
    /**
     * @param {?} value
     * @return {?}
     */
    set alignEnd(value) {
        this._alignEnd = toBoolean(value);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this._control) {
            /** @type {?} */
            const control = this._control.elementRef.nativeElement;
            if (control.nextElementSibling) {
                if (control.nextElementSibling.tagName === 'LABEL') {
                    this.label = control.nextElementSibling;
                    if (this.label && this._control.inputId) {
                        (/** @type {?} */ (this.label)).setAttribute('for', this._control.inputId);
                        this._loadListeners();
                    }
                }
            }
        }
        // When assistive elements change, initialize foundation
        this.assistiveElements.changes.pipe(startWith(null), takeUntil(this._destroy))
            .subscribe((/**
         * @return {?}
         */
        () => {
            (this.assistiveElements).forEach((/**
             * @param {?} helperText
             * @return {?}
             */
            helperText => this._initHelperTextFoundation(helperText)));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * @private
     * @param {?} helperText
     * @return {?}
     */
    _initHelperTextFoundation(helperText) {
        /** @type {?} */
        const control = this._control;
        if (control && control.controlType) {
            control.helperText = helperText;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _loadListeners() {
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => fromEvent((/** @type {?} */ (this.label)), 'click').pipe(takeUntil(this._destroy))
            .subscribe((/**
         * @return {?}
         */
        () => this._ngZone.run((/**
         * @return {?}
         */
        () => {
            (/** @type {?} */ (this._control.ripple)).activateRipple();
            if (typeof requestAnimationFrame !== 'undefined') {
                requestAnimationFrame((/**
                 * @return {?}
                 */
                () => (/** @type {?} */ (this._control.ripple)).deactivateRipple()));
            }
        }))))));
    }
}
MdcFormField.decorators = [
    { type: Component, args: [{selector: 'mdc-form-field',
                exportAs: 'mdcFormField',
                host: {
                    '[class.ngx-mdc-form-field--fluid]': 'fluid',
                    '[class.mdc-form-field--align-end]': 'alignEnd'
                },
                template: `<ng-content></ng-content>
  <ng-content select="[mdcHelperText, mdc-helper-text]"></ng-content>`,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcFormField.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: ElementRef }
];
MdcFormField.propDecorators = {
    fluid: [{ type: Input }],
    alignEnd: [{ type: Input }],
    _control: [{ type: ContentChild, args: [MdcFormFieldControl,] }],
    assistiveElements: [{ type: ContentChildren, args: [MdcHelperText, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FORM_FIELD_DECLARATIONS = [
    MdcCharacterCounter,
    MdcFormField,
    MdcHelperText
];
class MdcFormFieldModule {
}
MdcFormFieldModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [FORM_FIELD_DECLARATIONS],
                declarations: [FORM_FIELD_DECLARATIONS]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MdcCharacterCounter, mixinErrorState, ErrorStateMatcher, MdcFormField, MdcFormFieldControl, MdcFormFieldModule, MdcHelperText };
//# sourceMappingURL=form-field.js.map
