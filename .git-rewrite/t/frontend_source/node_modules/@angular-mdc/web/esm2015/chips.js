/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { InjectionToken, Component, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, Directive, EventEmitter, NgZone, ChangeDetectorRef, Optional, Inject, Input, Output, ContentChild, ContentChildren, forwardRef, Attribute, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MdcIcon, MdcIconRegistry, MDC_ICON_LOCATION, MdcIconModule } from '@angular-mdc/web/icon';
import { Subject, fromEvent, merge } from 'rxjs';
import { takeUntil, startWith } from 'rxjs/operators';
import { toBoolean, Platform } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { NgForm, FormGroupDirective, NgControl } from '@angular/forms';

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const strings = {
  ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
  INTERACTION_EVENT: 'MDCChip:interaction',
  SELECTION_EVENT: 'MDCChip:selection',
  TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
  REMOVAL_EVENT: 'MDCChip:removal',
  CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
  LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
  TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing',
};

/** @enum {string} */
const cssClasses = {
  CHECKMARK: 'mdc-chip__checkmark',
  CHIP_EXIT: 'mdc-chip--exit',
  HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
  LEADING_ICON: 'mdc-chip__icon--leading',
  TRAILING_ICON: 'mdc-chip__icon--trailing',
  SELECTED: 'mdc-chip--selected',
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */
class RippleCapableSurface {}

/** @protected {!Element} */
RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


/**
 * @extends {MDCFoundation<!MDCChipAdapter>}
 * @final
 */
class MDCChipFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings;
  }

  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses;
  }

  /**
   * {@see MDCChipAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCChipAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCChipAdapter} */ ({
      addClass: () => {},
      removeClass: () => {},
      hasClass: () => {},
      addClassToLeadingIcon: () => {},
      removeClassFromLeadingIcon: () => {},
      eventTargetHasClass: () => {},
      notifyInteraction: () => {},
      notifySelection: () => {},
      notifyTrailingIconInteraction: () => {},
      notifyRemoval: () => {},
      getComputedStyleValue: () => {},
      setStyleProperty: () => {},
      hasLeadingIcon: () => {},
      getRootBoundingClientRect: () => {},
      getCheckmarkBoundingClientRect: () => {},
    });
  }

  /**
   * @param {!MDCChipAdapter} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCChipFoundation.defaultAdapter, adapter));

    /**
     * Whether a trailing icon click should immediately trigger exit/removal of the chip.
     * @private {boolean}
     * */
    this.shouldRemoveOnTrailingIconClick_ = true;
  }

  /**
   * @return {boolean}
   */
  isSelected() {
    return this.adapter_.hasClass(cssClasses.SELECTED);
  }

  /**
   * @param {boolean} selected
   */
  setSelected(selected) {
    if (selected) {
      this.adapter_.addClass(cssClasses.SELECTED);
    } else {
      this.adapter_.removeClass(cssClasses.SELECTED);
    }
    this.adapter_.notifySelection(selected);
  }

  /**
   * @return {boolean}
   */
  getShouldRemoveOnTrailingIconClick() {
    return this.shouldRemoveOnTrailingIconClick_;
  }

  /**
   * @param {boolean} shouldRemove
   */
  setShouldRemoveOnTrailingIconClick(shouldRemove) {
    this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
  }

  /** @return {!ClientRect} */
  getDimensions() {
    // When a chip has a checkmark and not a leading icon, the bounding rect changes in size depending on the current
    // size of the checkmark.
    if (!this.adapter_.hasLeadingIcon() && this.adapter_.getCheckmarkBoundingClientRect() !== null) {
      const height = this.adapter_.getRootBoundingClientRect().height;
      // The checkmark's width is initially set to 0, so use the checkmark's height as a proxy since the checkmark
      // should always be square.
      const width =
          this.adapter_.getRootBoundingClientRect().width + this.adapter_.getCheckmarkBoundingClientRect().height;
      return /** @type {!ClientRect} */ ({height, width});
    } else {
      return this.adapter_.getRootBoundingClientRect();
    }
  }

  /**
   * Begins the exit animation which leads to removal of the chip.
   */
  beginExit() {
    this.adapter_.addClass(cssClasses.CHIP_EXIT);
  }

  /**
   * Handles an interaction event on the root element.
   * @param {!Event} evt
   */
  handleInteraction(evt) {
    if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
      this.adapter_.notifyInteraction();
    }
  }

  /**
   * Handles a transition end event on the root element.
   * @param {!Event} evt
   */
  handleTransitionEnd(evt) {
    // Handle transition end event on the chip when it is about to be removed.
    if (this.adapter_.eventTargetHasClass(/** @type {!EventTarget} */ (evt.target), cssClasses.CHIP_EXIT)) {
      if (evt.propertyName === 'width') {
        this.adapter_.notifyRemoval();
      } else if (evt.propertyName === 'opacity') {
        // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
        const chipWidth = this.adapter_.getComputedStyleValue('width');

        // On the next frame (once we get the computed width), explicitly set the chip's width
        // to its current pixel width, so we aren't transitioning out of 'auto'.
        requestAnimationFrame(() => {
          this.adapter_.setStyleProperty('width', chipWidth);

          // To mitigate jitter, start transitioning padding and margin before width.
          this.adapter_.setStyleProperty('padding', '0');
          this.adapter_.setStyleProperty('margin', '0');

          // On the next frame (once width is explicitly set), transition width to 0.
          requestAnimationFrame(() => {
            this.adapter_.setStyleProperty('width', '0');
          });
        });
      }
      return;
    }

    // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.
    if (evt.propertyName !== 'opacity') {
      return;
    }
    if (this.adapter_.eventTargetHasClass(/** @type {!EventTarget} */ (evt.target), cssClasses.LEADING_ICON) &&
        this.adapter_.hasClass(cssClasses.SELECTED)) {
      this.adapter_.addClassToLeadingIcon(cssClasses.HIDDEN_LEADING_ICON);
    } else if (this.adapter_.eventTargetHasClass(/** @type {!EventTarget} */ (evt.target), cssClasses.CHECKMARK) &&
               !this.adapter_.hasClass(cssClasses.SELECTED)) {
      this.adapter_.removeClassFromLeadingIcon(cssClasses.HIDDEN_LEADING_ICON);
    }
  }

  /**
   * Handles an interaction event on the trailing icon element. This is used to
   * prevent the ripple from activating on interaction with the trailing icon.
   * @param {!Event} evt
   */
  handleTrailingIconInteraction(evt) {
    evt.stopPropagation();
    if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
      this.adapter_.notifyTrailingIconInteraction();
      if (this.shouldRemoveOnTrailingIconClick_) {
        this.beginExit();
      }
    }
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token used to provide the parent MdcChipSet component to MdcChip.
 * @type {?}
 */
const MDC_CHIPSET_PARENT_COMPONENT = new InjectionToken('MDC_CHIPSET_PARENT_COMPONENT');
/** @type {?} */
let nextUniqueId = 0;
class MdcChipCheckmark {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
MdcChipCheckmark.decorators = [
    { type: Component, args: [{selector: 'mdc-chip-checkmark',
                exportAs: 'mdcChipCheckmark',
                template: `
  <div class="mdc-chip__checkmark">
    <svg
      class="mdc-chip__checkmark-svg"
      viewBox="-2 -3 30 30"
      focusable="false">
      <path class="mdc-chip__checkmark-path" fill="none" stroke="black" d="M1.73,12.91 8.1,19.28 22.79,4.59"/>
    </svg>
  </div>`,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcChipCheckmark.ctorParameters = () => [
    { type: ElementRef }
];
class MdcChipText {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
MdcChipText.decorators = [
    { type: Directive, args: [{
                selector: 'mdc-chip-text, [mdcChipText]',
                host: { 'class': 'mdc-chip__text' }
            },] },
];
/** @nocollapse */
MdcChipText.ctorParameters = () => [
    { type: ElementRef }
];
class MdcChip {
    /**
     * @param {?} _platform
     * @param {?} _ngZone
     * @param {?} _changeDetectorRef
     * @param {?} _ripple
     * @param {?} elementRef
     * @param {?} _parent
     */
    constructor(_platform, _ngZone, _changeDetectorRef, _ripple, elementRef, _parent) {
        this._platform = _platform;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this._ripple = _ripple;
        this.elementRef = elementRef;
        this._parent = _parent;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroyed = new Subject();
        this._id = `mdc-chip-${nextUniqueId++}`;
        this._selected = false;
        this._filter = false;
        this._choice = false;
        this._input = false;
        this._primary = false;
        this._secondary = false;
        this._removable = true;
        this._disabled = false;
        this._disableRipple = false;
        /**
         * Emitted when the chip is selected or deselected.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Emitted when the chip icon is interacted with.
         */
        this.trailingIconInteraction = new EventEmitter();
        /**
         * Emitted when a chip is to be removed.
         */
        this.removed = new EventEmitter();
        this._foundation = new MDCChipFoundation(this._createAdapter());
    }
    /**
     * The unique ID of the chip.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * @return {?}
     */
    get leadingIcon() {
        return this._icons.find((/**
         * @param {?} _
         * @return {?}
         */
        (_) => _.leading));
    }
    /**
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        /** @type {?} */
        const newValue = toBoolean(value);
        this._selected = newValue;
        this._foundation.setSelected(newValue);
        if (this.filter && this.leadingIcon) {
            this.leadingIcon.elementRef.nativeElement.classList.remove(cssClasses.HIDDEN_LEADING_ICON);
        }
    }
    /**
     * @return {?}
     */
    get filter() { return this._filter; }
    /**
     * @param {?} value
     * @return {?}
     */
    set filter(value) {
        /** @type {?} */
        const newValue = toBoolean(value);
        if (newValue !== this._filter) {
            this._filter = newValue;
        }
    }
    /**
     * @return {?}
     */
    get choice() { return this._choice; }
    /**
     * @param {?} value
     * @return {?}
     */
    set choice(value) {
        this._choice = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get input() { return this._input; }
    /**
     * @param {?} value
     * @return {?}
     */
    set input(value) {
        this._input = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get primary() { return this._primary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set primary(value) {
        this._primary = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get secondary() { return this._secondary; }
    /**
     * @param {?} value
     * @return {?}
     */
    set secondary(value) {
        this._secondary = toBoolean(value);
    }
    /**
     * Determines whether or not the chip displays the remove styling and emits (removed) events.
     * @return {?}
     */
    get removable() { return this._removable; }
    /**
     * @param {?} value
     * @return {?}
     */
    set removable(value) {
        /** @type {?} */
        const newValue = toBoolean(value);
        if (newValue !== this._removable) {
            this._removable = value;
            this._foundation.setShouldRemoveOnTrailingIconClick(this._removable);
        }
    }
    /**
     * Whether the chip is disabled.
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * Whether the chip ripple is disabled.
     * @return {?}
     */
    get disableRipple() { return this._disableRipple; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableRipple(value) {
        this._disableRipple = toBoolean(value);
    }
    /**
     * The value of the chip. Defaults to the content inside `<mdc-chip>` tags.
     * @return {?}
     */
    get value() {
        return this._value !== undefined
            ? this._value
            : this.elementRef.nativeElement.textContent;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) { this._value = value; }
    /**
     * @private
     * @return {?}
     */
    _createAdapter() {
        return {
            addClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.add(className)),
            removeClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.remove(className)),
            hasClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.contains(className)),
            addClassToLeadingIcon: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => {
                if (this.leadingIcon) {
                    this.leadingIcon.elementRef.nativeElement.classList.add(className);
                }
            }),
            removeClassFromLeadingIcon: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => {
                if (this.leadingIcon) {
                    this.leadingIcon.elementRef.nativeElement.classList.remove(className);
                }
            }),
            eventTargetHasClass: (/**
             * @param {?} target
             * @param {?} className
             * @return {?}
             */
            (target, className) => target.classList.contains(className)),
            notifyInteraction: (/**
             * @return {?}
             */
            () => this._emitSelectionChangeEvent(true)),
            notifyTrailingIconInteraction: (/**
             * @return {?}
             */
            () => this.trailingIconInteraction.emit({ detail: { chipId: this.id } })),
            notifyRemoval: (/**
             * @return {?}
             */
            () => this.removed.emit({ detail: { chipId: this.id, root: this } })),
            getComputedStyleValue: (/**
             * @param {?} propertyName
             * @return {?}
             */
            (propertyName) => {
                if (!this._platform.isBrowser) {
                    return;
                }
                return window.getComputedStyle(this._getHostElement()).getPropertyValue(propertyName);
            }),
            setStyleProperty: (/**
             * @param {?} propertyName
             * @param {?} value
             * @return {?}
             */
            (propertyName, value) => this._getHostElement().style.setProperty(propertyName, value)),
            hasLeadingIcon: (/**
             * @return {?}
             */
            () => !!this.leadingIcon),
            getRootBoundingClientRect: (/**
             * @return {?}
             */
            () => this._getHostElement().getBoundingClientRect()),
            getCheckmarkBoundingClientRect: (/**
             * @return {?}
             */
            () => this._checkmark ?
                this._checkmark.elementRef.nativeElement.getBoundingClientRect() : null)
        };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._foundation.init();
        this._setVariantFromChipSet();
        this._initRipple();
        this._loadListeners();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._ripple.destroy();
        if (this._foundation) {
            this._foundation.destroy();
        }
    }
    /**
     * Selects the chip.
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * Deselects the chip.
     * @return {?}
     */
    deselect() {
        if (this._selected) {
            this._selected = false;
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * Select this chip and emit selected event
     * @return {?}
     */
    selectViaInteraction() {
        if (!this._selected) {
            this._selected = true;
            this._emitSelectionChangeEvent(true);
        }
    }
    /**
     * Allows for programmatic focusing of the chip.
     * @return {?}
     */
    focus() {
        this._getHostElement().focus();
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    _handleInteraction(evt) {
        this._selected = !this._selected;
        this._foundation.handleInteraction(evt);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    _handleTrailingIconInteraction(evt) {
        this._foundation.handleTrailingIconInteraction(evt);
    }
    /**
     * @private
     * @return {?}
     */
    _initRipple() {
        this._ripple.init({
            surface: this._getHostElement()
        }, Object.assign(this._ripple.createAdapter(), {
            isSurfaceDisabled: (/**
             * @return {?}
             */
            () => this._disableRipple),
            computeBoundingRect: (/**
             * @return {?}
             */
            () => this._foundation.getDimensions())
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _setVariantFromChipSet() {
        if (this._parent) {
            this.input = this._parent.input;
            this.filter = this._parent.filter;
            this.choice = this._parent.choice;
            this._changeDetectorRef.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _loadListeners() {
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => fromEvent(this._getHostElement(), 'transitionend')
            .pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @param {?} evt
         * @return {?}
         */
        evt => this._ngZone.run((/**
         * @return {?}
         */
        () => this._foundation.handleTransitionEnd(evt)))))));
    }
    /**
     * Emits the removed event.
     * @return {?}
     */
    _emitRemovedEvent() {
        this.removed.emit({ detail: { chipId: this.id, root: this } });
    }
    /**
     * Emits the selection change event.
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    _emitSelectionChangeEvent(isUserInput) {
        this.selectionChange.emit({
            isUserInput: isUserInput,
            detail: { chipId: this.id, selected: this._selected, value: this._value }
        });
    }
    /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcChip.decorators = [
    { type: Component, args: [{selector: 'mdc-chip',
                exportAs: 'mdcChip',
                host: {
                    '[id]': 'id',
                    '[attr.tabindex]': 'disabled ? null : 0',
                    'class': 'mdc-chip',
                    '[class.ngx-mdc-chip--primary]': 'primary',
                    '[class.ngx-mdc-chip--secondary]': 'secondary',
                    '(click)': '_handleInteraction($event)',
                    '(keydown)': '_handleInteraction($event)'
                },
                template: `
  <ng-content select="mdc-chip-icon[leading]"></ng-content>
  <mdc-chip-checkmark *ngIf="filter"></mdc-chip-checkmark>
  <div class="mdc-chip__text" *ngIf="label">{{label}}</div>
  <ng-content></ng-content>`,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [MdcRipple]
            },] },
];
/** @nocollapse */
MdcChip.ctorParameters = () => [
    { type: Platform },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: MdcRipple },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MDC_CHIPSET_PARENT_COMPONENT,] }] }
];
MdcChip.propDecorators = {
    label: [{ type: Input }],
    selected: [{ type: Input }],
    filter: [{ type: Input }],
    choice: [{ type: Input }],
    input: [{ type: Input }],
    primary: [{ type: Input }],
    secondary: [{ type: Input }],
    removable: [{ type: Input }],
    disabled: [{ type: Input }],
    disableRipple: [{ type: Input }],
    value: [{ type: Input }],
    selectionChange: [{ type: Output }],
    trailingIconInteraction: [{ type: Output }],
    removed: [{ type: Output }],
    _checkmark: [{ type: ContentChild, args: [MdcChipCheckmark,] }],
    _icons: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => MdcChipIcon)), { descendants: true },] }]
};
class MdcChipIcon extends MdcIcon {
    /**
     * @param {?} _parentChip
     * @param {?} elementRef
     * @param {?} iconRegistry
     * @param {?} ariaHidden
     * @param {?=} location
     */
    constructor(_parentChip, elementRef, iconRegistry, ariaHidden, location) {
        super(elementRef, iconRegistry, ariaHidden, location);
        this._parentChip = _parentChip;
        this._leading = false;
        this._trailing = false;
    }
    /**
     * @return {?}
     */
    get leading() { return this._leading; }
    /**
     * @param {?} value
     * @return {?}
     */
    set leading(value) {
        this._leading = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get trailing() { return this._trailing; }
    /**
     * @param {?} value
     * @return {?}
     */
    set trailing(value) {
        this._trailing = toBoolean(value);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.trailing) {
            this.tabIndex = 0;
            this.role = 'button';
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    _onIconInteraction(evt) {
        if (this.trailing) {
            this._parentChip._handleTrailingIconInteraction(evt);
            if (this._parentChip.removable && this._parentChip.input) {
                this._parentChip._emitRemovedEvent();
            }
        }
    }
}
MdcChipIcon.decorators = [
    { type: Component, args: [{selector: 'mdc-chip-icon, [mdcChipIcon]',
                exportAs: 'mdcChipIcon',
                host: {
                    'class': 'mdc-chip__icon ngx-mdc-icon',
                    '[attr.role]': 'role',
                    '[attr.tabindex]': 'tabIndex',
                    '[class.ngx-mdc-icon--clickable]': 'clickable',
                    '[class.ngx-mdc-icon--inline]': 'inline',
                    '[class.mdc-chip__icon--leading]': 'leading',
                    '[class.mdc-chip__icon--trailing]': 'trailing',
                    '(click)': '_onIconInteraction($event)',
                    '(keydown)': '_onIconInteraction($event)'
                },
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcChipIcon.ctorParameters = () => [
    { type: MdcChip },
    { type: ElementRef },
    { type: MdcIconRegistry },
    { type: String, decorators: [{ type: Attribute, args: ['aria-hidden',] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MDC_ICON_LOCATION,] }] }
];
MdcChipIcon.propDecorators = {
    leading: [{ type: Input }],
    trailing: [{ type: Input }]
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/** @enum {string} */
const strings$1 = {
  CHIP_SELECTOR: '.mdc-chip',
};

/** @enum {string} */
const cssClasses$1 = {
  CHOICE: 'mdc-chip-set--choice',
  FILTER: 'mdc-chip-set--filter',
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @extends {MDCFoundation<!MDCChipSetAdapter>}
 * @final
 */
class MDCChipSetFoundation extends MDCFoundation {
  /** @return enum {string} */
  static get strings() {
    return strings$1;
  }

  /** @return enum {string} */
  static get cssClasses() {
    return cssClasses$1;
  }

  /**
   * {@see MDCChipSetAdapter} for typing information on parameters and return
   * types.
   * @return {!MDCChipSetAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCChipSetAdapter} */ ({
      hasClass: () => {},
      removeChip: () => {},
      setSelected: () => {},
    });
  }

  /**
   * @param {!MDCChipSetAdapter} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCChipSetFoundation.defaultAdapter, adapter));

    /**
     * The ids of the selected chips in the set. Only used for choice chip set or filter chip set.
     * @private {!Array<string>}
     */
    this.selectedChipIds_ = [];
  }

  /**
   * Returns an array of the IDs of all selected chips.
   * @return {!Array<string>}
   */
  getSelectedChipIds() {
    return this.selectedChipIds_;
  }

  /**
   * Toggles selection of the chip with the given id.
   * @private
   * @param {string} chipId
   */
  toggleSelect_(chipId) {
    if (this.selectedChipIds_.indexOf(chipId) >= 0) {
      this.deselect_(chipId);
    } else {
      this.select(chipId);
    }
  }

  /**
   * Selects the chip with the given id. Deselects all other chips if the chip set is of the choice variant.
   * @param {string} chipId
   */
  select(chipId) {
    if (this.selectedChipIds_.indexOf(chipId) >= 0) {
      return;
    }

    if (this.adapter_.hasClass(cssClasses$1.CHOICE) && this.selectedChipIds_.length > 0) {
      const previouslySelectedChip = this.selectedChipIds_[0];
      this.selectedChipIds_.length = 0;
      this.adapter_.setSelected(previouslySelectedChip, false);
    }
    this.selectedChipIds_.push(chipId);
    this.adapter_.setSelected(chipId, true);
  }

  /**
   * Deselects the chip with the given id.
   * @private
   * @param {string} chipId
   */
  deselect_(chipId) {
    const index = this.selectedChipIds_.indexOf(chipId);
    if (index >= 0) {
      this.selectedChipIds_.splice(index, 1);
      this.adapter_.setSelected(chipId, false);
    }
  }

  /**
   * Handles a chip interaction event
   * @param {string} chipId
   */
  handleChipInteraction(chipId) {
    if (this.adapter_.hasClass(cssClasses$1.CHOICE) || this.adapter_.hasClass(cssClasses$1.FILTER)) {
      this.toggleSelect_(chipId);
    }
  }

  /**
   * Handles a chip selection event, used to handle discrepancy when selection state is set directly on the Chip.
   * @param {string} chipId
   * @param {boolean} selected
   */
  handleChipSelection(chipId, selected) {
    const chipIsSelected = this.selectedChipIds_.indexOf(chipId) >= 0;
    if (selected && !chipIsSelected) {
      this.select(chipId);
    } else if (!selected && chipIsSelected) {
      this.deselect_(chipId);
    }
  }

  /**
   * Handles the event when a chip is removed.
   * @param {string} chipId
   */
  handleChipRemoval(chipId) {
    this.deselect_(chipId);
    this.adapter_.removeChip(chipId);
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcChipSetChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
class MdcChipSet {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} elementRef
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     * @param {?} ngControl
     */
    constructor(_changeDetectorRef, elementRef, _parentForm, _parentFormGroup, ngControl) {
        this._changeDetectorRef = _changeDetectorRef;
        this.elementRef = elementRef;
        this.ngControl = ngControl;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroyed = new Subject();
        this._choice = false;
        this._filter = false;
        this._input = false;
        /**
         * A function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         */
        this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        (o1, o2) => o1 === o2);
        this.change = new EventEmitter();
        /**
         * Function when touched
         */
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        /**
         * Function when changed
         */
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        /**
         * Subscription to selection events in chips.
         */
        this._chipSelectionSubscription = null;
        /**
         * Subscription to remove changes in chips.
         */
        this._chipRemoveSubscription = null;
        /**
         * Subscription to interaction events in chips.
         */
        this._chipInteractionSubscription = null;
        this._foundation = new MDCChipSetFoundation(this._createAdapter());
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
     * @return {?}
     */
    get choice() { return this._choice; }
    /**
     * @param {?} value
     * @return {?}
     */
    set choice(value) {
        this._choice = toBoolean(value);
    }
    /**
     * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
     * @return {?}
     */
    get filter() { return this._filter; }
    /**
     * @param {?} value
     * @return {?}
     */
    set filter(value) {
        this._filter = toBoolean(value);
    }
    /**
     * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
     * @return {?}
     */
    get input() { return this._input; }
    /**
     * @param {?} value
     * @return {?}
     */
    set input(value) {
        this._input = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.writeValue(value);
        this._value = value;
    }
    /**
     * Combined stream of all of the chip selection events.
     * @return {?}
     */
    get chipSelections() {
        return merge(...this.chips.map((/**
         * @param {?} chip
         * @return {?}
         */
        chip => chip.selectionChange)));
    }
    /**
     * Combined stream of all of the chip interaction events.
     * @return {?}
     */
    get chipInteractions() {
        return merge(...this.chips.map((/**
         * @param {?} chip
         * @return {?}
         */
        chip => chip.trailingIconInteraction)));
    }
    /**
     * Combined stream of all of the chip remove events.
     * @return {?}
     */
    get chipRemoveChanges() {
        return merge(...this.chips.map((/**
         * @param {?} chip
         * @return {?}
         */
        chip => chip.removed)));
    }
    /**
     * @private
     * @return {?}
     */
    _createAdapter() {
        return {
            hasClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.contains(className)),
            removeChip: (/**
             * @param {?} chipId
             * @return {?}
             */
            (chipId) => {
                /** @type {?} */
                const index = this._findChipIndex(chipId);
                this.chips.toArray().splice(index, 1);
            }),
            setSelected: (/**
             * @param {?} chipId
             * @param {?} selected
             * @return {?}
             */
            (chipId, selected) => {
                /** @type {?} */
                const chip = this.getChipById(chipId);
                if (chip) {
                    chip.selected = selected;
                }
            })
        };
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._foundation.init();
        // When chips change, re-subscribe
        this.chips.changes.pipe(startWith(null), takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            if (this.chips.length > 0) {
                this._resetChipSet();
                this._initializeSelection();
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._dropSubscriptions();
        if (this._chipRemoveSubscription) {
            this._chipRemoveSubscription.unsubscribe();
        }
        this._foundation.destroy();
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.chips) {
            this.selectByValue(value, false);
        }
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @return {?}
     */
    getSelectedChipIds() {
        return this._foundation.getSelectedChipIds();
    }
    /**
     * @param {?} chipId
     * @return {?}
     */
    select(chipId) {
        this._foundation.select(chipId);
    }
    /**
     * @param {?} chipId
     * @return {?}
     */
    getChipById(chipId) {
        return this.chips.find((/**
         * @param {?} _
         * @return {?}
         */
        _ => _.id === chipId));
    }
    /**
     * @param {?} value
     * @param {?=} isUserInput
     * @return {?}
     */
    selectByValue(value, isUserInput = true) {
        this.chips.forEach((/**
         * @param {?} chip
         * @return {?}
         */
        chip => chip.deselect()));
        if (Array.isArray(value)) {
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            currentValue => this._selectValue(currentValue, isUserInput)));
        }
        else {
            this._selectValue(value, isUserInput);
        }
    }
    /**
     * Finds and selects the chip based on its value.
     * @private
     * @param {?} value
     * @param {?=} isUserInput
     * @return {?} Chip that has the corresponding value.
     */
    _selectValue(value, isUserInput = true) {
        /** @type {?} */
        const correspondingChip = this.chips.find((/**
         * @param {?} chip
         * @return {?}
         */
        chip => {
            return chip.value != null && this._compareWith(chip.value, value);
        }));
        if (correspondingChip) {
            isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
        }
        return correspondingChip;
    }
    /**
     * @private
     * @return {?}
     */
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            if (this.ngControl || this._value) {
                this.selectByValue(this.ngControl ? this.ngControl.value : this._value, false);
            }
        }));
    }
    /**
     * @private
     * @param {?} evt
     * @return {?}
     */
    _propagateChanges(evt) {
        this._value = evt.detail.value;
        this.change.emit(new MdcChipSetChange(this, evt.detail));
        this._onChange(this._value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    _resetChipSet() {
        this._dropSubscriptions();
        this._listenForChipSelection();
        this._listenToChipsInteraction();
        this._listenToChipsRemoved();
    }
    /**
     * @private
     * @return {?}
     */
    _dropSubscriptions() {
        if (this._chipSelectionSubscription) {
            this._chipSelectionSubscription.unsubscribe();
            this._chipSelectionSubscription = null;
        }
        if (this._chipInteractionSubscription) {
            this._chipInteractionSubscription.unsubscribe();
            this._chipInteractionSubscription = null;
        }
        if (this._chipRemoveSubscription) {
            this._chipRemoveSubscription.unsubscribe();
            this._chipRemoveSubscription = null;
        }
    }
    /**
     * Listens to selected events on each chip.
     * @private
     * @return {?}
     */
    _listenForChipSelection() {
        this._chipSelectionSubscription = this.chipSelections
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this._foundation.handleChipSelection(event.detail.chipId, event.detail.selected);
            if (event.isUserInput) {
                this._propagateChanges(event);
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _listenToChipsInteraction() {
        this._chipInteractionSubscription = this.chipInteractions
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => this._foundation.handleChipInteraction(event.detail.chipId)));
    }
    /**
     * @private
     * @return {?}
     */
    _listenToChipsRemoved() {
        this._chipRemoveSubscription = this.chipRemoveChanges
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => this._foundation.handleChipRemoval(event.detail.chipId)));
    }
    /**
     * @private
     * @param {?} chipId
     * @return {?}
     */
    _findChipIndex(chipId) {
        return this.chips.toArray().findIndex((/**
         * @param {?} _
         * @return {?}
         */
        _ => _.id === chipId));
    }
    /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcChipSet.decorators = [
    { type: Component, args: [{selector: 'mdc-chip-set',
                exportAs: 'mdcChipSet',
                host: {
                    'class': 'mdc-chip-set',
                    '[class.mdc-chip-set--choice]': 'choice',
                    '[class.mdc-chip-set--filter]': 'filter',
                    '[class.mdc-chip-set--input]': 'input'
                },
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: MDC_CHIPSET_PARENT_COMPONENT, useExisting: MdcChipSet }]
            },] },
];
/** @nocollapse */
MdcChipSet.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Optional }] }
];
MdcChipSet.propDecorators = {
    choice: [{ type: Input }],
    filter: [{ type: Input }],
    input: [{ type: Input }],
    value: [{ type: Input }],
    change: [{ type: Output }],
    chips: [{ type: ContentChildren, args: [MdcChip, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CHIP_DECLARATIONS = [
    MdcChip,
    MdcChipCheckmark,
    MdcChipIcon,
    MdcChipSet,
    MdcChipText
];
class MdcChipsModule {
}
MdcChipsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, MdcIconModule],
                exports: CHIP_DECLARATIONS,
                declarations: CHIP_DECLARATIONS
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CHIP_DECLARATIONS, MdcChipsModule, MDC_CHIPSET_PARENT_COMPONENT, MdcChipCheckmark, MdcChipText, MdcChip, MdcChipIcon, MdcChipSetChange, MdcChipSet };
//# sourceMappingURL=chips.js.map
