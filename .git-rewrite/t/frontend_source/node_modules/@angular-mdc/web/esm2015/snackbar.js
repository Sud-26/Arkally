/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { InjectionToken, Component, ChangeDetectionStrategy, ViewEncapsulation, ChangeDetectorRef, ElementRef, Inject, ViewChild, NgZone, NgModule, Injectable, Injector, Optional, SkipSelf, defineInjectable, inject, INJECTOR } from '@angular/core';
import { CommonModule } from '@angular/common';
import { OverlayModule, Overlay } from '@angular-mdc/web/overlay';
import { BasePortalOutlet, CdkPortalOutlet, PortalModule, PortalInjector, ComponentPortal } from '@angular-mdc/web/portal';
import { MdcButtonModule } from '@angular-mdc/web/button';
import { Subject } from 'rxjs';
import { take } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Reference to a snackbar dispatched from the snackbar service.
 * @template T
 */
class MdcSnackbarRef {
    /**
     * @param {?} containerInstance
     * @param {?} _overlayRef
     */
    constructor(containerInstance, _overlayRef) {
        this.containerInstance = containerInstance;
        this._overlayRef = _overlayRef;
        /**
         * Subject for notifying the user that the snackbar has been dismissed.
         */
        this._afterDismiss = new Subject();
        this.componentInstance = containerInstance;
    }
    /**
     * Gets an observable that is notified when the snackbar is finished closing.
     * @return {?}
     */
    afterDismiss() {
        return this._afterDismiss.asObservable();
    }
    /**
     * @param {?=} reason
     * @return {?}
     */
    dismiss(reason) {
        if (!this._afterDismiss.closed) {
            this._dismissedReason = reason;
            this._finishDismiss();
        }
    }
    /**
     * Cleans up the DOM after closing.
     * @private
     * @return {?}
     */
    _finishDismiss() {
        this._overlayRef.dispose();
        this._afterDismiss.next(this._dismissedReason);
        this._afterDismiss.complete();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token that can be used to access the data that was passed in to a snackbar.
 * @type {?}
 */
const MDC_SNACKBAR_DATA = new InjectionToken('MdcSnackbarData');
/**
 * @template D
 */
class MdcSnackbarConfig {
    constructor() {
        /**
         * Data being injected into the child component.
         */
        this.data = null;
        /**
         * Positions the action button/icon below the label instead of alongside it.
         */
        this.stacked = false;
        /**
         * Positions the snackbar on the leading edge of the screen
         */
        this.leading = false;
        /**
         * Positions the snackbar on the trailing edge of the screen
         */
        this.trailing = false;
        /**
         * The layout direction of the snackbar content
         */
        this.direction = 'ltr';
        /**
         * Show dismiss ("X") icon
         */
        this.dismiss = false;
        /**
         * Whether the snackbar closes when it is focused and the user presses the ESC key
         */
        this.closeOnEscape = true;
    }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const cssClasses = {
  OPENING: 'mdc-snackbar--opening',
  OPEN: 'mdc-snackbar--open',
  CLOSING: 'mdc-snackbar--closing',
};

const strings = {
  SURFACE_SELECTOR: '.mdc-snackbar__surface',
  LABEL_SELECTOR: '.mdc-snackbar__label',
  ACTION_SELECTOR: '.mdc-snackbar__action',
  DISMISS_SELECTOR: '.mdc-snackbar__dismiss',

  OPENING_EVENT: 'MDCSnackbar:opening',
  OPENED_EVENT: 'MDCSnackbar:opened',
  CLOSING_EVENT: 'MDCSnackbar:closing',
  CLOSED_EVENT: 'MDCSnackbar:closed',

  REASON_ACTION: 'action',
  REASON_DISMISS: 'dismiss',

  ARIA_LIVE_LABEL_TEXT_ATTR: 'data-mdc-snackbar-label-text',
};

const numbers = {
  MIN_AUTO_DISMISS_TIMEOUT_MS: 4000,
  MAX_AUTO_DISMISS_TIMEOUT_MS: 10000,
  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,

  // These variables need to be kept in sync with the values in _variables.scss.
  SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
  SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,

  /**
   * Number of milliseconds to wait between temporarily clearing the label text
   * in the DOM and subsequently restoring it. This is necessary to force IE 11
   * to pick up the `aria-live` content change and announce it to the user.
   */
  ARIA_LIVE_DELAY_MS: 1000,
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const {ARIA_LIVE_DELAY_MS} = numbers;
const {ARIA_LIVE_LABEL_TEXT_ATTR} = strings;

/**
 * @param {!HTMLElement} ariaEl
 * @param {!HTMLElement=} labelEl
 */
function announce(ariaEl, labelEl = ariaEl) {
  const priority = ariaEl.getAttribute('aria-live');
  const labelText = labelEl.textContent.trim(); // Ignore `&nbsp;` (see below)
  if (!labelText) {
    return;
  }

  // Temporarily disable `aria-live` to prevent JAWS+Firefox from announcing the message twice.
  ariaEl.setAttribute('aria-live', 'off');

  // Temporarily clear `textContent` to force a DOM mutation event that will be detected by screen readers.
  // `aria-live` elements are only announced when the element's `textContent` *changes*, so snackbars
  // sent to the browser in the initial HTML response won't be read unless we clear the element's `textContent` first.
  // Similarly, displaying the same snackbar message twice in a row doesn't trigger a DOM mutation event,
  // so screen readers won't announce the second message unless we first clear `textContent`.
  //
  // We have to clear the label text two different ways to make it work in all browsers and screen readers:
  //
  //   1. `textContent = ''` is required for IE11 + JAWS
  //   2. `innerHTML = '&nbsp;'` is required for Chrome + JAWS and NVDA
  //
  // All other browser/screen reader combinations support both methods.
  //
  // The wrapper `<span>` visually hides the space character so that it doesn't cause jank when added/removed.
  // N.B.: Setting `position: absolute`, `opacity: 0`, or `height: 0` prevents Chrome from detecting the DOM change.
  //
  // This technique has been tested in:
  //
  //   * JAWS 2019:
  //       - Chrome 70
  //       - Firefox 60 (ESR)
  //       - IE 11
  //   * NVDA 2018:
  //       - Chrome 70
  //       - Firefox 60 (ESR)
  //       - IE 11
  //   * ChromeVox 53
  labelEl.textContent = '';
  labelEl.innerHTML = '<span style="display: inline-block; width: 0; height: 1px;">&nbsp;</span>';

  // Prevent visual jank by temporarily displaying the label text in the ::before pseudo-element.
  // CSS generated content is normally announced by screen readers
  // (except in IE 11; see https://tink.uk/accessibility-support-for-css-generated-content/);
  // however, `aria-live` is turned off, so this DOM update will be ignored by screen readers.
  labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);

  setTimeout(() => {
    // Allow screen readers to announce changes to the DOM again.
    ariaEl.setAttribute('aria-live', priority);

    // Remove the message from the ::before pseudo-element.
    labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR);

    // Restore the original label text, which will be announced by screen readers.
    labelEl.textContent = labelText;
  }, ARIA_LIVE_DELAY_MS);
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const {OPENING, OPEN, CLOSING} = cssClasses;
const {REASON_ACTION, REASON_DISMISS} = strings;

class MDCSnackbarFoundation extends MDCFoundation {
  static get cssClasses() {
    return cssClasses;
  }

  static get strings() {
    return strings;
  }

  static get numbers() {
    return numbers;
  }

  /**
   * @return {!MDCSnackbarAdapter}
   */
  static get defaultAdapter() {
    return /** @type {!MDCSnackbarAdapter} */ ({
      addClass: (/* className: string */) => {},
      removeClass: (/* className: string */) => {},
      announce: () => {},
      notifyOpening: () => {},
      notifyOpened: () => {},
      notifyClosing: (/* reason: string */) => {},
      notifyClosed: (/* reason: string */) => {},
    });
  }

  /**
   * @param {!MDCSnackbarAdapter=} adapter
   */
  constructor(adapter) {
    super(Object.assign(MDCSnackbarFoundation.defaultAdapter, adapter));

    /** @private {boolean} */
    this.isOpen_ = false;

    /** @private {number} */
    this.animationFrame_ = 0;

    /** @private {number} */
    this.animationTimer_ = 0;

    /** @private {number} */
    this.autoDismissTimer_ = 0;

    /** @private {number} */
    this.autoDismissTimeoutMs_ = numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;

    /** @private {boolean} */
    this.closeOnEscape_ = true;
  }

  destroy() {
    this.clearAutoDismissTimer_();
    cancelAnimationFrame(this.animationFrame_);
    this.animationFrame_ = 0;
    clearTimeout(this.animationTimer_);
    this.animationTimer_ = 0;
    this.adapter_.removeClass(OPENING);
    this.adapter_.removeClass(OPEN);
    this.adapter_.removeClass(CLOSING);
  }

  open() {
    this.clearAutoDismissTimer_();
    this.isOpen_ = true;
    this.adapter_.notifyOpening();
    this.adapter_.removeClass(CLOSING);
    this.adapter_.addClass(OPENING);
    this.adapter_.announce();

    // Wait a frame once display is no longer "none", to establish basis for animation
    this.runNextAnimationFrame_(() => {
      this.adapter_.addClass(OPEN);

      this.animationTimer_ = setTimeout(() => {
        this.handleAnimationTimerEnd_();
        this.adapter_.notifyOpened();
        this.autoDismissTimer_ = setTimeout(() => {
          this.close(REASON_DISMISS);
        }, this.getTimeoutMs());
      }, numbers.SNACKBAR_ANIMATION_OPEN_TIME_MS);
    });
  }

  /**
   * @param {string=} reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
   *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
   *     client-specific values may also be used if desired.
   */
  close(reason = '') {
    if (!this.isOpen_) {
      // Avoid redundant close calls (and events), e.g. repeated interactions as the snackbar is animating closed
      return;
    }

    cancelAnimationFrame(this.animationFrame_);
    this.animationFrame_ = 0;
    this.clearAutoDismissTimer_();

    this.isOpen_ = false;
    this.adapter_.notifyClosing(reason);
    this.adapter_.addClass(cssClasses.CLOSING);
    this.adapter_.removeClass(cssClasses.OPEN);
    this.adapter_.removeClass(cssClasses.OPENING);

    clearTimeout(this.animationTimer_);
    this.animationTimer_ = setTimeout(() => {
      this.handleAnimationTimerEnd_();
      this.adapter_.notifyClosed(reason);
    }, numbers.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
  }

  /**
   * @return {boolean}
   */
  isOpen() {
    return this.isOpen_;
  }

  /**
   * @return {number}
   */
  getTimeoutMs() {
    return this.autoDismissTimeoutMs_;
  }

  /**
   * @param {number} timeoutMs
   */
  setTimeoutMs(timeoutMs) {
    // Use shorter variable names to make the code more readable
    const minValue = numbers.MIN_AUTO_DISMISS_TIMEOUT_MS;
    const maxValue = numbers.MAX_AUTO_DISMISS_TIMEOUT_MS;

    if (timeoutMs <= maxValue && timeoutMs >= minValue) {
      this.autoDismissTimeoutMs_ = timeoutMs;
    } else {
      throw new Error(`timeoutMs must be an integer in the range ${minValue}–${maxValue}, but got '${timeoutMs}'`);
    }
  }

  /**
   * @return {boolean}
   */
  getCloseOnEscape() {
    return this.closeOnEscape_;
  }

  /**
   * @param {boolean} closeOnEscape
   */
  setCloseOnEscape(closeOnEscape) {
    this.closeOnEscape_ = closeOnEscape;
  }

  /**
   * @param {!KeyboardEvent} evt
   */
  handleKeyDown(evt) {
    if (this.getCloseOnEscape() && (evt.key === 'Escape' || evt.keyCode === 27)) {
      this.close(REASON_DISMISS);
    }
  }

  /**
   * @param {!MouseEvent} evt
   */
  handleActionButtonClick(evt) {
    this.close(REASON_ACTION);
  }

  /**
   * @param {!MouseEvent} evt
   */
  handleActionIconClick(evt) {
    this.close(REASON_DISMISS);
  }

  /** @private */
  clearAutoDismissTimer_() {
    clearTimeout(this.autoDismissTimer_);
    this.autoDismissTimer_ = 0;
  }

  /** @private */
  handleAnimationTimerEnd_() {
    this.animationTimer_ = 0;
    this.adapter_.removeClass(cssClasses.OPENING);
    this.adapter_.removeClass(cssClasses.CLOSING);
  }

  /**
   * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
   * @param {Function} callback
   * @private
   */
  runNextAnimationFrame_(callback) {
    cancelAnimationFrame(this.animationFrame_);
    this.animationFrame_ = requestAnimationFrame(() => {
      this.animationFrame_ = 0;
      clearTimeout(this.animationTimer_);
      this.animationTimer_ = setTimeout(callback, 0);
    });
  }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcSnackbarComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} elementRef
     * @param {?} snackbarRef
     * @param {?} data
     */
    constructor(_changeDetectorRef, elementRef, snackbarRef, data) {
        this._changeDetectorRef = _changeDetectorRef;
        this.elementRef = elementRef;
        this.snackbarRef = snackbarRef;
        this.data = data;
        this._foundation = new MDCSnackbarFoundation(this._createAdapter());
    }
    /**
     * @return {?}
     */
    get config() { return this.snackbarRef.componentInstance.snackbarConfig; }
    /**
     * @private
     * @return {?}
     */
    _createAdapter() {
        return {
            addClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.add(className)),
            removeClass: (/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._getHostElement().classList.remove(className)),
            announce: (/**
             * @return {?}
             */
            () => announce(this.label.nativeElement)),
            notifyClosed: (/**
             * @param {?} reason
             * @return {?}
             */
            (reason) => this.snackbarRef.dismiss(reason))
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._changeDetectorRef.detectChanges();
        this._applyClasses();
        this._applyConfig();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._foundation) {
            this._foundation.destroy();
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    _onKeydown(evt) {
        this._foundation.handleKeyDown(evt);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    _onActionClick(evt) {
        this._foundation.handleActionButtonClick(evt);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    _onActionIconClick(evt) {
        this._foundation.handleActionIconClick(evt);
    }
    /**
     * @return {?}
     */
    open() {
        this._foundation.open();
    }
    /**
     * @param {?=} reason
     * @return {?}
     */
    close(reason) {
        this._foundation.close(reason);
    }
    /**
     * @private
     * @return {?}
     */
    _applyClasses() {
        /** @type {?} */
        const classes = this.config.classes;
        if (classes) {
            if (classes instanceof Array) {
                this._getHostElement().classList.add(...(/** @type {?} */ (this.config.classes)));
            }
            else {
                this._getHostElement().classList.toggle(classes);
            }
        }
        /** @type {?} */
        const actionClasses = this.config.actionClasses;
        if (actionClasses && this.action) {
            if (actionClasses instanceof Array) {
                this.action.nativeElement.classList.add(...(/** @type {?} */ (this.config.actionClasses)));
            }
            else {
                this.action.nativeElement.classList.toggle(actionClasses);
            }
        }
        if (this.dismiss) {
            /** @type {?} */
            const dismissClasses = this.config.dismissClasses;
            if (dismissClasses) {
                if (dismissClasses instanceof Array) {
                    this.dismiss.nativeElement.classList.add(...(/** @type {?} */ (this.config.dismissClasses)));
                }
                else {
                    this.dismiss.nativeElement.classList.toggle(dismissClasses);
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    _applyConfig() {
        if (this.config.timeoutMs) {
            this._foundation.setTimeoutMs(this.config.timeoutMs);
        }
        if (this.config.dismiss) {
            this._foundation.setCloseOnEscape(this.config.closeOnEscape ? true : false);
        }
    }
    /**
     * Retrieves the DOM element of the component host.
     * @private
     * @return {?}
     */
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
}
MdcSnackbarComponent.decorators = [
    { type: Component, args: [{selector: 'mdc-snackbar',
                host: {
                    'class': 'mdc-snackbar',
                    '[dir]': 'this.config.direction',
                    '[class.mdc-snackbar--stacked]': 'config.stacked',
                    '[class.mdc-snackbar--leading]': 'config.leading',
                    '[class.ngx-mdc-snackbar--trailing]': 'config.trailing',
                    '(keydown)': '_onKeydown($event)'
                },
                template: `
  <div #surface class="mdc-snackbar__surface">
    <div #label class="mdc-snackbar__label"
      role="status"
      aria-live="polite">{{data.message}}</div>
    <div class="mdc-snackbar__actions" *ngIf="data.action">
      <button #action type="button" class="mdc-button mdc-snackbar__action"
        (click)="_onActionClick($event)">{{data.action}}</button>
      <button #dismiss *ngIf="config.dismiss"
        class="mdc-icon-button mdc-snackbar__dismiss material-icons"
        title="Dismiss" (click)="_onActionIconClick($event)">close</button>
    </div>
  </div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcSnackbarComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: MdcSnackbarRef },
    { type: undefined, decorators: [{ type: Inject, args: [MDC_SNACKBAR_DATA,] }] }
];
MdcSnackbarComponent.propDecorators = {
    label: [{ type: ViewChild, args: ['label',] }],
    action: [{ type: ViewChild, args: ['action',] }],
    dismiss: [{ type: ViewChild, args: ['dismiss',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcSnackbarContainer extends BasePortalOutlet {
    /**
     * @param {?} _ngZone
     * @param {?} snackbarConfig
     */
    constructor(_ngZone, snackbarConfig) {
        super();
        this._ngZone = _ngZone;
        this.snackbarConfig = snackbarConfig;
        /**
         * Subject for notifying that the snackbar has exited from view.
         */
        this._onExit = new Subject();
    }
    /**
     * Attach a component portal as content to this snackbar container.
     * @template T
     * @param {?} portal
     * @return {?}
     */
    attachComponentPortal(portal) {
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a template portal as content to this snackbar container.
     * @template C
     * @param {?} portal
     * @return {?}
     */
    attachTemplatePortal(portal) {
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._completeExit();
    }
    /**
     * Waits for the zone to settle before removing the element. Helps prevent
     * errors where we end up removing an element which is in the middle of an animation.
     * @private
     * @return {?}
     */
    _completeExit() {
        this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this._onExit.next();
            this._onExit.complete();
        }));
    }
}
MdcSnackbarContainer.decorators = [
    { type: Component, args: [{selector: 'mdc-snackbar-container',
                template: '<ng-template cdkPortalOutlet></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
MdcSnackbarContainer.ctorParameters = () => [
    { type: NgZone },
    { type: MdcSnackbarConfig }
];
MdcSnackbarContainer.propDecorators = {
    _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MdcSnackbarModule {
}
MdcSnackbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    PortalModule,
                    MdcButtonModule
                ],
                exports: [MdcSnackbarContainer],
                declarations: [MdcSnackbarContainer, MdcSnackbarComponent],
                entryComponents: [MdcSnackbarContainer, MdcSnackbarComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token that can be used to specify default snackbar.
 * @type {?}
 */
const MDC_SNACKBAR_DEFAULT_OPTIONS = new InjectionToken('mdc-snackbar-default-options', {
    providedIn: 'root',
    factory: MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
function MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY() {
    return new MdcSnackbarConfig();
}
class MdcSnackbar {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _parentSnackBar
     * @param {?} _defaultConfig
     */
    constructor(_overlay, _injector, _parentSnackBar, _defaultConfig) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._parentSnackBar = _parentSnackBar;
        this._defaultConfig = _defaultConfig;
        /**
         * Reference to the current snackbar in the view *at this level* (in the Angular injector tree).
         * If there is a parent snack-bar service, all operations should delegate to that parent
         * via `_openedSnackBarRef`.
         */
        this._snackBarRefAtThisLevel = null;
    }
    /**
     * Reference to the currently opened snackbar at *any* level.
     * @return {?}
     */
    get _openedSnackbarRef() {
        /** @type {?} */
        const parent = this._parentSnackBar;
        return parent ? parent._openedSnackbarRef : this._snackBarRefAtThisLevel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _openedSnackbarRef(value) {
        if (this._parentSnackBar) {
            this._parentSnackBar._openedSnackbarRef = value;
        }
        else {
            this._snackBarRefAtThisLevel = value;
        }
    }
    /**
     * Creates and dispatches a snackbar with a custom component for the content, removing any
     * currently opened snackbars.
     *
     * @template T
     * @param {?} component Component to be instantiated.
     * @param {?=} config Extra configuration for the snackbar.
     * @return {?}
     */
    openFromComponent(component, config) {
        return (/** @type {?} */ (this._attach(component, config)));
    }
    /**
     * Opens a snackbar with a message and an optional action.
     * @param {?} message Message text.
     * @param {?=} action The label for the snackbar action.
     * @param {?=} config Additional configuration options for the snackbar.
     * @return {?}
     */
    open(message, action = '', config) {
        /** @type {?} */
        const _config = Object.assign({}, this._defaultConfig, config);
        // Since the user doesn't have access to the component, we can
        // override the data to pass in our own message and action.
        _config.data = { message, action };
        return this.openFromComponent(MdcSnackbarComponent, _config);
    }
    /**
     * Dismisses the currently-visible snackbar.
     * @return {?}
     */
    dismiss() {
        if (this._openedSnackbarRef) {
            if (this._openedSnackbarRef.instance instanceof MdcSnackbarComponent) {
                ((/** @type {?} */ (this._openedSnackbarRef.instance))).close();
            }
            this._openedSnackbarRef.dismiss();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Only dismiss the snackbar at the current level on destroy.
        if (this._snackBarRefAtThisLevel) {
            this._snackBarRefAtThisLevel.dismiss();
        }
    }
    /**
     * Attaches the snackbar container component to the overlay.
     * @private
     * @param {?} overlayRef
     * @param {?} config
     * @return {?}
     */
    _attachSnackbarContainer(overlayRef, config) {
        /** @type {?} */
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        /** @type {?} */
        const injector = new PortalInjector(userInjector || this._injector, new WeakMap([
            [MdcSnackbarConfig, config]
        ]));
        /** @type {?} */
        const containerPortal = new ComponentPortal(MdcSnackbarContainer, config.viewContainerRef, injector);
        /** @type {?} */
        const containerRef = overlayRef.attach(containerPortal);
        containerRef.instance.snackbarConfig = config;
        return containerRef.instance;
    }
    /**
     * Places a new component or a template as the content of the snackbar container.
     * @private
     * @template T
     * @param {?} content
     * @param {?=} userConfig
     * @return {?}
     */
    _attach(content, userConfig) {
        /** @type {?} */
        const config = Object.assign({}, new MdcSnackbarConfig(), this._defaultConfig, userConfig);
        /** @type {?} */
        const overlayRef = this._createOverlay();
        /** @type {?} */
        const container = this._attachSnackbarContainer(overlayRef, config);
        /** @type {?} */
        const snackbarRef = new MdcSnackbarRef(container, overlayRef);
        /** @type {?} */
        const injector = this._createInjector(config, snackbarRef);
        /** @type {?} */
        const portal = new ComponentPortal(content, undefined, injector);
        /** @type {?} */
        const contentRef = container.attachComponentPortal(portal);
        // We can't pass this via the injector, because the injector is created earlier.
        snackbarRef.instance = contentRef.instance;
        this._loadListeners(snackbarRef);
        this._openedSnackbarRef = snackbarRef;
        if (snackbarRef.instance instanceof MdcSnackbarComponent) {
            ((/** @type {?} */ (snackbarRef.instance))).open();
        }
        return this._openedSnackbarRef;
    }
    /**
     * @private
     * @param {?} snackbarRef
     * @return {?}
     */
    _loadListeners(snackbarRef) {
        // When the snackbar is dismissed, clear the reference to it.
        snackbarRef.afterDismiss().subscribe((/**
         * @return {?}
         */
        () => {
            // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
            if (this._openedSnackbarRef === snackbarRef) {
                this._openedSnackbarRef = null;
            }
        }));
        if (this._openedSnackbarRef) {
            this._openedSnackbarRef.dismiss();
        }
    }
    /**
     * Creates a new overlay and places it in the correct location.
     * @private
     * @return {?}
     */
    _createOverlay() {
        return this._overlay.create();
    }
    /**
     * Creates an injector to be used inside of a snackbar component.
     * @private
     * @template T
     * @param {?} config Config that was used to create the snackbar.
     * @param {?} snackbarRef Reference to the snackbar.
     * @return {?}
     */
    _createInjector(config, snackbarRef) {
        /** @type {?} */
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        return new PortalInjector(userInjector || this._injector, new WeakMap([
            [MdcSnackbarRef, snackbarRef],
            [MDC_SNACKBAR_DATA, config.data]
        ]));
    }
}
MdcSnackbar.decorators = [
    { type: Injectable, args: [{ providedIn: MdcSnackbarModule },] },
];
/** @nocollapse */
MdcSnackbar.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: MdcSnackbar, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: MdcSnackbarConfig, decorators: [{ type: Inject, args: [MDC_SNACKBAR_DEFAULT_OPTIONS,] }] }
];
/** @nocollapse */ MdcSnackbar.ngInjectableDef = defineInjectable({ factory: function MdcSnackbar_Factory() { return new MdcSnackbar(inject(Overlay), inject(INJECTOR), inject(MdcSnackbar, 12), inject(MDC_SNACKBAR_DEFAULT_OPTIONS)); }, token: MdcSnackbar, providedIn: MdcSnackbarModule });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MdcSnackbarModule, MdcSnackbarContainer, MDC_SNACKBAR_DATA, MdcSnackbarConfig, MdcSnackbarRef, MdcSnackbarComponent, MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY, MDC_SNACKBAR_DEFAULT_OPTIONS, MdcSnackbar };
//# sourceMappingURL=snackbar.js.map
