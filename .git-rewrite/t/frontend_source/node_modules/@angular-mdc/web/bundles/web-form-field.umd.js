/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular-mdc/web/common'), require('@angular/common')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/form-field', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular-mdc/web/common', '@angular/common'], factory) :
  (global = global || self, factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.formField = {}), global.ng.core, global.rxjs, global.rxjs.operators, global.ng.web.common, global.ng.common));
}(this, function (exports, core, rxjs, operators, common, common$1) { 'use strict';

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Character Counter.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the TextField character counter into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldCharacterCounterAdapter =
  /*#__PURE__*/
  function () {
    function MDCTextFieldCharacterCounterAdapter() {
      _classCallCheck(this, MDCTextFieldCharacterCounterAdapter);
    }

    _createClass(MDCTextFieldCharacterCounterAdapter, [{
      key: "setContent",

      /**
       * Sets the text content of character counter element.
       * @param {string} content
       */
      value: function setContent(content) {}
    }]);

    return MDCTextFieldCharacterCounterAdapter;
  }();

  /**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses = {
    ROOT: 'mdc-text-field-character-counter'
  };
  /** @enum {string} */

  var strings = {
    ROOT_SELECTOR: ".".concat(cssClasses.ROOT)
  };

  /**
   * @extends {MDCFoundation<!MDCTextFieldCharacterCounterAdapter>}
   * @final
   */

  var MDCTextFieldCharacterCounterFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTextFieldCharacterCounterFoundation, _MDCFoundation);

    _createClass(MDCTextFieldCharacterCounterFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings;
      }
      /**
       * {@see MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldCharacterCounterAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTextFieldCharacterCounterAdapter} */
          {
            setContent: function setContent() {}
          }
        );
      }
      /**
       * @param {!MDCTextFieldCharacterCounterAdapter} adapter
       */

    }]);

    function MDCTextFieldCharacterCounterFoundation(adapter) {
      _classCallCheck(this, MDCTextFieldCharacterCounterFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCTextFieldCharacterCounterFoundation).call(this, Object.assign(MDCTextFieldCharacterCounterFoundation.defaultAdapter, adapter)));
    }
    /**
     * @param {number} currentLength
     * @param {number} maxLength
     */


    _createClass(MDCTextFieldCharacterCounterFoundation, [{
      key: "setCounterValue",
      value: function setCounterValue(currentLength, maxLength) {
        currentLength = Math.min(currentLength, maxLength);
        this.adapter_.setContent("".concat(currentLength, " / ").concat(maxLength));
      }
    }]);

    return MDCTextFieldCharacterCounterFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCTextFieldCharacterCounterFoundation>}
   * @final
   */

  var MDCTextFieldCharacterCounter =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCTextFieldCharacterCounter, _MDCComponent);

    function MDCTextFieldCharacterCounter() {
      _classCallCheck(this, MDCTextFieldCharacterCounter);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCTextFieldCharacterCounter).apply(this, arguments));
    }

    _createClass(MDCTextFieldCharacterCounter, [{
      key: "getDefaultFoundation",

      /**
       * @return {!MDCTextFieldCharacterCounterFoundation}
       */
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCTextFieldCharacterCounterFoundation(
        /** @type {!MDCTextFieldCharacterCounterAdapter} */
        Object.assign({
          setContent: function setContent(content) {
            _this.root_.textContent = content;
          }
        }));
      }
    }, {
      key: "foundation",

      /**
       * @return {!MDCTextFieldCharacterCounterFoundation}
       */
      get: function get() {
        return this.foundation_;
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCTextFieldCharacterCounter}
       */
      value: function attachTo(root) {
        return new MDCTextFieldCharacterCounter(root);
      }
    }]);

    return MDCTextFieldCharacterCounter;
  }(MDCComponent);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcCharacterCounter = /** @class */ (function () {
      function MdcCharacterCounter(elementRef) {
          this.elementRef = elementRef;
      }
      /**
       * @return {?}
       */
      MdcCharacterCounter.prototype.getDefaultFoundation = /**
       * @return {?}
       */
      function () {
          var _this = this;
          /** @type {?} */
          var adapter = {
              setContent: (/**
               * @param {?} content
               * @return {?}
               */
              function (content) { return _this.elementRef.nativeElement.textContent = content; })
          };
          return new MDCTextFieldCharacterCounterFoundation(adapter);
      };
      /**
       * @return {?}
       */
      MdcCharacterCounter.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this.getDefaultFoundation().destroy();
      };
      MdcCharacterCounter.decorators = [
          { type: core.Component, args: [{selector: '[mdcCharacterCounter]',
                      exportAs: 'mdcCharacterCounter',
                      host: { 'class': 'mdc-text-field-character-counter' },
                      template: '<ng-content></ng-content>'
                  },] },
      ];
      /** @nocollapse */
      MdcCharacterCounter.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      return MdcCharacterCounter;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with updateErrorState method.
   * For component with `errorState` and need to update `errorState`.
   * @template T
   * @param {?} base
   * @return {?}
   */
  function mixinErrorState(base) {
      return /** @class */ (function (_super) {
          __extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              /**
               * Whether the component is in an error state.
               */
              _this.errorState = false;
              _this.required = false;
              return _this;
          }
          /**
           * @return {?}
           */
          class_1.prototype.updateErrorState = /**
           * @return {?}
           */
          function () {
              /** @type {?} */
              var oldState = this.errorState;
              /** @type {?} */
              var parent = this._parentFormGroup || this._parentForm;
              /** @type {?} */
              var matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;
              /** @type {?} */
              var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
              /** @type {?} */
              var newState = matcher.isErrorState(control, parent);
              if (newState !== oldState) {
                  this.errorState = newState;
              }
              // Currently there isn't a great way to determine if Validators.required
              // has been added to the control since form validators are combined into
              // an aggregate function at initialization.
              if (control && !this.required) {
                  this.required = control.hasError('required');
              }
          };
          return class_1;
      }(base));
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Provider that defines how form controls behave with regards to displaying error messages.
   */
  var ErrorStateMatcher = /** @class */ (function () {
      function ErrorStateMatcher() {
      }
      /**
       * @param {?} control
       * @param {?} form
       * @return {?}
       */
      ErrorStateMatcher.prototype.isErrorState = /**
       * @param {?} control
       * @param {?} form
       * @return {?}
       */
      function (control, form) {
          return !!(control && control.invalid && (control.touched || (form && form.submitted)));
      };
      ErrorStateMatcher.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = core.defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
      return ErrorStateMatcher;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @abstract
   * @template T
   */
  var   /**
   * @abstract
   * @template T
   */
  MdcFormFieldControl = /** @class */ (function () {
      function MdcFormFieldControl() {
          /**
           * The value of the control.
           */
          this.value = null;
      }
      return MdcFormFieldControl;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcHelperText = /** @class */ (function () {
      function MdcHelperText(elementRef) {
          this.elementRef = elementRef;
          this.characterCounter = false;
          this._persistent = false;
          this._validation = false;
      }
      Object.defineProperty(MdcHelperText.prototype, "persistent", {
          get: /**
           * @return {?}
           */
          function () { return this._persistent; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._persistent = common.toBoolean(value);
              if (this._foundation) {
                  this._foundation.setPersistent(this._persistent);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcHelperText.prototype, "validation", {
          get: /**
           * @return {?}
           */
          function () { return this._validation; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._validation = common.toBoolean(value);
              if (this._foundation) {
                  this._foundation.setValidation(this._validation);
              }
          },
          enumerable: true,
          configurable: true
      });
      /** Sets the validity of the helper text based on inputIsValid. */
      /**
       * Sets the validity of the helper text based on inputIsValid.
       * @param {?} inputIsValid
       * @return {?}
       */
      MdcHelperText.prototype.setValidity = /**
       * Sets the validity of the helper text based on inputIsValid.
       * @param {?} inputIsValid
       * @return {?}
       */
      function (inputIsValid) {
          this._foundation.setValidity(inputIsValid);
      };
      /** Makes the helper text visible to the screen reader. */
      /**
       * Makes the helper text visible to the screen reader.
       * @return {?}
       */
      MdcHelperText.prototype.showToScreenReader = /**
       * Makes the helper text visible to the screen reader.
       * @return {?}
       */
      function () {
          this._foundation.showToScreenReader();
      };
      /**
       * @param {?} foundation
       * @return {?}
       */
      MdcHelperText.prototype.init = /**
       * @param {?} foundation
       * @return {?}
       */
      function (foundation) {
          this._foundation = new foundation(this._createAdapter());
          this._foundation.setPersistent(this.persistent);
          this._foundation.setValidation(this.validation);
      };
      /**
       * @param {?} className
       * @return {?}
       */
      MdcHelperText.prototype.addHelperTextClass = /**
       * @param {?} className
       * @return {?}
       */
      function (className) {
          (/** @type {?} */ (this._helperTextElement)).nativeElement.classList.add(className + "-helper-text");
      };
      /**
       * @private
       * @return {?}
       */
      MdcHelperText.prototype._createAdapter = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              addClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.classList.add(className); }),
              removeClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.classList.remove(className); }),
              hasClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.classList.contains(className); }),
              setAttr: (/**
               * @param {?} attr
               * @param {?} value
               * @return {?}
               */
              function (attr, value) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.setAttribute(attr, value); }),
              removeAttr: (/**
               * @param {?} attr
               * @return {?}
               */
              function (attr) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.removeAttribute(attr); })
          };
      };
      MdcHelperText.decorators = [
          { type: core.Component, args: [{selector: "mdc-helper-text, [mdcHelperText],\n  mdc-text-field-helper-text, [mdcTextFieldHelperText], [mdcSelectHelperText]",
                      exportAs: 'mdcHelperText, mdcSelectHelperText',
                      host: { 'class': 'mdc-text-field-helper-line' },
                      template: "<div #helperText><ng-content></ng-content></div>\n  <div mdcCharacterCounter *ngIf=\"characterCounter\"></div>",
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None
                  },] },
      ];
      /** @nocollapse */
      MdcHelperText.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcHelperText.propDecorators = {
          id: [{ type: core.Input }],
          persistent: [{ type: core.Input }],
          validation: [{ type: core.Input }],
          _helperTextElement: [{ type: core.ViewChild, args: ['helperText',] }],
          _characterCounterElement: [{ type: core.ViewChild, args: [MdcCharacterCounter,] }]
      };
      return MdcHelperText;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcFormField = /** @class */ (function () {
      function MdcFormField(_changeDetectorRef, _ngZone, elementRef) {
          this._changeDetectorRef = _changeDetectorRef;
          this._ngZone = _ngZone;
          this.elementRef = elementRef;
          /**
           * Emits whenever the component is destroyed.
           */
          this._destroy = new rxjs.Subject();
          this._fluid = false;
          this._alignEnd = false;
      }
      Object.defineProperty(MdcFormField.prototype, "fluid", {
          get: /**
           * @return {?}
           */
          function () { return this._fluid; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._fluid = common.toBoolean(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcFormField.prototype, "alignEnd", {
          get: /**
           * @return {?}
           */
          function () { return this._alignEnd; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._alignEnd = common.toBoolean(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MdcFormField.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          var _this = this;
          if (this._control) {
              /** @type {?} */
              var control = this._control.elementRef.nativeElement;
              if (control.nextElementSibling) {
                  if (control.nextElementSibling.tagName === 'LABEL') {
                      this.label = control.nextElementSibling;
                      if (this.label && this._control.inputId) {
                          (/** @type {?} */ (this.label)).setAttribute('for', this._control.inputId);
                          this._loadListeners();
                      }
                  }
              }
          }
          // When assistive elements change, initialize foundation
          this.assistiveElements.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy))
              .subscribe((/**
           * @return {?}
           */
          function () {
              (_this.assistiveElements).forEach((/**
               * @param {?} helperText
               * @return {?}
               */
              function (helperText) {
                  return _this._initHelperTextFoundation(helperText);
              }));
          }));
      };
      /**
       * @return {?}
       */
      MdcFormField.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._destroy.next();
          this._destroy.complete();
      };
      /**
       * @private
       * @param {?} helperText
       * @return {?}
       */
      MdcFormField.prototype._initHelperTextFoundation = /**
       * @private
       * @param {?} helperText
       * @return {?}
       */
      function (helperText) {
          /** @type {?} */
          var control = this._control;
          if (control && control.controlType) {
              control.helperText = helperText;
              this._changeDetectorRef.markForCheck();
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcFormField.prototype._loadListeners = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          this._ngZone.runOutsideAngular((/**
           * @return {?}
           */
          function () {
              return rxjs.fromEvent((/** @type {?} */ (_this.label)), 'click').pipe(operators.takeUntil(_this._destroy))
                  .subscribe((/**
               * @return {?}
               */
              function () { return _this._ngZone.run((/**
               * @return {?}
               */
              function () {
                  (/** @type {?} */ (_this._control.ripple)).activateRipple();
                  if (typeof requestAnimationFrame !== 'undefined') {
                      requestAnimationFrame((/**
                       * @return {?}
                       */
                      function () { return (/** @type {?} */ (_this._control.ripple)).deactivateRipple(); }));
                  }
              })); }));
          }));
      };
      MdcFormField.decorators = [
          { type: core.Component, args: [{selector: 'mdc-form-field',
                      exportAs: 'mdcFormField',
                      host: {
                          '[class.ngx-mdc-form-field--fluid]': 'fluid',
                          '[class.mdc-form-field--align-end]': 'alignEnd'
                      },
                      template: "<ng-content></ng-content>\n  <ng-content select=\"[mdcHelperText, mdc-helper-text]\"></ng-content>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MdcFormField.ctorParameters = function () { return [
          { type: core.ChangeDetectorRef },
          { type: core.NgZone },
          { type: core.ElementRef }
      ]; };
      MdcFormField.propDecorators = {
          fluid: [{ type: core.Input }],
          alignEnd: [{ type: core.Input }],
          _control: [{ type: core.ContentChild, args: [MdcFormFieldControl,] }],
          assistiveElements: [{ type: core.ContentChildren, args: [MdcHelperText, { descendants: true },] }]
      };
      return MdcFormField;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var FORM_FIELD_DECLARATIONS = [
      MdcCharacterCounter,
      MdcFormField,
      MdcHelperText
  ];
  var MdcFormFieldModule = /** @class */ (function () {
      function MdcFormFieldModule() {
      }
      MdcFormFieldModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common$1.CommonModule],
                      exports: [FORM_FIELD_DECLARATIONS],
                      declarations: [FORM_FIELD_DECLARATIONS]
                  },] },
      ];
      return MdcFormFieldModule;
  }());

  exports.MdcCharacterCounter = MdcCharacterCounter;
  exports.mixinErrorState = mixinErrorState;
  exports.ErrorStateMatcher = ErrorStateMatcher;
  exports.MdcFormField = MdcFormField;
  exports.MdcFormFieldControl = MdcFormFieldControl;
  exports.MdcFormFieldModule = MdcFormFieldModule;
  exports.MdcHelperText = MdcHelperText;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=web-form-field.umd.js.map
