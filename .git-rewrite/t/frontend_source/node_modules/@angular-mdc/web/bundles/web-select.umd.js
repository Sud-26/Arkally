/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular-mdc/web/floating-label'), require('@angular-mdc/web/line-ripple'), require('@angular-mdc/web/notched-outline'), require('@angular-mdc/web/form-field'), require('@angular-mdc/web/menu'), require('@angular/forms'), require('rxjs'), require('rxjs/operators'), require('@angular-mdc/web/common'), require('@angular-mdc/web/ripple'), require('@angular-mdc/web/list'), require('@angular-mdc/web/icon')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/select', ['exports', '@angular/core', '@angular/common', '@angular-mdc/web/floating-label', '@angular-mdc/web/line-ripple', '@angular-mdc/web/notched-outline', '@angular-mdc/web/form-field', '@angular-mdc/web/menu', '@angular/forms', 'rxjs', 'rxjs/operators', '@angular-mdc/web/common', '@angular-mdc/web/ripple', '@angular-mdc/web/list', '@angular-mdc/web/icon'], factory) :
  (global = global || self, factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.select = {}), global.ng.core, global.ng.common, global.ng.web.floatingLabel, global.ng.web.lineRipple, global.ng.web.notchedOutline, global.ng.web.formField, global.ng.web.menu, global.ng.forms, global.rxjs, global.rxjs.operators, global.ng.web.common, global.ng.web.ripple, global.ng.web.list, global.ng.web.icon));
}(this, function (exports, core, common, floatingLabel, lineRipple, notchedOutline, formField, menu, forms, rxjs, operators, common$1, ripple, list, icon) { 'use strict';

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcSelectIcon = /** @class */ (function (_super) {
      __extends(MdcSelectIcon, _super);
      function MdcSelectIcon() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MdcSelectIcon.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcSelectIcon]',
                      exportAs: 'mdcSelectIcon',
                      host: { 'class': 'mdc-select__icon' }
                  },] },
      ];
      return MdcSelectIcon;
  }(icon.MdcIcon));

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Select Helper Text.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Select helper text into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSelectHelperTextAdapter =
  /*#__PURE__*/
  function () {
    function MDCSelectHelperTextAdapter() {
      _classCallCheck(this, MDCSelectHelperTextAdapter);
    }

    _createClass(MDCSelectHelperTextAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the helper text element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the helper text element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns whether or not the helper text element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets an attribute with a given value on the helper text element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}
      /**
       * Removes an attribute from the helper text element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}
      /**
       * Sets the text content for the helper text element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
    }]);

    return MDCSelectHelperTextAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
  };
  /** @enum {string} */

  var cssClasses = {
    HELPER_TEXT_PERSISTENT: 'mdc-select-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-select-helper-text--validation-msg'
  };

  /**
   * @extends {MDCFoundation<!MDCSelectHelperTextAdapter>}
   * @final
   */

  var MDCSelectHelperTextFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSelectHelperTextFoundation, _MDCFoundation);

    _createClass(MDCSelectHelperTextFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings;
      }
      /**
       * {@see MDCSelectHelperTextAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectHelperTextAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSelectHelperTextAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {}
          }
        );
      }
      /**
       * @param {!MDCSelectHelperTextAdapter} adapter
       */

    }]);

    function MDCSelectHelperTextFoundation(adapter) {
      _classCallCheck(this, MDCSelectHelperTextFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectHelperTextFoundation).call(this, Object.assign(MDCSelectHelperTextFoundation.defaultAdapter, adapter)));
    }
    /**
     * Sets the content of the helper text field.
     * @param {string} content
     */


    _createClass(MDCSelectHelperTextFoundation, [{
      key: "setContent",
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }
      /** @param {boolean} isPersistent Sets the persistency of the helper text. */

    }, {
      key: "setPersistent",
      value: function setPersistent(isPersistent) {
        if (isPersistent) {
          this.adapter_.addClass(cssClasses.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter_.removeClass(cssClasses.HELPER_TEXT_PERSISTENT);
        }
      }
      /**
       * @param {boolean} isValidation True to make the helper text act as an
       *   error validation message.
       */

    }, {
      key: "setValidation",
      value: function setValidation(isValidation) {
        if (isValidation) {
          this.adapter_.addClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter_.removeClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
        }
      }
      /** Makes the helper text visible to the screen reader. */

    }, {
      key: "showToScreenReader",
      value: function showToScreenReader() {
        this.adapter_.removeAttr(strings.ARIA_HIDDEN);
      }
      /**
       * Sets the validity of the helper text based on the select validity.
       * @param {boolean} selectIsValid
       */

    }, {
      key: "setValidity",
      value: function setValidity(selectIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !selectIsValid;

        if (validationMsgNeedsDisplay) {
          this.adapter_.setAttr(strings.ROLE, 'alert');
        } else {
          this.adapter_.removeAttr(strings.ROLE);
        }

        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      }
      /**
       * Hides the help text from screen readers.
       * @private
       */

    }, {
      key: "hide_",
      value: function hide_() {
        this.adapter_.setAttr(strings.ARIA_HIDDEN, 'true');
      }
    }]);

    return MDCSelectHelperTextFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCSelectHelperTextFoundation>}
   * @final
   */

  var MDCSelectHelperText =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCSelectHelperText, _MDCComponent);

    function MDCSelectHelperText() {
      _classCallCheck(this, MDCSelectHelperText);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectHelperText).apply(this, arguments));
    }

    _createClass(MDCSelectHelperText, [{
      key: "getDefaultFoundation",

      /**
       * @return {!MDCSelectHelperTextFoundation}
       */
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCSelectHelperTextFoundation(
        /** @type {!MDCSelectHelperTextAdapter} */
        Object.assign({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this.root_.classList.contains(className);
          },
          setAttr: function setAttr(attr, value) {
            return _this.root_.setAttribute(attr, value);
          },
          removeAttr: function removeAttr(attr) {
            return _this.root_.removeAttribute(attr);
          },
          setContent: function setContent(content) {
            _this.root_.textContent = content;
          }
        }));
      }
    }, {
      key: "foundation",

      /**
       * @return {!MDCSelectHelperTextFoundation}
       */
      get: function get() {
        return this.foundation_;
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCSelectHelperText}
       */
      value: function attachTo(root) {
        return new MDCSelectHelperText(root);
      }
    }]);

    return MDCSelectHelperText;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$1 = {
    DISABLED: 'mdc-select--disabled',
    ROOT: 'mdc-select',
    OUTLINED: 'mdc-select--outlined',
    FOCUSED: 'mdc-select--focused',
    SELECTED_ITEM_CLASS: 'mdc-list-item--selected',
    WITH_LEADING_ICON: 'mdc-select--with-leading-icon',
    INVALID: 'mdc-select--invalid',
    REQUIRED: 'mdc-select--required'
  };
  /** @enum {string} */

  var strings$1 = {
    ARIA_CONTROLS: 'aria-controls',
    CHANGE_EVENT: 'MDCSelect:change',
    SELECTED_ITEM_SELECTOR: ".".concat(cssClasses$1.SELECTED_ITEM_CLASS),
    LEADING_ICON_SELECTOR: '.mdc-select__icon',
    SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text',
    HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
    MENU_SELECTOR: '.mdc-select__menu',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    LABEL_SELECTOR: '.mdc-floating-label',
    NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    ENHANCED_VALUE_ATTR: 'data-value',
    ARIA_SELECTED_ATTR: 'aria-selected'
  };
  /** @enum {number} */

  var numbers = {
    LABEL_SCALE: 0.75
  };

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Floating Label.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the floating label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCFloatingLabelAdapter =
  /*#__PURE__*/
  function () {
    function MDCFloatingLabelAdapter() {
      _classCallCheck(this, MDCFloatingLabelAdapter);
    }

    _createClass(MDCFloatingLabelAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the label element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the label element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {}
      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
    }]);

    return MDCFloatingLabelAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$2 = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_SHAKE: 'mdc-floating-label--shake',
    ROOT: 'mdc-floating-label'
  };

  /**
   * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
   * @final
   */

  var MDCFloatingLabelFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCFloatingLabelFoundation, _MDCFoundation);

    _createClass(MDCFloatingLabelFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$2;
      }
      /**
       * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCFloatingLabelAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCFloatingLabelAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            getWidth: function getWidth() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {}
          }
        );
      }
      /**
       * @param {!MDCFloatingLabelAdapter} adapter
       */

    }]);

    function MDCFloatingLabelFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCFloatingLabelFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
      /** @private {function(!Event): undefined} */

      _this.shakeAnimationEndHandler_ = function () {
        return _this.handleShakeAnimationEnd_();
      };

      return _this;
    }

    _createClass(MDCFloatingLabelFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.adapter_.getWidth();
      }
      /**
       * Styles the label to produce the label shake for errors.
       * @param {boolean} shouldShake adds shake class if true,
       * otherwise removes shake class.
       */

    }, {
      key: "shake",
      value: function shake(shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        if (shouldShake) {
          this.adapter_.addClass(LABEL_SHAKE);
        } else {
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }
      /**
       * Styles the label to float or dock.
       * @param {boolean} shouldFloat adds float class if true, otherwise remove
       * float and shake class to dock label.
       */

    }, {
      key: "float",
      value: function float(shouldFloat) {
        var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
            LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
            LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

        if (shouldFloat) {
          this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
          this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }
      /**
       * Handles an interaction event on the root element.
       */

    }, {
      key: "handleShakeAnimationEnd_",
      value: function handleShakeAnimationEnd_() {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }]);

    return MDCFloatingLabelFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
   * @final
   */

  var MDCFloatingLabel =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCFloatingLabel, _MDCComponent);

    function MDCFloatingLabel() {
      _classCallCheck(this, MDCFloatingLabel);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCFloatingLabel).apply(this, arguments));
    }

    _createClass(MDCFloatingLabel, [{
      key: "shake",

      /**
       * Styles the label to produce the label shake for errors.
       * @param {boolean} shouldShake styles the label to shake by adding shake class
       * if true, otherwise will stop shaking by removing shake class.
       */
      value: function shake(shouldShake) {
        this.foundation_.shake(shouldShake);
      }
      /**
       * Styles label to float/dock.
       * @param {boolean} shouldFloat styles the label to float by adding float class
       * if true, otherwise docks the label by removing the float class.
       */

    }, {
      key: "float",
      value: function float(shouldFloat) {
        this.foundation_.float(shouldFloat);
      }
      /**
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.foundation_.getWidth();
      }
      /**
       * @return {!MDCFloatingLabelFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCFloatingLabelFoundation({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          getWidth: function getWidth() {
            return _this.root_.scrollWidth;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return _this.root_.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return _this.root_.removeEventListener(evtType, handler);
          }
        });
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCFloatingLabel}
       */
      value: function attachTo(root) {
        return new MDCFloatingLabel(root);
      }
    }]);

    return MDCFloatingLabel;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC TextField Line Ripple.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the line ripple into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCLineRippleAdapter =
  /*#__PURE__*/
  function () {
    function MDCLineRippleAdapter() {
      _classCallCheck(this, MDCLineRippleAdapter);
    }

    _createClass(MDCLineRippleAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the line ripple element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the line ripple element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets the style property with propertyName to value on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(propertyName, value) {}
      /**
       * Registers an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}
    }]);

    return MDCLineRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$3 = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
  };

  /**
   * @extends {MDCFoundation<!MDCLineRippleAdapter>}
   * @final
   */

  var MDCLineRippleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCLineRippleFoundation, _MDCFoundation);

    _createClass(MDCLineRippleFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$3;
      }
      /**
       * {@see MDCLineRippleAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCLineRippleAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCLineRippleAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setStyle: function setStyle() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {}
          }
        );
      }
      /**
       * @param {!MDCLineRippleAdapter=} adapter
       */

    }]);

    function MDCLineRippleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCLineRippleFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCLineRippleFoundation).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
      /** @private {function(!Event): undefined} */

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };

      return _this;
    }

    _createClass(MDCLineRippleFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
      }
      /**
       * Activates the line ripple
       */

    }, {
      key: "activate",
      value: function activate() {
        this.adapter_.removeClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses$3.LINE_RIPPLE_ACTIVE);
      }
      /**
       * Sets the center of the ripple animation to the given X coordinate.
       * @param {number} xCoordinate
       */

    }, {
      key: "setRippleCenter",
      value: function setRippleCenter(xCoordinate) {
        this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
      }
      /**
       * Deactivates the line ripple
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        this.adapter_.addClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);
      }
      /**
       * Handles a transition end event
       * @param {!Event} evt
       */

    }, {
      key: "handleTransitionEnd",
      value: function handleTransitionEnd(evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);

        if (evt.propertyName === 'opacity') {
          if (isDeactivating) {
            this.adapter_.removeClass(cssClasses$3.LINE_RIPPLE_ACTIVE);
            this.adapter_.removeClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);
          }
        }
      }
    }]);

    return MDCLineRippleFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCLineRippleFoundation>}
   * @final
   */

  var MDCLineRipple =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCLineRipple, _MDCComponent);

    function MDCLineRipple() {
      _classCallCheck(this, MDCLineRipple);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCLineRipple).apply(this, arguments));
    }

    _createClass(MDCLineRipple, [{
      key: "activate",

      /**
       * Activates the line ripple
       */
      value: function activate() {
        this.foundation_.activate();
      }
      /**
       * Deactivates the line ripple
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        this.foundation_.deactivate();
      }
      /**
       * Sets the transform origin given a user's click location. The `rippleCenter` is the
       * x-coordinate of the middle of the ripple.
       * @param {number} xCoordinate
       */

    }, {
      key: "setRippleCenter",
      value: function setRippleCenter(xCoordinate) {
        this.foundation_.setRippleCenter(xCoordinate);
      }
      /**
       * @return {!MDCLineRippleFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCLineRippleFoundation(
        /** @type {!MDCLineRippleAdapter} */
        Object.assign({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this.root_.classList.contains(className);
          },
          setStyle: function setStyle(propertyName, value) {
            return _this.root_.style[propertyName] = value;
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            return _this.root_.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            return _this.root_.removeEventListener(evtType, handler);
          }
        }));
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCLineRipple}
       */
      value: function attachTo(root) {
        return new MDCLineRipple(root);
      }
    }]);

    return MDCLineRipple;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Menu. Provides an interface for managing
   * - selected element classes
   * - get focused elements
   * - toggling a checkbox inside a list item
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuAdapter =
  /*#__PURE__*/
  function () {
    function MDCMenuAdapter() {
      _classCallCheck(this, MDCMenuAdapter);
    }

    _createClass(MDCMenuAdapter, [{
      key: "addClassToElementAtIndex",

      /**
       * Adds a class to the element at the index provided.
       * @param {number} index
       * @param {string} className
       */
      value: function addClassToElementAtIndex(index, className) {}
      /**
       * Removes a class from the element at the index provided
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "removeClassFromElementAtIndex",
      value: function removeClassFromElementAtIndex(index, className) {}
      /**
       * Adds an attribute, with value, to the element at the index provided.
       * @param {number} index
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "addAttributeToElementAtIndex",
      value: function addAttributeToElementAtIndex(index, attr, value) {}
      /**
       * Removes an attribute from an element at the index provided.
       * @param {number} index
       * @param {string} attr
       */

    }, {
      key: "removeAttributeFromElementAtIndex",
      value: function removeAttributeFromElementAtIndex(index, attr) {}
      /**
       * Returns true if the element contains the className.
       * @param {?HTMLElement} element
       * @param {string} className
       * @return {boolean} true if the element contains the className
       */

    }, {
      key: "elementContainsClass",
      value: function elementContainsClass(element, className) {}
      /**
       * Closes the menu-surface.
       */

    }, {
      key: "closeSurface",
      value: function closeSurface() {}
      /**
       * Returns the index for the element provided.
       * @param {?HTMLElement} element
       * @return {number} index of the element in the list or -1 if it is not in the list.
       */

    }, {
      key: "getElementIndex",
      value: function getElementIndex(element) {}
      /**
       * Returns the parentElement of the provided element.
       * @param {?HTMLElement} element
       * @return {?HTMLElement} parentElement of the element provided.
       */

    }, {
      key: "getParentElement",
      value: function getParentElement(element) {}
      /**
       * Returns the element within the selectionGroup containing the selected element class.
       * @param {!HTMLElement} selectionGroup
       * @return {number} element within the selectionGroup that contains the selected element class.
       */

    }, {
      key: "getSelectedElementIndex",
      value: function getSelectedElementIndex(selectionGroup) {}
      /**
       * Emits an event using the evtData.
       * @param {{
      *    index: number
      *   }} evtData
       */

    }, {
      key: "notifySelected",
      value: function notifySelected(evtData) {}
    }]);

    return MDCMenuAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$4 = {
    ROOT: 'mdc-menu',
    MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
    MENU_SELECTION_GROUP: 'mdc-menu__selection-group'
  };
  /** @enum {string} */

  var strings$2 = {
    SELECTED_EVENT: 'MDCMenu:selected',
    ARIA_SELECTED_ATTR: 'aria-selected',
    LIST_SELECTOR: '.mdc-list',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]'
  };

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDCMenuSurface. Provides an interface for managing
   * - classes
   * - dom
   * - focus
   * - position
   * - dimensions
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuSurfaceAdapter =
  /*#__PURE__*/
  function () {
    function MDCMenuSurfaceAdapter() {
      _classCallCheck(this, MDCMenuSurfaceAdapter);
    }

    _createClass(MDCMenuSurfaceAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /** @return {boolean} */

    }, {
      key: "hasAnchor",
      value: function hasAnchor() {}
      /** Emits an event when the menu surface is closed. */

    }, {
      key: "notifyClose",
      value: function notifyClose() {}
      /** Emits an event when the menu surface is opened. */

    }, {
      key: "notifyOpen",
      value: function notifyOpen() {}
      /**
       * @return {boolean}
       * @param {EventTarget} el
       */

    }, {
      key: "isElementInContainer",
      value: function isElementInContainer(el) {}
      /** @return {boolean} */

    }, {
      key: "isRtl",
      value: function isRtl() {}
      /** @param {string} origin */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(origin) {}
      /** @return {boolean} */

    }, {
      key: "isFocused",
      value: function isFocused() {}
      /** Saves the element that was focused before the menu surface was opened. */

    }, {
      key: "saveFocus",
      value: function saveFocus() {}
      /** Restores focus to the element that was focused before the menu surface was opened. */

    }, {
      key: "restoreFocus",
      value: function restoreFocus() {}
      /** @return {boolean} */

    }, {
      key: "isFirstElementFocused",
      value: function isFirstElementFocused() {}
      /** @return {boolean} */

    }, {
      key: "isLastElementFocused",
      value: function isLastElementFocused() {}
      /** Focuses the first focusable element in the menu-surface. */

    }, {
      key: "focusFirstElement",
      value: function focusFirstElement() {}
      /** Focuses the first focusable element in the menu-surface. */

    }, {
      key: "focusLastElement",
      value: function focusLastElement() {}
      /** @return {!{width: number, height: number}} */

    }, {
      key: "getInnerDimensions",
      value: function getInnerDimensions() {}
      /** @return {!{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

    }, {
      key: "getAnchorDimensions",
      value: function getAnchorDimensions() {}
      /** @return {!{ width: number, height: number }} */

    }, {
      key: "getWindowDimensions",
      value: function getWindowDimensions() {}
      /** @return {!{ width: number, height: number }} */

    }, {
      key: "getBodyDimensions",
      value: function getBodyDimensions() {}
      /** @return {!{ width: number, height: number }} */

    }, {
      key: "getWindowScroll",
      value: function getWindowScroll() {}
      /** @param {!{
      *   top: (string|undefined),
      *   right: (string|undefined),
      *   bottom: (string|undefined),
      *   left: (string|undefined)
      * }} position */

    }, {
      key: "setPosition",
      value: function setPosition(position) {}
      /** @param {string} height */

    }, {
      key: "setMaxHeight",
      value: function setMaxHeight(height) {}
    }]);

    return MDCMenuSurfaceAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$5 = {
    ANCHOR: 'mdc-menu-surface--anchor',
    ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
    ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
    FIXED: 'mdc-menu-surface--fixed',
    OPEN: 'mdc-menu-surface--open',
    ROOT: 'mdc-menu-surface'
  };
  /** @enum {string} */

  var strings$3 = {
    CLOSED_EVENT: 'MDCMenuSurface:closed',
    OPENED_EVENT: 'MDCMenuSurface:opened',
    FOCUSABLE_ELEMENTS: 'button:not(:disabled), [href]:not([aria-disabled="true"]), input:not(:disabled), ' + 'select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
  };
  /** @enum {number} */

  var numbers$1 = {
    // Total duration of menu-surface open animation.
    TRANSITION_OPEN_DURATION: 120,
    // Total duration of menu-surface close animation.
    TRANSITION_CLOSE_DURATION: 75,
    // Margin left to the edge of the viewport when menu-surface is at maximum possible height.
    MARGIN_TO_EDGE: 32,
    // Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning.
    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
  };
  /**
   * Enum for bits in the {@see Corner) bitmap.
   * @enum {number}
   */

  var CornerBit = {
    BOTTOM: 1,
    CENTER: 2,
    RIGHT: 4,
    FLIP_RTL: 8
  };
  /**
   * Enum for representing an element corner for positioning the menu-surface.
   *
   * The START constants map to LEFT if element directionality is left
   * to right and RIGHT if the directionality is right to left.
   * Likewise END maps to RIGHT or LEFT depending on the directionality.
   *
   * @enum {number}
   */

  var Corner = {
    TOP_LEFT: 0,
    TOP_RIGHT: CornerBit.RIGHT,
    BOTTOM_LEFT: CornerBit.BOTTOM,
    BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
    TOP_START: CornerBit.FLIP_RTL,
    TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
    BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
    BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
  };

  /**
   * @extends {MDCFoundation<!MDCMenuSurfaceAdapter>}
   */

  var MDCMenuSurfaceFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCMenuSurfaceFoundation, _MDCFoundation);

    _createClass(MDCMenuSurfaceFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        return cssClasses$5;
      }
      /** @return enum{string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$3;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$1;
      }
      /** @return enum{number} */

    }, {
      key: "Corner",
      get: function get() {
        return Corner;
      }
      /**
       * {@see MDCMenuSurfaceAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuSurfaceAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCMenuSurfaceAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {
              return false;
            },
            hasAnchor: function hasAnchor() {
              return false;
            },
            notifyClose: function notifyClose() {},
            notifyOpen: function notifyOpen() {},
            isElementInContainer: function isElementInContainer() {
              return false;
            },
            isRtl: function isRtl() {
              return false;
            },
            setTransformOrigin: function setTransformOrigin() {},
            isFocused: function isFocused() {
              return false;
            },
            saveFocus: function saveFocus() {},
            restoreFocus: function restoreFocus() {},
            isFirstElementFocused: function isFirstElementFocused() {},
            isLastElementFocused: function isLastElementFocused() {},
            focusFirstElement: function focusFirstElement() {},
            focusLastElement: function focusLastElement() {},
            getInnerDimensions: function getInnerDimensions() {
              return {};
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return {};
            },
            getWindowDimensions: function getWindowDimensions() {
              return {};
            },
            getBodyDimensions: function getBodyDimensions() {
              return {};
            },
            getWindowScroll: function getWindowScroll() {
              return {};
            },
            setPosition: function setPosition() {},
            setMaxHeight: function setMaxHeight() {}
          }
        );
      }
      /** @param {!MDCMenuSurfaceAdapter} adapter */

    }]);

    function MDCMenuSurfaceFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCMenuSurfaceFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCMenuSurfaceFoundation).call(this, Object.assign(MDCMenuSurfaceFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.isOpen_ = false;
      /** @private {number} */

      _this.openAnimationEndTimerId_ = 0;
      /** @private {number} */

      _this.closeAnimationEndTimerId_ = 0;
      /** @private {number} */

      _this.animationRequestId_ = 0;
      /** @private {!{ width: number, height: number }} */

      _this.dimensions_;
      /** @private {!Corner} */

      _this.anchorCorner_ = Corner.TOP_START;
      /** @private {!AnchorMargin} */

      _this.anchorMargin_ = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      /** @private {?AutoLayoutMeasurements} */

      _this.measures_ = null;
      /** @private {boolean} */

      _this.quickOpen_ = false;
      /** @private {boolean} */

      _this.hoistedElement_ = false;
      /** @private {boolean} */

      _this.isFixedPosition_ = false;
      /** @private {!{x: number, y: number}} */

      _this.position_ = {
        x: 0,
        y: 0
      };
      return _this;
    }

    _createClass(MDCMenuSurfaceFoundation, [{
      key: "init",
      value: function init() {
        var _MDCMenuSurfaceFounda = MDCMenuSurfaceFoundation.cssClasses,
            ROOT = _MDCMenuSurfaceFounda.ROOT,
            OPEN = _MDCMenuSurfaceFounda.OPEN;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error("".concat(ROOT, " class required in root element."));
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.

        cancelAnimationFrame(this.animationRequestId_);
      }
      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left menu surface corner.
       */

    }, {
      key: "setAnchorCorner",
      value: function setAnchorCorner(corner) {
        this.anchorCorner_ = corner;
      }
      /**
       * @param {!AnchorMargin} margin set of margin values from anchor.
       */

    }, {
      key: "setAnchorMargin",
      value: function setAnchorMargin(margin) {
        this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
        this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
        this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
        this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
      }
      /**
       * Used to indicate if the menu-surface is hoisted to the body.
       * @param {boolean} isHoisted
       */

    }, {
      key: "setIsHoisted",
      value: function setIsHoisted(isHoisted) {
        this.hoistedElement_ = isHoisted;
      }
      /**
       * Used to set the menu-surface calculations based on a fixed position menu.
       * @param {boolean} isFixedPosition
       */

    }, {
      key: "setFixedPosition",
      value: function setFixedPosition(isFixedPosition) {
        this.isFixedPosition_ = isFixedPosition;
      }
      /**
       * Sets the menu-surface position on the page.
       * @param {number} x
       * @param {number} y
       */

    }, {
      key: "setAbsolutePosition",
      value: function setAbsolutePosition(x, y) {
        this.position_.x = this.typeCheckisFinite_(x) ? x : 0;
        this.position_.y = this.typeCheckisFinite_(y) ? y : 0;
      }
      /** @param {boolean} quickOpen */

    }, {
      key: "setQuickOpen",
      value: function setQuickOpen(quickOpen) {
        this.quickOpen_ = quickOpen;
      }
      /**
       * Handle clicks and close if not within menu-surface element.
       * @param {!Event} evt
       */

    }, {
      key: "handleBodyClick",
      value: function handleBodyClick(evt) {
        var el = evt.target;

        if (this.adapter_.isElementInContainer(el)) {
          return;
        }

        this.close();
      }
    }, {
      key: "handleKeydown",

      /**
       * Handle keys that close the surface.
       * @param {!Event} evt
       */
      value: function handleKeydown(evt) {
        var keyCode = evt.keyCode,
            key = evt.key,
            shiftKey = evt.shiftKey;
        var isEscape = key === 'Escape' || keyCode === 27;
        var isTab = key === 'Tab' || keyCode === 9;

        if (isEscape) {
          this.close();
        } else if (isTab) {
          if (this.adapter_.isLastElementFocused() && !shiftKey) {
            this.adapter_.focusFirstElement();
            evt.preventDefault();
          } else if (this.adapter_.isFirstElementFocused() && shiftKey) {
            this.adapter_.focusLastElement();
            evt.preventDefault();
          }
        }
      }
      /**
       * @return {!AutoLayoutMeasurements} Measurements used to position menu surface popup.
       */

    }, {
      key: "getAutoLayoutMeasurements_",
      value: function getAutoLayoutMeasurements_() {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var viewport = this.adapter_.getWindowDimensions();
        var bodyDimensions = this.adapter_.getBodyDimensions();
        var windowScroll = this.adapter_.getWindowScroll();

        if (!anchorRect) {
          anchorRect =
          /** @type {ClientRect} */
          {
            x: this.position_.x,
            y: this.position_.y,
            top: this.position_.y,
            bottom: this.position_.y,
            left: this.position_.x,
            right: this.position_.x,
            height: 0,
            width: 0
          };
        }

        return {
          viewport: viewport,
          bodyDimensions: bodyDimensions,
          windowScroll: windowScroll,
          viewportDistance: {
            top: anchorRect.top,
            right: viewport.width - anchorRect.right,
            left: anchorRect.left,
            bottom: viewport.height - anchorRect.bottom
          },
          anchorHeight: anchorRect.height,
          anchorWidth: anchorRect.width,
          surfaceHeight: this.dimensions_.height,
          surfaceWidth: this.dimensions_.width
        };
      }
      /**
       * Computes the corner of the anchor from which to animate and position the menu surface.
       * @return {!Corner}
       * @private
       */

    }, {
      key: "getOriginCorner_",
      value: function getOriginCorner_() {
        // Defaults: open from the top left.
        var corner = Corner.TOP_LEFT;
        var _this$measures_ = this.measures_,
            viewportDistance = _this$measures_.viewportDistance,
            anchorHeight = _this$measures_.anchorHeight,
            anchorWidth = _this$measures_.anchorWidth,
            surfaceHeight = _this$measures_.surfaceHeight,
            surfaceWidth = _this$measures_.surfaceWidth;
        var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;
        var topOverflow = surfaceHeight - availableTop;
        var bottomOverflow = surfaceHeight - availableBottom;

        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
          corner |= CornerBit.BOTTOM;
        }

        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
        var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;
        var leftOverflow = surfaceWidth - availableLeft;
        var rightOverflow = surfaceWidth - availableRight;

        if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
          corner |= CornerBit.RIGHT;
        }

        return (
          /** @type {Corner} */
          corner
        );
      }
      /**
       * @param {!Corner} corner Origin corner of the menu surface.
       * @return {number} Horizontal offset of menu surface origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: "getHorizontalOriginOffset_",
      value: function getHorizontalOriginOffset_(corner) {
        var anchorWidth = this.measures_.anchorWidth; // isRightAligned corresponds to using the 'right' property on the surface.

        var isRightAligned = Boolean(corner & CornerBit.RIGHT);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);

        if (isRightAligned) {
          var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right; // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
          // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
          // the right property is correct.

          if (this.hoistedElement_ || this.isFixedPosition_) {
            return rightOffset - (this.measures_.viewport.width - this.measures_.bodyDimensions.width);
          }

          return rightOffset;
        }

        return avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
      }
      /**
       * @param {!Corner} corner Origin corner of the menu surface.
       * @return {number} Vertical offset of menu surface origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: "getVerticalOriginOffset_",
      value: function getVerticalOriginOffset_(corner) {
        var anchorHeight = this.measures_.anchorHeight;
        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var y = 0;

        if (isBottomAligned) {
          y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
        } else {
          y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
        }

        return y;
      }
      /**
       * @param {!Corner} corner Origin corner of the menu surface.
       * @return {number} Maximum height of the menu surface, based on available space. 0 indicates should not be set.
       * @private
       */

    }, {
      key: "getMenuSurfaceMaxHeight_",
      value: function getMenuSurfaceMaxHeight_(corner) {
        var maxHeight = 0;
        var viewportDistance = this.measures_.viewportDistance;
        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE; // When maximum height is not specified, it is handled from css.

        if (isBottomAligned) {
          maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;

          if (!(this.anchorCorner_ & CornerBit.BOTTOM)) {
            maxHeight += this.measures_.anchorHeight;
          }
        } else {
          maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measures_.anchorHeight - MARGIN_TO_EDGE;

          if (this.anchorCorner_ & CornerBit.BOTTOM) {
            maxHeight -= this.measures_.anchorHeight;
          }
        }

        return maxHeight;
      }
      /** @private */

    }, {
      key: "autoPosition_",
      value: function autoPosition_() {
        var _position;

        // Compute measurements for autoposition methods reuse.
        this.measures_ = this.getAutoLayoutMeasurements_();
        var corner = this.getOriginCorner_();
        var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
        var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
        var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var position = (_position = {}, _defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset : '0'), _defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset : '0'), _position);
        var _this$measures_2 = this.measures_,
            anchorWidth = _this$measures_2.anchorWidth,
            surfaceWidth = _this$measures_2.surfaceWidth; // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.

        if (anchorWidth / surfaceWidth > numbers$1.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
          horizontalAlignment = 'center';
        } // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element


        if (this.hoistedElement_ || this.isFixedPosition_) {
          position = this.adjustPositionForHoistedElement_(position);
        }

        for (var prop in position) {
          if (position.hasOwnProperty(prop) && position[prop] !== '0') {
            position[prop] = "".concat(parseInt(position[prop], 10), "px");
          }
        }

        this.adapter_.setTransformOrigin("".concat(horizontalAlignment, " ").concat(verticalAlignment));
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : ''); // Clear measures after positioning is complete.

        this.measures_ = null;
      }
      /**
       * Calculates the offsets for positioning the menu-surface when the menu-surface has been
       * hoisted to the body.
       * @param {!{
       *   top: (string|undefined),
       *   right: (string|undefined),
       *   bottom: (string|undefined),
       *   left: (string|undefined)
       * }} position
       * @return {!{
       *   top: (string|undefined),
       *   right: (string|undefined),
       *   bottom: (string|undefined),
       *   left: (string|undefined)
       * }} position
       * @private
       */

    }, {
      key: "adjustPositionForHoistedElement_",
      value: function adjustPositionForHoistedElement_(position) {
        var _this$measures_3 = this.measures_,
            windowScroll = _this$measures_3.windowScroll,
            viewportDistance = _this$measures_3.viewportDistance;

        for (var prop in position) {
          if (position.hasOwnProperty(prop)) {
            // Hoisted surfaces need to have the anchor elements location on the page added to the
            // position properties for proper alignment on the body.
            if (viewportDistance.hasOwnProperty(prop)) {
              position[prop] = parseInt(position[prop], 10) + viewportDistance[prop];
            } // Surfaces that are absolutely positioned need to have additional calculations for scroll
            // and bottom positioning.


            if (!this.isFixedPosition_) {
              if (prop === 'top') {
                position[prop] = parseInt(position[prop], 10) + windowScroll.y;
              } else if (prop === 'bottom') {
                position[prop] = parseInt(position[prop], 10) - windowScroll.y;
              } else if (prop === 'left') {
                position[prop] = parseInt(position[prop], 10) + windowScroll.x;
              } else if (prop === 'right') {
                position[prop] = parseInt(position[prop], 10) - windowScroll.x;
              }
            }
          }
        }

        return position;
      }
      /**
       * Open the menu surface.
       */

    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        this.adapter_.saveFocus();

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
        }

        this.animationRequestId_ = requestAnimationFrame(function () {
          _this2.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

          _this2.dimensions_ = _this2.adapter_.getInnerDimensions();

          _this2.autoPosition_();

          if (_this2.quickOpen_) {
            _this2.adapter_.notifyOpen();
          } else {
            _this2.openAnimationEndTimerId_ = setTimeout(function () {
              _this2.openAnimationEndTimerId_ = 0;

              _this2.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);

              _this2.adapter_.notifyOpen();
            }, numbers$1.TRANSITION_OPEN_DURATION);
          }
        });
        this.isOpen_ = true;
      }
      /**
       * Closes the menu surface.
       */

    }, {
      key: "close",
      value: function close() {
        var _this3 = this;

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
        }

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

          if (_this3.quickOpen_) {
            _this3.adapter_.notifyClose();
          } else {
            _this3.closeAnimationEndTimerId_ = setTimeout(function () {
              _this3.closeAnimationEndTimerId_ = 0;

              _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);

              _this3.adapter_.notifyClose();
            }, numbers$1.TRANSITION_CLOSE_DURATION);
          }
        });
        this.isOpen_ = false;
        this.maybeRestoreFocus_();
      }
      /**
       * The last focused element when the menu surface was opened should regain focus, if the user is
       * focused on or within the menu surface when it is closed.
       * @private
       */

    }, {
      key: "maybeRestoreFocus_",
      value: function maybeRestoreFocus_() {
        if (this.adapter_.isFocused() || this.adapter_.isElementInContainer(document.activeElement)) {
          this.adapter_.restoreFocus();
        }
      }
      /** @return {boolean} */

    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.isOpen_;
      }
      /**
       * isFinite that doesn't force conversion to number type.
       * Equivalent to Number.isFinite in ES2015, but is not included in IE11.
       * @param {number} num
       * @return {boolean}
       * @private
       */

    }, {
      key: "typeCheckisFinite_",
      value: function typeCheckisFinite_(num) {
        return typeof num === 'number' && isFinite(num);
      }
    }]);

    return MDCMenuSurfaceFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC List. Provides an interface for managing focus.
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCListAdapter =
  /*#__PURE__*/
  function () {
    function MDCListAdapter() {
      _classCallCheck(this, MDCListAdapter);
    }

    _createClass(MDCListAdapter, [{
      key: "getListItemCount",

      /** @return {number} */
      value: function getListItemCount() {}
      /**
       * @return {number} */

    }, {
      key: "getFocusedElementIndex",
      value: function getFocusedElementIndex() {}
      /**
       * @param {number} index
       * @param {string} attribute
       * @param {string} value
       */

    }, {
      key: "setAttributeForElementIndex",
      value: function setAttributeForElementIndex(index, attribute, value) {}
      /**
       * @param {number} index
       * @param {string} attribute
       */

    }, {
      key: "removeAttributeForElementIndex",
      value: function removeAttributeForElementIndex(index, attribute) {}
      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "addClassForElementIndex",
      value: function addClassForElementIndex(index, className) {}
      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "removeClassForElementIndex",
      value: function removeClassForElementIndex(index, className) {}
      /**
       * Focuses list item at the index specified.
       * @param {number} index
       */

    }, {
      key: "focusItemAtIndex",
      value: function focusItemAtIndex(index) {}
      /**
       * Sets the tabindex to the value specified for all button/a element children of
       * the list item at the index specified.
       * @param {number} listItemIndex
       * @param {number} tabIndexValue
       */

    }, {
      key: "setTabIndexForListItemChildren",
      value: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {}
      /**
       * @param {number} index
       * @return {boolean} Returns true if radio button is present at given list item index.
       */

    }, {
      key: "hasRadioAtIndex",
      value: function hasRadioAtIndex(index) {}
      /**
       * @param {number} index
       * @return {boolean} Returns true if checkbox is present at given list item index.
       */

    }, {
      key: "hasCheckboxAtIndex",
      value: function hasCheckboxAtIndex(index) {}
      /**
       * @param {number} index
       * @return {boolean} Returns true if checkbox inside a list item is checked.
       */

    }, {
      key: "isCheckboxCheckedAtIndex",
      value: function isCheckboxCheckedAtIndex(index) {}
      /**
       * Sets the checked status of checkbox or radio at given list item index.
       * @param {number} index
       * @param {boolean} isChecked
       */

    }, {
      key: "setCheckedCheckboxOrRadioAtIndex",
      value: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {}
      /**
       * Notifies user action on list item.
       */

    }, {
      key: "notifyAction",
      value: function notifyAction(index) {}
      /**
       * @return {boolean} Returns true when the current focused element is inside list root.
       */

    }, {
      key: "isFocusInsideList",
      value: function isFocusInsideList() {}
    }]);

    return MDCListAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$6 = {
    ROOT: 'mdc-list',
    LIST_ITEM_CLASS: 'mdc-list-item',
    LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
    LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated'
  };
  /** @enum {string} */

  var strings$4 = {
    ARIA_ORIENTATION: 'aria-orientation',
    ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
    ARIA_SELECTED: 'aria-selected',
    ARIA_CHECKED: 'aria-checked',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: ".".concat(cssClasses$6.LIST_ITEM_CLASS, " button:not(:disabled),\n  .").concat(cssClasses$6.LIST_ITEM_CLASS, " a"),
    FOCUSABLE_CHILD_ELEMENTS: ".".concat(cssClasses$6.LIST_ITEM_CLASS, " button:not(:disabled), .").concat(cssClasses$6.LIST_ITEM_CLASS, " a,\n  .").concat(cssClasses$6.LIST_ITEM_CLASS, " input[type=\"radio\"]:not(:disabled),\n  .").concat(cssClasses$6.LIST_ITEM_CLASS, " input[type=\"checkbox\"]:not(:disabled)"),
    ENABLED_ITEMS_SELECTOR: '.mdc-list-item:not(.mdc-list-item--disabled)',
    ACTION_EVENT: 'MDCList:action'
  };

  var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];

  var MDCListFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCListFoundation, _MDCFoundation);

    _createClass(MDCListFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$4;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$6;
      }
      /**
       * {@see MDCListAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCListAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCListAdapter} */
          {
            getListItemCount: function getListItemCount() {},
            getFocusedElementIndex: function getFocusedElementIndex() {},
            setAttributeForElementIndex: function setAttributeForElementIndex() {},
            removeAttributeForElementIndex: function removeAttributeForElementIndex() {},
            addClassForElementIndex: function addClassForElementIndex() {},
            removeClassForElementIndex: function removeClassForElementIndex() {},
            focusItemAtIndex: function focusItemAtIndex() {},
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {},
            hasRadioAtIndex: function hasRadioAtIndex() {},
            hasCheckboxAtIndex: function hasCheckboxAtIndex() {},
            isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {},
            setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {},
            notifyAction: function notifyAction() {},
            isFocusInsideList: function isFocusInsideList() {}
          }
        );
      }
      /**
       * @param {!MDCListAdapter=} adapter
       */

    }]);

    function MDCListFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCListFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCListFoundation).call(this, Object.assign(MDCListFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.wrapFocus_ = false;
      /** @private {boolean} */

      _this.isVertical_ = true;
      /** @private {boolean} */

      _this.isSingleSelectionList_ = false;
      /** @private {!Index} */

      _this.selectedIndex_ = -1;
      /** @private {number} */

      _this.focusedItemIndex_ = -1;
      /** @private {boolean} */

      _this.useActivatedClass_ = false;
      /** @private {boolean} */

      _this.isCheckboxList_ = false;
      /** @private {boolean} */

      _this.isRadioList_ = false;
      return _this;
    }

    _createClass(MDCListFoundation, [{
      key: "layout",
      value: function layout() {
        if (this.adapter_.getListItemCount() === 0) return;

        if (this.adapter_.hasCheckboxAtIndex(0)) {
          this.isCheckboxList_ = true;
        } else if (this.adapter_.hasRadioAtIndex(0)) {
          this.isRadioList_ = true;
        }
      }
      /**
       * Sets the private wrapFocus_ variable.
       * @param {boolean} value
       */

    }, {
      key: "setWrapFocus",
      value: function setWrapFocus(value) {
        this.wrapFocus_ = value;
      }
      /**
       * Sets the isVertical_ private variable.
       * @param {boolean} value
       */

    }, {
      key: "setVerticalOrientation",
      value: function setVerticalOrientation(value) {
        this.isVertical_ = value;
      }
      /**
       * Sets the isSingleSelectionList_ private variable.
       * @param {boolean} value
       */

    }, {
      key: "setSingleSelection",
      value: function setSingleSelection(value) {
        this.isSingleSelectionList_ = value;
      }
      /**
       * Sets the useActivatedClass_ private variable.
       * @param {boolean} useActivated
       */

    }, {
      key: "setUseActivatedClass",
      value: function setUseActivatedClass(useActivated) {
        this.useActivatedClass_ = useActivated;
      }
      /** @return {!Index} */

    }, {
      key: "getSelectedIndex",
      value: function getSelectedIndex() {
        return this.selectedIndex_;
      }
      /** @param {!Index} index */

    }, {
      key: "setSelectedIndex",
      value: function setSelectedIndex(index) {
        if (!this.isIndexValid_(index)) return;

        if (this.isCheckboxList_) {
          this.setCheckboxAtIndex_(
          /** @type {!Array<number>} */
          index);
        } else if (this.isRadioList_) {
          this.setRadioAtIndex_(
          /** @type {number} */
          index);
        } else {
          this.setSingleSelectionAtIndex_(
          /** @type {number} */
          index);
        }
      }
      /**
       * Focus in handler for the list items.
       * @param evt
       * @param {number} listItemIndex
       */

    }, {
      key: "handleFocusIn",
      value: function handleFocusIn(evt, listItemIndex) {
        if (listItemIndex >= 0) {
          this.adapter_.setTabIndexForListItemChildren(listItemIndex, 0);
        }
      }
      /**
       * Focus out handler for the list items.
       * @param {Event} evt
       * @param {number} listItemIndex
       */

    }, {
      key: "handleFocusOut",
      value: function handleFocusOut(evt, listItemIndex) {
        var _this2 = this;

        if (listItemIndex >= 0) {
          this.adapter_.setTabIndexForListItemChildren(listItemIndex, -1);
        }
        /**
         * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
         * is moved to next element.
         */


        setTimeout(function () {
          if (!_this2.adapter_.isFocusInsideList()) {
            _this2.setTabindexToFirstSelectedItem_();
          }
        }, 0);
      }
      /**
       * Key handler for the list.
       * @param {Event} evt
       * @param {boolean} isRootListItem
       * @param {number} listItemIndex
       */

    }, {
      key: "handleKeydown",
      value: function handleKeydown(evt, isRootListItem, listItemIndex) {
        var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
        var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
        var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
        var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
        var isHome = evt.key === 'Home' || evt.keyCode === 36;
        var isEnd = evt.key === 'End' || evt.keyCode === 35;
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
        var isSpace = evt.key === 'Space' || evt.keyCode === 32;
        var currentIndex = this.adapter_.getFocusedElementIndex();
        var nextIndex = -1;

        if (currentIndex === -1) {
          currentIndex = listItemIndex;

          if (currentIndex < 0) {
            // If this event doesn't have a mdc-list-item ancestor from the
            // current list (not from a sublist), return early.
            return;
          }
        }

        if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusNextElement(currentIndex);
        } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusPrevElement(currentIndex);
        } else if (isHome) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusFirstElement();
        } else if (isEnd) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusLastElement();
        } else if (isEnter || isSpace) {
          if (isRootListItem) {
            // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
            if (evt.target.tagName === 'A' && isEnter) return;
            this.preventDefaultEvent_(evt);

            if (this.isSelectableList_()) {
              this.setSelectedIndexOnAction_(currentIndex);
            }

            this.adapter_.notifyAction(currentIndex);
          }
        }

        this.focusedItemIndex_ = currentIndex;

        if (nextIndex >= 0) {
          this.setTabindexAtIndex_(nextIndex);
          this.focusedItemIndex_ = nextIndex;
        }
      }
      /**
       * Click handler for the list.
       * @param {number} index
       * @param {boolean} toggleCheckbox
       */

    }, {
      key: "handleClick",
      value: function handleClick(index, toggleCheckbox) {
        if (index === -1) return;

        if (this.isSelectableList_()) {
          this.setSelectedIndexOnAction_(index, toggleCheckbox);
        }

        this.adapter_.notifyAction(index);
        this.setTabindexAtIndex_(index);
        this.focusedItemIndex_ = index;
      }
      /**
       * Ensures that preventDefault is only called if the containing element doesn't
       * consume the event, and it will cause an unintended scroll.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "preventDefaultEvent_",
      value: function preventDefaultEvent_(evt) {
        var tagName = "".concat(evt.target.tagName).toLowerCase();

        if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
          evt.preventDefault();
        }
      }
      /**
       * Focuses the next element on the list.
       * @param {number} index
       * @return {number}
       */

    }, {
      key: "focusNextElement",
      value: function focusNextElement(index) {
        var count = this.adapter_.getListItemCount();
        var nextIndex = index + 1;

        if (nextIndex >= count) {
          if (this.wrapFocus_) {
            nextIndex = 0;
          } else {
            // Return early because last item is already focused.
            return index;
          }
        }

        this.adapter_.focusItemAtIndex(nextIndex);
        return nextIndex;
      }
      /**
       * Focuses the previous element on the list.
       * @param {number} index
       * @return {number}
       */

    }, {
      key: "focusPrevElement",
      value: function focusPrevElement(index) {
        var prevIndex = index - 1;

        if (prevIndex < 0) {
          if (this.wrapFocus_) {
            prevIndex = this.adapter_.getListItemCount() - 1;
          } else {
            // Return early because first item is already focused.
            return index;
          }
        }

        this.adapter_.focusItemAtIndex(prevIndex);
        return prevIndex;
      }
      /**
       * @return {number}
       */

    }, {
      key: "focusFirstElement",
      value: function focusFirstElement() {
        this.adapter_.focusItemAtIndex(0);
        return 0;
      }
      /**
       * @return {number}
       */

    }, {
      key: "focusLastElement",
      value: function focusLastElement() {
        var lastIndex = this.adapter_.getListItemCount() - 1;
        this.adapter_.focusItemAtIndex(lastIndex);
        return lastIndex;
      }
      /**
       * @param {number} index
       * @private
       */

    }, {
      key: "setSingleSelectionAtIndex_",
      value: function setSingleSelectionAtIndex_(index) {
        var selectedClassName = cssClasses$6.LIST_ITEM_SELECTED_CLASS;

        if (this.useActivatedClass_) {
          selectedClassName = cssClasses$6.LIST_ITEM_ACTIVATED_CLASS;
        }

        if (this.selectedIndex_ >= 0 && this.selectedIndex_ !== index) {
          this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
          this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$4.ARIA_SELECTED, 'false');
        }

        this.adapter_.addClassForElementIndex(index, selectedClassName);
        this.adapter_.setAttributeForElementIndex(index, strings$4.ARIA_SELECTED, 'true');
        this.selectedIndex_ = index;
      }
      /**
       * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
       * @param {number} index
       * @private
       */

    }, {
      key: "setRadioAtIndex_",
      value: function setRadioAtIndex_(index) {
        this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);

        if (this.selectedIndex_ >= 0) {
          this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$4.ARIA_CHECKED, 'false');
        }

        this.adapter_.setAttributeForElementIndex(index, strings$4.ARIA_CHECKED, 'true');
        this.selectedIndex_ = index;
      }
      /**
       * @param {!Array<number>} index
       * @private
       */

    }, {
      key: "setCheckboxAtIndex_",
      value: function setCheckboxAtIndex_(index) {
        for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
          var isChecked = false;

          if (index.indexOf(i) >= 0) {
            isChecked = true;
          }

          this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
          this.adapter_.setAttributeForElementIndex(i, strings$4.ARIA_CHECKED, isChecked ? 'true' : 'false');
        }

        this.selectedIndex_ = index;
      }
      /**
       * @param {number} index
       * @private
       */

    }, {
      key: "setTabindexAtIndex_",
      value: function setTabindexAtIndex_(index) {
        if (this.focusedItemIndex_ === -1 && index !== 0) {
          // If no list item was selected set first list item's tabindex to -1.
          // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
          this.adapter_.setAttributeForElementIndex(0, 'tabindex', -1);
        } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
          this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', -1);
        }

        this.adapter_.setAttributeForElementIndex(index, 'tabindex', 0);
      }
      /**
       * @return {boolean} Return true if it is single selectin list, checkbox list or radio list.
       * @private
       */

    }, {
      key: "isSelectableList_",
      value: function isSelectableList_() {
        return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
      }
      /** @private */

    }, {
      key: "setTabindexToFirstSelectedItem_",
      value: function setTabindexToFirstSelectedItem_() {
        var targetIndex = 0;

        if (this.isSelectableList_()) {
          if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== -1) {
            targetIndex = this.selectedIndex_;
          } else if (this.selectedIndex_ instanceof Array && this.selectedIndex_.length > 0) {
            targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
              return Math.min(currentIndex, minIndex);
            });
          }
        }

        this.setTabindexAtIndex_(targetIndex);
      }
      /**
       * @param {!Index} index
       * @return {boolean}
       * @private
       */

    }, {
      key: "isIndexValid_",
      value: function isIndexValid_(index) {
        var _this3 = this;

        if (index instanceof Array) {
          if (!this.isCheckboxList_) {
            throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
          }

          if (index.length === 0) {
            return true;
          } else {
            return index.some(function (i) {
              return _this3.isIndexInRange_(i);
            });
          }
        } else if (typeof index === 'number') {
          if (this.isCheckboxList_) {
            throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
          }

          return this.isIndexInRange_(index);
        } else {
          return false;
        }
      }
      /**
       * @param {number} index
       * @return {boolean}
       * @private
       */

    }, {
      key: "isIndexInRange_",
      value: function isIndexInRange_(index) {
        var listSize = this.adapter_.getListItemCount();
        return index >= 0 && index < listSize;
      }
      /**
       * @param {number} index
       * @param {boolean=} toggleCheckbox
       * @private
       */

    }, {
      key: "setSelectedIndexOnAction_",
      value: function setSelectedIndexOnAction_(index) {
        var toggleCheckbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (this.isCheckboxList_) {
          this.toggleCheckboxAtIndex_(index, toggleCheckbox);
        } else {
          this.setSelectedIndex(index);
        }
      }
      /**
       * @param {number} index
       * @param {boolean} toggleCheckbox
       * @private
       */

    }, {
      key: "toggleCheckboxAtIndex_",
      value: function toggleCheckboxAtIndex_(index, toggleCheckbox) {
        var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);

        if (toggleCheckbox) {
          isChecked = !isChecked;
          this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
        }

        this.adapter_.setAttributeForElementIndex(index, strings$4.ARIA_CHECKED, isChecked ? 'true' : 'false'); // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.

        if (this.selectedIndex_ === -1) {
          this.selectedIndex_ = [];
        }

        if (isChecked) {
          this.selectedIndex_.push(index);
        } else {
          this.selectedIndex_ = this.selectedIndex_.filter(function (i) {
            return i !== index;
          });
        }
      }
    }]);

    return MDCListFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCFoundation<!MDCMenuAdapter>}
   */

  var MDCMenuFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCMenuFoundation, _MDCFoundation);

    _createClass(MDCMenuFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        return cssClasses$4;
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        return strings$2;
      }
      /**
       * {@see MDCMenuAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCMenuAdapter} */
          {
            addClassToElementAtIndex: function addClassToElementAtIndex() {},
            removeClassFromElementAtIndex: function removeClassFromElementAtIndex() {},
            addAttributeToElementAtIndex: function addAttributeToElementAtIndex() {},
            removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex() {},
            elementContainsClass: function elementContainsClass() {},
            closeSurface: function closeSurface() {},
            getElementIndex: function getElementIndex() {},
            getParentElement: function getParentElement() {},
            getSelectedElementIndex: function getSelectedElementIndex() {},
            notifySelected: function notifySelected() {}
          }
        );
      }
      /** @param {!MDCMenuAdapter} adapter */

    }]);

    function MDCMenuFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCMenuFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCMenuFoundation).call(this, Object.assign(MDCMenuFoundation.defaultAdapter, adapter)));
      /** @type {number} */

      _this.closeAnimationEndTimerId_ = 0;
      return _this;
    }

    _createClass(MDCMenuFoundation, [{
      key: "destroy",
      value: function destroy() {
        if (this.closeAnimationEndTimerId_) {
          clearTimeout(this.closeAnimationEndTimerId_);
        }

        this.adapter_.closeSurface();
      }
      /**
       * Handler function for the keydown events.
       * @param {!Event} evt
       */

    }, {
      key: "handleKeydown",
      value: function handleKeydown(evt) {
        var key = evt.key,
            keyCode = evt.keyCode;
        var isTab = key === 'Tab' || keyCode === 9;

        if (isTab) {
          this.adapter_.closeSurface();
        }
      }
      /**
       * @param {!HTMLElement} listItem
       */

    }, {
      key: "handleItemAction",
      value: function handleItemAction(listItem) {
        var _this2 = this;

        var index = this.adapter_.getElementIndex(listItem);

        if (index < 0) {
          return;
        }

        this.adapter_.notifySelected({
          index: index
        });
        this.adapter_.closeSurface(); // Wait for the menu to close before adding/removing classes that affect styles.

        this.closeAnimationEndTimerId_ = setTimeout(function () {
          var selectionGroup = _this2.getSelectionGroup_(listItem);

          if (selectionGroup !== null) {
            _this2.handleSelectionGroup_(
            /** @type {!HTMLElement} */
            selectionGroup, index);
          }
        }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
      }
      /**
       * Handles toggling the selected classes in a selection group when a
       * selection is made.
       * @param {!HTMLElement} selectionGroup
       * @param {number} index The selected index value
       * @private
       */

    }, {
      key: "handleSelectionGroup_",
      value: function handleSelectionGroup_(selectionGroup, index) {
        // De-select the previous selection in this group.
        var selectedIndex = this.adapter_.getSelectedElementIndex(selectionGroup);

        if (selectedIndex >= 0) {
          this.adapter_.removeAttributeFromElementAtIndex(selectedIndex, strings$2.ARIA_SELECTED_ATTR);
          this.adapter_.removeClassFromElementAtIndex(selectedIndex, cssClasses$4.MENU_SELECTED_LIST_ITEM);
        } // Select the new list item in this group.


        this.adapter_.addClassToElementAtIndex(index, cssClasses$4.MENU_SELECTED_LIST_ITEM);
        this.adapter_.addAttributeToElementAtIndex(index, strings$2.ARIA_SELECTED_ATTR, 'true');
      }
      /**
       * Returns the parent selection group of an element if one exists.
       * @param listItem
       * @return {?HTMLElement} parent selection group element or null.
       * @private
       */

    }, {
      key: "getSelectionGroup_",
      value: function getSelectionGroup_(listItem) {
        var parent = this.adapter_.getParentElement(listItem);
        var isGroup = this.adapter_.elementContainsClass(parent, cssClasses$4.MENU_SELECTION_GROUP); // Iterate through ancestors until we find the group or get to the list.

        while (!isGroup && !this.adapter_.elementContainsClass(parent, MDCListFoundation.cssClasses.ROOT)) {
          parent = this.adapter_.getParentElement(parent);
          isGroup = this.adapter_.elementContainsClass(parent, cssClasses$4.MENU_SELECTION_GROUP);
        }

        if (isGroup) {
          return parent;
        } else {
          return null;
        }
      }
      /**
       * Find the first ancestor with the mdc-list-item class.
       * @param {?HTMLElement} target
       * @return {?HTMLElement}
       * @private
       */

    }, {
      key: "getListItem_",
      value: function getListItem_(target) {
        var isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation.cssClasses.LIST_ITEM_CLASS);

        while (!isListItem) {
          target = this.adapter_.getParentElement(target);

          if (target) {
            isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation.cssClasses.LIST_ITEM_CLASS);
          } else {
            // target has no parent element.
            return null;
          }
        }

        return target;
      }
    }]);

    return MDCMenuFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @type {string|undefined} */
  var storedTransformPropertyName_;
  /**
   * Returns the name of the correct transform property to use on the current browser.
   * @param {!Window} globalObj
   * @param {boolean=} forceRefresh
   * @return {string}
   */

  function getTransformPropertyName(globalObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  }

  /**
   * @extends MDCComponent<!MDCMenuSurfaceFoundation>
   */

  var MDCMenuSurface =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCMenuSurface, _MDCComponent);

    /** @param {...?} args */
    function MDCMenuSurface() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCMenuSurface);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCMenuSurface)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @private {!Element} */

      _this.previousFocus_;
      /** @private {!Element} */

      _this.anchorElement;
      /** @private {Element} */

      _this.firstFocusableElement_;
      /** @private {Element} */

      _this.lastFocusableElement_;
      /** @private {!Function} */

      _this.handleKeydown_;
      /** @private {!Function} */

      _this.handleBodyClick_;
      /** @private {!Function} */

      _this.registerBodyClickListener_;
      /** @private {!Function} */

      _this.deregisterBodyClickListener_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @return {!MDCMenuSurface}
     */


    _createClass(MDCMenuSurface, [{
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        var _this2 = this;

        if (this.root_.parentElement && this.root_.parentElement.classList.contains(cssClasses$5.ANCHOR)) {
          this.anchorElement = this.root_.parentElement;
        }

        if (this.root_.classList.contains(cssClasses$5.FIXED)) {
          this.setFixedPosition(true);
        }

        this.handleKeydown_ = function (evt) {
          return _this2.foundation_.handleKeydown(evt);
        };

        this.handleBodyClick_ = function (evt) {
          return _this2.foundation_.handleBodyClick(evt);
        };

        this.registerBodyClickListener_ = function () {
          return document.body.addEventListener('click', _this2.handleBodyClick_);
        };

        this.deregisterBodyClickListener_ = function () {
          return document.body.removeEventListener('click', _this2.handleBodyClick_);
        };

        this.root_.addEventListener('keydown', this.handleKeydown_);
        this.root_.addEventListener(strings$3.OPENED_EVENT, this.registerBodyClickListener_);
        this.root_.addEventListener(strings$3.CLOSED_EVENT, this.deregisterBodyClickListener_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.root_.removeEventListener('keydown', this.handleKeydown_);
        this.root_.removeEventListener(strings$3.OPENED_EVENT, this.registerBodyClickListener_);
        this.root_.removeEventListener(strings$3.CLOSED_EVENT, this.deregisterBodyClickListener_);

        _get(_getPrototypeOf(MDCMenuSurface.prototype), "destroy", this).call(this);
      }
      /** @return {boolean} */

    }, {
      key: "hoistMenuToBody",

      /**
       * Removes the menu-surface from it's current location and appends it to the
       * body to overcome any overflow:hidden issues.
       */
      value: function hoistMenuToBody() {
        document.body.appendChild(this.root_.parentElement.removeChild(this.root_));
        this.setIsHoisted(true);
      }
      /**
       * Sets the foundation to use page offsets for an positioning when the menu
       * is hoisted to the body.
       * @param {boolean} isHoisted
       */

    }, {
      key: "setIsHoisted",
      value: function setIsHoisted(isHoisted) {
        this.foundation_.setIsHoisted(isHoisted);
      }
      /**
       * Sets the element that the menu-surface is anchored to.
       * @param {!Element} element
       */

    }, {
      key: "setMenuSurfaceAnchorElement",
      value: function setMenuSurfaceAnchorElement(element) {
        this.anchorElement = element;
      }
      /**
       * Sets the menu-surface to position: fixed.
       * @param {boolean} isFixed
       */

    }, {
      key: "setFixedPosition",
      value: function setFixedPosition(isFixed) {
        if (isFixed) {
          this.root_.classList.add(cssClasses$5.FIXED);
        } else {
          this.root_.classList.remove(cssClasses$5.FIXED);
        }

        this.foundation_.setFixedPosition(isFixed);
      }
      /**
       * Sets the absolute x/y position to position based on. Requires the menu to be hoisted.
       * @param {number} x
       * @param {number} y
       */

    }, {
      key: "setAbsolutePosition",
      value: function setAbsolutePosition(x, y) {
        this.foundation_.setAbsolutePosition(x, y);
        this.setIsHoisted(true);
      }
      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left
       *     surface corner.
       */

    }, {
      key: "setAnchorCorner",
      value: function setAnchorCorner(corner) {
        this.foundation_.setAnchorCorner(corner);
      }
      /**
       * @param {!AnchorMargin} margin
       */

    }, {
      key: "setAnchorMargin",
      value: function setAnchorMargin(margin) {
        this.foundation_.setAnchorMargin(margin);
      }
      /** @param {boolean} quickOpen */

    }, {
      key: "getDefaultFoundation",

      /** @return {!MDCMenuSurfaceFoundation} */
      value: function getDefaultFoundation() {
        var _this3 = this;

        return new MDCMenuSurfaceFoundation(
        /** @type {!MDCMenuSurfaceAdapter} */
        Object.assign({
          addClass: function addClass(className) {
            return _this3.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this3.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this3.root_.classList.contains(className);
          },
          hasAnchor: function hasAnchor() {
            return !!_this3.anchorElement;
          },
          notifyClose: function notifyClose() {
            return _this3.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});
          },
          notifyOpen: function notifyOpen() {
            return _this3.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});
          },
          isElementInContainer: function isElementInContainer(el) {
            return _this3.root_ === el || _this3.root_.contains(el);
          },
          isRtl: function isRtl() {
            return getComputedStyle(_this3.root_).getPropertyValue('direction') === 'rtl';
          },
          setTransformOrigin: function setTransformOrigin(origin) {
            _this3.root_.style["".concat(getTransformPropertyName(window), "-origin")] = origin;
          }
        }, this.getFocusAdapterMethods_(), this.getDimensionAdapterMethods_()));
      }
      /**
       * @return {!{
       * isFocused: function(): boolean,
       * saveFocus: function(),
       * restoreFocus: function(),
       * isFirstElementFocused: function(): boolean,
       * isLastElementFocused: function(): boolean,
       * focusFirstElement: function(),
       * focusLastElement: function(),
       * }}
       * @private
       */

    }, {
      key: "getFocusAdapterMethods_",
      value: function getFocusAdapterMethods_() {
        var _this4 = this;

        return {
          isFocused: function isFocused() {
            return document.activeElement === _this4.root_;
          },
          saveFocus: function saveFocus() {
            _this4.previousFocus_ = document.activeElement;
          },
          restoreFocus: function restoreFocus() {
            if (_this4.root_.contains(document.activeElement)) {
              if (_this4.previousFocus_ && _this4.previousFocus_.focus) {
                _this4.previousFocus_.focus();
              }
            }
          },
          isFirstElementFocused: function isFirstElementFocused() {
            return _this4.firstFocusableElement_ && _this4.firstFocusableElement_ === document.activeElement;
          },
          isLastElementFocused: function isLastElementFocused() {
            return _this4.lastFocusableElement_ && _this4.lastFocusableElement_ === document.activeElement;
          },
          focusFirstElement: function focusFirstElement() {
            return _this4.firstFocusableElement_ && _this4.firstFocusableElement_.focus && _this4.firstFocusableElement_.focus();
          },
          focusLastElement: function focusLastElement() {
            return _this4.lastFocusableElement_ && _this4.lastFocusableElement_.focus && _this4.lastFocusableElement_.focus();
          }
        };
      }
      /**
       * @return {!{
       * getInnerDimensions: function(),
       * getAnchorDimensions: function(): (HTMLElement | null | * | ClientRect),
       * getWindowDimensions: function(),
       * setPosition: function(*),
       * setMaxHeight: function(string)}}
       * @private
       */

    }, {
      key: "getDimensionAdapterMethods_",
      value: function getDimensionAdapterMethods_() {
        var _this5 = this;

        return {
          getInnerDimensions: function getInnerDimensions() {
            return {
              width: _this5.root_.offsetWidth,
              height: _this5.root_.offsetHeight
            };
          },
          getAnchorDimensions: function getAnchorDimensions() {
            return _this5.anchorElement && _this5.anchorElement.getBoundingClientRect();
          },
          getWindowDimensions: function getWindowDimensions() {
            return {
              width: window.innerWidth,
              height: window.innerHeight
            };
          },
          getBodyDimensions: function getBodyDimensions() {
            return {
              width: document.body.clientWidth,
              height: document.body.clientHeight
            };
          },
          getWindowScroll: function getWindowScroll() {
            return {
              x: window.pageXOffset,
              y: window.pageYOffset
            };
          },
          setPosition: function setPosition(position) {
            _this5.root_.style.left = 'left' in position ? position.left : null;
            _this5.root_.style.right = 'right' in position ? position.right : null;
            _this5.root_.style.top = 'top' in position ? position.top : null;
            _this5.root_.style.bottom = 'bottom' in position ? position.bottom : null;
          },
          setMaxHeight: function setMaxHeight(height) {
            _this5.root_.style.maxHeight = height;
          }
        };
      }
    }, {
      key: "open",
      get: function get() {
        return this.foundation_.isOpen();
      }
      /** @param {boolean} value */
      ,
      set: function set(value) {
        if (value) {
          var focusableElements = this.root_.querySelectorAll(strings$3.FOCUSABLE_ELEMENTS);
          this.firstFocusableElement_ = focusableElements.length > 0 ? focusableElements[0] : null;
          this.lastFocusableElement_ = focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
          this.foundation_.open();
        } else {
          this.foundation_.close();
        }
      }
    }, {
      key: "quickOpen",
      set: function set(quickOpen) {
        this.foundation_.setQuickOpen(quickOpen);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCMenuSurface(root);
      }
    }]);

    return MDCMenuSurface;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /**
   * @param {!Element} element
   * @param {string} selector
   * @return {boolean}
   */


  function matches(element, selector) {
    var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
    return nativeMatches.call(element, selector);
  }

  /**
   * @extends MDCComponent<!MDCListFoundation>
   */

  var MDCList =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCList, _MDCComponent);

    /** @param {...?} args */
    function MDCList() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCList)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @private {!Function} */

      _this.handleKeydown_;
      /** @private {!Function} */

      _this.handleClick_;
      /** @private {!Function} */

      _this.focusInEventListener_;
      /** @private {!Function} */

      _this.focusOutEventListener_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @return {!MDCList}
     */


    _createClass(MDCList, [{
      key: "destroy",
      value: function destroy() {
        this.root_.removeEventListener('keydown', this.handleKeydown_);
        this.root_.removeEventListener('click', this.handleClick_);
        this.root_.removeEventListener('focusin', this.focusInEventListener_);
        this.root_.removeEventListener('focusout', this.focusOutEventListener_);
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        this.handleClick_ = this.handleClickEvent_.bind(this);
        this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
        this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
        this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
        this.root_.addEventListener('keydown', this.handleKeydown_);
        this.root_.addEventListener('focusin', this.focusInEventListener_);
        this.root_.addEventListener('focusout', this.focusOutEventListener_);
        this.root_.addEventListener('click', this.handleClick_);
        this.layout();
        this.initializeListType();
      }
    }, {
      key: "layout",
      value: function layout() {
        var direction = this.root_.getAttribute(strings$4.ARIA_ORIENTATION);
        this.vertical = direction !== strings$4.ARIA_ORIENTATION_HORIZONTAL; // List items need to have at least tabindex=-1 to be focusable.

        [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
          ele.setAttribute('tabindex', -1);
        }); // Child button/a elements are not tabbable until the list item is focused.

        [].slice.call(this.root_.querySelectorAll(strings$4.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
          return ele.setAttribute('tabindex', -1);
        });
        this.foundation_.layout();
      }
      /**
       * Used to figure out which list item this event is targetting. Or returns -1 if
       * there is no list item
       * @param {Event} evt
       * @private
       */

    }, {
      key: "getListItemIndex_",
      value: function getListItemIndex_(evt) {
        var eventTarget =
        /** @type {HTMLElement} */
        evt.target;
        var index = -1; // Find the first ancestor that is a list item or the list.

        while (!eventTarget.classList.contains(cssClasses$6.LIST_ITEM_CLASS) && !eventTarget.classList.contains(cssClasses$6.ROOT)) {
          eventTarget = eventTarget.parentElement;
        } // Get the index of the element if it is a list item.


        if (eventTarget.classList.contains(cssClasses$6.LIST_ITEM_CLASS)) {
          index = this.listElements.indexOf(eventTarget);
        }

        return index;
      }
      /**
       * Used to figure out which element was clicked before sending the event to the foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleFocusInEvent_",
      value: function handleFocusInEvent_(evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusIn(evt, index);
      }
      /**
       * Used to figure out which element was clicked before sending the event to the foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleFocusOutEvent_",
      value: function handleFocusOutEvent_(evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusOut(evt, index);
      }
      /**
       * Used to figure out which element was focused when keydown event occurred before sending the event to the
       * foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleKeydownEvent_",
      value: function handleKeydownEvent_(evt) {
        var index = this.getListItemIndex_(evt);

        if (index >= 0) {
          this.foundation_.handleKeydown(evt, evt.target.classList.contains(cssClasses$6.LIST_ITEM_CLASS), index);
        }
      }
      /**
       * Used to figure out which element was clicked before sending the event to the foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleClickEvent_",
      value: function handleClickEvent_(evt) {
        var index = this.getListItemIndex_(evt); // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.

        var toggleCheckbox = !matches(
        /** @type {!Element} */
        evt.target, strings$4.CHECKBOX_RADIO_SELECTOR);
        this.foundation_.handleClick(index, toggleCheckbox);
      }
      /**
       * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
       */

    }, {
      key: "initializeListType",
      value: function initializeListType() {
        var _this2 = this;

        var checkboxListItems = this.root_.querySelectorAll(strings$4.ARIA_ROLE_CHECKBOX_SELECTOR);
        var singleSelectedListItem = this.root_.querySelector(".".concat(cssClasses$6.LIST_ITEM_ACTIVATED_CLASS, ",\n        .").concat(cssClasses$6.LIST_ITEM_SELECTED_CLASS));
        var radioSelectedListItem = this.root_.querySelector(strings$4.ARIA_CHECKED_RADIO_SELECTOR);

        if (checkboxListItems.length) {
          var preselectedItems = this.root_.querySelectorAll(strings$4.ARIA_CHECKED_CHECKBOX_SELECTOR);
          this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
            return _this2.listElements.indexOf(listItem);
          });
        } else if (singleSelectedListItem) {
          if (singleSelectedListItem.classList.contains(cssClasses$6.LIST_ITEM_ACTIVATED_CLASS)) {
            this.foundation_.setUseActivatedClass(true);
          }

          this.singleSelection = true;
          this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
        } else if (radioSelectedListItem) {
          this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
        }
      }
      /** @param {boolean} value */

    }, {
      key: "getDefaultFoundation",

      /** @return {!MDCListFoundation} */
      value: function getDefaultFoundation() {
        var _this3 = this;

        return new MDCListFoundation(
        /** @type {!MDCListAdapter} */
        Object.assign({
          getListItemCount: function getListItemCount() {
            return _this3.listElements.length;
          },
          getFocusedElementIndex: function getFocusedElementIndex() {
            return _this3.listElements.indexOf(document.activeElement);
          },
          setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
            var element = _this3.listElements[index];

            if (element) {
              element.setAttribute(attr, value);
            }
          },
          removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
            var element = _this3.listElements[index];

            if (element) {
              element.removeAttribute(attr);
            }
          },
          addClassForElementIndex: function addClassForElementIndex(index, className) {
            var element = _this3.listElements[index];

            if (element) {
              element.classList.add(className);
            }
          },
          removeClassForElementIndex: function removeClassForElementIndex(index, className) {
            var element = _this3.listElements[index];

            if (element) {
              element.classList.remove(className);
            }
          },
          focusItemAtIndex: function focusItemAtIndex(index) {
            var element = _this3.listElements[index];

            if (element) {
              element.focus();
            }
          },
          setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
            var element = _this3.listElements[listItemIndex];
            var listItemChildren = [].slice.call(element.querySelectorAll(strings$4.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
            listItemChildren.forEach(function (ele) {
              return ele.setAttribute('tabindex', tabIndexValue);
            });
          },
          hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
            var listItem = _this3.listElements[index];
            return !!listItem.querySelector(strings$4.CHECKBOX_SELECTOR);
          },
          hasRadioAtIndex: function hasRadioAtIndex(index) {
            var listItem = _this3.listElements[index];
            return !!listItem.querySelector(strings$4.RADIO_SELECTOR);
          },
          isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
            var listItem = _this3.listElements[index];
            var toggleEl = listItem.querySelector(strings$4.CHECKBOX_SELECTOR);
            return toggleEl.checked;
          },
          setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
            var listItem = _this3.listElements[index];
            var toggleEl = listItem.querySelector(strings$4.CHECKBOX_RADIO_SELECTOR);
            toggleEl.checked = isChecked;
            var event = document.createEvent('Event');
            event.initEvent('change', true, true);
            toggleEl.dispatchEvent(event);
          },
          notifyAction: function notifyAction(index) {
            _this3.emit(strings$4.ACTION_EVENT, index,
            /** shouldBubble */
            true);
          },
          isFocusInsideList: function isFocusInsideList() {
            return _this3.root_.contains(document.activeElement);
          }
        }));
      }
    }, {
      key: "vertical",
      set: function set(value) {
        this.foundation_.setVerticalOrientation(value);
      }
      /** @return Array<!Element>*/

    }, {
      key: "listElements",
      get: function get() {
        return [].slice.call(this.root_.querySelectorAll(strings$4.ENABLED_ITEMS_SELECTOR));
      }
      /** @param {boolean} value */

    }, {
      key: "wrapFocus",
      set: function set(value) {
        this.foundation_.setWrapFocus(value);
      }
      /** @param {boolean} isSingleSelectionList */

    }, {
      key: "singleSelection",
      set: function set(isSingleSelectionList) {
        this.foundation_.setSingleSelection(isSingleSelectionList);
      }
      /** @return {!Index} */

    }, {
      key: "selectedIndex",
      get: function get() {
        return this.foundation_.getSelectedIndex();
      }
      /** @param {!Index} index */
      ,
      set: function set(index) {
        this.foundation_.setSelectedIndex(index);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCList(root);
      }
    }]);

    return MDCList;
  }(MDCComponent);

  /**
   * @extends MDCComponent<!MDCMenuFoundation>
   */

  var MDCMenu =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCMenu, _MDCComponent);

    /** @param {...?} args */
    function MDCMenu() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCMenu);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCMenu)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @private {!MDCMenuSurface} */

      _this.menuSurface_;
      /** @private {!MDCList} */

      _this.list_;
      /** @private {!Function} */

      _this.handleKeydown_;
      /** @private {!Function} */

      _this.handleItemAction_;
      /** @private {!Function} */

      _this.afterOpenedCallback_;
      return _this;
    }
    /**
     * @param {!HTMLElement} root
     * @return {!MDCMenu}
     */


    _createClass(MDCMenu, [{
      key: "initialize",
      value: function initialize() {
        var menuSurfaceFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
          return new MDCMenuSurface(el);
        };
        var listFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
          return new MDCList(el);
        };
        this.menuSurface_ = menuSurfaceFactory(this.root_);
        var list = this.root_.querySelector(strings$2.LIST_SELECTOR);

        if (list) {
          this.list_ = listFactory(list);
          this.list_.wrapFocus = true;
        }
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        var _this2 = this;

        this.afterOpenedCallback_ = function () {
          return _this2.handleAfterOpened_();
        };

        this.handleKeydown_ = function (evt) {
          return _this2.foundation_.handleKeydown(evt);
        };

        this.handleItemAction_ = function (evt) {
          return _this2.foundation_.handleItemAction(_this2.items[evt.detail]);
        };

        this.menuSurface_.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.afterOpenedCallback_);
        this.listen('keydown', this.handleKeydown_);
        this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.list_) {
          this.list_.destroy();
        }

        this.menuSurface_.destroy();
        this.menuSurface_.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.afterOpenedCallback_);
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);

        _get(_getPrototypeOf(MDCMenu.prototype), "destroy", this).call(this);
      }
      /** @return {boolean} */

    }, {
      key: "setAnchorCorner",

      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left
       *     menu corner.
       */
      value: function setAnchorCorner(corner) {
        this.menuSurface_.setAnchorCorner(corner);
      }
      /**
       * @param {!AnchorMargin} margin
       */

    }, {
      key: "setAnchorMargin",
      value: function setAnchorMargin(margin) {
        this.menuSurface_.setAnchorMargin(margin);
      }
      /**
       * Return the items within the menu. Note that this only contains the set of elements within
       * the items container that are proper list items, and not supplemental / presentational DOM
       * elements.
       * @return {!Array<!HTMLElement>}
       */

    }, {
      key: "getOptionByIndex",

      /**
       * Return the item within the menu at the index specified.
       * @param {number} index
       * @return {?HTMLElement}
       */
      value: function getOptionByIndex(index) {
        var items = this.items;

        if (index < items.length) {
          return this.items[index];
        } else {
          return null;
        }
      }
      /** @param {boolean} quickOpen */

    }, {
      key: "setFixedPosition",

      /** @param {boolean} isFixed */
      value: function setFixedPosition(isFixed) {
        this.menuSurface_.setFixedPosition(isFixed);
      }
    }, {
      key: "hoistMenuToBody",
      value: function hoistMenuToBody() {
        this.menuSurface_.hoistMenuToBody();
      }
      /** @param {boolean} isHoisted */

    }, {
      key: "setIsHoisted",
      value: function setIsHoisted(isHoisted) {
        this.menuSurface_.setIsHoisted(isHoisted);
      }
      /**
       * @param {number} x
       * @param {number} y
       */

    }, {
      key: "setAbsolutePosition",
      value: function setAbsolutePosition(x, y) {
        this.menuSurface_.setAbsolutePosition(x, y);
      }
      /**
       * Sets the element that the menu-surface is anchored to.
       * @param {!HTMLElement} element
       */

    }, {
      key: "setAnchorElement",
      value: function setAnchorElement(element) {
        this.menuSurface_.anchorElement = element;
      }
    }, {
      key: "handleAfterOpened_",
      value: function handleAfterOpened_() {
        var list = this.items;

        if (list.length > 0) {
          list[0].focus();
        }
      }
      /** @return {!MDCMenuFoundation} */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this3 = this;

        return new MDCMenuFoundation({
          addClassToElementAtIndex: function addClassToElementAtIndex(index, className) {
            var list = _this3.items;
            list[index].classList.add(className);
          },
          removeClassFromElementAtIndex: function removeClassFromElementAtIndex(index, className) {
            var list = _this3.items;
            list[index].classList.remove(className);
          },
          addAttributeToElementAtIndex: function addAttributeToElementAtIndex(index, attr, value) {
            var list = _this3.items;
            list[index].setAttribute(attr, value);
          },
          removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex(index, attr) {
            var list = _this3.items;
            list[index].removeAttribute(attr);
          },
          elementContainsClass: function elementContainsClass(element, className) {
            return element.classList.contains(className);
          },
          closeSurface: function closeSurface() {
            return _this3.open = false;
          },
          getElementIndex: function getElementIndex(element) {
            return _this3.items.indexOf(element);
          },
          getParentElement: function getParentElement(element) {
            return element.parentElement;
          },
          getSelectedElementIndex: function getSelectedElementIndex(selectionGroup) {
            return _this3.items.indexOf(selectionGroup.querySelector(".".concat(cssClasses$4.MENU_SELECTED_LIST_ITEM)));
          },
          notifySelected: function notifySelected(evtData) {
            return _this3.emit(strings$2.SELECTED_EVENT, {
              index: evtData.index,
              item: _this3.items[evtData.index]
            });
          }
        });
      }
    }, {
      key: "open",
      get: function get() {
        return this.menuSurface_.open;
      }
      /** @param {boolean} value */
      ,
      set: function set(value) {
        this.menuSurface_.open = value;
      }
      /** @return {boolean} */

    }, {
      key: "wrapFocus",
      get: function get() {
        return this.list_.wrapFocus;
      }
      /** @param {boolean} value */
      ,
      set: function set(value) {
        this.list_.wrapFocus = value;
      }
    }, {
      key: "items",
      get: function get() {
        return this.list_.listElements;
      }
    }, {
      key: "quickOpen",
      set: function set(quickOpen) {
        this.menuSurface_.quickOpen = quickOpen;
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCMenu(root);
      }
    }]);

    return MDCMenu;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter =
  /*#__PURE__*/
  function () {
    function MDCRippleAdapter() {
      _classCallCheck(this, MDCRippleAdapter);
    }

    _createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}
      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}
      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}
      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}
      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}
      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);

    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$7 = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };
  var strings$5 = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };
  var numbers$2 = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225,
    // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150,
    // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_;
  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */

  var supportsPassive_;
  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */

  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }
  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */


  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var supportsCssVariables = supportsCssVariables_;

    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari

    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }

    return supportsCssVariables;
  } //

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|!EventListenerOptions}
   */


  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;

      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = true;
            return isSupported;
          }

        });
      } catch (e) {}

      supportsPassive_ = isSupported;
    }

    return supportsPassive_ ?
    /** @type {!EventListenerOptions} */
    {
      passive: true
    } : false;
  }
  /**
   * @param {!Object} HTMLElementPrototype
   * @return {string}
   */


  function getMatchesProperty(HTMLElementPrototype) {
    /**
     * Order is important because we return the first existing method we find.
     * Do not change the order of the items in the below array.
     */
    var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
    var method = 'matches';

    for (var i = 0; i < matchesMethods.length; i++) {
      var matchesMethod = matchesMethods[i];

      if (matchesMethod in HTMLElementPrototype) {
        method = matchesMethod;
        break;
      }
    }

    return method;
  }
  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */


  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY; // Determine touch point relative to the ripple container.

    if (ev.type === 'touchstart') {
      ev =
      /** @type {!TouchEvent} */
      ev;
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      ev =
      /** @type {!MouseEvent} */
      ev;
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return {
      x: normalizedX,
      y: normalizedY
    };
  }

  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

  /** @type {!Array<!EventTarget>} */

  var activatedTargets = [];
  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCRippleFoundation, _MDCFoundation);

    _createClass(MDCRippleFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$7;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$5;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers$2;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars()
          /* boolean - cached */
          {},
          isUnbounded: function isUnbounded()
          /* boolean */
          {},
          isSurfaceActive: function isSurfaceActive()
          /* boolean */
          {},
          isSurfaceDisabled: function isSurfaceDisabled()
          /* boolean */
          {},
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          containsEventTarget: function containsEventTarget()
          /* target: !EventTarget */
          {},
          registerInteractionHandler: function registerInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerResizeHandler: function registerResizeHandler()
          /* handler: EventListener */
          {},
          deregisterResizeHandler: function deregisterResizeHandler()
          /* handler: EventListener */
          {},
          updateCssVariable: function updateCssVariable()
          /* varName: string, value: string */
          {},
          computeBoundingRect: function computeBoundingRect()
          /* ClientRect */
          {},
          getWindowPageOffset: function getWindowPageOffset()
          /* {x: number, y: number} */
          {}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCRippleFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
      /** @private {number} */

      _this.layoutFrame_ = 0;
      /** @private {!ClientRect} */

      _this.frame_ =
      /** @type {!ClientRect} */
      {
        width: 0,
        height: 0
      };
      /** @private {!ActivationStateType} */

      _this.activationState_ = _this.defaultActivationState_();
      /** @private {number} */

      _this.initialSize_ = 0;
      /** @private {number} */

      _this.maxRadius_ = 0;
      /** @private {function(!Event)} */

      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };
      /** @private {function(!Event=)} */


      _this.deactivateHandler_ = function () {
        return _this.deactivate_();
      };
      /** @private {function(!Event=)} */


      _this.focusHandler_ = function () {
        return _this.handleFocus();
      };
      /** @private {function(!Event=)} */


      _this.blurHandler_ = function () {
        return _this.handleBlur();
      };
      /** @private {!Function} */


      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      /** @private {{left: number, top:number}} */


      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };
      /** @private {number} */

      _this.fgScale_ = 0;
      /** @private {number} */

      _this.activationTimer_ = 0;
      /** @private {number} */

      _this.fgDeactivationRemovalTimer_ = 0;
      /** @private {boolean} */

      _this.activationAnimationHasEnded_ = false;
      /** @private {!Function} */

      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;

        _this.runDeactivationUXLogicIfReady_();
      };
      /** @private {!Event|undefined} */


      _this.previousActivationEvent_;
      return _this;
    }
    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    _createClass(MDCRippleFoundation, [{
      key: "supportsPressRipple_",
      value: function supportsPressRipple_() {
        return this.adapter_.browserSupportsCssVars();
      }
      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: "defaultActivationState_",
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: undefined,
          isProgrammatic: false
        };
      }
      /** @override */

    }, {
      key: "init",
      value: function init() {
        var _this2 = this;

        var supportsPressRipple = this.supportsPressRipple_();
        this.registerRootHandlers_(supportsPressRipple);

        if (supportsPressRipple) {
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
      }
      /** @override */

    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        if (this.supportsPressRipple_()) {
          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
          }

          if (this.fgDeactivationRemovalTimer_) {
            clearTimeout(this.fgDeactivationRemovalTimer_);
            this.fgDeactivationRemovalTimer_ = 0;
            this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
          }

          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();
      }
      /**
       * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
       * @private
       */

    }, {
      key: "registerRootHandlers_",
      value: function registerRootHandlers_(supportsPressRipple) {
        var _this4 = this;

        if (supportsPressRipple) {
          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }

        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      }
      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: "registerDeactivationHandlers_",
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }
      /** @private */

    }, {
      key: "deregisterRootHandlers_",
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }
      /** @private */

    }, {
      key: "deregisterDeactivationHandlers_",
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }
      /** @private */

    }, {
      key: "removeCssVars_",
      value: function removeCssVars_() {
        var _this8 = this;

        var strings = MDCRippleFoundation.strings;
        Object.keys(strings).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings[k], null);
          }
        });
      }
      /**
       * @param {!Event=} e
       * @private
       */

    }, {
      key: "activate_",
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;

        if (activationState.isActivated) {
          return;
        } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === undefined;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
        var hasActivatedChild = e !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });

        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e !== undefined) {
          activatedTargets.push(
          /** @type {!EventTarget} */
          e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];

          if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }
      /**
       * @param {!Event=} e
       * @private
       */

    }, {
      key: "checkElementMadeActive_",
      value: function checkElementMadeActive_(e) {
        return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }
      /**
       * @param {!Event=} event Optional event containing position information.
       */

    }, {
      key: "activate",
      value: function activate(event) {
        this.activate_(event);
      }
      /** @private */

    }, {
      key: "animateActivation_",
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
        this.layoutInternal_();
        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
              startPoint = _this$getFgTranslatio.startPoint,
              endPoint = _this$getFgTranslatio.endPoint;

          translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
          translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }
      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: "getFgTranslationCoordinates_",
      value: function getFgTranslationCoordinates_() {
        var _this$activationState = this.activationState_,
            activationEvent = _this$activationState.activationEvent,
            wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
        var startPoint;

        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */
          activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        } // Center the element around the start point.


        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };
        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };
        return {
          startPoint: startPoint,
          endPoint: endPoint
        };
      }
      /** @private */

    }, {
      key: "runDeactivationUXLogicIfReady_",
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _this$activationState2 = this.activationState_,
            hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
            isActivated = _this$activationState2.isActivated;
        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers$2.FG_DEACTIVATION_MS);
        }
      }
      /** @private */

    }, {
      key: "rmBoundedActivationClasses_",
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: "resetActivationState_",
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.

        setTimeout(function () {
          return _this12.previousActivationEvent_ = undefined;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }
      /**
       * @private
       */

    }, {
      key: "deactivate_",
      value: function deactivate_() {
        var _this13 = this;

        var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

        if (!activationState.isActivated) {
          return;
        }

        var state =
        /** @type {!ActivationStateType} */
        Object.assign({}, activationState);

        if (activationState.isProgrammatic) {
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;

            _this13.animateDeactivation_(state);

            _this13.resetActivationState_();
          });
        }
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.deactivate_();
      }
      /**
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: "animateDeactivation_",
      value: function animateDeactivation_(_ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();

          _this14.layoutFrame_ = 0;
        });
      }
      /** @private */

    }, {
      key: "layoutInternal_",
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.

        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

        this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
        this.fgScale_ = this.maxRadius_ / this.initialSize_;
        this.updateLayoutCssVars_();
      }
      /** @private */

    }, {
      key: "updateLayoutCssVars_",
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
        this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };
          this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
          this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
        }
      }
      /** @param {boolean} unbounded */

    }, {
      key: "setUnbounded",
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }, {
      key: "handleFocus",
      value: function handleFocus() {
        var _this16 = this;

        requestAnimationFrame(function () {
          return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }, {
      key: "handleBlur",
      value: function handleBlur() {
        var _this17 = this;

        requestAnimationFrame(function () {
          return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }]);

    return MDCRippleFoundation;
  }(MDCFoundation);

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @type {boolean} */

      _this.disabled = false;
      /** @private {boolean} */

      _this.unbounded_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    _createClass(MDCRipple, [{
      key: "setUnbounded_",

      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: "activate",
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
      /**
       * @return {!MDCRippleFoundation}
       * @override
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
      }
      /** @override */

    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: "unbounded",

      /** @return {boolean} */
      get: function get() {
        return this.unbounded_;
      }
      /** @param {boolean} unbounded */
      ,
      set: function set(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$isUnbounded = _ref.isUnbounded,
            isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

        var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

        if (isUnbounded !== undefined) {
          ripple.unbounded =
          /** @type {boolean} */
          isUnbounded;
        }

        return ripple;
      }
      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: "createAdapter",
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty(HTMLElement.prototype);
        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return {
              x: window.pageXOffset,
              y: window.pageYOffset
            };
          }
        };
      }
    }]);

    return MDCRipple;
  }(MDCComponent);
  /**
   * See Material Design spec for more details on when to use ripples.
   * https://material.io/guidelines/motion/choreography.html#choreography-creation
   * @record
   */


  var RippleCapableSurface = function RippleCapableSurface() {
    _classCallCheck(this, RippleCapableSurface);
  };
  /** @protected {!Element} */


  RippleCapableSurface.prototype.root_;
  /**
   * Whether or not the ripple bleeds out of the bounds of the element.
   * @type {boolean|undefined}
   */

  RippleCapableSurface.prototype.unbounded;
  /**
   * Whether or not the ripple is attached to a disabled component.
   * @type {boolean|undefined}
   */

  RippleCapableSurface.prototype.disabled;

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Notched Outline.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Notched Outline into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCNotchedOutlineAdapter =
  /*#__PURE__*/
  function () {
    function MDCNotchedOutlineAdapter() {
      _classCallCheck(this, MDCNotchedOutlineAdapter);
    }

    _createClass(MDCNotchedOutlineAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Sets the width style property of the notch element.
       * @param {number} width
       */

    }, {
      key: "setNotchWidthProperty",
      value: function setNotchWidthProperty(width) {}
      /**
       * Removes the width style property from the notch element.
       */

    }, {
      key: "removeNotchWidthProperty",
      value: function removeNotchWidthProperty() {}
    }]);

    return MDCNotchedOutlineAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$6 = {
    NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch'
  };
  /** @enum {number} */

  var numbers$3 = {
    // This should stay in sync with $mdc-notched-outline-padding * 2.
    NOTCH_ELEMENT_PADDING: 8
  };
  /** @enum {string} */

  var cssClasses$8 = {
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
    OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
    NO_LABEL: 'mdc-notched-outline--no-label'
  };

  /**
   * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
   * @final
   */

  var MDCNotchedOutlineFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCNotchedOutlineFoundation, _MDCFoundation);

    _createClass(MDCNotchedOutlineFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$6;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$8;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$3;
      }
      /**
       * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCNotchedOutlineAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCNotchedOutlineAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            setNotchWidthProperty: function setNotchWidthProperty() {},
            removeNotchWidthProperty: function removeNotchWidthProperty() {}
          }
        );
      }
      /**
       * @param {!MDCNotchedOutlineAdapter} adapter
       */

    }]);

    function MDCNotchedOutlineFoundation(adapter) {
      _classCallCheck(this, MDCNotchedOutlineFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCNotchedOutlineFoundation).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
    }
    /**
     * Adds the outline notched selector and updates the notch width
     * calculated based off of notchWidth.
     * @param {number} notchWidth
     */


    _createClass(MDCNotchedOutlineFoundation, [{
      key: "notch",
      value: function notch(notchWidth) {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        if (notchWidth > 0) {
          notchWidth += numbers$3.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
        }

        this.adapter_.setNotchWidthProperty(notchWidth);
        this.adapter_.addClass(OUTLINE_NOTCHED);
      }
      /**
       * Removes notched outline selector to close the notch in the outline.
       */

    }, {
      key: "closeNotch",
      value: function closeNotch() {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        this.adapter_.removeClass(OUTLINE_NOTCHED);
        this.adapter_.removeNotchWidthProperty();
      }
    }]);

    return MDCNotchedOutlineFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
   * @final
   */

  var MDCNotchedOutline =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCNotchedOutline, _MDCComponent);

    _createClass(MDCNotchedOutline, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCNotchedOutline}
       */
      value: function attachTo(root) {
        return new MDCNotchedOutline(root);
      }
      /** @param {...?} args */

    }]);

    function MDCNotchedOutline() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCNotchedOutline);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCNotchedOutline)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @private {Element} */

      _this.notchElement_;
      return _this;
    }

    _createClass(MDCNotchedOutline, [{
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        var label = this.root_.querySelector('.' + MDCFloatingLabelFoundation.cssClasses.ROOT);
        this.notchElement_ = this.root_.querySelector(strings$6.NOTCH_ELEMENT_SELECTOR);

        if (label) {
          label.style.transitionDuration = '0s';
          this.root_.classList.add(cssClasses$8.OUTLINE_UPGRADED);
          requestAnimationFrame(function () {
            label.style.transitionDuration = '';
          });
        } else {
          this.root_.classList.add(cssClasses$8.NO_LABEL);
        }
      }
      /**
        * Updates classes and styles to open the notch to the specified width.
        * @param {number} notchWidth The notch width in the outline.
        */

    }, {
      key: "notch",
      value: function notch(notchWidth) {
        this.foundation_.notch(notchWidth);
      }
      /**
       * Updates classes and styles to close the notch.
       */

    }, {
      key: "closeNotch",
      value: function closeNotch() {
        this.foundation_.closeNotch();
      }
      /**
       * @return {!MDCNotchedOutlineFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this2 = this;

        return new MDCNotchedOutlineFoundation(
        /** @type {!MDCNotchedOutlineAdapter} */
        Object.assign({
          addClass: function addClass(className) {
            return _this2.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this2.root_.classList.remove(className);
          },
          setNotchWidthProperty: function setNotchWidthProperty(width) {
            return _this2.notchElement_.style.setProperty('width', width + 'px');
          },
          removeNotchWidthProperty: function removeNotchWidthProperty() {
            return _this2.notchElement_.style.removeProperty('width');
          }
        }));
      }
    }]);

    return MDCNotchedOutline;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Select Icon.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the select icon into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSelectIconAdapter =
  /*#__PURE__*/
  function () {
    function MDCSelectIconAdapter() {
      _classCallCheck(this, MDCSelectIconAdapter);
    }

    _createClass(MDCSelectIconAdapter, [{
      key: "getAttr",

      /**
       * Gets the value of an attribute on the icon element.
       * @param {string} attr
       * @return {string}
       */
      value: function getAttr(attr) {}
      /**
       * Sets an attribute on the icon element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}
      /**
       * Removes an attribute from the icon element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}
      /**
       * Sets the text content of the icon element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
      /**
       * Registers an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
      /**
       * Emits a custom event "MDCSelect:icon" denoting a user has clicked the icon.
       */

    }, {
      key: "notifyIconAction",
      value: function notifyIconAction() {}
    }]);

    return MDCSelectIconAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$7 = {
    ICON_EVENT: 'MDCSelect:icon',
    ICON_ROLE: 'button'
  };

  /**
   * @extends {MDCFoundation<!MDCSelectIconAdapter>}
   * @final
   */

  var MDCSelectIconFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSelectIconFoundation, _MDCFoundation);

    _createClass(MDCSelectIconFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$7;
      }
      /**
       * {@see MDCSelectIconAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectIconAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSelectIconAdapter} */
          {
            getAttr: function getAttr() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            notifyIconAction: function notifyIconAction() {}
          }
        );
      }
      /**
       * @param {!MDCSelectIconAdapter} adapter
       */

    }]);

    function MDCSelectIconFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCSelectIconFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectIconFoundation).call(this, Object.assign(MDCSelectIconFoundation.defaultAdapter, adapter)));
      /** @private {string?} */

      _this.savedTabIndex_ = null;
      /** @private {function(!Event): undefined} */

      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };

      return _this;
    }

    _createClass(MDCSelectIconFoundation, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }
      /** @param {boolean} disabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        if (!this.savedTabIndex_) {
          return;
        }

        if (disabled) {
          this.adapter_.setAttr('tabindex', '-1');
          this.adapter_.removeAttr('role');
        } else {
          this.adapter_.setAttr('tabindex', this.savedTabIndex_);
          this.adapter_.setAttr('role', strings$7.ICON_ROLE);
        }
      }
      /** @param {string} label */

    }, {
      key: "setAriaLabel",
      value: function setAriaLabel(label) {
        this.adapter_.setAttr('aria-label', label);
      }
      /** @param {string} content */

    }, {
      key: "setContent",
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }
      /**
       * Handles an interaction event
       * @param {!Event} evt
       */

    }, {
      key: "handleInteraction",
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyIconAction();
        }
      }
    }]);

    return MDCSelectIconFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCSelectIconFoundation>}
   * @final
   */

  var MDCSelectIcon =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCSelectIcon, _MDCComponent);

    function MDCSelectIcon() {
      _classCallCheck(this, MDCSelectIcon);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectIcon).apply(this, arguments));
    }

    _createClass(MDCSelectIcon, [{
      key: "getDefaultFoundation",

      /**
       * @return {!MDCSelectIconFoundation}
       */
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCSelectIconFoundation(
        /** @type {!MDCSelectIconAdapter} */
        Object.assign({
          getAttr: function getAttr(attr) {
            return _this.root_.getAttribute(attr);
          },
          setAttr: function setAttr(attr, value) {
            return _this.root_.setAttribute(attr, value);
          },
          removeAttr: function removeAttr(attr) {
            return _this.root_.removeAttribute(attr);
          },
          setContent: function setContent(content) {
            _this.root_.textContent = content;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return _this.root_.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return _this.root_.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.emit(MDCSelectIconFoundation.strings.ICON_EVENT, {}
            /* evtData */
            , true
            /* shouldBubble */
            );
          }
        }));
      }
    }, {
      key: "foundation",

      /**
       * @return {!MDCSelectIconFoundation}
       */
      get: function get() {
        return this.foundation_;
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCSelectIcon}
       */
      value: function attachTo(root) {
        return new MDCSelectIcon(root);
      }
    }]);

    return MDCSelectIcon;
  }(MDCComponent);

  /**
   * Adapter for MDC Select. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCSelectAdapter =
  /*#__PURE__*/
  function () {
    function MDCSelectAdapter() {
      _classCallCheck(this, MDCSelectAdapter);
    }

    _createClass(MDCSelectAdapter, [{
      key: "addClass",

      /**
       * Adds class to root element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Activates the bottom line, showing a focused state.
       */

    }, {
      key: "activateBottomLine",
      value: function activateBottomLine() {}
      /**
       * Deactivates the bottom line.
       */

    }, {
      key: "deactivateBottomLine",
      value: function deactivateBottomLine() {}
      /**
       * Sets the value of the select.
       * @param {string} value
       */

    }, {
      key: "setValue",
      value: function setValue(value) {}
      /**
       * Returns the selected value of the select element.
       * @return {string}
       */

    }, {
      key: "getValue",
      value: function getValue() {}
      /**
       * Floats label determined based off of the shouldFloat argument.
       * @param {boolean} shouldFloat
       */

    }, {
      key: "floatLabel",
      value: function floatLabel(shouldFloat) {}
      /**
       * Returns width of label in pixels, if the label exists.
       * @return {number}
       */

    }, {
      key: "getLabelWidth",
      value: function getLabelWidth() {}
      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: "hasOutline",
      value: function hasOutline() {}
      /**
       * Only implement if outline element exists.
       * @param {number} labelWidth
       */

    }, {
      key: "notchOutline",
      value: function notchOutline(labelWidth) {}
      /**
       * Closes notch in outline element, if the outline exists.
       */

    }, {
      key: "closeOutline",
      value: function closeOutline() {}
      /**
       * Opens the menu.
       */

    }, {
      key: "openMenu",
      value: function openMenu() {}
      /**
       * Closes the menu.
       */

    }, {
      key: "closeMenu",
      value: function closeMenu() {}
      /**
       * Returns true if the menu is currently open.
       * @return {boolean}
       */

    }, {
      key: "isMenuOpen",
      value: function isMenuOpen() {}
      /**
       * Sets the selected index of the select to the index provided.
       * @param {number} index
       */

    }, {
      key: "setSelectedIndex",
      value: function setSelectedIndex(index) {}
      /**
       * Sets the select to disabled.
       * @param {boolean} isDisabled
       */

    }, {
      key: "setDisabled",
      value: function setDisabled(isDisabled) {}
      /**
       * Sets the line ripple transform origin center.
       * @param {number} normalizedX
       */

    }, {
      key: "setRippleCenter",
      value: function setRippleCenter(normalizedX) {}
      /**
       * Emits a change event when an element is selected.
       * @param {string} value
       */

    }, {
      key: "notifyChange",
      value: function notifyChange(value) {}
      /**
       * Checks if the select is currently valid.
       * @return {boolean} isValid
       */

    }, {
      key: "checkValidity",
      value: function checkValidity() {}
      /**
       * Adds/Removes the invalid class.
       * @param {boolean} isValid
       */

    }, {
      key: "setValid",
      value: function setValid(isValid) {}
    }]);

    return MDCSelectAdapter;
  }();

  /**
   * @extends {MDCFoundation<!MDCSelectAdapter>}
   * @final
   */

  var MDCSelectFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSelectFoundation, _MDCFoundation);

    _createClass(MDCSelectFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$1;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$1;
      }
      /**
       * {@see MDCSelectAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSelectAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            hasClass: function hasClass() {
              return (
                /* className: string */
                false
              );
            },
            activateBottomLine: function activateBottomLine() {},
            deactivateBottomLine: function deactivateBottomLine() {},
            setValue: function setValue() {},
            getValue: function getValue() {},
            floatLabel: function floatLabel()
            /* value: boolean */
            {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {
              return false;
            },
            notchOutline: function notchOutline()
            /* labelWidth: number, */
            {},
            closeOutline: function closeOutline() {},
            openMenu: function openMenu() {},
            closeMenu: function closeMenu() {},
            isMenuOpen: function isMenuOpen() {},
            setSelectedIndex: function setSelectedIndex() {},
            setDisabled: function setDisabled() {},
            setRippleCenter: function setRippleCenter() {},
            notifyChange: function notifyChange() {},
            checkValidity: function checkValidity() {},
            setValid: function setValid() {}
          }
        );
      }
      /**
       * @param {!MDCSelectAdapter} adapter
       * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
       */

    }]);

    function MDCSelectFoundation(adapter) {
      var _this;

      var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :
      /** @type {!FoundationMapType} */
      {};

      _classCallCheck(this, MDCSelectFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectFoundation).call(this, Object.assign(MDCSelectFoundation.defaultAdapter, adapter)));
      /** @type {!MDCSelectIconFoundation|undefined} */

      _this.leadingIcon_ = foundationMap.leadingIcon;
      /** @type {!MDCSelectHelperTextFoundation|undefined} */

      _this.helperText_ = foundationMap.helperText;
      return _this;
    }

    _createClass(MDCSelectFoundation, [{
      key: "setSelectedIndex",
      value: function setSelectedIndex(index) {
        this.adapter_.setSelectedIndex(index);
        this.adapter_.closeMenu();
        var didChange = true;
        this.handleChange(didChange);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.adapter_.setValue(value);
        var didChange = true;
        this.handleChange(didChange);
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this.adapter_.getValue();
      }
    }, {
      key: "setDisabled",
      value: function setDisabled(isDisabled) {
        isDisabled ? this.adapter_.addClass(cssClasses$1.DISABLED) : this.adapter_.removeClass(cssClasses$1.DISABLED);
        this.adapter_.setDisabled(isDisabled);
        this.adapter_.closeMenu();

        if (this.leadingIcon_) {
          this.leadingIcon_.setDisabled(isDisabled);
        }
      }
      /**
       * @param {string} content Sets the content of the helper text.
       */

    }, {
      key: "setHelperTextContent",
      value: function setHelperTextContent(content) {
        if (this.helperText_) {
          this.helperText_.setContent(content);
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        var openNotch = this.getValue().length > 0;
        this.notchOutline(openNotch);
      }
      /**
       * Handles value changes, via change event or programmatic updates.
       */

    }, {
      key: "handleChange",
      value: function handleChange() {
        var didChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var value = this.getValue();
        var optionHasValue = value.length > 0;
        var isRequired = this.adapter_.hasClass(cssClasses$1.REQUIRED);
        this.notchOutline(optionHasValue);

        if (!this.adapter_.hasClass(cssClasses$1.FOCUSED)) {
          this.adapter_.floatLabel(optionHasValue);
        }

        if (didChange) {
          this.adapter_.notifyChange(value);

          if (isRequired) {
            this.setValid(this.isValid());

            if (this.helperText_) {
              this.helperText_.setValidity(this.isValid());
            }
          }
        }
      }
      /**
       * Handles focus events from select element.
       */

    }, {
      key: "handleFocus",
      value: function handleFocus() {
        this.adapter_.addClass(cssClasses$1.FOCUSED);
        this.adapter_.floatLabel(true);
        this.notchOutline(true);
        this.adapter_.activateBottomLine();

        if (this.helperText_) {
          this.helperText_.showToScreenReader();
        }
      }
      /**
       * Handles blur events from select element.
       */

    }, {
      key: "handleBlur",
      value: function handleBlur() {
        if (this.adapter_.isMenuOpen()) return;
        this.adapter_.removeClass(cssClasses$1.FOCUSED);
        this.handleChange(false);
        this.adapter_.deactivateBottomLine();
        var isRequired = this.adapter_.hasClass(cssClasses$1.REQUIRED);

        if (isRequired) {
          this.setValid(this.isValid());

          if (this.helperText_) {
            this.helperText_.setValidity(this.isValid());
          }
        }
      }
    }, {
      key: "handleClick",
      value: function handleClick(normalizedX) {
        if (this.adapter_.isMenuOpen()) return;
        this.adapter_.setRippleCenter(normalizedX);
        this.adapter_.openMenu();
      }
    }, {
      key: "handleKeydown",
      value: function handleKeydown(event) {
        if (this.adapter_.isMenuOpen()) return;
        var isEnter = event.key === 'Enter' || event.keyCode === 13;
        var isSpace = event.key === 'Space' || event.keyCode === 32;
        var arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
        var arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;

        if (this.adapter_.hasClass(cssClasses$1.FOCUSED) && (isEnter || isSpace || arrowUp || arrowDown)) {
          this.adapter_.openMenu();
          event.preventDefault();
        }
      }
      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: "notchOutline",
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline()) {
          return;
        }

        var isFocused = this.adapter_.hasClass(cssClasses$1.FOCUSED);

        if (openNotch) {
          var labelScale = numbers.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          this.adapter_.notchOutline(labelWidth);
        } else if (!isFocused) {
          this.adapter_.closeOutline();
        }
      }
      /**
       * Sets the aria label of the leading icon.
       * @param {string} label
       */

    }, {
      key: "setLeadingIconAriaLabel",
      value: function setLeadingIconAriaLabel(label) {
        if (this.leadingIcon_) {
          this.leadingIcon_.setAriaLabel(label);
        }
      }
      /**
       * Sets the text content of the leading icon.
       * @param {string} content
       */

    }, {
      key: "setLeadingIconContent",
      value: function setLeadingIconContent(content) {
        if (this.leadingIcon_) {
          this.leadingIcon_.setContent(content);
        }
      }
    }, {
      key: "setValid",
      value: function setValid(isValid) {
        this.adapter_.setValid(isValid);
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return this.adapter_.checkValidity();
      }
    }]);

    return MDCSelectFoundation;
  }(MDCFoundation);

  var VALIDATION_ATTR_WHITELIST = ['required', 'aria-required'];
  /**
   * @extends MDCComponent<!MDCSelectFoundation>
   */

  var MDCSelect =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCSelect, _MDCComponent);

    /**
     * @param {...?} args
     */
    function MDCSelect() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCSelect);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCSelect)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @private {?Element} */

      _this.nativeControl_;
      /** @private {?Element} */

      _this.selectedText_;
      /** @private {?Element} */

      _this.hiddenInput_;
      /** @private {?MDCSelectIcon} */

      _this.leadingIcon_;
      /** @private {?MDCSelectHelperText} */

      _this.helperText_;
      /** @private {?Element} */

      _this.menuElement_;
      /** @type {?MDCMenu} */

      _this.menu_;
      /** @type {?MDCRipple} */

      _this.ripple;
      /** @private {?MDCLineRipple} */

      _this.lineRipple_;
      /** @private {?MDCFloatingLabel} */

      _this.label_;
      /** @private {?MDCNotchedOutline} */

      _this.outline_;
      /** @private {!Function} */

      _this.handleChange_;
      /** @private {!Function} */

      _this.handleFocus_;
      /** @private {!Function} */

      _this.handleBlur_;
      /** @private {!Function} */

      _this.handleClick_;
      /** @private {!Function} */

      _this.handleKeydown_;
      /** @private {!Function} */

      _this.handleMenuOpened_;
      /** @private {!Function} */

      _this.handleMenuClosed_;
      /** @private {!Function} */

      _this.handleMenuSelected_;
      /** @private {boolean} */

      _this.menuOpened_ = false;
      /** @private {!MutationObserver} */

      _this.validationObserver_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @return {!MDCSelect}
     */


    _createClass(MDCSelect, [{
      key: "layout",

      /**
       * Recomputes the outline SVG path for the outline element.
       */
      value: function layout() {
        this.foundation_.layout();
      }
      /**
       * @param {(function(!Element): !MDCLineRipple)=} lineRippleFactory A function which creates a new MDCLineRipple.
       * @param {(function(!Element): !MDCFloatingLabel)=} labelFactory A function which creates a new MDCFloatingLabel.
       * @param {(function(!Element): !MDCNotchedOutline)=} outlineFactory A function which creates a new MDCNotchedOutline.
       * @param {(function(!Element): !MDCMenu)=} menuFactory A function which creates a new MDCMenu.
       * @param {(function(!Element): !MDCSelectIcon)=} iconFactory A function which creates a new MDCSelectIcon.
       * @param {(function(!Element): !MDCSelectHelperText)=} helperTextFactory A function which creates a new
       * MDCSelectHelperText.
       */

    }, {
      key: "initialize",
      value: function initialize() {
        var labelFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
          return new MDCFloatingLabel(el);
        };
        var lineRippleFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
          return new MDCLineRipple(el);
        };
        var outlineFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el) {
          return new MDCNotchedOutline(el);
        };
        var menuFactory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (el) {
          return new MDCMenu(el);
        };
        var iconFactory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (el) {
          return new MDCSelectIcon(el);
        };
        var helperTextFactory = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (el) {
          return new MDCSelectHelperText(el);
        };
        this.nativeControl_ =
        /** @type {HTMLElement} */
        this.root_.querySelector(strings$1.NATIVE_CONTROL_SELECTOR);
        this.selectedText_ =
        /** @type {HTMLElement} */
        this.root_.querySelector(strings$1.SELECTED_TEXT_SELECTOR);

        if (this.selectedText_) {
          this.enhancedSelectSetup_(menuFactory);
        }

        var labelElement = this.root_.querySelector(strings$1.LABEL_SELECTOR);

        if (labelElement) {
          this.label_ = labelFactory(labelElement);
        }

        var lineRippleElement = this.root_.querySelector(strings$1.LINE_RIPPLE_SELECTOR);

        if (lineRippleElement) {
          this.lineRipple_ = lineRippleFactory(lineRippleElement);
        }

        var outlineElement = this.root_.querySelector(strings$1.OUTLINE_SELECTOR);

        if (outlineElement) {
          this.outline_ = outlineFactory(outlineElement);
        }

        var leadingIcon = this.root_.querySelector(strings$1.LEADING_ICON_SELECTOR);

        if (leadingIcon) {
          this.root_.classList.add(cssClasses$1.WITH_LEADING_ICON);
          this.leadingIcon_ = iconFactory(leadingIcon);

          if (this.menuElement_) {
            this.menuElement_.classList.add(cssClasses$1.WITH_LEADING_ICON);
          }
        }

        var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;

        if (element.hasAttribute(strings$1.ARIA_CONTROLS)) {
          var helperTextElement = document.getElementById(element.getAttribute(strings$1.ARIA_CONTROLS));

          if (helperTextElement) {
            this.helperText_ = helperTextFactory(helperTextElement);
          }
        }

        if (!this.root_.classList.contains(cssClasses$1.OUTLINED)) {
          this.ripple = this.initRipple_();
        } // The required state needs to be sync'd before the mutation observer is added.


        this.initialSyncRequiredState_();
        this.addMutationObserverForRequired_();
      }
      /**
       * Handles setup for the enhanced menu.
       * @private
       */

    }, {
      key: "enhancedSelectSetup_",
      value: function enhancedSelectSetup_(menuFactory) {
        var isDisabled = this.root_.classList.contains(cssClasses$1.DISABLED);
        this.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');
        this.hiddenInput_ = this.root_.querySelector(strings$1.HIDDEN_INPUT_SELECTOR);
        this.menuElement_ =
        /** @type {HTMLElement} */
        this.root_.querySelector(strings$1.MENU_SELECTOR);
        this.menu_ = menuFactory(this.menuElement_);
        this.menu_.hoistMenuToBody();
        this.menu_.setAnchorElement(
        /** @type {!HTMLElement} */
        this.root_);
        this.menu_.setAnchorCorner(Corner.BOTTOM_START);
        this.menu_.wrapFocus = false;
      }
      /**
       * @private
       * @return {!MDCRipple}
       */

    }, {
      key: "initRipple_",
      value: function initRipple_() {
        var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
        var adapter = Object.assign(MDCRipple.createAdapter(this), {
          registerInteractionHandler: function registerInteractionHandler(type, handler) {
            return element.addEventListener(type, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
            return element.removeEventListener(type, handler);
          }
        });
        var foundation = new MDCRippleFoundation(adapter);
        return new MDCRipple(this.root_, foundation);
      }
      /**
       * Initializes the select's event listeners and internal state based
       * on the environment's state.
       */

    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        var _this2 = this;

        this.handleChange_ = function () {
          return _this2.foundation_.handleChange(
          /* didChange */
          true);
        };

        this.handleFocus_ = function () {
          return _this2.foundation_.handleFocus();
        };

        this.handleBlur_ = function () {
          return _this2.foundation_.handleBlur();
        };

        this.handleClick_ = function (evt) {
          if (_this2.selectedText_) _this2.selectedText_.focus();

          _this2.foundation_.handleClick(_this2.getNormalizedXCoordinate_(evt));
        };

        this.handleKeydown_ = function (evt) {
          return _this2.foundation_.handleKeydown(evt);
        };

        this.handleMenuSelected_ = function (evtData) {
          return _this2.selectedIndex = evtData.detail.index;
        };

        this.handleMenuOpened_ = function () {
          // Menu should open to the last selected element.
          if (_this2.selectedIndex >= 0) {
            _this2.menu_.items[_this2.selectedIndex].focus();
          }
        };

        this.handleMenuClosed_ = function () {
          // menuOpened_ is used to track the state of the menu opening or closing since the menu.open function
          // will return false if the menu is still closing and this method listens to the closed event which
          // occurs after the menu is already closed.
          _this2.menuOpened_ = false;

          _this2.selectedText_.removeAttribute('aria-expanded');

          if (document.activeElement !== _this2.selectedText_) {
            _this2.foundation_.handleBlur();
          }
        };

        var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
        element.addEventListener('change', this.handleChange_);
        element.addEventListener('focus', this.handleFocus_);
        element.addEventListener('blur', this.handleBlur_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          element.addEventListener(evtType, _this2.handleClick_);
        });

        if (this.menuElement_) {
          this.selectedText_.addEventListener('keydown', this.handleKeydown_);
          this.menu_.listen(strings$3.CLOSED_EVENT, this.handleMenuClosed_);
          this.menu_.listen(strings$3.OPENED_EVENT, this.handleMenuOpened_);
          this.menu_.listen(strings$2.SELECTED_EVENT, this.handleMenuSelected_);

          if (this.hiddenInput_ && this.hiddenInput_.value) {
            // If the hidden input already has a value, use it to restore the select's value.
            // This can happen e.g. if the user goes back or (in some browsers) refreshes the page.
            var enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();
            enhancedAdapterMethods.setValue(this.hiddenInput_.value);
          } else if (this.menuElement_.querySelector(strings$1.SELECTED_ITEM_SELECTOR)) {
            // If an element is selected, the select should set the initial selected text.
            var _enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();

            _enhancedAdapterMethods.setValue(_enhancedAdapterMethods.getValue());
          }
        } // Initially sync floating label


        this.foundation_.handleChange(
        /* didChange */
        false);

        if (this.root_.classList.contains(cssClasses$1.DISABLED) || this.nativeControl_ && this.nativeControl_.disabled) {
          this.disabled = true;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
        element.removeEventListener('change', this.handleChange_);
        element.removeEventListener('focus', this.handleFocus_);
        element.removeEventListener('blur', this.handleBlur_);
        element.removeEventListener('keydown', this.handleKeydown_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          element.removeEventListener(evtType, _this3.handleClick_);
        });

        if (this.menu_) {
          this.menu_.unlisten(strings$3.CLOSED_EVENT, this.handleMenuClosed_);
          this.menu_.unlisten(strings$3.OPENED_EVENT, this.handleMenuOpened_);
          this.menu_.unlisten(strings$2.SELECTED_EVENT, this.handleMenuSelected_);
          this.menu_.destroy();
        }

        if (this.ripple) {
          this.ripple.destroy();
        }

        if (this.outline_) {
          this.outline_.destroy();
        }

        if (this.leadingIcon_) {
          this.leadingIcon_.destroy();
        }

        if (this.helperText_) {
          this.helperText_.destroy();
        }

        if (this.validationObserver_) {
          this.validationObserver_.disconnect();
        }

        _get(_getPrototypeOf(MDCSelect.prototype), "destroy", this).call(this);
      }
      /**
       * @return {!MDCSelectFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        return new MDCSelectFoundation(
        /** @type {!MDCSelectAdapter} */
        Object.assign(this.nativeControl_ ? this.getNativeSelectAdapterMethods_() : this.getEnhancedSelectAdapterMethods_(), this.getCommonAdapterMethods_(), this.getOutlineAdapterMethods_(), this.getLabelAdapterMethods_()), this.getFoundationMap_());
      }
      /**
       * @return {!{
       *   getValue: function(): string,
       *   setValue: function(string): string,
       *   openMenu: function(): void,
       *   closeMenu: function(): void,
       *   isMenuOpen: function(): boolean,
       *   setSelectedIndex: function(number): void,
       *   setDisabled: function(boolean): void
       * }}
       * @private
       */

    }, {
      key: "getNativeSelectAdapterMethods_",
      value: function getNativeSelectAdapterMethods_() {
        var _this4 = this;

        return {
          getValue: function getValue() {
            return _this4.nativeControl_.value;
          },
          setValue: function setValue(value) {
            return _this4.nativeControl_.value = value;
          },
          openMenu: function openMenu() {},
          closeMenu: function closeMenu() {},
          isMenuOpen: function isMenuOpen() {
            return false;
          },
          setSelectedIndex: function setSelectedIndex(index) {
            _this4.nativeControl_.selectedIndex = index;
          },
          setDisabled: function setDisabled(isDisabled) {
            return _this4.nativeControl_.disabled = isDisabled;
          },
          setValid: function setValid(isValid) {
            isValid ? _this4.root_.classList.remove(cssClasses$1.INVALID) : _this4.root_.classList.add(cssClasses$1.INVALID);
          },
          checkValidity: function checkValidity() {
            return _this4.nativeControl_.checkValidity();
          }
        };
      }
      /**
       * @return {!{
       *   getValue: function(): string,
       *   setValue: function(string): string,
       *   openMenu: function(): void,
       *   closeMenu: function(): void,
       *   isMenuOpen: function(): boolean,
       *   setSelectedIndex: function(number): void,
       *   setDisabled: function(boolean): void
       * }}
       * @private
       */

    }, {
      key: "getEnhancedSelectAdapterMethods_",
      value: function getEnhancedSelectAdapterMethods_() {
        var _this5 = this;

        return {
          getValue: function getValue() {
            var listItem = _this5.menuElement_.querySelector(strings$1.SELECTED_ITEM_SELECTOR);

            if (listItem && listItem.hasAttribute(strings$1.ENHANCED_VALUE_ATTR)) {
              return listItem.getAttribute(strings$1.ENHANCED_VALUE_ATTR);
            }

            return '';
          },
          setValue: function setValue(value) {
            var element =
            /** @type {HTMLElement} */
            _this5.menuElement_.querySelector("[".concat(strings$1.ENHANCED_VALUE_ATTR, "=\"").concat(value, "\"]"));

            _this5.setEnhancedSelectedIndex_(element ? _this5.menu_.items.indexOf(element) : -1);
          },
          openMenu: function openMenu() {
            if (_this5.menu_ && !_this5.menu_.open) {
              _this5.menu_.open = true;
              _this5.menuOpened_ = true;

              _this5.selectedText_.setAttribute('aria-expanded', 'true');
            }
          },
          closeMenu: function closeMenu() {
            if (_this5.menu_ && _this5.menu_.open) {
              _this5.menu_.open = false;
            }
          },
          isMenuOpen: function isMenuOpen() {
            return _this5.menu_ && _this5.menuOpened_;
          },
          setSelectedIndex: function setSelectedIndex(index) {
            _this5.setEnhancedSelectedIndex_(index);
          },
          setDisabled: function setDisabled(isDisabled) {
            _this5.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');

            _this5.selectedText_.setAttribute('aria-disabled', isDisabled.toString());

            if (_this5.hiddenInput_) {
              _this5.hiddenInput_.disabled = isDisabled;
            }
          },
          checkValidity: function checkValidity() {
            var classList = _this5.root_.classList;

            if (classList.contains(cssClasses$1.REQUIRED) && !classList.contains(cssClasses$1.DISABLED)) {
              // See notes for required attribute under https://www.w3.org/TR/html52/sec-forms.html#the-select-element
              // TL;DR: Invalid if no index is selected, or if the first index is selected and has an empty value.
              return _this5.selectedIndex !== -1 && (_this5.selectedIndex !== 0 || _this5.value);
            } else {
              return true;
            }
          },
          setValid: function setValid(isValid) {
            _this5.selectedText_.setAttribute('aria-invalid', (!isValid).toString());

            isValid ? _this5.root_.classList.remove(cssClasses$1.INVALID) : _this5.root_.classList.add(cssClasses$1.INVALID);
          }
        };
      }
      /**
       * @return {!{
       *   addClass: function(string): void,
       *   removeClass: function(string): void,
       *   hasClass: function(string): void,
       *   setRippleCenter: function(number): void,
       *   activateBottomLine: function(): void,
       *   deactivateBottomLine: function(): void,
       *   notifyChange: function(string): void
       * }}
       * @private
       */

    }, {
      key: "getCommonAdapterMethods_",
      value: function getCommonAdapterMethods_() {
        var _this6 = this;

        return {
          addClass: function addClass(className) {
            return _this6.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this6.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this6.root_.classList.contains(className);
          },
          setRippleCenter: function setRippleCenter(normalizedX) {
            return _this6.lineRipple_ && _this6.lineRipple_.setRippleCenter(normalizedX);
          },
          activateBottomLine: function activateBottomLine() {
            return _this6.lineRipple_ && _this6.lineRipple_.activate();
          },
          deactivateBottomLine: function deactivateBottomLine() {
            return _this6.lineRipple_ && _this6.lineRipple_.deactivate();
          },
          notifyChange: function notifyChange(value) {
            var index = _this6.selectedIndex;

            _this6.emit(strings$1.CHANGE_EVENT, {
              value: value,
              index: index
            }, true
            /* shouldBubble  */
            );
          }
        };
      }
      /**
       * @return {!{
       *   hasOutline: function(): boolean,
       *   notchOutline: function(number, boolean): undefined,
       *   closeOutline: function(): undefined,
       * }}
       */

    }, {
      key: "getOutlineAdapterMethods_",
      value: function getOutlineAdapterMethods_() {
        var _this7 = this;

        return {
          hasOutline: function hasOutline() {
            return !!_this7.outline_;
          },
          notchOutline: function notchOutline(labelWidth) {
            if (_this7.outline_) {
              _this7.outline_.notch(labelWidth);
            }
          },
          closeOutline: function closeOutline() {
            if (_this7.outline_) {
              _this7.outline_.closeNotch();
            }
          }
        };
      }
      /**
       * @return {!{
       *   floatLabel: function(boolean): undefined,
       *   getLabelWidth: function(): number,
       * }}
       */

    }, {
      key: "getLabelAdapterMethods_",
      value: function getLabelAdapterMethods_() {
        var _this8 = this;

        return {
          floatLabel: function floatLabel(shouldFloat) {
            if (_this8.label_) {
              _this8.label_.float(shouldFloat);
            }
          },
          getLabelWidth: function getLabelWidth() {
            return _this8.label_ ? _this8.label_.getWidth() : 0;
          }
        };
      }
      /**
       * Calculates where the line ripple should start based on the x coordinate within the component.
       * @param {!(MouseEvent|TouchEvent)} evt
       * @return {number} normalizedX
       */

    }, {
      key: "getNormalizedXCoordinate_",
      value: function getNormalizedXCoordinate_(evt) {
        var targetClientRect = evt.target.getBoundingClientRect();
        var xCoordinate = evt.clientX;
        return xCoordinate - targetClientRect.left;
      }
      /**
       * Returns a map of all subcomponents to subfoundations.
       * @return {!FoundationMapType}
       */

    }, {
      key: "getFoundationMap_",
      value: function getFoundationMap_() {
        return {
          leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
          helperText: this.helperText_ ? this.helperText_.foundation : undefined
        };
      }
      /**
       * Sets the selected index of the enhanced menu.
       * @param {number} index
       * @private
       */

    }, {
      key: "setEnhancedSelectedIndex_",
      value: function setEnhancedSelectedIndex_(index) {
        var selectedItem = this.menu_.items[index];
        this.selectedText_.textContent = selectedItem ? selectedItem.textContent.trim() : '';
        var previouslySelected = this.menuElement_.querySelector(strings$1.SELECTED_ITEM_SELECTOR);

        if (previouslySelected) {
          previouslySelected.classList.remove(cssClasses$1.SELECTED_ITEM_CLASS);
          previouslySelected.removeAttribute(strings$1.ARIA_SELECTED_ATTR);
        }

        if (selectedItem) {
          selectedItem.classList.add(cssClasses$1.SELECTED_ITEM_CLASS);
          selectedItem.setAttribute(strings$1.ARIA_SELECTED_ATTR, 'true');
        } // Synchronize hidden input's value with data-value attribute of selected item.
        // This code path is also followed when setting value directly, so this covers all cases.


        if (this.hiddenInput_) {
          this.hiddenInput_.value = selectedItem ? selectedItem.getAttribute(strings$1.ENHANCED_VALUE_ATTR) || '' : '';
        }

        this.layout();
      }
    }, {
      key: "initialSyncRequiredState_",
      value: function initialSyncRequiredState_() {
        var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
        var isRequired = element.required || element.getAttribute('aria-required') === 'true' || this.root_.classList.contains(cssClasses$1.REQUIRED);

        if (isRequired) {
          if (this.nativeControl_) {
            this.nativeControl_.required = true;
          } else {
            this.selectedText_.setAttribute('aria-required', 'true');
          }

          this.root_.classList.add(cssClasses$1.REQUIRED);
        }
      }
    }, {
      key: "addMutationObserverForRequired_",
      value: function addMutationObserverForRequired_() {
        var _this9 = this;

        var observerHandler = function observerHandler(attributesList) {
          attributesList.some(function (attributeName) {
            if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
              if (_this9.selectedText_) {
                if (_this9.selectedText_.getAttribute('aria-required') === 'true') {
                  _this9.root_.classList.add(cssClasses$1.REQUIRED);
                } else {
                  _this9.root_.classList.remove(cssClasses$1.REQUIRED);
                }
              } else {
                if (_this9.nativeControl_.required) {
                  _this9.root_.classList.add(cssClasses$1.REQUIRED);
                } else {
                  _this9.root_.classList.remove(cssClasses$1.REQUIRED);
                }
              }

              return true;
            }
          });
        };

        var getAttributesList = function getAttributesList(mutationsList) {
          return mutationsList.map(function (mutation) {
            return mutation.attributeName;
          });
        };

        var observer = new MutationObserver(function (mutationsList) {
          return observerHandler(getAttributesList(mutationsList));
        });
        var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
        observer.observe(element, {
          attributes: true
        });
        this.validationObserver_ = observer;
      }
    }, {
      key: "value",

      /**
       * @return {string} The value of the select.
       */
      get: function get() {
        return this.foundation_.getValue();
      }
      /**
       * @param {string} value The value to set on the select.
       */
      ,
      set: function set(value) {
        this.foundation_.setValue(value);
      }
      /**
       * @return {number} The selected index of the select.
       */

    }, {
      key: "selectedIndex",
      get: function get() {
        var selectedIndex;

        if (this.menuElement_) {
          var selectedEl =
          /** @type {!HTMLElement} */
          this.menuElement_.querySelector(strings$1.SELECTED_ITEM_SELECTOR);
          selectedIndex = this.menu_.items.indexOf(selectedEl);
        } else {
          selectedIndex = this.nativeControl_.selectedIndex;
        }

        return selectedIndex;
      }
      /**
       * @param {number} selectedIndex The index of the option to be set on the select.
       */
      ,
      set: function set(selectedIndex) {
        this.foundation_.setSelectedIndex(selectedIndex);
      }
      /**
       * @return {boolean} True if the select is disabled.
       */

    }, {
      key: "disabled",
      get: function get() {
        return this.root_.classList.contains(cssClasses$1.DISABLED) || (this.nativeControl_ ? this.nativeControl_.disabled : false);
      }
      /**
       * @param {boolean} disabled Sets the select disabled or enabled.
       */
      ,
      set: function set(disabled) {
        this.foundation_.setDisabled(disabled);
      }
      /**
       * Sets the aria label of the leading icon.
       * @param {string} label
       */

    }, {
      key: "leadingIconAriaLabel",
      set: function set(label) {
        this.foundation_.setLeadingIconAriaLabel(label);
      }
      /**
       * Sets the text content of the leading icon.
       * @param {string} content
       */

    }, {
      key: "leadingIconContent",
      set: function set(content) {
        this.foundation_.setLeadingIconContent(content);
      }
      /**
       * Sets the text content of the helper text.
       * @param {string} content
       */

    }, {
      key: "helperTextContent",
      set: function set(content) {
        this.foundation_.setHelperTextContent(content);
      }
      /**
       * Sets the current invalid state of the select.
       * @param {boolean} isValid
       */

    }, {
      key: "valid",
      set: function set(isValid) {
        this.foundation_.setValid(isValid);
      }
      /**
       * Checks if the select is in a valid state.
       * @return {boolean}
       */
      ,
      get: function get() {
        return this.foundation_.isValid();
      }
      /**
       * Sets the control to the required state.
       * @param {boolean} isRequired
       */

    }, {
      key: "required",
      set: function set(isRequired) {
        if (this.nativeControl_) {
          this.nativeControl_.required = isRequired;
        } else {
          if (isRequired) {
            this.selectedText_.setAttribute('aria-required', isRequired.toString());
          } else {
            this.selectedText_.removeAttribute('aria-required');
          }
        }
      }
      /**
       * Returns whether the select is required.
       * @return {boolean}
       */
      ,
      get: function get() {
        if (this.nativeControl_) {
          return this.nativeControl_.required;
        } else {
          return this.selectedText_.getAttribute('aria-required') === 'true';
        }
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCSelect(root);
      }
    }]);

    return MDCSelect;
  }(MDCComponent);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to configure the default options for all
   * mdc-select usage within an app.
   * @type {?}
   */
  var MDC_SELECT_DEFAULT_OPTIONS = new core.InjectionToken('MDC_SELECT_DEFAULT_OPTIONS');
  var MdcSelectBase = /** @class */ (function () {
      function MdcSelectBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
          this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
          this._parentForm = _parentForm;
          this._parentFormGroup = _parentFormGroup;
          this.ngControl = ngControl;
      }
      return MdcSelectBase;
  }());
  /** @type {?} */
  var _MdcSelectMixinBase = formField.mixinErrorState(MdcSelectBase);
  var MdcSelectChange = /** @class */ (function () {
      function MdcSelectChange(source, index, value) {
          this.source = source;
          this.index = index;
          this.value = value;
      }
      return MdcSelectChange;
  }());
  var MdcSelectOption = /** @class */ (function () {
      function MdcSelectOption() {
      }
      MdcSelectOption.decorators = [
          { type: core.Directive, args: [{
                      selector: 'option',
                      exportAs: 'mdcSelectOption',
                  },] },
      ];
      return MdcSelectOption;
  }());
  /** @type {?} */
  var nextUniqueId = 0;
  var MdcSelect = /** @class */ (function (_super) {
      __extends(MdcSelect, _super);
      function MdcSelect(_platform, _changeDetectorRef, elementRef, _defaultErrorStateMatcher, _parentFormField, _ripple, ngControl, _parentForm, _parentFormGroup, _defaults) {
          var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
          _this._platform = _platform;
          _this._changeDetectorRef = _changeDetectorRef;
          _this.elementRef = elementRef;
          _this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
          _this._parentFormField = _parentFormField;
          _this._ripple = _ripple;
          _this.ngControl = ngControl;
          _this._defaults = _defaults;
          /**
           * Emits whenever the component is destroyed.
           */
          _this._destroyed = new rxjs.Subject();
          _this._uniqueId = "mdc-select-" + ++nextUniqueId;
          _this.controlType = 'mdc-select';
          _this._enhancedSelectedText = '';
          _this.id = _this._uniqueId;
          _this.name = null;
          _this._placeholder = '';
          _this._disabled = false;
          _this._floatLabel = true;
          _this._outlined = false;
          _this._required = false;
          _this._autosize = false;
          _this._compareWith = (/**
           * @param {?} o1
           * @param {?} o2
           * @return {?}
           */
          function (o1, o2) { return o1 === o2; });
          _this._helperText = null;
          /**
           * Event emitted when the selected value has been changed by the user.
           */
          _this.selectionChange = new core.EventEmitter();
          /**
           * Event that emits whenever the raw value of the select changes. This is here primarily
           * to facilitate the two-way binding for the `value` input.
           */
          _this.valueChange = new core.EventEmitter();
          /**
           * View to model callback called when value changes
           */
          _this._onChange = (/**
           * @return {?}
           */
          function () { });
          /**
           * View to model callback called when select has been touched
           */
          _this._onTouched = (/**
           * @return {?}
           */
          function () { });
          if (_this.ngControl) {
              // Note: we provide the value accessor through here, instead of
              // the `providers` to avoid running into a circular import.
              _this.ngControl.valueAccessor = _this;
          }
          if (_this._parentFormField) {
              _parentFormField.elementRef.nativeElement.classList.add('ngx-form-field-select');
          }
          // Force setter to be called in case id was not specified.
          _this.id = _this.id;
          return _this;
      }
      Object.defineProperty(MdcSelect.prototype, "placeholder", {
          /** Placeholder to be shown if no value has been selected. */
          get: /**
           * Placeholder to be shown if no value has been selected.
           * @return {?}
           */
          function () { return this._placeholder; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._placeholder = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "disabled", {
          get: /**
           * @return {?}
           */
          function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setDisabledState(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "floatLabel", {
          get: /**
           * @return {?}
           */
          function () { return this._floatLabel; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              /** @type {?} */
              var newValue = common$1.toBoolean(value);
              if (newValue !== this._floatLabel) {
                  this._floatLabel = newValue;
                  this.layout();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "outlined", {
          get: /**
           * @return {?}
           */
          function () { return this._outlined; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              /** @type {?} */
              var newValue = common$1.toBoolean(value);
              if (newValue !== this._outlined) {
                  this._outlined = newValue || (this._defaults && this._defaults.outlined) || false;
                  this.layout();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "required", {
          get: /**
           * @return {?}
           */
          function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              /** @type {?} */
              var newValue = common$1.toBoolean(value);
              if (newValue !== this._required) {
                  this._required = newValue;
                  if (this._foundation) {
                      if (!this._required) {
                          this.valid = true;
                          this._changeDetectorRef.markForCheck();
                      }
                      if (this.ngControl) {
                          this._required ? this._getInputElement().setAttribute('required', '') :
                              this._getInputElement().removeAttribute('required');
                      }
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "valid", {
          get: /**
           * @return {?}
           */
          function () { return this._valid; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              /** @type {?} */
              var newValue = common$1.toBoolean(value);
              if (newValue !== this._valid) {
                  this._valid = newValue;
                  if (this._foundation && this._valid !== undefined) {
                      this._foundation.setValid(this._valid);
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "autosize", {
          get: /**
           * @return {?}
           */
          function () { return this._autosize; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              /** @type {?} */
              var newValue = common$1.toBoolean(value);
              if (newValue !== this._autosize) {
                  this._autosize = newValue;
                  this._setWidth();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "compareWith", {
          get: /**
           * @return {?}
           */
          function () { return this._compareWith; },
          set: /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._compareWith = fn;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "value", {
          /** Value of the select control. */
          get: /**
           * Value of the select control.
           * @return {?}
           */
          function () { return this._value; },
          set: /**
           * @param {?} newValue
           * @return {?}
           */
          function (newValue) {
              this.setSelectionByValue(newValue);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "helperText", {
          get: /**
           * @return {?}
           */
          function () { return this._helperText; },
          set: /**
           * @param {?} helperText
           * @return {?}
           */
          function (helperText) {
              if (this._helperText !== helperText) {
                  this._helperText = helperText;
                  this._initHelperText();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcSelect.prototype, "placeholderText", {
          get: /**
           * @return {?}
           */
          function () {
              return !this._hasFloatingLabel() && this.getValue() ? '' : this.placeholder;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._createAdapter = /**
       * @private
       * @return {?}
       */
      function () {
          return Object.assign(this._isEnhancedVariant() ? this._getEnhancedSelectAdapterMethods() : this._getNativeSelectAdapterMethods(), this._getCommonAdapterMethods(), this._getOutlineAdapterMethods(), this._getLabelAdapterMethods());
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getCommonAdapterMethods = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              addClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getHostElement().classList.add(className); }),
              removeClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getHostElement().classList.remove(className); }),
              hasClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getHostElement().classList.contains(className); }),
              setRippleCenter: (/**
               * @param {?} normalizedX
               * @return {?}
               */
              function (normalizedX) { return _this._lineRipple && _this._lineRipple.setRippleCenter(normalizedX); }),
              activateBottomLine: (/**
               * @return {?}
               */
              function () {
                  if (_this._lineRipple) {
                      _this._lineRipple.activate();
                  }
              }),
              deactivateBottomLine: (/**
               * @return {?}
               */
              function () {
                  if (_this._lineRipple) {
                      _this._lineRipple.deactivate();
                  }
              }),
              notifyChange: (/**
               * @param {?} value
               * @return {?}
               */
              function (value) {
                  return _this.selectionChange.emit(new MdcSelectChange(_this, _this.getSelectedIndex(), value));
              })
          };
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getNativeSelectAdapterMethods = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              getValue: (/**
               * @return {?}
               */
              function () { return _this._platform.isBrowser ? _this._getInputElement().value : ''; }),
              setValue: (/**
               * @param {?} value
               * @return {?}
               */
              function (value) { return _this._getInputElement().value = value; }),
              isMenuOpen: (/**
               * @return {?}
               */
              function () { return false; }),
              setSelectedIndex: (/**
               * @param {?} index
               * @return {?}
               */
              function (index) { return _this._getInputElement().selectedIndex = index; }),
              setDisabled: (/**
               * @param {?} isDisabled
               * @return {?}
               */
              function (isDisabled) { return _this._getInputElement().disabled = isDisabled; }),
              setValid: (/**
               * @param {?} isValid
               * @return {?}
               */
              function (isValid) {
                  if (_this.ngControl) {
                      return;
                  }
                  isValid ? _this._getHostElement().classList.remove(cssClasses$1.INVALID) :
                      _this._getHostElement().classList.add(cssClasses$1.INVALID);
              }),
              checkValidity: (/**
               * @return {?}
               */
              function () { return _this._getInputElement().checkValidity(); })
          };
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getEnhancedSelectAdapterMethods = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              getValue: (/**
               * @return {?}
               */
              function () { return _this.getValue() || ''; }),
              openMenu: (/**
               * @return {?}
               */
              function () {
                  if (_this._menu && !_this._menu.open) {
                      _this._menu.open = true;
                      (/** @type {?} */ (_this._selectedText)).nativeElement.setAttribute('aria-expanded', 'true');
                  }
              }),
              closeMenu: (/**
               * @return {?}
               */
              function () {
                  if (_this._menu && _this._menu.open) {
                      _this._menu.open = false;
                  }
              }),
              isMenuOpen: (/**
               * @return {?}
               */
              function () { return _this._menu && _this._menu.open; }),
              setDisabled: (/**
               * @param {?} isDisabled
               * @return {?}
               */
              function (isDisabled) {
                  _this._selectedText.nativeElement.setAttribute('aria-disabled', isDisabled.toString());
              }),
              checkValidity: (/**
               * @return {?}
               */
              function () { return _this._isValid(); }),
              setValid: (/**
               * @param {?} isValid
               * @return {?}
               */
              function (isValid) {
                  _this._selectedText.nativeElement.setAttribute('aria-invalid', (!isValid).toString());
                  _this._valid = isValid;
                  isValid ? _this._getHostElement().classList.remove(cssClasses$1.INVALID) :
                      _this._getHostElement().classList.add(cssClasses$1.INVALID);
              })
          };
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getOutlineAdapterMethods = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              hasOutline: (/**
               * @return {?}
               */
              function () { return !!_this._notchedOutline; }),
              notchOutline: (/**
               * @param {?} labelWidth
               * @return {?}
               */
              function (labelWidth) { return (/** @type {?} */ (_this._notchedOutline)).notch(labelWidth); }),
              closeOutline: (/**
               * @return {?}
               */
              function () { return (/** @type {?} */ (_this._notchedOutline)).closeNotch(); })
          };
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getLabelAdapterMethods = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              floatLabel: (/**
               * @param {?} shouldFloat
               * @return {?}
               */
              function (shouldFloat) { return _this._getFloatingLabel().float(shouldFloat); }),
              getLabelWidth: (/**
               * @return {?}
               */
              function () { return _this._hasFloatingLabel() ? (/** @type {?} */ (_this._getFloatingLabel())).getWidth() : 0; })
          };
      };
      /** Returns a map of all subcomponents to subfoundations.*/
      /**
       * Returns a map of all subcomponents to subfoundations.
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getFoundationMap = /**
       * Returns a map of all subcomponents to subfoundations.
       * @private
       * @return {?}
       */
      function () {
          return {
              helperText: this._helperText || undefined
          };
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          this._setDefaultOptions();
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.ngAfterViewInit = /**
       * @return {?}
       */
      function () {
          var _this = this;
          this.init();
          if (!this._isEnhancedVariant()) {
              this._options.changes.pipe(operators.takeUntil(this._destroyed))
                  .subscribe((/**
               * @return {?}
               */
              function () {
                  _this._getFloatingLabel().float(!!_this.getValue());
                  if (_this.outlined) {
                      _this.getValue() ?
                          (/** @type {?} */ (_this._notchedOutline)).notch(_this._getFloatingLabel().getWidth()) : (/** @type {?} */ (_this._notchedOutline)).closeNotch();
                  }
              }));
          }
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._destroy();
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.ngDoCheck = /**
       * @return {?}
       */
      function () {
          if (this.ngControl) {
              // We need to re-evaluate this on every change detection cycle, because there are some
              // error triggers that we can't subscribe to (e.g. parent form submissions). This means
              // that whatever logic is in here has to be super lean or we risk destroying the performance.
              this.updateErrorState();
          }
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.init = /**
       * @return {?}
       */
      function () {
          this._foundation = new MDCSelectFoundation(this._createAdapter(), this._getFoundationMap());
          this._changeDetectorRef.detectChanges();
          // initialize after running a detectChanges()
          this._initRipple();
          this._initializeSelection();
          this._setWidth();
          this._enhancedSelectSetup();
          this._foundation.handleChange(false);
      };
      /**
       * @param {?} value
       * @return {?}
       */
      MdcSelect.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
      function (value) {
          this.setSelectionByValue(value, false);
      };
      /**
       * @param {?} fn
       * @return {?}
       */
      MdcSelect.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
      function (fn) {
          this._onChange = fn;
      };
      /**
       * @param {?} fn
       * @return {?}
       */
      MdcSelect.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
      function (fn) {
          this._onTouched = fn;
      };
      /**
       * @param {?} event
       * @return {?}
       */
      MdcSelect.prototype.onChange = /**
       * @param {?} event
       * @return {?}
       */
      function (event) {
          this.setSelectionByValue(((/** @type {?} */ (event.target))).value);
          event.stopPropagation();
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.onBlur = /**
       * @return {?}
       */
      function () {
          if (!this.disabled) {
              this._foundation.handleBlur();
              this._onTouched();
          }
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.onFocus = /**
       * @return {?}
       */
      function () {
          if (!this.disabled) {
              this._foundation.handleFocus();
              this._onTouched();
          }
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcSelect.prototype.onInteraction = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          if (this._selectedText) {
              this._selectedText.nativeElement.focus();
          }
          this._foundation.handleClick(this._getNormalizedXCoordinate(evt));
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcSelect.prototype.onKeydown = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleKeydown(evt);
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.getValue = /**
       * @return {?}
       */
      function () {
          return this._value;
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.getSelectedIndex = /**
       * @return {?}
       */
      function () {
          if (this._isEnhancedVariant()) {
              return this._list ? this._list.getSelectedIndex() : -1;
          }
          return ((/** @type {?} */ (this._getInputElement()))).selectedIndex || -1;
      };
      /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       */
      /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       * @param {?} value
       * @param {?=} isUserInput
       * @return {?}
       */
      MdcSelect.prototype.setSelectionByValue = /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       * @param {?} value
       * @param {?=} isUserInput
       * @return {?}
       */
      function (value, isUserInput) {
          if (isUserInput === void 0) { isUserInput = true; }
          if (!this._foundation) {
              return;
          }
          /** @type {?} */
          var newValue = value;
          this._setEnhancedSelection(newValue); // if enhanced select, perform selection
          if (this._value === newValue) {
              if (newValue === null) {
                  this._valid = true;
              }
              return;
          }
          this._value = newValue;
          this._foundation.setValue(this._value);
          this.valueChange.emit({ index: this.getSelectedIndex(), value: this._value });
          if (isUserInput) {
              this._onChange(this._value);
          }
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @param {?} index
       * @return {?}
       */
      MdcSelect.prototype.setSelectedIndex = /**
       * @param {?} index
       * @return {?}
       */
      function (index) {
          this._foundation.setSelectedIndex(index);
          if (this._isEnhancedVariant()) {
              this._list.setSelectedIndex(index);
          }
          /** @type {?} */
          var value = this._isEnhancedVariant() ? this._list.getSelectedValue() : this._getInputElement().value;
          this.setSelectionByValue(value);
      };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} disabled
       * @return {?}
       */
      MdcSelect.prototype.setDisabledState = 
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} disabled
       * @return {?}
       */
      function (disabled) {
          this._disabled = common$1.toBoolean(disabled);
          if (this._foundation) {
              this._foundation.setDisabled(this._disabled);
          }
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.focus = /**
       * @return {?}
       */
      function () {
          if (!this.disabled) {
              this._isEnhancedVariant() ? this._selectedText.nativeElement.focus() : this._getInputElement().focus();
          }
      };
      /**
       * @return {?}
       */
      MdcSelect.prototype.reset = /**
       * @return {?}
       */
      function () {
          if (this._isEnhancedVariant()) {
              this._enhancedSelectedText = '';
              this._list.reset();
          }
          this._value = null;
          this.valid = true;
          this.layout();
      };
      /** Initialize Select internal state based on the environment state */
      /**
       * Initialize Select internal state based on the environment state
       * @private
       * @return {?}
       */
      MdcSelect.prototype.layout = /**
       * Initialize Select internal state based on the environment state
       * @private
       * @return {?}
       */
      function () {
          if (this._foundation) {
              this._destroy();
          }
          this.init();
          this._changeDetectorRef.markForCheck();
          if (this._outlined) {
              this._foundation.layout();
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._initializeSelection = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          // Defer setting the value in order to avoid the "Expression
          // has changed after it was checked" errors from Angular.
          Promise.resolve().then((/**
           * @return {?}
           */
          function () {
              /** @type {?} */
              var value = _this.ngControl ? _this.ngControl.value : _this._value;
              if (value) {
                  _this.setSelectionByValue(value, false);
                  _this._foundation.layout();
              }
          }));
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._initHelperText = /**
       * @private
       * @return {?}
       */
      function () {
          /** @type {?} */
          var helper = this.helperText;
          if (helper) {
              helper.addHelperTextClass(this.controlType);
              helper.init(MDCSelectHelperTextFoundation);
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._initRipple = /**
       * @private
       * @return {?}
       */
      function () {
          if (!this.outlined) {
              this._ripple.init({
                  surface: this.elementRef.nativeElement,
                  activator: this._nativeSelect ? this._nativeSelect.nativeElement : this._selectedText.nativeElement
              });
          }
      };
      /** Set the default options. */
      /**
       * Set the default options.
       * @private
       * @return {?}
       */
      MdcSelect.prototype._setDefaultOptions = /**
       * Set the default options.
       * @private
       * @return {?}
       */
      function () {
          if (this._defaults && this._defaults.outlined) {
              this._outlined = this._defaults.outlined;
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._destroy = /**
       * @private
       * @return {?}
       */
      function () {
          this._destroyed.next();
          this._destroyed.complete();
          if (this._lineRipple) {
              this._lineRipple.destroy();
          }
          if (this._ripple) {
              this._ripple.destroy();
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._isEnhancedVariant = /**
       * @private
       * @return {?}
       */
      function () {
          return !!this._list;
      };
      /**
       * @private
       * @param {?} value
       * @return {?}
       */
      MdcSelect.prototype._setEnhancedSelection = /**
       * @private
       * @param {?} value
       * @return {?}
       */
      function (value) {
          if (this._isEnhancedVariant()) {
              this._list.setSelectedValue(value);
              this._enhancedSelectedText = this._list.getSelectedText();
              this._menu.open = false;
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._enhancedSelectSetup = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          if (this._isEnhancedVariant()) {
              this._menu.elementRef.nativeElement.classList.add('mdc-select__menu');
              this._menu.hoistToBody = true;
              this._menu.anchorElement = this._getHostElement();
              this._menu.wrapFocus = false;
              this._list.useSelectedClass = true;
              this._list.singleSelection = true;
              // Subscribe to menu opened event
              this._menu.opened.pipe(operators.takeUntil(this._destroyed))
                  .subscribe((/**
               * @return {?}
               */
              function () {
                  /** @type {?} */
                  var selectedIndex = _this._list.getSelectedIndex();
                  if (selectedIndex > -1) {
                      _this._list.items.toArray()[selectedIndex].focus();
                  }
              }));
              // Subscribe to menu closed event
              this._menu.closed.pipe(operators.takeUntil(this._destroyed))
                  .subscribe((/**
               * @return {?}
               */
              function () {
                  _this._selectedText.nativeElement.removeAttribute('aria-expanded');
                  if (_this._platform.isBrowser) {
                      if (document.activeElement !== _this._selectedText.nativeElement) {
                          _this._foundation.handleBlur();
                      }
                  }
              }));
              // Subscribe to menu selected event
              this._list.selectionChange.pipe(operators.takeUntil(this._destroyed))
                  .subscribe((/**
               * @param {?} evt
               * @return {?}
               */
              function (evt) {
                  _this.setSelectionByValue(evt.option.value, true);
              }));
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._isValid = /**
       * @private
       * @return {?}
       */
      function () {
          if (this.ngControl) {
              return !this.errorState;
          }
          if (this.required && !this.disabled) {
              return this.getSelectedIndex() !== -1 && (this.getSelectedIndex() !== 0 || this._value);
          }
          return true;
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._hasFloatingLabel = /**
       * @private
       * @return {?}
       */
      function () {
          return (this.placeholder && this.floatLabel) || this._required
              && (this._floatingLabel || this._notchedOutline) ? true : false;
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getFloatingLabel = /**
       * @private
       * @return {?}
       */
      function () {
          return this._floatingLabel || (/** @type {?} */ (this._notchedOutline)).floatingLabel;
      };
      /**
       * Calculates where the line ripple should start based on the x coordinate within the component.
       */
      /**
       * Calculates where the line ripple should start based on the x coordinate within the component.
       * @private
       * @param {?} evt
       * @return {?}
       */
      MdcSelect.prototype._getNormalizedXCoordinate = /**
       * Calculates where the line ripple should start based on the x coordinate within the component.
       * @private
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          /** @type {?} */
          var targetClientRect = ((/** @type {?} */ (evt.target))).getBoundingClientRect();
          if (evt instanceof MouseEvent) {
              return evt.clientX - targetClientRect.left;
          }
          /** @type {?} */
          var clientX = evt.touches[0] && evt.touches[0].clientX;
          return clientX - targetClientRect.left;
      };
      /**
       * @private
       * @return {?}
       */
      MdcSelect.prototype._setWidth = /**
       * @private
       * @return {?}
       */
      function () {
          if (this.placeholder && this.autosize) {
              /** @type {?} */
              var labelLength = this.placeholder.length;
              this._getHostElement().style.setProperty('width', labelLength + "rem");
          }
          else {
              this._getHostElement().style.removeProperty('width');
          }
      };
      /** Retrieves the select input element. */
      /**
       * Retrieves the select input element.
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getInputElement = /**
       * Retrieves the select input element.
       * @private
       * @return {?}
       */
      function () {
          return this._nativeSelect.nativeElement;
      };
      /** Retrieves the DOM element of the component host. */
      /**
       * Retrieves the DOM element of the component host.
       * @private
       * @return {?}
       */
      MdcSelect.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @private
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      MdcSelect.decorators = [
          { type: core.Component, args: [{selector: 'mdc-select',
                      exportAs: 'mdcSelect',
                      host: {
                          '[id]': 'id',
                          'class': 'mdc-select',
                          '[class.mdc-select--disabled]': 'disabled',
                          '[class.mdc-select--outlined]': 'outlined',
                          '[class.mdc-select--required]': 'required',
                          '[class.mdc-select--with-leading-icon]': 'leadingIcon',
                          '[class.mdc-select--invalid]': 'errorState'
                      },
                      template: "\n  <ng-content select=\"mdc-icon\"></ng-content>\n  <ng-container *ngIf=\"_list\">\n    <div #selectedText class=\"mdc-select__selected-text\"\n      [tabindex]=\"disabled ? '-1' : '0'\"\n      (blur)=\"onBlur()\"\n      (change)=\"onChange($event)\"\n      (focus)=\"onFocus()\"\n      (keydown)=\"onKeydown($event)\"\n      (mousedown)=\"onInteraction($event)\">{{_enhancedSelectedText}}</div>\n    <ng-content select=\"mdc-menu\"></ng-content>\n  </ng-container>\n  <i class=\"mdc-select__dropdown-icon\"></i>\n  <select #nativeSelect *ngIf=\"!_list\"\n   class=\"mdc-select__native-control\"\n   [attr.aria-describedby]=\"_ariaDescribedby || null\"\n   [required]=\"required\"\n   [value]=\"value\"\n   (mousedown)=\"onInteraction($event)\"\n   (touchstart)=\"onInteraction($event)\"\n   (blur)=\"onBlur()\"\n   (change)=\"onChange($event)\"\n   (focus)=\"onFocus()\">\n    <ng-content></ng-content>\n  </select>\n  <label mdcFloatingLabel *ngIf=\"!outlined\" [for]=\"id\">{{placeholderText}}</label>\n  <mdc-line-ripple *ngIf=\"!outlined\"></mdc-line-ripple>\n  <mdc-notched-outline *ngIf=\"outlined\" [label]=\"placeholderText\" [for]=\"id\"></mdc-notched-outline>\n  ",
                      providers: [
                          ripple.MdcRipple,
                          { provide: formField.MdcFormFieldControl, useExisting: MdcSelect }
                      ],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MdcSelect.ctorParameters = function () { return [
          { type: common$1.Platform },
          { type: core.ChangeDetectorRef },
          { type: core.ElementRef },
          { type: formField.ErrorStateMatcher },
          { type: formField.MdcFormField, decorators: [{ type: core.Optional }] },
          { type: ripple.MdcRipple, decorators: [{ type: core.Optional }] },
          { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
          { type: forms.NgForm, decorators: [{ type: core.Optional }] },
          { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
          { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_SELECT_DEFAULT_OPTIONS,] }] }
      ]; };
      MdcSelect.propDecorators = {
          id: [{ type: core.Input }],
          name: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          floatLabel: [{ type: core.Input }],
          outlined: [{ type: core.Input }],
          required: [{ type: core.Input }],
          valid: [{ type: core.Input }],
          autosize: [{ type: core.Input }],
          compareWith: [{ type: core.Input }],
          value: [{ type: core.Input }],
          helperText: [{ type: core.Input }],
          errorStateMatcher: [{ type: core.Input }],
          selectionChange: [{ type: core.Output }],
          valueChange: [{ type: core.Output }],
          _floatingLabel: [{ type: core.ViewChild, args: [floatingLabel.MdcFloatingLabel,] }],
          _lineRipple: [{ type: core.ViewChild, args: [lineRipple.MdcLineRipple,] }],
          _notchedOutline: [{ type: core.ViewChild, args: [notchedOutline.MdcNotchedOutline,] }],
          _nativeSelect: [{ type: core.ViewChild, args: ['nativeSelect',] }],
          _selectedText: [{ type: core.ViewChild, args: ['selectedText',] }],
          _menu: [{ type: core.ContentChild, args: [menu.MdcMenu,] }],
          leadingIcon: [{ type: core.ContentChild, args: [MdcSelectIcon,] }],
          _list: [{ type: core.ContentChild, args: [list.MdcList,] }],
          _options: [{ type: core.ContentChildren, args: [MdcSelectOption,] }]
      };
      return MdcSelect;
  }(_MdcSelectMixinBase));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var SELECT_DECLARATIONS = [
      MdcSelect,
      MdcSelectIcon,
      MdcSelectOption
  ];
  var MdcSelectModule = /** @class */ (function () {
      function MdcSelectModule() {
      }
      MdcSelectModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          menu.MdcMenuModule,
                          formField.MdcFormFieldModule,
                          floatingLabel.MdcFloatingLabelModule,
                          notchedOutline.MdcNotchedOutlineModule,
                          lineRipple.MdcLineRippleModule
                      ],
                      exports: [
                          menu.MdcMenuModule,
                          formField.MdcFormFieldModule,
                          SELECT_DECLARATIONS
                      ],
                      declarations: SELECT_DECLARATIONS
                  },] },
      ];
      return MdcSelectModule;
  }());

  exports.MdcSelectModule = MdcSelectModule;
  exports.MDC_SELECT_DEFAULT_OPTIONS = MDC_SELECT_DEFAULT_OPTIONS;
  exports.MdcSelectBase = MdcSelectBase;
  exports._MdcSelectMixinBase = _MdcSelectMixinBase;
  exports.MdcSelectChange = MdcSelectChange;
  exports.MdcSelectOption = MdcSelectOption;
  exports.MdcSelect = MdcSelect;
  exports.MdcSelectIcon = MdcSelectIcon;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=web-select.umd.js.map
