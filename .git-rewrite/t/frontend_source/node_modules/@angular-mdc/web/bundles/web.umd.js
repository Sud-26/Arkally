/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@angular/common/http'), require('@angular/platform-browser'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@angular-mdc/web', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators', '@angular/common/http', '@angular/platform-browser', '@angular/forms'], factory) :
    (global = global || self, factory((global.ng = global.ng || {}, global.ng.web = {}), global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators, global.ng.common.http, global.ng.platformBrowser, global.ng.forms));
}(this, function (exports, core, common, rxjs, operators, http, platformBrowser, forms) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function toBoolean(value) {
        return value != null && "" + value !== 'false';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /** @type {?} */
    var UP_ARROW = 38;
    /** @type {?} */
    var DOWN_ARROW = 40;
    /** @type {?} */
    var RIGHT_ARROW = 39;
    /** @type {?} */
    var LEFT_ARROW = 37;
    /** @type {?} */
    var PAGE_UP = 33;
    /** @type {?} */
    var PAGE_DOWN = 34;
    /** @type {?} */
    var HOME = 36;
    /** @type {?} */
    var END = 35;
    /** @type {?} */
    var ENTER = 13;
    /** @type {?} */
    var SPACE = 32;
    /** @type {?} */
    var TAB = 9;
    /** @type {?} */
    var ESCAPE = 27;
    /** @type {?} */
    var BACKSPACE = 8;
    /** @type {?} */
    var DELETE = 46;
    /** @type {?} */
    var A = 65;
    /** @type {?} */
    var Z = 90;
    /** @type {?} */
    var ZERO = 48;
    /** @type {?} */
    var NINE = 57;
    /** @type {?} */
    var COMMA = 188;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?=} fallbackValue
     * @return {?}
     */
    function toNumber(value, fallbackValue) {
        if (fallbackValue === void 0) { fallbackValue = 0; }
        return _isNumberValue(value) ? Number(value) : fallbackValue;
    }
    /**
     * Whether the provided value is considered a number.
     * @param {?} value
     * @return {?}
     */
    function _isNumberValue(value) {
        // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
        // and other non-number values as NaN, where Number just uses 0) but it considers the string
        // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
        return !isNaN(parseFloat((/** @type {?} */ (value)))) && !isNaN(Number(value));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Platform = /** @class */ (function () {
        function Platform(_platformId) {
            this._platformId = _platformId;
            this.isBrowser = this._platformId ?
                common.isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;
        }
        Platform.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] },
        ];
        /** @nocollapse */
        Platform.ctorParameters = function () { return [
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        /** @nocollapse */ Platform.ngInjectableDef = core.defineInjectable({ factory: function Platform_Factory() { return new Platform(core.inject(core.PLATFORM_ID)); }, token: Platform, providedIn: "root" });
        return Platform;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Class to coordinate unique selection based on name.
     * Intended to be consumed as an Angular service.
     * This service is needed because native radio change events are only fired on the item currently
     * being selected, and we still need to uncheck the previous selection.
     *
     * This service does not *store* any IDs and names because they may change at any time, so it is
     * less error-prone if they are simply passed through when the events occur.
     */
    var UniqueSelectionDispatcher = /** @class */ (function () {
        function UniqueSelectionDispatcher() {
            this._listeners = [];
        }
        /**
         * Notify other items that selection for the given name has been set.
         * @param id ID of the item.
         * @param name Name of the item.
         */
        /**
         * Notify other items that selection for the given name has been set.
         * @param {?} id ID of the item.
         * @param {?} name Name of the item.
         * @return {?}
         */
        UniqueSelectionDispatcher.prototype.notify = /**
         * Notify other items that selection for the given name has been set.
         * @param {?} id ID of the item.
         * @param {?} name Name of the item.
         * @return {?}
         */
        function (id, name) {
            for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {
                var listener = _a[_i];
                listener(id, name);
            }
        };
        /**
         * Listen for future changes to item selection.
         * @return Function used to deregister listener
         */
        /**
         * Listen for future changes to item selection.
         * @param {?} listener
         * @return {?} Function used to deregister listener
         */
        UniqueSelectionDispatcher.prototype.listen = /**
         * Listen for future changes to item selection.
         * @param {?} listener
         * @return {?} Function used to deregister listener
         */
        function (listener) {
            var _this = this;
            this._listeners.push(listener);
            return (/**
             * @return {?}
             */
            function () {
                _this._listeners = _this._listeners.filter((/**
                 * @param {?} registered
                 * @return {?}
                 */
                function (registered) {
                    return listener !== registered;
                }));
            });
        };
        /**
         * @return {?}
         */
        UniqueSelectionDispatcher.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._listeners = [];
        };
        UniqueSelectionDispatcher.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] },
        ];
        /** @nocollapse */ UniqueSelectionDispatcher.ngInjectableDef = core.defineInjectable({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: "root" });
        return UniqueSelectionDispatcher;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign = function __assign() {
      _assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return _assign.apply(this, arguments);
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_;

      if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_ = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_ === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_ = isSupported;
      }

      return supportsPassive_ ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation =
    /*#__PURE__*/
    function () {
      _createClass(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent =
    /*#__PURE__*/
    function () {
      _createClass(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck(this, MDCRippleAdapter);
      }

      _createClass(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits(MDCRippleFoundation, _MDCFoundation);

      _createClass(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface = function RippleCapableSurface() {
      _classCallCheck(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface.prototype.disabled;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // Activation events registered on the root element of each instance for activation
    /** @type {?} */
    var ACTIVATION_EVENT_TYPES$1 = ['touchstart', 'mousedown', 'keydown'];
    // Deactivation events registered on documentElement when a pointer-related down event occurs
    /** @type {?} */
    var POINTER_DEACTIVATION_EVENT_TYPES$1 = ['touchend', 'pointerup', 'mouseup', 'keyup', 'contextmenu'];
    /**
     * Time in milliseconds for which to ignore mouse events, after
     * receiving a touch event. Used to avoid doing double work for
     * touch devices where the browser fires fake mouse events, in
     * addition to touch events.
     * @type {?}
     */
    var MOUSE_EVENT_IGNORE_TIME = 800;
    var MdcRippleConfig = /** @class */ (function () {
        function MdcRippleConfig() {
        }
        return MdcRippleConfig;
    }());
    var MdcRipple = /** @class */ (function () {
        function MdcRipple(_ngZone, _platform) {
            this._ngZone = _ngZone;
            this._platform = _platform;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._initialized = false;
            this.initialized = this._initialized;
            /**
             * Time in milliseconds when the last touchstart event happened.
             */
            this._lastTouchStartEvent = 0;
            this._focusSubscription = null;
            this._blurSubscription = null;
            this._activationEventsSubscription = null;
            this._pointerDeactivationEventsSubscription = null;
        }
        Object.defineProperty(MdcRipple.prototype, "activationEvents", {
            /** Combined stream of all of the activation events. */
            get: /**
             * Combined stream of all of the activation events.
             * @return {?}
             */
            function () {
                var _this = this;
                return rxjs.merge.apply(void 0, ACTIVATION_EVENT_TYPES$1.map((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) {
                    return rxjs.fromEvent(_this._rippleConfig.activator ? _this._rippleConfig.activator :
                        _this._rippleConfig.surface, evt, applyPassive());
                })));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRipple.prototype, "pointerDeactivationEvents", {
            /** Combined stream of all of the de-activation events. */
            get: /**
             * Combined stream of all of the de-activation events.
             * @return {?}
             */
            function () {
                var _this = this;
                return rxjs.merge.apply(void 0, POINTER_DEACTIVATION_EVENT_TYPES$1.map((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) {
                    return rxjs.fromEvent(_this._rippleConfig.activator ? _this._rippleConfig.activator :
                        _this._rippleConfig.surface, evt, applyPassive());
                })));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcRipple.prototype.createAdapter = /**
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                browserSupportsCssVars: (/**
                 * @return {?}
                 */
                function () { return _this._platform.isBrowser ? supportsCssVariables(window) : false; }),
                isUnbounded: (/**
                 * @return {?}
                 */
                function () { return _this._rippleConfig.unbounded; }),
                isSurfaceActive: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._platform.isBrowser) {
                        return false;
                    }
                    /** @type {?} */
                    var MATCHES = getMatchesProperty(HTMLElement.prototype);
                    return _this._rippleConfig.activator ? _this._rippleConfig.activator[MATCHES](':active') :
                        _this._rippleConfig.surface[MATCHES](':active');
                }),
                isSurfaceDisabled: (/**
                 * @return {?}
                 */
                function () { return _this._rippleConfig.disabled; }),
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._rippleConfig.surface.classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._rippleConfig.surface.classList.remove(className); }),
                containsEventTarget: (/**
                 * @param {?} target
                 * @return {?}
                 */
                function (target) { return _this._rippleConfig.surface.contains(target); }),
                registerDocumentInteractionHandler: (/**
                 * @param {?} evtType
                 * @param {?} handler
                 * @return {?}
                 */
                function (evtType, handler) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    (/** @type {?} */ (document.documentElement)).addEventListener(evtType, handler, applyPassive());
                }),
                deregisterDocumentInteractionHandler: (/**
                 * @param {?} evtType
                 * @param {?} handler
                 * @return {?}
                 */
                function (evtType, handler) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    (/** @type {?} */ (document.documentElement)).removeEventListener(evtType, handler, applyPassive());
                }),
                registerResizeHandler: (/**
                 * @param {?} handler
                 * @return {?}
                 */
                function (handler) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    window.addEventListener('resize', handler);
                }),
                deregisterResizeHandler: (/**
                 * @param {?} handler
                 * @return {?}
                 */
                function (handler) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    window.removeEventListener('resize', handler);
                }),
                updateCssVariable: (/**
                 * @param {?} varName
                 * @param {?} value
                 * @return {?}
                 */
                function (varName, value) {
                    return _this._rippleConfig.surface.style.setProperty(varName, value);
                }),
                computeBoundingRect: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._platform.isBrowser) {
                        return {};
                    }
                    return _this._rippleConfig.surface.getBoundingClientRect();
                }),
                getWindowPageOffset: (/**
                 * @return {?}
                 */
                function () { return ({
                    x: _this._platform.isBrowser ? window.pageXOffset : 0,
                    y: _this._platform.isBrowser ? window.pageYOffset : 0
                }); })
            };
        };
        /**
         * @param {?} config
         * @param {?=} adapter
         * @return {?}
         */
        MdcRipple.prototype.init = /**
         * @param {?} config
         * @param {?=} adapter
         * @return {?}
         */
        function (config, adapter) {
            if (!this._platform.isBrowser) {
                return;
            }
            this._rippleConfig = config;
            this._foundation = new MDCRippleFoundation(adapter || this.createAdapter());
            this._loadListeners();
            this._foundation.init();
            this._initialized = true;
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.destroy = /**
         * @return {?}
         */
        function () {
            if (!this._platform.isBrowser) {
                return;
            }
            this._destroy.next();
            this._destroy.complete();
            this._unloadListeners();
            if (this._foundation) {
                this._foundation.destroy();
            }
            this._initialized = false;
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroy();
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        MdcRipple.prototype.activateRipple = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            if (event) {
                if (event instanceof MouseEvent) {
                    /** @type {?} */
                    var isSyntheticEvent = this._lastTouchStartEvent &&
                        Date.now() < this._lastTouchStartEvent + MOUSE_EVENT_IGNORE_TIME;
                    if (isSyntheticEvent) {
                        return;
                    }
                }
                else {
                    this._lastTouchStartEvent = Date.now();
                }
            }
            setTimeout((/**
             * @return {?}
             */
            function () { return _this._foundation.activate(event); }));
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        MdcRipple.prototype.deactivateRipple = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            setTimeout((/**
             * @return {?}
             */
            function () { return _this._foundation.deactivate(event); }));
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.handleFocus = /**
         * @return {?}
         */
        function () {
            this._foundation.handleFocus();
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.handleBlur = /**
         * @return {?}
         */
        function () {
            this._foundation.handleBlur();
        };
        /**
         * @private
         * @return {?}
         */
        MdcRipple.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._activationEventsSubscription = this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return _this.activationEvents.pipe(operators.takeUntil(_this._destroy))
                    .subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.activateRipple(event); })); }));
            }));
            this._pointerDeactivationEventsSubscription = this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return _this.pointerDeactivationEvents.pipe(operators.takeUntil(_this._destroy))
                    .subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.deactivateRipple(event); })); }));
            }));
            this._focusSubscription = this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._rippleConfig.activator ?
                    _this._rippleConfig.activator : _this._rippleConfig.surface, 'focus').pipe(operators.takeUntil(_this._destroy))
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.handleFocus(); })); }));
            }));
            this._blurSubscription = this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._rippleConfig.activator ?
                    _this._rippleConfig.activator : _this._rippleConfig.surface, 'blur').pipe(operators.takeUntil(_this._destroy))
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.handleBlur(); })); }));
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcRipple.prototype._unloadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._activationEventsSubscription) {
                this._activationEventsSubscription.unsubscribe();
                this._activationEventsSubscription = null;
            }
            if (this._pointerDeactivationEventsSubscription) {
                this._pointerDeactivationEventsSubscription.unsubscribe();
                this._pointerDeactivationEventsSubscription = null;
            }
            if (this._focusSubscription) {
                this._focusSubscription.unsubscribe();
                this._focusSubscription = null;
            }
            if (this._blurSubscription) {
                this._blurSubscription.unsubscribe();
                this._blurSubscription = null;
            }
        };
        MdcRipple.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MdcRipple.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: Platform }
        ]; };
        return MdcRipple;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcRippleComponent = /** @class */ (function () {
        function MdcRippleComponent(_changeDetectorRef, _ripple, elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._ripple = _ripple;
            this.elementRef = elementRef;
            this._attachTo = this._getHostElement();
            this._primary = false;
            this._secondary = false;
            this._disabled = false;
            this._unbounded = false;
        }
        Object.defineProperty(MdcRippleComponent.prototype, "ripple", {
            get: /**
             * @return {?}
             */
            function () {
                return this._ripple;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "attachTo", {
            get: /**
             * @return {?}
             */
            function () { return this._attachTo; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (this._attachTo) {
                    this._attachTo.classList.remove('mdc-ripple-surface');
                }
                this._attachTo = element;
                if (this._attachTo) {
                    this._attachTo.classList.add('mdc-ripple-surface');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._primary = toBoolean(value);
                this._primary ? this.attachTo.classList.add('mdc-ripple-surface--primary')
                    : this.attachTo.classList.remove('mdc-ripple-surface--primary');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._secondary = toBoolean(value);
                this._secondary ? this.attachTo.classList.add('mdc-ripple-surface--accent')
                    : this.attachTo.classList.remove('mdc-ripple-surface--accent');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "unbounded", {
            get: /**
             * @return {?}
             */
            function () { return this._unbounded; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._unbounded = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcRippleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._initRipple();
        };
        /**
         * @return {?}
         */
        MdcRippleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
        };
        /**
         * @private
         * @return {?}
         */
        MdcRippleComponent.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.ripple.init({
                surface: this._attachTo
            }, Object.assign(this.ripple.createAdapter(), {
                isUnbounded: (/**
                 * @return {?}
                 */
                function () { return _this._unbounded; }),
                isSurfaceDisabled: (/**
                 * @return {?}
                 */
                function () { return _this._disabled; })
            }));
            this._changeDetectorRef.markForCheck();
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcRippleComponent.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcRippleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'mdc-ripple, [mdc-ripple]',
                        template: '<ng-content></ng-content>',
                        providers: [MdcRipple],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcRippleComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.ElementRef }
        ]; };
        MdcRippleComponent.propDecorators = {
            attachTo: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            unbounded: [{ type: core.Input }]
        };
        return MdcRippleComponent;
    }());
    var MdcRippleDirective = /** @class */ (function (_super) {
        __extends(MdcRippleDirective, _super);
        function MdcRippleDirective(_changeDetectorRef, _ripple, elementRef) {
            var _this = _super.call(this, _changeDetectorRef, _ripple, elementRef) || this;
            _this._unbounded = true;
            _this.elementRef.nativeElement.setAttribute('data-mdc-ripple-is-unbounded', '');
            return _this;
        }
        MdcRippleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcRipple]',
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcRippleDirective.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.ElementRef }
        ]; };
        return MdcRippleDirective;
    }(MdcRippleComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcRippleModule = /** @class */ (function () {
        function MdcRippleModule() {
        }
        MdcRippleModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcRippleComponent, MdcRippleDirective],
                        declarations: [MdcRippleComponent, MdcRippleDirective],
                    },] },
        ];
        return MdcRippleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcMaterialIcons = /** @class */ (function () {
        function MdcMaterialIcons() {
        }
        MdcMaterialIcons.decorators = [
            { type: core.Directive, args: [{
                        selector: '[materialIcons]',
                        host: {
                            'class': 'material-icons'
                        }
                    },] },
        ];
        return MdcMaterialIcons;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns an exception to be thrown in the case when attempting to
     * load an icon with a name that cannot be found.
     * @param {?} iconName
     * @return {?}
     */
    function getMdcIconNameNotFoundError(iconName) {
        return Error("Unable to find icon with the name \"" + iconName + "\"");
    }
    /**
     * Returns an exception to be thrown when the consumer attempts to use
     * `<mdc-icon>` without including \@angular/http.
     * \@docs-private
     * @return {?}
     */
    function getMdcIconNoHttpProviderError() {
        return Error('Could not find HttpClient provider for use with Angular Material icons. ' +
            'Please include the HttpClientModule from @angular/common/http in your ' +
            'app imports.');
    }
    /**
     * Returns an exception to be thrown when a URL couldn't be sanitized.
     * \@docs-private
     * @param {?} url URL that was attempted to be sanitized.
     * @return {?}
     */
    function getMdcIconFailedToSanitizeUrlError(url) {
        return Error("The URL provided to MatIconRegistry was not trusted as a resource URL " +
            ("via Angular's DomSanitizer. Attempted URL was \"" + url + "\"."));
    }
    /**
     * Returns an exception to be thrown when a HTML string couldn't be sanitized.
     * \@docs-private
     * @param {?} literal HTML that was attempted to be sanitized.
     * @return {?}
     */
    function getMdcIconFailedToSanitizeLiteralError(literal) {
        return Error("The literal provided to MatIconRegistry was not trusted as safe HTML by " +
            ("Angular's DomSanitizer. Attempted literal was \"" + literal + "\"."));
    }
    /**
     * Configuration for an icon, including the URL and possibly the cached SVG element.
     * \@docs-private
     */
    var /**
     * Configuration for an icon, including the URL and possibly the cached SVG element.
     * \@docs-private
     */
    SvgIconConfig = /** @class */ (function () {
        function SvgIconConfig(data) {
            this.url = null;
            this.svgElement = null;
            // Note that we can't use `instanceof SVGElement` here,
            // because it'll break during server-side rendering.
            if (!!((/** @type {?} */ (data))).nodeName) {
                this.svgElement = (/** @type {?} */ (data));
            }
            else {
                this.url = (/** @type {?} */ (data));
            }
        }
        return SvgIconConfig;
    }());
    /**
     * Service to register and display icons used by the `<mdc-icon>` component.
     * - Registers icon URLs by namespace and name.
     * - Registers icon set URLs by namespace.
     * - Registers aliases for CSS classes, for use with icon fonts.
     * - Loads icons from URLs and extracts individual icons from icon sets.
     */
    var MdcIconRegistry = /** @class */ (function () {
        function MdcIconRegistry(_httpClient, _sanitizer, document) {
            this._httpClient = _httpClient;
            this._sanitizer = _sanitizer;
            /**
             * URLs and cached SVG elements for individual icons. Keys are of the format "[namespace]:[icon]".
             */
            this._svgIconConfigs = new Map();
            /**
             * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.
             * Multiple icon sets can be registered under the same namespace.
             */
            this._iconSetConfigs = new Map();
            /**
             * Cache for icons loaded by direct URLs.
             */
            this._cachedIconsByUrl = new Map();
            /**
             * In-progress icon fetches. Used to coalesce multiple requests to the same URL.
             */
            this._inProgressUrlFetches = new Map();
            /**
             * Map from font identifiers to their CSS class names. Used for icon fonts.
             */
            this._fontCssClassesByAlias = new Map();
            /**
             * The CSS classes to apply when an `<mdc-icon>` component has no icon name, url, or font specified.
             * The default 'material-icons' value assumes that the material icon font has been loaded as
             * described at http://google.github.io/material-design-icons/#icon-font-for-the-web
             */
            this._defaultFontSetClass = ['material-icons'];
            this._document = document;
        }
        /**
         * Registers an icon by URL in the default namespace.
         * @param iconName Name under which the icon should be registered.
         * @param url
         */
        /**
         * Registers an icon by URL in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} url
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIcon = /**
         * Registers an icon by URL in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} url
         * @return {THIS}
         */
        function (iconName, url) {
            return (/** @type {?} */ (this)).addSvgIconInNamespace('', iconName, url);
        };
        /**
         * Registers an icon using an HTML string in the default namespace.
         * @param iconName Name under which the icon should be registered.
         * @param literal SVG source of the icon.
         */
        /**
         * Registers an icon using an HTML string in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} literal SVG source of the icon.
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIconLiteral = /**
         * Registers an icon using an HTML string in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} literal SVG source of the icon.
         * @return {THIS}
         */
        function (iconName, literal) {
            return (/** @type {?} */ (this)).addSvgIconLiteralInNamespace('', iconName, literal);
        };
        /**
         * Registers an icon by URL in the specified namespace.
         * @param namespace Namespace in which the icon should be registered.
         * @param iconName Name under which the icon should be registered.
         * @param url
         */
        /**
         * Registers an icon by URL in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which the icon should be registered.
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} url
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIconInNamespace = /**
         * Registers an icon by URL in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which the icon should be registered.
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} url
         * @return {THIS}
         */
        function (namespace, iconName, url) {
            return (/** @type {?} */ (this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url));
        };
        /**
         * Registers an icon using an HTML string in the specified namespace.
         * @param namespace Namespace in which the icon should be registered.
         * @param iconName Name under which the icon should be registered.
         * @param literal SVG source of the icon.
         */
        /**
         * Registers an icon using an HTML string in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which the icon should be registered.
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} literal SVG source of the icon.
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIconLiteralInNamespace = /**
         * Registers an icon using an HTML string in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which the icon should be registered.
         * @param {?} iconName Name under which the icon should be registered.
         * @param {?} literal SVG source of the icon.
         * @return {THIS}
         */
        function (namespace, iconName, literal) {
            /** @type {?} */
            var sanitizedLiteral = (/** @type {?} */ (this))._sanitizer.sanitize(core.SecurityContext.HTML, literal);
            if (!sanitizedLiteral) {
                throw getMdcIconFailedToSanitizeLiteralError(literal);
            }
            /** @type {?} */
            var svgElement = (/** @type {?} */ (this))._createSvgElementForSingleIcon(sanitizedLiteral);
            return (/** @type {?} */ (this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));
        };
        /**
         * Registers an icon set by URL in the default namespace.
         * @param url
         */
        /**
         * Registers an icon set by URL in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} url
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIconSet = /**
         * Registers an icon set by URL in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} url
         * @return {THIS}
         */
        function (url) {
            return (/** @type {?} */ (this)).addSvgIconSetInNamespace('', url);
        };
        /**
         * Registers an icon set using an HTML string in the default namespace.
         * @param literal SVG source of the icon set.
         */
        /**
         * Registers an icon set using an HTML string in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} literal SVG source of the icon set.
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIconSetLiteral = /**
         * Registers an icon set using an HTML string in the default namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} literal SVG source of the icon set.
         * @return {THIS}
         */
        function (literal) {
            return (/** @type {?} */ (this)).addSvgIconSetLiteralInNamespace('', literal);
        };
        /**
         * Registers an icon set by URL in the specified namespace.
         * @param namespace Namespace in which to register the icon set.
         * @param url
         */
        /**
         * Registers an icon set by URL in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon set.
         * @param {?} url
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIconSetInNamespace = /**
         * Registers an icon set by URL in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon set.
         * @param {?} url
         * @return {THIS}
         */
        function (namespace, url) {
            return (/** @type {?} */ (this))._addSvgIconSetConfig(namespace, new SvgIconConfig(url));
        };
        /**
         * Registers an icon set using an HTML string in the specified namespace.
         * @param namespace Namespace in which to register the icon set.
         * @param literal SVG source of the icon set.
         */
        /**
         * Registers an icon set using an HTML string in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon set.
         * @param {?} literal SVG source of the icon set.
         * @return {THIS}
         */
        MdcIconRegistry.prototype.addSvgIconSetLiteralInNamespace = /**
         * Registers an icon set using an HTML string in the specified namespace.
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon set.
         * @param {?} literal SVG source of the icon set.
         * @return {THIS}
         */
        function (namespace, literal) {
            /** @type {?} */
            var sanitizedLiteral = (/** @type {?} */ (this))._sanitizer.sanitize(core.SecurityContext.HTML, literal);
            if (!sanitizedLiteral) {
                throw getMdcIconFailedToSanitizeLiteralError(literal);
            }
            /** @type {?} */
            var svgElement = (/** @type {?} */ (this))._svgElementFromString(sanitizedLiteral);
            return (/** @type {?} */ (this))._addSvgIconSetConfig(namespace, new SvgIconConfig(svgElement));
        };
        /**
         * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdcIcon
         * component with the alias as the fontSet input will cause the class name to be applied
         * to the `<mdc-icon>` element.
         *
         * @param alias Alias for the font.
         * @param className Class name override to be used instead of the alias.
         */
        /**
         * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdcIcon
         * component with the alias as the fontSet input will cause the class name to be applied
         * to the `<mdc-icon>` element.
         *
         * @template THIS
         * @this {THIS}
         * @param {?} alias Alias for the font.
         * @param {?=} className Class name override to be used instead of the alias.
         * @return {THIS}
         */
        MdcIconRegistry.prototype.registerFontClassAlias = /**
         * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdcIcon
         * component with the alias as the fontSet input will cause the class name to be applied
         * to the `<mdc-icon>` element.
         *
         * @template THIS
         * @this {THIS}
         * @param {?} alias Alias for the font.
         * @param {?=} className Class name override to be used instead of the alias.
         * @return {THIS}
         */
        function (alias, className) {
            if (className === void 0) { className = alias; }
            (/** @type {?} */ (this))._fontCssClassesByAlias.set(alias, className);
            return (/** @type {?} */ (this));
        };
        /**
         * Returns the CSS class name associated with the alias by a previous call to
         * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
         */
        /**
         * Returns the CSS class name associated with the alias by a previous call to
         * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
         * @param {?} alias
         * @return {?}
         */
        MdcIconRegistry.prototype.classNameForFontAlias = /**
         * Returns the CSS class name associated with the alias by a previous call to
         * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
         * @param {?} alias
         * @return {?}
         */
        function (alias) {
            return this._fontCssClassesByAlias.get(alias) || alias;
        };
        /**
         * Sets the CSS class name to be used for icon fonts when an `<mdc-icon>` component does not
         * have a fontSet input value, and is not loading an icon by name or URL.
         *
         * @param className
         */
        /**
         * Sets the CSS class name to be used for icon fonts when an `<mdc-icon>` component does not
         * have a fontSet input value, and is not loading an icon by name or URL.
         *
         * @template THIS
         * @this {THIS}
         * @param {...?} classNames
         * @return {THIS}
         */
        MdcIconRegistry.prototype.setDefaultFontSetClass = /**
         * Sets the CSS class name to be used for icon fonts when an `<mdc-icon>` component does not
         * have a fontSet input value, and is not loading an icon by name or URL.
         *
         * @template THIS
         * @this {THIS}
         * @param {...?} classNames
         * @return {THIS}
         */
        function () {
            var classNames = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                classNames[_i] = arguments[_i];
            }
            (/** @type {?} */ (this))._defaultFontSetClass = classNames;
            return (/** @type {?} */ (this));
        };
        /**
         * Returns the CSS class name to be used for icon fonts when an `<mdc-icon>` component does not
         * have a fontSet input value, and is not loading an icon by name or URL.
         */
        /**
         * Returns the CSS class name to be used for icon fonts when an `<mdc-icon>` component does not
         * have a fontSet input value, and is not loading an icon by name or URL.
         * @return {?}
         */
        MdcIconRegistry.prototype.getDefaultFontSetClass = /**
         * Returns the CSS class name to be used for icon fonts when an `<mdc-icon>` component does not
         * have a fontSet input value, and is not loading an icon by name or URL.
         * @return {?}
         */
        function () {
            return this._defaultFontSetClass;
        };
        /**
         * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.
         * The response from the URL may be cached so this will not always cause an HTTP request, but
         * the produced element will always be a new copy of the originally fetched icon. (That is,
         * it will not contain any modifications made to elements previously returned).
         *
         * @param safeUrl URL from which to fetch the SVG icon.
         */
        /**
         * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.
         * The response from the URL may be cached so this will not always cause an HTTP request, but
         * the produced element will always be a new copy of the originally fetched icon. (That is,
         * it will not contain any modifications made to elements previously returned).
         *
         * @param {?} safeUrl URL from which to fetch the SVG icon.
         * @return {?}
         */
        MdcIconRegistry.prototype.getSvgIconFromUrl = /**
         * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.
         * The response from the URL may be cached so this will not always cause an HTTP request, but
         * the produced element will always be a new copy of the originally fetched icon. (That is,
         * it will not contain any modifications made to elements previously returned).
         *
         * @param {?} safeUrl URL from which to fetch the SVG icon.
         * @return {?}
         */
        function (safeUrl) {
            var _this = this;
            /** @type {?} */
            var url = this._sanitizer.sanitize(core.SecurityContext.RESOURCE_URL, safeUrl);
            if (!url) {
                throw getMdcIconFailedToSanitizeUrlError(safeUrl);
            }
            /** @type {?} */
            var cachedIcon = this._cachedIconsByUrl.get(url);
            if (cachedIcon) {
                return rxjs.of(cloneSvg(cachedIcon));
            }
            return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(operators.tap((/**
             * @param {?} svg
             * @return {?}
             */
            function (svg) { return _this._cachedIconsByUrl.set((/** @type {?} */ (url)), svg); })), operators.map((/**
             * @param {?} svg
             * @return {?}
             */
            function (svg) { return cloneSvg(svg); })));
        };
        /**
         * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name
         * and namespace. The icon must have been previously registered with addIcon or addIconSet;
         * if not, the Observable will throw an error.
         *
         * @param name Name of the icon to be retrieved.
         * @param namespace Namespace in which to look for the icon.
         */
        /**
         * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name
         * and namespace. The icon must have been previously registered with addIcon or addIconSet;
         * if not, the Observable will throw an error.
         *
         * @param {?} name Name of the icon to be retrieved.
         * @param {?=} namespace Namespace in which to look for the icon.
         * @return {?}
         */
        MdcIconRegistry.prototype.getNamedSvgIcon = /**
         * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name
         * and namespace. The icon must have been previously registered with addIcon or addIconSet;
         * if not, the Observable will throw an error.
         *
         * @param {?} name Name of the icon to be retrieved.
         * @param {?=} namespace Namespace in which to look for the icon.
         * @return {?}
         */
        function (name, namespace) {
            if (namespace === void 0) { namespace = ''; }
            // Return (copy of) cached icon if possible.
            /** @type {?} */
            var key = iconKey(namespace, name);
            /** @type {?} */
            var config = this._svgIconConfigs.get(key);
            if (config) {
                return this._getSvgFromConfig(config);
            }
            // See if we have any icon sets registered for the namespace.
            /** @type {?} */
            var iconSetConfigs = this._iconSetConfigs.get(namespace);
            if (iconSetConfigs) {
                return this._getSvgFromIconSetConfigs(name, iconSetConfigs);
            }
            return rxjs.throwError(getMdcIconNameNotFoundError(key));
        };
        /**
         * @return {?}
         */
        MdcIconRegistry.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._svgIconConfigs.clear();
            this._iconSetConfigs.clear();
            this._cachedIconsByUrl.clear();
        };
        /**
         * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
         */
        /**
         * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
         * @private
         * @param {?} config
         * @return {?}
         */
        MdcIconRegistry.prototype._getSvgFromConfig = /**
         * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
         * @private
         * @param {?} config
         * @return {?}
         */
        function (config) {
            if (config.svgElement) {
                // We already have the SVG element for this icon, return a copy.
                return rxjs.of(cloneSvg(config.svgElement));
            }
            else {
                // Fetch the icon from the config's URL, cache it, and return a copy.
                return this._loadSvgIconFromConfig(config).pipe(operators.tap((/**
                 * @param {?} svg
                 * @return {?}
                 */
                function (svg) { return config.svgElement = svg; })), operators.map((/**
                 * @param {?} svg
                 * @return {?}
                 */
                function (svg) { return cloneSvg(svg); })));
            }
        };
        /**
         * Attempts to find an icon with the specified name in any of the SVG icon sets.
         * First searches the available cached icons for a nested element with a matching name, and
         * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets
         * that have not been cached, and searches again after all fetches are completed.
         * The returned Observable produces the SVG element if possible, and throws
         * an error if no icon with the specified name can be found.
         */
        /**
         * Attempts to find an icon with the specified name in any of the SVG icon sets.
         * First searches the available cached icons for a nested element with a matching name, and
         * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets
         * that have not been cached, and searches again after all fetches are completed.
         * The returned Observable produces the SVG element if possible, and throws
         * an error if no icon with the specified name can be found.
         * @private
         * @param {?} name
         * @param {?} iconSetConfigs
         * @return {?}
         */
        MdcIconRegistry.prototype._getSvgFromIconSetConfigs = /**
         * Attempts to find an icon with the specified name in any of the SVG icon sets.
         * First searches the available cached icons for a nested element with a matching name, and
         * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets
         * that have not been cached, and searches again after all fetches are completed.
         * The returned Observable produces the SVG element if possible, and throws
         * an error if no icon with the specified name can be found.
         * @private
         * @param {?} name
         * @param {?} iconSetConfigs
         * @return {?}
         */
        function (name, iconSetConfigs) {
            var _this = this;
            // For all the icon set SVG elements we've fetched, see if any contain an icon with the
            // requested name.
            /** @type {?} */
            var namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
            if (namedIcon) {
                // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every
                // time anyway, there's probably not much advantage compared to just always extracting
                // it from the icon set.
                return rxjs.of(namedIcon);
            }
            // Not found in any cached icon sets. If there are icon sets with URLs that we haven't
            // fetched, fetch them now and look for iconName in the results.
            /** @type {?} */
            var iconSetFetchRequests = iconSetConfigs
                .filter((/**
             * @param {?} iconSetConfig
             * @return {?}
             */
            function (iconSetConfig) { return !iconSetConfig.svgElement; }))
                .map((/**
             * @param {?} iconSetConfig
             * @return {?}
             */
            function (iconSetConfig) {
                return _this._loadSvgIconSetFromConfig(iconSetConfig).pipe(operators.catchError((/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    /** @type {?} */
                    var url = _this._sanitizer.sanitize(core.SecurityContext.RESOURCE_URL, iconSetConfig.url);
                    // Swallow errors fetching individual URLs so the
                    // combined Observable won't necessarily fail.
                    console.error("Loading icon set URL: " + url + " failed: " + err.message);
                    return rxjs.of(null);
                })));
            }));
            // Fetch all the icon set URLs. When the requests complete, every IconSet should have a
            // cached SVG element (unless the request failed), and we can check again for the icon.
            return rxjs.forkJoin(iconSetFetchRequests).pipe(operators.map((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);
                if (!foundIcon) {
                    throw getMdcIconNameNotFoundError(name);
                }
                return foundIcon;
            })));
        };
        /**
         * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
         * tag matches the specified name. If found, copies the nested element to a new SVG element and
         * returns it. Returns null if no matching element is found.
         */
        /**
         * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
         * tag matches the specified name. If found, copies the nested element to a new SVG element and
         * returns it. Returns null if no matching element is found.
         * @private
         * @param {?} iconName
         * @param {?} iconSetConfigs
         * @return {?}
         */
        MdcIconRegistry.prototype._extractIconWithNameFromAnySet = /**
         * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
         * tag matches the specified name. If found, copies the nested element to a new SVG element and
         * returns it. Returns null if no matching element is found.
         * @private
         * @param {?} iconName
         * @param {?} iconSetConfigs
         * @return {?}
         */
        function (iconName, iconSetConfigs) {
            // Iterate backwards, so icon sets added later have precedence.
            for (var i = iconSetConfigs.length - 1; i >= 0; i--) {
                /** @type {?} */
                var config = iconSetConfigs[i];
                if (config.svgElement) {
                    /** @type {?} */
                    var foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName);
                    if (foundIcon) {
                        return foundIcon;
                    }
                }
            }
            return null;
        };
        /**
         * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
         * from it.
         */
        /**
         * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
         * from it.
         * @private
         * @param {?} config
         * @return {?}
         */
        MdcIconRegistry.prototype._loadSvgIconFromConfig = /**
         * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
         * from it.
         * @private
         * @param {?} config
         * @return {?}
         */
        function (config) {
            var _this = this;
            return this._fetchUrl(config.url)
                .pipe(operators.map((/**
             * @param {?} svgText
             * @return {?}
             */
            function (svgText) { return _this._createSvgElementForSingleIcon(svgText); })));
        };
        /**
         * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
         * from it.
         */
        /**
         * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
         * from it.
         * @private
         * @param {?} config
         * @return {?}
         */
        MdcIconRegistry.prototype._loadSvgIconSetFromConfig = /**
         * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
         * from it.
         * @private
         * @param {?} config
         * @return {?}
         */
        function (config) {
            var _this = this;
            // If the SVG for this icon set has already been parsed, do nothing.
            if (config.svgElement) {
                return rxjs.of(config.svgElement);
            }
            return this._fetchUrl(config.url).pipe(operators.map((/**
             * @param {?} svgText
             * @return {?}
             */
            function (svgText) {
                // It is possible that the icon set was parsed and cached by an earlier request, so parsing
                // only needs to occur if the cache is yet unset.
                if (!config.svgElement) {
                    config.svgElement = _this._svgElementFromString(svgText);
                }
                return config.svgElement;
            })));
        };
        /**
         * Creates a DOM element from the given SVG string, and adds default attributes.
         */
        /**
         * Creates a DOM element from the given SVG string, and adds default attributes.
         * @private
         * @param {?} responseText
         * @return {?}
         */
        MdcIconRegistry.prototype._createSvgElementForSingleIcon = /**
         * Creates a DOM element from the given SVG string, and adds default attributes.
         * @private
         * @param {?} responseText
         * @return {?}
         */
        function (responseText) {
            /** @type {?} */
            var svg = this._svgElementFromString(responseText);
            this._setSvgAttributes(svg);
            return svg;
        };
        /**
         * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
         * tag matches the specified name. If found, copies the nested element to a new SVG element and
         * returns it. Returns null if no matching element is found.
         */
        /**
         * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
         * tag matches the specified name. If found, copies the nested element to a new SVG element and
         * returns it. Returns null if no matching element is found.
         * @private
         * @param {?} iconSet
         * @param {?} iconName
         * @return {?}
         */
        MdcIconRegistry.prototype._extractSvgIconFromSet = /**
         * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
         * tag matches the specified name. If found, copies the nested element to a new SVG element and
         * returns it. Returns null if no matching element is found.
         * @private
         * @param {?} iconSet
         * @param {?} iconName
         * @return {?}
         */
        function (iconSet, iconName) {
            /** @type {?} */
            var iconSource = iconSet.querySelector('#' + iconName);
            if (!iconSource) {
                return null;
            }
            // Clone the element and remove the ID to prevent multiple elements from being added
            // to the page with the same ID.
            /** @type {?} */
            var iconElement = (/** @type {?} */ (iconSource.cloneNode(true)));
            iconElement.removeAttribute('id');
            // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as
            // the content of a new <svg> node.
            if (iconElement.nodeName.toLowerCase() === 'svg') {
                return this._setSvgAttributes((/** @type {?} */ (iconElement)));
            }
            // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note
            // that the same could be achieved by referring to it via <use href="#id">, however the <use>
            // tag is problematic on Firefox, because it needs to include the current page path.
            if (iconElement.nodeName.toLowerCase() === 'symbol') {
                return this._setSvgAttributes(this._toSvgElement(iconElement));
            }
            // createElement('SVG') doesn't work as expected; the DOM ends up with
            // the correct nodes, but the SVG content doesn't render. Instead we
            // have to create an empty SVG node using innerHTML and append its content.
            // Elements created using DOMParser.parseFromString have the same problem.
            // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display
            /** @type {?} */
            var svg = this._svgElementFromString('<svg></svg>');
            // Clone the node so we don't remove it from the parent icon set element.
            svg.appendChild(iconElement);
            return this._setSvgAttributes(svg);
        };
        /**
         * Creates a DOM element from the given SVG string.
         */
        /**
         * Creates a DOM element from the given SVG string.
         * @private
         * @param {?} str
         * @return {?}
         */
        MdcIconRegistry.prototype._svgElementFromString = /**
         * Creates a DOM element from the given SVG string.
         * @private
         * @param {?} str
         * @return {?}
         */
        function (str) {
            /** @type {?} */
            var div = this._document.createElement('DIV');
            div.innerHTML = str;
            /** @type {?} */
            var svg = (/** @type {?} */ (div.querySelector('svg')));
            if (!svg) {
                throw Error('<svg> tag not found');
            }
            else {
                /** @type {?} */
                var viewBox = svg.getAttribute('viewBox');
                if (viewBox) {
                    svg.setAttribute('viewBox', viewBox);
                }
            }
            return svg;
        };
        /**
         * Converts an element into an SVG node by cloning all of its children.
         */
        /**
         * Converts an element into an SVG node by cloning all of its children.
         * @private
         * @param {?} element
         * @return {?}
         */
        MdcIconRegistry.prototype._toSvgElement = /**
         * Converts an element into an SVG node by cloning all of its children.
         * @private
         * @param {?} element
         * @return {?}
         */
        function (element) {
            /** @type {?} */
            var svg = this._svgElementFromString('<svg></svg>');
            for (var i = 0; i < element.childNodes.length; i++) {
                if (element.childNodes[i].nodeType === this._document.ELEMENT_NODE) {
                    svg.appendChild(element.childNodes[i].cloneNode(true));
                }
            }
            return svg;
        };
        /**
         * Sets the default attributes for an SVG element to be used as an icon.
         */
        /**
         * Sets the default attributes for an SVG element to be used as an icon.
         * @private
         * @param {?} svg
         * @return {?}
         */
        MdcIconRegistry.prototype._setSvgAttributes = /**
         * Sets the default attributes for an SVG element to be used as an icon.
         * @private
         * @param {?} svg
         * @return {?}
         */
        function (svg) {
            svg.setAttribute('fit', '');
            svg.setAttribute('height', '100%');
            svg.setAttribute('width', '100%');
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
            return svg;
        };
        /**
         * Returns an Observable which produces the string contents of the given URL. Results may be
         * cached, so future calls with the same URL may not cause another HTTP request.
         */
        /**
         * Returns an Observable which produces the string contents of the given URL. Results may be
         * cached, so future calls with the same URL may not cause another HTTP request.
         * @private
         * @param {?} safeUrl
         * @return {?}
         */
        MdcIconRegistry.prototype._fetchUrl = /**
         * Returns an Observable which produces the string contents of the given URL. Results may be
         * cached, so future calls with the same URL may not cause another HTTP request.
         * @private
         * @param {?} safeUrl
         * @return {?}
         */
        function (safeUrl) {
            var _this = this;
            if (!this._httpClient) {
                throw getMdcIconNoHttpProviderError();
            }
            if (safeUrl == null) {
                throw Error("Cannot fetch icon from URL \"" + safeUrl + "\".");
            }
            /** @type {?} */
            var url = this._sanitizer.sanitize(core.SecurityContext.RESOURCE_URL, safeUrl);
            if (!url) {
                throw getMdcIconFailedToSanitizeUrlError(safeUrl);
            }
            // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
            // already a request in progress for that URL. It's necessary to call share() on the
            // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
            /** @type {?} */
            var inProgressFetch = this._inProgressUrlFetches.get(url);
            if (inProgressFetch) {
                return inProgressFetch;
            }
            // TODO(jelbourn): for some reason, the `finalize` operator "loses" the generic type on the
            // Observable. Figure out why and fix it.
            /** @type {?} */
            var req = this._httpClient.get(url, { responseType: 'text' }).pipe(operators.finalize((/**
             * @return {?}
             */
            function () { return _this._inProgressUrlFetches.delete(url); })), operators.share());
            this._inProgressUrlFetches.set(url, req);
            return req;
        };
        /**
         * Registers an icon config by name in the specified namespace.
         * @param namespace Namespace in which to register the icon config.
         * @param iconName Name under which to register the config.
         * @param config Config to be registered.
         */
        /**
         * Registers an icon config by name in the specified namespace.
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon config.
         * @param {?} iconName Name under which to register the config.
         * @param {?} config Config to be registered.
         * @return {THIS}
         */
        MdcIconRegistry.prototype._addSvgIconConfig = /**
         * Registers an icon config by name in the specified namespace.
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon config.
         * @param {?} iconName Name under which to register the config.
         * @param {?} config Config to be registered.
         * @return {THIS}
         */
        function (namespace, iconName, config) {
            (/** @type {?} */ (this))._svgIconConfigs.set(iconKey(namespace, iconName), config);
            return (/** @type {?} */ (this));
        };
        /**
         * Registers an icon set config in the specified namespace.
         * @param namespace Namespace in which to register the icon config.
         * @param config Config to be registered.
         */
        /**
         * Registers an icon set config in the specified namespace.
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon config.
         * @param {?} config Config to be registered.
         * @return {THIS}
         */
        MdcIconRegistry.prototype._addSvgIconSetConfig = /**
         * Registers an icon set config in the specified namespace.
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} namespace Namespace in which to register the icon config.
         * @param {?} config Config to be registered.
         * @return {THIS}
         */
        function (namespace, config) {
            /** @type {?} */
            var configNamespace = (/** @type {?} */ (this))._iconSetConfigs.get(namespace);
            if (configNamespace) {
                configNamespace.push(config);
            }
            else {
                (/** @type {?} */ (this))._iconSetConfigs.set(namespace, [config]);
            }
            return (/** @type {?} */ (this));
        };
        MdcIconRegistry.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] },
        ];
        /** @nocollapse */
        MdcIconRegistry.ctorParameters = function () { return [
            { type: http.HttpClient, decorators: [{ type: core.Optional }] },
            { type: platformBrowser.DomSanitizer },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        /** @nocollapse */ MdcIconRegistry.ngInjectableDef = core.defineInjectable({ factory: function MdcIconRegistry_Factory() { return new MdcIconRegistry(core.inject(http.HttpClient, 8), core.inject(platformBrowser.DomSanitizer), core.inject(common.DOCUMENT, 8)); }, token: MdcIconRegistry, providedIn: "root" });
        return MdcIconRegistry;
    }());
    /**
     * \@docs-private
     * @param {?} parentRegistry
     * @param {?} httpClient
     * @param {?} sanitizer
     * @param {?=} document
     * @return {?}
     */
    function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, document) {
        return parentRegistry || new MdcIconRegistry(httpClient, sanitizer, document);
    }
    /**
     * \@docs-private
     * @type {?}
     */
    var ICON_REGISTRY_PROVIDER = {
        // If there is already an MdcIconRegistry available, use that. Otherwise, provide a new one.
        provide: MdcIconRegistry,
        deps: [
            [new core.Optional(), new core.SkipSelf(), MdcIconRegistry],
            [new core.Optional(), http.HttpClient],
            platformBrowser.DomSanitizer,
            [new core.Optional(), (/** @type {?} */ (common.DOCUMENT))],
        ],
        useFactory: ICON_REGISTRY_PROVIDER_FACTORY,
    };
    /**
     * Clones an SVGElement while preserving type information.
     * @param {?} svg
     * @return {?}
     */
    function cloneSvg(svg) {
        return (/** @type {?} */ (svg.cloneNode(true)));
    }
    /**
     * Returns the cache key to use for an icon namespace and name.
     * @param {?} namespace
     * @param {?} name
     * @return {?}
     */
    function iconKey(namespace, name) {
        return namespace + ':' + name;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function MDC_ICON_LOCATION_FACTORY() {
        /** @type {?} */
        var _document = core.inject(common.DOCUMENT);
        /** @type {?} */
        var _location = _document ? _document.location : null;
        return {
            // Note that this needs to be a function, rather than a property, because Angular
            // will only resolve it once, but we want the current path on each call.
            getPathname: (/**
             * @return {?}
             */
            function () { return _location ? (_location.pathname + _location.search) : ''; })
        };
    }
    /**
     * Injection token used to provide the current location to `MdcIcon`.
     * Used to handle server-side rendering and to stub out during unit tests.
     * @type {?}
     */
    var MDC_ICON_LOCATION = new core.InjectionToken('mdc-icon-location', {
        providedIn: 'root',
        factory: MDC_ICON_LOCATION_FACTORY
    });
    /**
     * SVG attributes that accept a FuncIRI (e.g. `url(<something>)`).
     * @type {?}
     */
    var funcIriAttributes = [
        'clip-path',
        'color-profile',
        'src',
        'cursor',
        'fill',
        'filter',
        'marker',
        'marker-start',
        'marker-mid',
        'marker-end',
        'mask',
        'stroke'
    ];
    var ɵ0 = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) { return "[" + attr + "]"; };
    /**
     * Selector that can be used to find all elements that are using a `FuncIRI`.
     * @type {?}
     */
    var funcIriAttributeSelector = funcIriAttributes.map((ɵ0)).join(', ');
    /**
     * Regex that can be used to extract the id out of a FuncIRI.
     * @type {?}
     */
    var funcIriPattern = /^url\(['"]?#(.*?)['"]?\)$/;
    var MdcIcon = /** @class */ (function () {
        function MdcIcon(elementRef, _iconRegistry, ariaHidden, _location) {
            this.elementRef = elementRef;
            this._iconRegistry = _iconRegistry;
            this._location = _location;
            this._previousFontSetClass = [];
            this._inline = false;
            this.role = 'img';
            this.tabIndex = null;
            this._fontSet = '';
            this._fontIcon = '';
            this._clickable = false;
            if (!ariaHidden) {
                this._getHostElement().setAttribute('aria-hidden', 'true');
            }
        }
        Object.defineProperty(MdcIcon.prototype, "inline", {
            /**
             * Whether the icon should be inlined, automatically sizing the icon to match the font size of
             * the element the icon is contained in.
             */
            get: /**
             * Whether the icon should be inlined, automatically sizing the icon to match the font size of
             * the element the icon is contained in.
             * @return {?}
             */
            function () { return this._inline; },
            set: /**
             * @param {?} inline
             * @return {?}
             */
            function (inline) {
                this._inline = toBoolean(inline);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "fontSet", {
            /** Font set that the icon is a part of. */
            get: /**
             * Font set that the icon is a part of.
             * @return {?}
             */
            function () { return this._fontSet; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fontSet = this._cleanupFontValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "fontIcon", {
            /** Name of an icon within a font set. */
            get: /**
             * Name of an icon within a font set.
             * @return {?}
             */
            function () { return this._fontIcon; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fontIcon = this._cleanupFontValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "clickable", {
            get: /**
             * @return {?}
             */
            function () { return this._clickable; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._clickable = toBoolean(value);
                if (this._clickable) {
                    this.tabIndex = 0;
                    this.role = 'button';
                }
                else {
                    this.tabIndex = null;
                    this.role = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcIcon.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var cachedElements = this._elementsWithExternalReferences;
            if (cachedElements && this._location && cachedElements.size) {
                /** @type {?} */
                var newPath = this._location.getPathname();
                // We need to check whether the URL has changed on each change detection since
                // the browser doesn't have an API that will let us react on link clicks and
                // we can't depend on the Angular router. The references need to be updated,
                // because while most browsers don't care whether the URL is correct after
                // the first render, Safari will break if the user navigates to a different
                // page and the SVG isn't re-rendered.
                if (newPath !== this._previousPath) {
                    this._previousPath = newPath;
                    this._prependPathToReferences(newPath);
                }
            }
        };
        /**
         * @return {?}
         */
        MdcIcon.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._elementsWithExternalReferences) {
                this._elementsWithExternalReferences.clear();
            }
        };
        /**
         * Splits an svgIcon binding value into its icon set and icon name components.
         * Returns a 2-element array of [(icon set), (icon name)].
         * The separator for the two fields is ':'. If there is no separator, an empty
         * string is returned for the icon set and the entire value is returned for
         * the icon name. If the argument is falsy, returns an array of two empty strings.
         * Throws an error if the name contains two or more ':' separators.
         * Examples:
         *   `'social:cake' -> ['social', 'cake']
         *   'penguin' -> ['', 'penguin']
         *   null -> ['', '']
         *   'a:b:c' -> (throws Error)`
         */
        /**
         * Splits an svgIcon binding value into its icon set and icon name components.
         * Returns a 2-element array of [(icon set), (icon name)].
         * The separator for the two fields is ':'. If there is no separator, an empty
         * string is returned for the icon set and the entire value is returned for
         * the icon name. If the argument is falsy, returns an array of two empty strings.
         * Throws an error if the name contains two or more ':' separators.
         * Examples:
         *   `'social:cake' -> ['social', 'cake']
         *   'penguin' -> ['', 'penguin']
         *   null -> ['', '']
         *   'a:b:c' -> (throws Error)`
         * @private
         * @param {?} iconName
         * @return {?}
         */
        MdcIcon.prototype._splitIconName = /**
         * Splits an svgIcon binding value into its icon set and icon name components.
         * Returns a 2-element array of [(icon set), (icon name)].
         * The separator for the two fields is ':'. If there is no separator, an empty
         * string is returned for the icon set and the entire value is returned for
         * the icon name. If the argument is falsy, returns an array of two empty strings.
         * Throws an error if the name contains two or more ':' separators.
         * Examples:
         *   `'social:cake' -> ['social', 'cake']
         *   'penguin' -> ['', 'penguin']
         *   null -> ['', '']
         *   'a:b:c' -> (throws Error)`
         * @private
         * @param {?} iconName
         * @return {?}
         */
        function (iconName) {
            if (!iconName) {
                return ['', ''];
            }
            /** @type {?} */
            var parts = iconName.split(':');
            switch (parts.length) {
                case 1: return ['', parts[0]]; // Use default namespace.
                case 2: return (/** @type {?} */ (parts));
                default: throw Error("Invalid icon name: \"" + iconName + "\"");
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        MdcIcon.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var _this = this;
            // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.
            if (changes.svgIcon) {
                if (this.svgIcon) {
                    var _a = this._splitIconName(this.svgIcon), namespace = _a[0], iconName = _a[1];
                    this._iconRegistry.getNamedSvgIcon(iconName, namespace).pipe(operators.take(1)).subscribe((/**
                     * @param {?} svg
                     * @return {?}
                     */
                    function (svg) { return _this._setSvgElement(svg); }), (/**
                     * @param {?} err
                     * @return {?}
                     */
                    function (err) { return console.log("Error retrieving icon: " + err.message); }));
                }
                else {
                    this._clearSvgElement();
                }
            }
            if (this._usingFontIcon()) {
                this._updateFontIconClasses();
            }
        };
        /**
         * @return {?}
         */
        MdcIcon.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // Update font classes because ngOnChanges won't be called if none of the inputs are present,
            // e.g. <mdc-icon>arrow</mdc-icon> In this case we need to add a CSS class for the default font.
            if (this._usingFontIcon()) {
                this._updateFontIconClasses();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcIcon.prototype._usingFontIcon = /**
         * @private
         * @return {?}
         */
        function () {
            return !this.svgIcon;
        };
        /**
         * @private
         * @param {?} svg
         * @return {?}
         */
        MdcIcon.prototype._setSvgElement = /**
         * @private
         * @param {?} svg
         * @return {?}
         */
        function (svg) {
            this._clearSvgElement();
            // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.
            // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/
            // Do this before inserting the element into the DOM, in order to avoid a style recalculation.
            /** @type {?} */
            var styleTags = (/** @type {?} */ (svg.querySelectorAll('style')));
            for (var i = 0; i < styleTags.length; i++) {
                styleTags[i].textContent += ' ';
            }
            // Note: we do this fix here, rather than the icon registry, because the
            // references have to point to the URL at the time that the icon was created.
            if (this._location) {
                /** @type {?} */
                var path = this._location.getPathname();
                this._previousPath = path;
                this._cacheChildrenWithExternalReferences(svg);
                this._prependPathToReferences(path);
            }
            this._getHostElement().appendChild(svg);
        };
        /**
         * @private
         * @return {?}
         */
        MdcIcon.prototype._clearSvgElement = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var layoutElement = this._getHostElement();
            /** @type {?} */
            var childCount = layoutElement.childNodes.length;
            if (this._elementsWithExternalReferences) {
                this._elementsWithExternalReferences.clear();
            }
            // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that
            // we can't use innerHTML, because IE will throw if the element has a data binding.
            while (childCount--) {
                /** @type {?} */
                var child = layoutElement.childNodes[childCount];
                // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid
                // of any loose text nodes, as well as any SVG elements in order to remove any old icons.
                if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {
                    layoutElement.removeChild(child);
                }
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcIcon.prototype._updateFontIconClasses = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this._usingFontIcon()) {
                return;
            }
            /** @type {?} */
            var elem = this._getHostElement();
            /** @type {?} */
            var fontSetClasses = this.fontSet ?
                [this._iconRegistry.classNameForFontAlias(this.fontSet)] :
                this._iconRegistry.getDefaultFontSetClass();
            (/** @type {?} */ (this._previousFontSetClass)).forEach((/**
             * @param {?} className
             * @return {?}
             */
            function (className) { return elem.classList.remove(className); }));
            fontSetClasses.forEach((/**
             * @param {?} className
             * @return {?}
             */
            function (className) { return elem.classList.add(className); }));
            this._previousFontSetClass = fontSetClasses;
            if (this.fontIcon !== this._previousFontIconClass) {
                if (this._previousFontIconClass) {
                    elem.classList.remove(this._previousFontIconClass);
                }
                if (this.fontIcon) {
                    elem.classList.add(this.fontIcon);
                }
                this._previousFontIconClass = this.fontIcon;
            }
        };
        /**
         * Cleans up a value to be used as a fontIcon or fontSet.
         * Since the value ends up being assigned as a CSS class, we
         * have to trim the value and omit space-separated values.
         */
        /**
         * Cleans up a value to be used as a fontIcon or fontSet.
         * Since the value ends up being assigned as a CSS class, we
         * have to trim the value and omit space-separated values.
         * @private
         * @param {?} value
         * @return {?}
         */
        MdcIcon.prototype._cleanupFontValue = /**
         * Cleans up a value to be used as a fontIcon or fontSet.
         * Since the value ends up being assigned as a CSS class, we
         * have to trim the value and omit space-separated values.
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return typeof value === 'string' ? value.trim().split(' ')[0] : value;
        };
        /**
         * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`
         * reference. This is required because WebKit browsers require references to be prefixed with
         * the current path, if the page has a `base` tag.
         */
        /**
         * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`
         * reference. This is required because WebKit browsers require references to be prefixed with
         * the current path, if the page has a `base` tag.
         * @private
         * @param {?} path
         * @return {?}
         */
        MdcIcon.prototype._prependPathToReferences = /**
         * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`
         * reference. This is required because WebKit browsers require references to be prefixed with
         * the current path, if the page has a `base` tag.
         * @private
         * @param {?} path
         * @return {?}
         */
        function (path) {
            /** @type {?} */
            var elements = this._elementsWithExternalReferences;
            if (elements) {
                elements.forEach((/**
                 * @param {?} attrs
                 * @param {?} element
                 * @return {?}
                 */
                function (attrs, element) {
                    attrs.forEach((/**
                     * @param {?} attr
                     * @return {?}
                     */
                    function (attr) {
                        element.setAttribute(attr.name, "url('" + path + "#" + attr.value + "')");
                    }));
                }));
            }
        };
        /**
         * Caches the children of an SVG element that have `url()`
         * references that we need to prefix with the current path.
         */
        /**
         * Caches the children of an SVG element that have `url()`
         * references that we need to prefix with the current path.
         * @private
         * @param {?} element
         * @return {?}
         */
        MdcIcon.prototype._cacheChildrenWithExternalReferences = /**
         * Caches the children of an SVG element that have `url()`
         * references that we need to prefix with the current path.
         * @private
         * @param {?} element
         * @return {?}
         */
        function (element) {
            /** @type {?} */
            var elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);
            /** @type {?} */
            var elements = this._elementsWithExternalReferences =
                this._elementsWithExternalReferences || new Map();
            var _loop_1 = function (i) {
                funcIriAttributes.forEach((/**
                 * @param {?} attr
                 * @return {?}
                 */
                function (attr) {
                    /** @type {?} */
                    var elementWithReference = elementsWithFuncIri[i];
                    /** @type {?} */
                    var value = elementWithReference.getAttribute(attr);
                    /** @type {?} */
                    var match = value ? value.match(funcIriPattern) : null;
                    if (match) {
                        /** @type {?} */
                        var attributes = elements.get(elementWithReference);
                        if (!attributes) {
                            attributes = [];
                            elements.set(elementWithReference, attributes);
                        }
                        (/** @type {?} */ (attributes)).push({ name: attr, value: match[1] });
                    }
                }));
            };
            for (var i = 0; i < elementsWithFuncIri.length; i++) {
                _loop_1(i);
            }
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @protected
         * @return {?}
         */
        MdcIcon.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @protected
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcIcon.decorators = [
            { type: core.Component, args: [{selector: 'mdc-icon, [mdcIcon]',
                        exportAs: 'mdcIcon',
                        host: {
                            '[attr.role]': 'role',
                            '[attr.tabindex]': 'tabIndex',
                            'class': 'ngx-mdc-icon',
                            '[class.ngx-mdc-icon--clickable]': 'clickable',
                            '[class.ngx-mdc-icon--inline]': 'inline'
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcIcon.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: MdcIconRegistry },
            { type: String, decorators: [{ type: core.Attribute, args: ['aria-hidden',] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [MDC_ICON_LOCATION,] }] }
        ]; };
        MdcIcon.propDecorators = {
            inline: [{ type: core.Input }],
            svgIcon: [{ type: core.Input }],
            role: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            fontSet: [{ type: core.Input }],
            fontIcon: [{ type: core.Input }],
            clickable: [{ type: core.Input }]
        };
        return MdcIcon;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICON_DECLARATIONS = [
        MdcIcon,
        MdcMaterialIcons
    ];
    var MdcIconModule = /** @class */ (function () {
        function MdcIconModule() {
        }
        MdcIconModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: ICON_DECLARATIONS,
                        declarations: ICON_DECLARATIONS
                    },] },
        ];
        return MdcIconModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcButtonLabel = /** @class */ (function () {
        function MdcButtonLabel() {
        }
        MdcButtonLabel.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-button-label, [mdcButtonLabel]',
                        exportAs: 'mdcButtonLabel',
                        host: {
                            'class': 'mdc-button__label'
                        }
                    },] },
        ];
        return MdcButtonLabel;
    }());
    var MdcButton = /** @class */ (function () {
        function MdcButton(elementRef, _ripple) {
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this._raised = false;
            this._primary = false;
            this._dense = false;
            this._secondary = false;
            this._unelevated = false;
            this._outlined = false;
            this._disabled = false;
        }
        Object.defineProperty(MdcButton.prototype, "raised", {
            get: /**
             * @return {?}
             */
            function () { return this._raised; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._raised = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._primary = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "dense", {
            get: /**
             * @return {?}
             */
            function () { return this._dense; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._dense = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._secondary = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "unelevated", {
            get: /**
             * @return {?}
             */
            function () { return this._unelevated; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._unelevated = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "outlined", {
            get: /**
             * @return {?}
             */
            function () { return this._outlined; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._outlined = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcButton.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this._icon) {
                this._icon.elementRef.nativeElement.classList.add('mdc-button__icon');
            }
            this._ripple.init({ surface: this.getHostElement() });
        };
        /**
         * @return {?}
         */
        MdcButton.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._ripple.destroy();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcButton.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = toBoolean(disabled);
            if (this._disabled) {
                this.getHostElement().setAttribute('disabled', 'true');
                this.getHostElement().setAttribute('aria-disabled', 'true');
            }
            else {
                this.getHostElement().removeAttribute('disabled');
                this.getHostElement().removeAttribute('aria-disabled');
            }
        };
        /** Focuses the button. */
        /**
         * Focuses the button.
         * @return {?}
         */
        MdcButton.prototype.focus = /**
         * Focuses the button.
         * @return {?}
         */
        function () {
            this.getHostElement().focus();
        };
        /**
         * @return {?}
         */
        MdcButton.prototype.getHostElement = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcButton.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // A disabled button shouldn't apply any actions
            if (this.disabled) {
                event.preventDefault();
                event.stopImmediatePropagation();
            }
        };
        MdcButton.decorators = [
            { type: core.Component, args: [{exportAs: 'mdcButton',
                        selector: 'button[mdc-button], a[mdc-button]',
                        host: {
                            '[tabIndex]': 'disabled ? -1 : 0',
                            'class': 'mdc-button',
                            '[class.ngx-mdc-button--primary]': 'primary',
                            '[class.ngx-mdc-button--secondary]': 'secondary',
                            '[class.mdc-button--raised]': 'raised',
                            '[class.mdc-button--dense]': 'dense',
                            '[class.mdc-button--unelevated]': 'unelevated',
                            '[class.mdc-button--outlined]': 'outlined',
                            '(click)': 'onClick($event)'
                        },
                        template: "\n  <mdc-button-label *ngIf=\"label\">{{label}}</mdc-button-label>\n  <ng-content></ng-content>\n  ",
                        providers: [MdcRipple],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcButton.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcButton.propDecorators = {
            raised: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            dense: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            unelevated: [{ type: core.Input }],
            outlined: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            _icon: [{ type: core.ContentChild, args: [MdcIcon,] }],
            label: [{ type: core.Input }]
        };
        return MdcButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcButtonModule = /** @class */ (function () {
        function MdcButtonModule() {
        }
        MdcButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [MdcButton, MdcButtonLabel],
                        declarations: [MdcButton, MdcButtonLabel]
                    },] },
        ];
        return MdcButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcCardMediaContent = /** @class */ (function () {
        function MdcCardMediaContent(elementRef) {
            this.elementRef = elementRef;
        }
        MdcCardMediaContent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-card-media-content, [mdcCardMediaContent]',
                        exportAs: 'mdcCardMediaContent',
                        host: { 'class': 'mdc-card__media-content' }
                    },] },
        ];
        /** @nocollapse */
        MdcCardMediaContent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcCardMediaContent;
    }());
    var MdcCardMedia = /** @class */ (function () {
        function MdcCardMedia(elementRef) {
            this.elementRef = elementRef;
            this._square = false;
            this._wide = false;
        }
        Object.defineProperty(MdcCardMedia.prototype, "square", {
            get: /**
             * @return {?}
             */
            function () { return this._square; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._square = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardMedia.prototype, "wide", {
            get: /**
             * @return {?}
             */
            function () { return this._wide; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._wide = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcCardMedia.decorators = [
            { type: core.Component, args: [{selector: 'mdc-card-media, [mdcCardMedia]',
                        exportAs: 'mdcCardMedia',
                        host: {
                            'class': 'mdc-card__media',
                            '[class.mdc-card__media--square]': 'square',
                            '[class.mdc-card__media--16-9]': 'wide'
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCardMedia.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardMedia.propDecorators = {
            square: [{ type: core.Input }],
            wide: [{ type: core.Input }]
        };
        return MdcCardMedia;
    }());
    var MdcCardPrimaryAction = /** @class */ (function () {
        function MdcCardPrimaryAction(_ripple, elementRef) {
            this._ripple = _ripple;
            this.elementRef = elementRef;
            this._ripple.init({ surface: this.elementRef.nativeElement });
        }
        /**
         * @return {?}
         */
        MdcCardPrimaryAction.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._ripple.destroy();
        };
        MdcCardPrimaryAction.decorators = [
            { type: core.Component, args: [{selector: 'mdc-card-primary-action, [mdcCardPrimaryAction]',
                        exportAs: 'mdcCardPrimaryAction',
                        host: { 'class': 'mdc-card__primary-action' },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcCardPrimaryAction.ctorParameters = function () { return [
            { type: MdcRipple },
            { type: core.ElementRef }
        ]; };
        return MdcCardPrimaryAction;
    }());
    var MdcCardActions = /** @class */ (function () {
        function MdcCardActions(elementRef) {
            this.elementRef = elementRef;
            this._fullBleed = false;
        }
        Object.defineProperty(MdcCardActions.prototype, "fullBleed", {
            get: /**
             * @return {?}
             */
            function () { return this._fullBleed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fullBleed = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcCardActions.decorators = [
            { type: core.Component, args: [{selector: 'mdc-card-actions, [mdcCardActions]',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcCardActions',
                        host: {
                            'class': 'mdc-card__actions',
                            '[class.mdc-card__actions--full-bleed]': 'fullBleed'
                        },
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCardActions.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardActions.propDecorators = {
            fullBleed: [{ type: core.Input }]
        };
        return MdcCardActions;
    }());
    var MdcCardActionButtons = /** @class */ (function () {
        function MdcCardActionButtons(elementRef) {
            this.elementRef = elementRef;
        }
        MdcCardActionButtons.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-card-action-buttons, [mdcCardActionButtons]',
                        exportAs: 'mdcCardActionButtons',
                        host: { 'class': 'mdc-card__action-buttons' }
                    },] },
        ];
        /** @nocollapse */
        MdcCardActionButtons.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcCardActionButtons;
    }());
    var MdcCardActionIcons = /** @class */ (function () {
        function MdcCardActionIcons(elementRef) {
            this.elementRef = elementRef;
        }
        MdcCardActionIcons.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-card-action-icons, [mdcCardActionIcons]',
                        exportAs: 'mdcCardActionIcons',
                        host: { 'class': 'mdc-card__action-icons' }
                    },] },
        ];
        /** @nocollapse */
        MdcCardActionIcons.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcCardActionIcons;
    }());
    var MdcCardAction = /** @class */ (function () {
        function MdcCardAction(elementRef) {
            this.elementRef = elementRef;
            this._action = '';
        }
        Object.defineProperty(MdcCardAction.prototype, "action", {
            get: /**
             * @return {?}
             */
            function () { return this._action; },
            set: /**
             * @param {?} action
             * @return {?}
             */
            function (action) {
                // If the directive is set without a name (updated programatically), then this setter will
                // trigger with an empty string and should not overwrite the programatically set value.
                if (!action) {
                    return;
                }
                if (action === 'button') {
                    this.elementRef.nativeElement.classList.remove('mdc-card__action--icon');
                    this.elementRef.nativeElement.classList.add('mdc-card__action--button');
                }
                else if (action === 'icon') {
                    this.elementRef.nativeElement.classList.remove('mdc-card__action--button');
                    this.elementRef.nativeElement.classList.add('mdc-card__action--icon');
                    this.elementRef.nativeElement.setAttribute('tabIndex', '0');
                    this.elementRef.nativeElement.setAttribute('role', 'button');
                }
                this._action = action;
            },
            enumerable: true,
            configurable: true
        });
        MdcCardAction.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcCardAction]',
                        host: { 'class': 'mdc-card__action' }
                    },] },
        ];
        /** @nocollapse */
        MdcCardAction.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardAction.propDecorators = {
            action: [{ type: core.Input, args: ['mdcCardAction',] }]
        };
        return MdcCardAction;
    }());
    var MdcCard = /** @class */ (function () {
        function MdcCard(elementRef) {
            this.elementRef = elementRef;
            this._outlined = false;
        }
        Object.defineProperty(MdcCard.prototype, "outlined", {
            get: /**
             * @return {?}
             */
            function () { return this._outlined; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._outlined = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcCard.decorators = [
            { type: core.Component, args: [{selector: 'mdc-card',
                        exportAs: 'mdcCard',
                        host: {
                            'class': 'mdc-card',
                            '[class.mdc-card--outlined]': 'outlined'
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCard.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCard.propDecorators = {
            outlined: [{ type: core.Input }]
        };
        return MdcCard;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CARD_DECLARATIONS = [
        MdcCard,
        MdcCardAction,
        MdcCardActionButtons,
        MdcCardActionIcons,
        MdcCardActions,
        MdcCardMedia,
        MdcCardMediaContent,
        MdcCardPrimaryAction
    ];
    var MdcCardModule = /** @class */ (function () {
        function MdcCardModule() {
        }
        MdcCardModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: CARD_DECLARATIONS,
                        declarations: CARD_DECLARATIONS,
                    },] },
        ];
        return MdcCardModule;
    }());

    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$1(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$1(subClass, superClass);
    }

    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$1(o);
    }

    function _setPrototypeOf$1(o, p) {
      _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$1(o, p);
    }

    function _assertThisInitialized$1(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$1(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$1(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$1 =
    /*#__PURE__*/
    function () {
      _createClass$1(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$1(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$1(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$1 =
    /*#__PURE__*/
    function () {
      _createClass$1(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$1());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$1(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$1(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Character Counter.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the TextField character counter into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldCharacterCounterAdapter =
    /*#__PURE__*/
    function () {
      function MDCTextFieldCharacterCounterAdapter() {
        _classCallCheck$1(this, MDCTextFieldCharacterCounterAdapter);
      }

      _createClass$1(MDCTextFieldCharacterCounterAdapter, [{
        key: "setContent",

        /**
         * Sets the text content of character counter element.
         * @param {string} content
         */
        value: function setContent(content) {}
      }]);

      return MDCTextFieldCharacterCounterAdapter;
    }();

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1 = {
      ROOT: 'mdc-text-field-character-counter'
    };
    /** @enum {string} */

    var strings$1 = {
      ROOT_SELECTOR: ".".concat(cssClasses$1.ROOT)
    };

    /**
     * @extends {MDCFoundation<!MDCTextFieldCharacterCounterAdapter>}
     * @final
     */

    var MDCTextFieldCharacterCounterFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$1(MDCTextFieldCharacterCounterFoundation, _MDCFoundation);

      _createClass$1(MDCTextFieldCharacterCounterFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$1;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1;
        }
        /**
         * {@see MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldCharacterCounterAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldCharacterCounterAdapter} */
            {
              setContent: function setContent() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldCharacterCounterAdapter} adapter
         */

      }]);

      function MDCTextFieldCharacterCounterFoundation(adapter) {
        _classCallCheck$1(this, MDCTextFieldCharacterCounterFoundation);

        return _possibleConstructorReturn$1(this, _getPrototypeOf$1(MDCTextFieldCharacterCounterFoundation).call(this, Object.assign(MDCTextFieldCharacterCounterFoundation.defaultAdapter, adapter)));
      }
      /**
       * @param {number} currentLength
       * @param {number} maxLength
       */


      _createClass$1(MDCTextFieldCharacterCounterFoundation, [{
        key: "setCounterValue",
        value: function setCounterValue(currentLength, maxLength) {
          currentLength = Math.min(currentLength, maxLength);
          this.adapter_.setContent("".concat(currentLength, " / ").concat(maxLength));
        }
      }]);

      return MDCTextFieldCharacterCounterFoundation;
    }(MDCFoundation$1);

    /**
     * @extends {MDCComponent<!MDCTextFieldCharacterCounterFoundation>}
     * @final
     */

    var MDCTextFieldCharacterCounter =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$1(MDCTextFieldCharacterCounter, _MDCComponent);

      function MDCTextFieldCharacterCounter() {
        _classCallCheck$1(this, MDCTextFieldCharacterCounter);

        return _possibleConstructorReturn$1(this, _getPrototypeOf$1(MDCTextFieldCharacterCounter).apply(this, arguments));
      }

      _createClass$1(MDCTextFieldCharacterCounter, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTextFieldCharacterCounterFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCTextFieldCharacterCounterFoundation(
          /** @type {!MDCTextFieldCharacterCounterAdapter} */
          Object.assign({
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCTextFieldCharacterCounterFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTextFieldCharacterCounter}
         */
        value: function attachTo(root) {
          return new MDCTextFieldCharacterCounter(root);
        }
      }]);

      return MDCTextFieldCharacterCounter;
    }(MDCComponent$1);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcCharacterCounter = /** @class */ (function () {
        function MdcCharacterCounter(elementRef) {
            this.elementRef = elementRef;
        }
        /**
         * @return {?}
         */
        MdcCharacterCounter.prototype.getDefaultFoundation = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var adapter = {
                setContent: (/**
                 * @param {?} content
                 * @return {?}
                 */
                function (content) { return _this.elementRef.nativeElement.textContent = content; })
            };
            return new MDCTextFieldCharacterCounterFoundation(adapter);
        };
        /**
         * @return {?}
         */
        MdcCharacterCounter.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.getDefaultFoundation().destroy();
        };
        MdcCharacterCounter.decorators = [
            { type: core.Component, args: [{selector: '[mdcCharacterCounter]',
                        exportAs: 'mdcCharacterCounter',
                        host: { 'class': 'mdc-text-field-character-counter' },
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        /** @nocollapse */
        MdcCharacterCounter.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcCharacterCounter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Mixin to augment a directive with updateErrorState method.
     * For component with `errorState` and need to update `errorState`.
     * @template T
     * @param {?} base
     * @return {?}
     */
    function mixinErrorState(base) {
        return /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, args) || this;
                /**
                 * Whether the component is in an error state.
                 */
                _this.errorState = false;
                _this.required = false;
                return _this;
            }
            /**
             * @return {?}
             */
            class_1.prototype.updateErrorState = /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var oldState = this.errorState;
                /** @type {?} */
                var parent = this._parentFormGroup || this._parentForm;
                /** @type {?} */
                var matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;
                /** @type {?} */
                var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
                /** @type {?} */
                var newState = matcher.isErrorState(control, parent);
                if (newState !== oldState) {
                    this.errorState = newState;
                }
                // Currently there isn't a great way to determine if Validators.required
                // has been added to the control since form validators are combined into
                // an aggregate function at initialization.
                if (control && !this.required) {
                    this.required = control.hasError('required');
                }
            };
            return class_1;
        }(base));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Provider that defines how form controls behave with regards to displaying error messages.
     */
    var ErrorStateMatcher = /** @class */ (function () {
        function ErrorStateMatcher() {
        }
        /**
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        ErrorStateMatcher.prototype.isErrorState = /**
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        function (control, form) {
            return !!(control && control.invalid && (control.touched || (form && form.submitted)));
        };
        ErrorStateMatcher.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] },
        ];
        /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = core.defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
        return ErrorStateMatcher;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template T
     */
    var   /**
     * @abstract
     * @template T
     */
    MdcFormFieldControl = /** @class */ (function () {
        function MdcFormFieldControl() {
            /**
             * The value of the control.
             */
            this.value = null;
        }
        return MdcFormFieldControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcHelperText = /** @class */ (function () {
        function MdcHelperText(elementRef) {
            this.elementRef = elementRef;
            this.characterCounter = false;
            this._persistent = false;
            this._validation = false;
        }
        Object.defineProperty(MdcHelperText.prototype, "persistent", {
            get: /**
             * @return {?}
             */
            function () { return this._persistent; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._persistent = toBoolean(value);
                if (this._foundation) {
                    this._foundation.setPersistent(this._persistent);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcHelperText.prototype, "validation", {
            get: /**
             * @return {?}
             */
            function () { return this._validation; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._validation = toBoolean(value);
                if (this._foundation) {
                    this._foundation.setValidation(this._validation);
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Sets the validity of the helper text based on inputIsValid. */
        /**
         * Sets the validity of the helper text based on inputIsValid.
         * @param {?} inputIsValid
         * @return {?}
         */
        MdcHelperText.prototype.setValidity = /**
         * Sets the validity of the helper text based on inputIsValid.
         * @param {?} inputIsValid
         * @return {?}
         */
        function (inputIsValid) {
            this._foundation.setValidity(inputIsValid);
        };
        /** Makes the helper text visible to the screen reader. */
        /**
         * Makes the helper text visible to the screen reader.
         * @return {?}
         */
        MdcHelperText.prototype.showToScreenReader = /**
         * Makes the helper text visible to the screen reader.
         * @return {?}
         */
        function () {
            this._foundation.showToScreenReader();
        };
        /**
         * @param {?} foundation
         * @return {?}
         */
        MdcHelperText.prototype.init = /**
         * @param {?} foundation
         * @return {?}
         */
        function (foundation) {
            this._foundation = new foundation(this._createAdapter());
            this._foundation.setPersistent(this.persistent);
            this._foundation.setValidation(this.validation);
        };
        /**
         * @param {?} className
         * @return {?}
         */
        MdcHelperText.prototype.addHelperTextClass = /**
         * @param {?} className
         * @return {?}
         */
        function (className) {
            (/** @type {?} */ (this._helperTextElement)).nativeElement.classList.add(className + "-helper-text");
        };
        /**
         * @private
         * @return {?}
         */
        MdcHelperText.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.classList.contains(className); }),
                setAttr: (/**
                 * @param {?} attr
                 * @param {?} value
                 * @return {?}
                 */
                function (attr, value) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.setAttribute(attr, value); }),
                removeAttr: (/**
                 * @param {?} attr
                 * @return {?}
                 */
                function (attr) { return (/** @type {?} */ (_this._helperTextElement)).nativeElement.removeAttribute(attr); })
            };
        };
        MdcHelperText.decorators = [
            { type: core.Component, args: [{selector: "mdc-helper-text, [mdcHelperText],\n  mdc-text-field-helper-text, [mdcTextFieldHelperText], [mdcSelectHelperText]",
                        exportAs: 'mdcHelperText, mdcSelectHelperText',
                        host: { 'class': 'mdc-text-field-helper-line' },
                        template: "<div #helperText><ng-content></ng-content></div>\n  <div mdcCharacterCounter *ngIf=\"characterCounter\"></div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcHelperText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcHelperText.propDecorators = {
            id: [{ type: core.Input }],
            persistent: [{ type: core.Input }],
            validation: [{ type: core.Input }],
            _helperTextElement: [{ type: core.ViewChild, args: ['helperText',] }],
            _characterCounterElement: [{ type: core.ViewChild, args: [MdcCharacterCounter,] }]
        };
        return MdcHelperText;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcFormField = /** @class */ (function () {
        function MdcFormField(_changeDetectorRef, _ngZone, elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._ngZone = _ngZone;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._fluid = false;
            this._alignEnd = false;
        }
        Object.defineProperty(MdcFormField.prototype, "fluid", {
            get: /**
             * @return {?}
             */
            function () { return this._fluid; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fluid = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFormField.prototype, "alignEnd", {
            get: /**
             * @return {?}
             */
            function () { return this._alignEnd; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._alignEnd = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcFormField.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._control) {
                /** @type {?} */
                var control = this._control.elementRef.nativeElement;
                if (control.nextElementSibling) {
                    if (control.nextElementSibling.tagName === 'LABEL') {
                        this.label = control.nextElementSibling;
                        if (this.label && this._control.inputId) {
                            (/** @type {?} */ (this.label)).setAttribute('for', this._control.inputId);
                            this._loadListeners();
                        }
                    }
                }
            }
            // When assistive elements change, initialize foundation
            this.assistiveElements.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy))
                .subscribe((/**
             * @return {?}
             */
            function () {
                (_this.assistiveElements).forEach((/**
                 * @param {?} helperText
                 * @return {?}
                 */
                function (helperText) {
                    return _this._initHelperTextFoundation(helperText);
                }));
            }));
        };
        /**
         * @return {?}
         */
        MdcFormField.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
        };
        /**
         * @private
         * @param {?} helperText
         * @return {?}
         */
        MdcFormField.prototype._initHelperTextFoundation = /**
         * @private
         * @param {?} helperText
         * @return {?}
         */
        function (helperText) {
            /** @type {?} */
            var control = this._control;
            if (control && control.controlType) {
                control.helperText = helperText;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcFormField.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent((/** @type {?} */ (_this.label)), 'click').pipe(operators.takeUntil(_this._destroy))
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    (/** @type {?} */ (_this._control.ripple)).activateRipple();
                    if (typeof requestAnimationFrame !== 'undefined') {
                        requestAnimationFrame((/**
                         * @return {?}
                         */
                        function () { return (/** @type {?} */ (_this._control.ripple)).deactivateRipple(); }));
                    }
                })); }));
            }));
        };
        MdcFormField.decorators = [
            { type: core.Component, args: [{selector: 'mdc-form-field',
                        exportAs: 'mdcFormField',
                        host: {
                            '[class.ngx-mdc-form-field--fluid]': 'fluid',
                            '[class.mdc-form-field--align-end]': 'alignEnd'
                        },
                        template: "<ng-content></ng-content>\n  <ng-content select=\"[mdcHelperText, mdc-helper-text]\"></ng-content>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcFormField.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.NgZone },
            { type: core.ElementRef }
        ]; };
        MdcFormField.propDecorators = {
            fluid: [{ type: core.Input }],
            alignEnd: [{ type: core.Input }],
            _control: [{ type: core.ContentChild, args: [MdcFormFieldControl,] }],
            assistiveElements: [{ type: core.ContentChildren, args: [MdcHelperText, { descendants: true },] }]
        };
        return MdcFormField;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FORM_FIELD_DECLARATIONS = [
        MdcCharacterCounter,
        MdcFormField,
        MdcHelperText
    ];
    var MdcFormFieldModule = /** @class */ (function () {
        function MdcFormFieldModule() {
        }
        MdcFormFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [FORM_FIELD_DECLARATIONS],
                        declarations: [FORM_FIELD_DECLARATIONS]
                    },] },
        ];
        return MdcFormFieldModule;
    }());

    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$2(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$2(subClass, superClass);
    }

    function _getPrototypeOf$2(o) {
      _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$2(o);
    }

    function _setPrototypeOf$2(o, p) {
      _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$2(o, p);
    }

    function _assertThisInitialized$2(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$2(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$2(self);
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$2(object);
        if (object === null) break;
      }

      return object;
    }

    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /** @const {Object<string, !VendorPropertyMapType>} */

    var eventTypeMap = {
      'animationstart': {
        noPrefix: 'animationstart',
        webkitPrefix: 'webkitAnimationStart',
        styleProperty: 'animation'
      },
      'animationend': {
        noPrefix: 'animationend',
        webkitPrefix: 'webkitAnimationEnd',
        styleProperty: 'animation'
      },
      'animationiteration': {
        noPrefix: 'animationiteration',
        webkitPrefix: 'webkitAnimationIteration',
        styleProperty: 'animation'
      },
      'transitionend': {
        noPrefix: 'transitionend',
        webkitPrefix: 'webkitTransitionEnd',
        styleProperty: 'transition'
      }
    };
    /** @const {Object<string, !VendorPropertyMapType>} */

    var cssPropertyMap = {
      'animation': {
        noPrefix: 'animation',
        webkitPrefix: '-webkit-animation'
      },
      'transform': {
        noPrefix: 'transform',
        webkitPrefix: '-webkit-transform'
      },
      'transition': {
        noPrefix: 'transition',
        webkitPrefix: '-webkit-transition'
      }
    };
    /**
     * @param {!Object} windowObj
     * @return {boolean}
     */

    function hasProperShape(windowObj) {
      return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
    }
    /**
     * @param {string} eventType
     * @return {boolean}
     */


    function eventFoundInMaps(eventType) {
      return eventType in eventTypeMap || eventType in cssPropertyMap;
    }
    /**
     * @param {string} eventType
     * @param {!Object<string, !VendorPropertyMapType>} map
     * @param {!Element} el
     * @return {string}
     */


    function getJavaScriptEventName(eventType, map, el) {
      return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }
    /**
     * Helper function to determine browser prefix for CSS3 animation events
     * and property names.
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getAnimationName(windowObj, eventType) {
      if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
        return eventType;
      }

      var map =
      /** @type {!Object<string, !VendorPropertyMapType>} */
      eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
      var el = windowObj['document']['createElement']('div');
      var eventName = '';

      if (map === eventTypeMap) {
        eventName = getJavaScriptEventName(eventType, map, el);
      } else {
        eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
      }

      return eventName;
    } // Public functions to access getAnimationName() for JavaScript events or CSS
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */

    function getCorrectEventName(windowObj, eventType) {
      return getAnimationName(windowObj, eventType);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$2 =
    /*#__PURE__*/
    function () {
      _createClass$2(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$2(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$2(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$2 =
    /*#__PURE__*/
    function () {
      _createClass$2(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$2());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$2(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$2(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$2(this, MDCRippleAdapter);
      }

      _createClass$2(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$2 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$2 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$1 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$1;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$1;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$1(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$1(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$1;

      if (typeof supportsCssVariables_$1 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$1(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$1 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$1() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$1 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$1 = isSupported;
      }

      return supportsPassive_$1 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$1(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$1(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$2 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$2 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$1 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$2(MDCRippleFoundation, _MDCFoundation);

      _createClass$2(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$2;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$2;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$1;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$2(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$2(this, _getPrototypeOf$2(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$2(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$2.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$2.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$2.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$2.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$1.length > 0 && activatedTargets$1.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$1.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$1 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$1(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$1.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$2);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$2(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$2(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$2(this, (_getPrototypeOf2 = _getPrototypeOf$2(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$2(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$1(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$1(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$1(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$1());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$1());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$2);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$1 = function RippleCapableSurface() {
      _classCallCheck$2(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$1.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$1.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$1.prototype.disabled;

    /**
     * @record
     */

    var MDCSelectionControl =
    /*#__PURE__*/
    function () {
      function MDCSelectionControl() {
        _classCallCheck$2(this, MDCSelectionControl);
      }

      _createClass$2(MDCSelectionControl, [{
        key: "ripple",

        /** @return {?MDCRipple} */
        get: function get() {}
      }]);

      return MDCSelectionControl;
    }();

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Checkbox. Provides an interface for managing
     * - classes
     * - dom
     * - event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */

    var MDCCheckboxAdapter =
    /*#__PURE__*/
    function () {
      function MDCCheckboxAdapter() {
        _classCallCheck$2(this, MDCCheckboxAdapter);
      }

      _createClass$2(MDCCheckboxAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets an attribute with a given value on the input element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setNativeControlAttr",
        value: function setNativeControlAttr(attr, value) {}
        /**
         * Removes an attribute from the input element.
         * @param {string} attr
         */

      }, {
        key: "removeNativeControlAttr",
        value: function removeNativeControlAttr(attr) {}
      }, {
        key: "forceLayout",
        value: function forceLayout() {}
        /** @return {boolean} */

      }, {
        key: "isAttachedToDOM",
        value: function isAttachedToDOM() {}
        /** @return {boolean} */

      }, {
        key: "isIndeterminate",
        value: function isIndeterminate() {}
        /** @return {boolean} */

      }, {
        key: "isChecked",
        value: function isChecked() {}
        /** @return {boolean} */

      }, {
        key: "hasNativeControl",
        value: function hasNativeControl() {}
        /** @param {boolean} disabled */

      }, {
        key: "setNativeControlDisabled",
        value: function setNativeControlDisabled(disabled) {}
      }]);

      return MDCCheckboxAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @const {string} */
    var ROOT = 'mdc-checkbox';
    /** @enum {string} */

    var cssClasses$1$1 = {
      UPGRADED: 'mdc-checkbox--upgraded',
      CHECKED: 'mdc-checkbox--checked',
      INDETERMINATE: 'mdc-checkbox--indeterminate',
      DISABLED: 'mdc-checkbox--disabled',
      ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
      ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
      ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
      ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
      ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
      ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
    };
    /** @enum {string} */

    var strings$1$1 = {
      NATIVE_CONTROL_SELECTOR: ".".concat(ROOT, "__native-control"),
      TRANSITION_STATE_INIT: 'init',
      TRANSITION_STATE_CHECKED: 'checked',
      TRANSITION_STATE_UNCHECKED: 'unchecked',
      TRANSITION_STATE_INDETERMINATE: 'indeterminate',
      ARIA_CHECKED_ATTR: 'aria-checked',
      ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed'
    };
    /** @enum {number} */

    var numbers$1$1 = {
      ANIM_END_LATCH_MS: 250
    };

    /**
     * @extends {MDCFoundation<!MDCCheckboxAdapter>}
     */

    var MDCCheckboxFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$2(MDCCheckboxFoundation, _MDCFoundation);

      _createClass$2(MDCCheckboxFoundation, null, [{
        key: "cssClasses",

        /** @return enum {cssClasses} */
        get: function get() {
          return cssClasses$1$1;
        }
        /** @return enum {strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$1;
        }
        /** @return enum {numbers} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$1;
        }
        /** @return {!MDCCheckboxAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCCheckboxAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              setNativeControlAttr: function setNativeControlAttr()
              /* attr: string, value: string */
              {},
              removeNativeControlAttr: function removeNativeControlAttr()
              /* attr: string */
              {},
              forceLayout: function forceLayout() {},
              isAttachedToDOM: function isAttachedToDOM()
              /* boolean */
              {},
              isIndeterminate: function isIndeterminate()
              /* boolean */
              {},
              isChecked: function isChecked()
              /* boolean */
              {},
              hasNativeControl: function hasNativeControl()
              /* boolean */
              {},
              setNativeControlDisabled: function setNativeControlDisabled()
              /* disabled: boolean */
              {}
            }
          );
        }
      }]);

      function MDCCheckboxFoundation(adapter) {
        var _this;

        _classCallCheck$2(this, MDCCheckboxFoundation);

        _this = _possibleConstructorReturn$2(this, _getPrototypeOf$2(MDCCheckboxFoundation).call(this, Object.assign(MDCCheckboxFoundation.defaultAdapter, adapter)));
        /** @private {string} */

        _this.currentCheckState_ = strings$1$1.TRANSITION_STATE_INIT;
        /** @private {string} */

        _this.currentAnimationClass_ = '';
        /** @private {number} */

        _this.animEndLatchTimer_ = 0;
        /** @private {boolean} */

        _this.enableAnimationEndHandler_ = false;
        return _this;
      }
      /** @override */


      _createClass$2(MDCCheckboxFoundation, [{
        key: "init",
        value: function init() {
          this.currentCheckState_ = this.determineCheckState_();
          this.updateAriaChecked_();
          this.adapter_.addClass(cssClasses$1$1.UPGRADED);
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          clearTimeout(this.animEndLatchTimer_);
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          this.adapter_.setNativeControlDisabled(disabled);

          if (disabled) {
            this.adapter_.addClass(cssClasses$1$1.DISABLED);
          } else {
            this.adapter_.removeClass(cssClasses$1$1.DISABLED);
          }
        }
        /**
         * Handles the animationend event for the checkbox
         */

      }, {
        key: "handleAnimationEnd",
        value: function handleAnimationEnd() {
          var _this2 = this;

          if (!this.enableAnimationEndHandler_) return;
          clearTimeout(this.animEndLatchTimer_);
          this.animEndLatchTimer_ = setTimeout(function () {
            _this2.adapter_.removeClass(_this2.currentAnimationClass_);

            _this2.enableAnimationEndHandler_ = false;
          }, numbers$1$1.ANIM_END_LATCH_MS);
        }
        /**
         * Handles the change event for the checkbox
         */

      }, {
        key: "handleChange",
        value: function handleChange() {
          this.transitionCheckState_();
        }
        /** @private */

      }, {
        key: "transitionCheckState_",
        value: function transitionCheckState_() {
          if (!this.adapter_.hasNativeControl()) {
            return;
          }

          var oldState = this.currentCheckState_;
          var newState = this.determineCheckState_();

          if (oldState === newState) {
            return;
          }

          this.updateAriaChecked_(); // Check to ensure that there isn't a previously existing animation class, in case for example
          // the user interacted with the checkbox before the animation was finished.

          if (this.currentAnimationClass_.length > 0) {
            clearTimeout(this.animEndLatchTimer_);
            this.adapter_.forceLayout();
            this.adapter_.removeClass(this.currentAnimationClass_);
          }

          this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
          this.currentCheckState_ = newState; // Check for parentNode so that animations are only run when the element is attached
          // to the DOM.

          if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
            this.adapter_.addClass(this.currentAnimationClass_);
            this.enableAnimationEndHandler_ = true;
          }
        }
        /**
         * @return {string}
         * @private
         */

      }, {
        key: "determineCheckState_",
        value: function determineCheckState_() {
          var TRANSITION_STATE_INDETERMINATE = strings$1$1.TRANSITION_STATE_INDETERMINATE,
              TRANSITION_STATE_CHECKED = strings$1$1.TRANSITION_STATE_CHECKED,
              TRANSITION_STATE_UNCHECKED = strings$1$1.TRANSITION_STATE_UNCHECKED;

          if (this.adapter_.isIndeterminate()) {
            return TRANSITION_STATE_INDETERMINATE;
          }

          return this.adapter_.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
        }
        /**
         * @param {string} oldState
         * @param {string} newState
         * @return {string}
         */

      }, {
        key: "getTransitionAnimationClass_",
        value: function getTransitionAnimationClass_(oldState, newState) {
          var TRANSITION_STATE_INIT = strings$1$1.TRANSITION_STATE_INIT,
              TRANSITION_STATE_CHECKED = strings$1$1.TRANSITION_STATE_CHECKED,
              TRANSITION_STATE_UNCHECKED = strings$1$1.TRANSITION_STATE_UNCHECKED;
          var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
              ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
              ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
              ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
              ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
              ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
              ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;

          switch (oldState) {
            case TRANSITION_STATE_INIT:
              if (newState === TRANSITION_STATE_UNCHECKED) {
                return '';
              }

            // fallthrough

            case TRANSITION_STATE_UNCHECKED:
              return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;

            case TRANSITION_STATE_CHECKED:
              return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
            // TRANSITION_STATE_INDETERMINATE

            default:
              return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
          }
        }
      }, {
        key: "updateAriaChecked_",
        value: function updateAriaChecked_() {
          // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
          if (this.adapter_.isIndeterminate()) {
            this.adapter_.setNativeControlAttr(strings$1$1.ARIA_CHECKED_ATTR, strings$1$1.ARIA_CHECKED_INDETERMINATE_VALUE);
          } else {
            // The on/off state does not need to keep track of aria-checked, since
            // the screenreader uses the checked property on the checkbox element.
            this.adapter_.removeNativeControlAttr(strings$1$1.ARIA_CHECKED_ATTR);
          }
        }
      }]);

      return MDCCheckboxFoundation;
    }(MDCFoundation$2);

    /** @const {!Array<string>} */

    var CB_PROTO_PROPS = ['checked', 'indeterminate'];
    /**
     * @extends MDCComponent<!MDCCheckboxFoundation>
     * @implements {MDCSelectionControl}
     */

    var MDCCheckbox =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$2(MDCCheckbox, _MDCComponent);

      _createClass$2(MDCCheckbox, [{
        key: "nativeCb_",

        /**
         * Returns the state of the native control element, or null if the native control element is not present.
         * @return {!MDCSelectionControlState}
         * @private
         */
        get: function get() {
          var NATIVE_CONTROL_SELECTOR = MDCCheckboxFoundation.strings.NATIVE_CONTROL_SELECTOR;
          var cbEl =
          /** @type {!MDCSelectionControlState} */
          this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
          return cbEl;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCCheckbox(root);
        }
      }]);

      function MDCCheckbox() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$2(this, MDCCheckbox);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$2(this, (_getPrototypeOf2 = _getPrototypeOf$2(MDCCheckbox)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        /** @private {!Function} */

        _this.handleChange_;
        /** @private {!Function} */

        _this.handleAnimationEnd_;
        return _this;
      }

      _createClass$2(MDCCheckbox, [{
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.handleChange_ = function () {
            return _this2.foundation_.handleChange();
          };

          this.handleAnimationEnd_ = function () {
            return _this2.foundation_.handleAnimationEnd();
          };

          this.nativeCb_.addEventListener('change', this.handleChange_);
          this.listen(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
          this.installPropertyChangeHooks_();
        }
        /**
         * @return {!MDCRipple}
         * @private
         */

      }, {
        key: "initRipple_",
        value: function initRipple_() {
          var _this3 = this;

          var MATCHES = getMatchesProperty$1(HTMLElement.prototype);
          var adapter = Object.assign(MDCRipple$1.createAdapter(this), {
            isUnbounded: function isUnbounded() {
              return true;
            },
            isSurfaceActive: function isSurfaceActive() {
              return _this3.nativeCb_[MATCHES](':active');
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this3.nativeCb_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this3.nativeCb_.removeEventListener(type, handler);
            }
          });
          var foundation = new MDCRippleFoundation$1(adapter);
          return new MDCRipple$1(this.root_, foundation);
        }
        /** @private */

      }, {
        key: "installPropertyChangeHooks_",
        value: function installPropertyChangeHooks_() {
          var _this4 = this;

          var nativeCb = this.nativeCb_;
          var cbProto = Object.getPrototypeOf(nativeCb);
          CB_PROTO_PROPS.forEach(function (controlState) {
            var desc = Object.getOwnPropertyDescriptor(cbProto, controlState); // We have to check for this descriptor, since some browsers (Safari) don't support its return.
            // See: https://bugs.webkit.org/show_bug.cgi?id=49739

            if (validDescriptor(desc)) {
              var nativeCbDesc =
              /** @type {!ObjectPropertyDescriptor} */
              {
                get: desc.get,
                set: function set(state) {
                  desc.set.call(nativeCb, state);

                  _this4.foundation_.handleChange();
                },
                configurable: desc.configurable,
                enumerable: desc.enumerable
              };
              Object.defineProperty(nativeCb, controlState, nativeCbDesc);
            }
          });
        }
        /** @private */

      }, {
        key: "uninstallPropertyChangeHooks_",
        value: function uninstallPropertyChangeHooks_() {
          var nativeCb = this.nativeCb_;
          var cbProto = Object.getPrototypeOf(nativeCb);
          CB_PROTO_PROPS.forEach(function (controlState) {
            var desc =
            /** @type {!ObjectPropertyDescriptor} */
            Object.getOwnPropertyDescriptor(cbProto, controlState);

            if (validDescriptor(desc)) {
              Object.defineProperty(nativeCb, controlState, desc);
            }
          });
        }
        /** @return {!MDCCheckboxFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this5 = this;

          return new MDCCheckboxFoundation({
            addClass: function addClass(className) {
              return _this5.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this5.root_.classList.remove(className);
            },
            setNativeControlAttr: function setNativeControlAttr(attr, value) {
              return _this5.nativeCb_.setAttribute(attr, value);
            },
            removeNativeControlAttr: function removeNativeControlAttr(attr) {
              return _this5.nativeCb_.removeAttribute(attr);
            },
            isIndeterminate: function isIndeterminate() {
              return _this5.indeterminate;
            },
            isChecked: function isChecked() {
              return _this5.checked;
            },
            hasNativeControl: function hasNativeControl() {
              return !!_this5.nativeCb_;
            },
            setNativeControlDisabled: function setNativeControlDisabled(disabled) {
              return _this5.nativeCb_.disabled = disabled;
            },
            forceLayout: function forceLayout() {
              return _this5.root_.offsetWidth;
            },
            isAttachedToDOM: function isAttachedToDOM() {
              return Boolean(_this5.root_.parentNode);
            }
          });
        }
        /** @return {!MDCRipple} */

      }, {
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();
          this.nativeCb_.removeEventListener('change', this.handleChange_);
          this.unlisten(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
          this.uninstallPropertyChangeHooks_();

          _get(_getPrototypeOf$2(MDCCheckbox.prototype), "destroy", this).call(this);
        }
      }, {
        key: "ripple",
        get: function get() {
          return this.ripple_;
        }
        /** @return {boolean} */

      }, {
        key: "checked",
        get: function get() {
          return this.nativeCb_.checked;
        }
        /** @param {boolean} checked */
        ,
        set: function set(checked) {
          this.nativeCb_.checked = checked;
        }
        /** @return {boolean} */

      }, {
        key: "indeterminate",
        get: function get() {
          return this.nativeCb_.indeterminate;
        }
        /** @param {boolean} indeterminate */
        ,
        set: function set(indeterminate) {
          this.nativeCb_.indeterminate = indeterminate;
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get() {
          return this.nativeCb_.disabled;
        }
        /** @param {boolean} disabled */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
        /** @return {?string} */

      }, {
        key: "value",
        get: function get() {
          return this.nativeCb_.value;
        }
        /** @param {?string} value */
        ,
        set: function set(value) {
          this.nativeCb_.value = value;
        }
      }]);

      return MDCCheckbox;
    }(MDCComponent$2);
    /**
     * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
     * @return {boolean}
     */


    function validDescriptor(inputPropDesc) {
      return !!inputPropDesc && typeof inputPropDesc.set === 'function';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextUniqueId = 0;
    /**
     * Change event object emitted by MdcCheckbox.
     */
    var   /**
     * Change event object emitted by MdcCheckbox.
     */
    MdcCheckboxChange = /** @class */ (function () {
        function MdcCheckboxChange(source, checked) {
            this.source = source;
            this.checked = checked;
        }
        return MdcCheckboxChange;
    }());
    /** @type {?} */
    var MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return MdcCheckbox; })),
        multi: true
    };
    var MdcCheckbox = /** @class */ (function () {
        function MdcCheckbox(_platform, _ngZone, _changeDetectorRef, elementRef, ripple, _parentFormField) {
            this._platform = _platform;
            this._ngZone = _ngZone;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this.ripple = ripple;
            this._parentFormField = _parentFormField;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._uniqueId = "mdc-checkbox-" + ++nextUniqueId;
            this.id = this._uniqueId;
            this.name = null;
            this._checked = false;
            this._disabled = false;
            /**
             * The value attribute of the native input element
             */
            this.value = null;
            this._indeterminate = false;
            this._indeterminateToChecked = true;
            this.tabIndex = 0;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            /**
             * Fired when checkbox is checked or unchecked, but not when set
             * indeterminate. Sends the state of [checked].
             */
            this.change = new core.EventEmitter();
            /**
             * Fired when checkbox goes in and out of indeterminate state, but not when
             * set to checked. Sends the state of [indeterminate];
             */
            this.indeterminateChange = new core.EventEmitter();
            /**
             * View to model callback called when value changes
             */
            this._onChange = (/**
             * @return {?}
             */
            function () { });
            /**
             * View to model callback called when component has been touched
             */
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
            this._foundation = new MDCCheckboxFoundation(this._createAdapter());
            if (this._parentFormField) {
                _parentFormField.elementRef.nativeElement.classList.add('mdc-form-field');
            }
        }
        Object.defineProperty(MdcCheckbox.prototype, "inputId", {
            /** Returns the unique id for the visual hidden input. */
            get: /**
             * Returns the unique id for the visual hidden input.
             * @return {?}
             */
            function () { return (this.id || this._uniqueId) + "-input"; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () { return this._checked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this.checked) {
                    this._checked = toBoolean(value);
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabledState(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "indeterminate", {
            /**
             * Alternative state of the checkbox, not user set-able state. Between
             * [checked] and [indeterminate], only one can be true, though both can be
             * false.
             * `true` is INDETERMINATE and `false` is not.
             */
            get: /**
             * Alternative state of the checkbox, not user set-able state. Between
             * [checked] and [indeterminate], only one can be true, though both can be
             * false.
             * `true` is INDETERMINATE and `false` is not.
             * @return {?}
             */
            function () { return this._indeterminate; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this.disabled) {
                    return;
                }
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._indeterminate) {
                    this._indeterminate = newValue;
                    if (newValue) {
                        this.checked = false;
                    }
                    this.indeterminateChange.emit({ source: this, indeterminate: this._indeterminate });
                    this._changeDetectorRef.markForCheck();
                    this._foundation.handleChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "indeterminateToChecked", {
            /**
             * Determines the state to go into when [indeterminate] state is toggled.
             * `true` will go to checked and `false` will go to unchecked.
             */
            get: /**
             * Determines the state to go into when [indeterminate] state is toggled.
             * `true` will go to checked and `false` will go to unchecked.
             * @return {?}
             */
            function () { return this._indeterminateToChecked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._indeterminateToChecked = toBoolean(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcCheckbox.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                setNativeControlAttr: (/**
                 * @param {?} attr
                 * @param {?} value
                 * @return {?}
                 */
                function (attr, value) {
                    return _this._inputElement.nativeElement.setAttribute(attr, value);
                }),
                removeNativeControlAttr: (/**
                 * @param {?} attr
                 * @return {?}
                 */
                function (attr) {
                    return _this._inputElement.nativeElement.removeAttribute(attr);
                }),
                isIndeterminate: (/**
                 * @return {?}
                 */
                function () { return _this.indeterminate; }),
                isChecked: (/**
                 * @return {?}
                 */
                function () { return _this.checked; }),
                hasNativeControl: (/**
                 * @return {?}
                 */
                function () { return true; }),
                setNativeControlDisabled: (/**
                 * @param {?} disabled
                 * @return {?}
                 */
                function (disabled) {
                    return _this._inputElement.nativeElement.disabled = disabled;
                }),
                forceLayout: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().offsetWidth; }),
                isAttachedToDOM: (/**
                 * @return {?}
                 */
                function () { return true; })
            };
        };
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._initRipple();
            this._loadListeners();
        };
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this.ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcCheckbox.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.checked = !!value;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcCheckbox.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcCheckbox.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /** Focuses the checkbox. */
        /**
         * Focuses the checkbox.
         * @return {?}
         */
        MdcCheckbox.prototype.focus = /**
         * Focuses the checkbox.
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._inputElement.nativeElement.focus();
            }
        };
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.toggle = /**
         * @return {?}
         */
        function () {
            this._setState();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcCheckbox.prototype._onInteraction = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            // We have to stop propagation for click events on the visual hidden input element.
            // Preventing bubbling for the second event will solve that issue.
            evt.stopPropagation();
            this._setState();
            this._onChange(this.checked);
            this._changeDetectorRef.markForCheck();
            this.change.emit(new MdcCheckboxChange(this, this.checked));
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcCheckbox.prototype._onInputClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcCheckbox.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = toBoolean(disabled);
            this._foundation.setDisabled(this._disabled);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        MdcCheckbox.prototype._setState = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.disabled) {
                return;
            }
            if (this.indeterminate) {
                this._checked = this.indeterminateToChecked;
                this.indeterminate = false;
            }
            else {
                this.checked = !this.checked;
            }
            // Reset native input when clicked with noop. The native checkbox becomes checked after
            // click, reset it to be align with `checked` value of `mdc-checkbox`.
            this._inputElement.nativeElement.checked = this.checked;
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return requestAnimationFrame((/**
                 * @return {?}
                 */
                function () { return _this._foundation.handleChange(); }));
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcCheckbox.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.ripple.init({
                surface: this.elementRef.nativeElement,
                activator: this._inputElement.nativeElement
            }, Object.assign(this.ripple.createAdapter(), {
                isUnbounded: (/**
                 * @return {?}
                 */
                function () { return true; }),
                isSurfaceDisabled: (/**
                 * @return {?}
                 */
                function () { return _this._disabled; })
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcCheckbox.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this._platform.isBrowser) {
                return;
            }
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._getHostElement(), 'animationend')
                    .pipe(operators.takeUntil(_this._destroy), operators.filter((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    return e.target === _this._getHostElement();
                })))
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    return _this._ngZone.run((/**
                     * @return {?}
                     */
                    function () { return _this._foundation.handleAnimationEnd(); }));
                }));
            }));
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcCheckbox.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcCheckbox.decorators = [
            { type: core.Component, args: [{selector: 'mdc-checkbox',
                        exportAs: 'mdcCheckbox',
                        host: {
                            '[id]': 'id',
                            'class': 'mdc-checkbox'
                        },
                        template: "\n  <input type=\"checkbox\"\n    #input\n    class=\"mdc-checkbox__native-control\"\n    [id]=\"inputId\"\n    [attr.name]=\"name\"\n    [tabIndex]=\"tabIndex\"\n    [attr.aria-label]=\"ariaLabel || null\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [attr.value]=\"value\"\n    [indeterminate]=\"indeterminate\"\n    (change)=\"_onInteraction($event)\"\n    (click)=\"_onInputClick($event)\"/>\n  <div class=\"mdc-checkbox__background\">\n    <svg\n      class=\"mdc-checkbox__checkmark\"\n      viewBox=\"0 0 24 24\"\n      focusable=\"false\">\n      <path class=\"mdc-checkbox__checkmark-path\"\n        fill=\"none\"\n        d=\"M1.73,12.91 8.1,19.28 22.79,4.59\"/>\n    </svg>\n    <div class=\"mdc-checkbox__mixedmark\"></div>\n  </div>\n  ",
                        providers: [
                            MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR,
                            MdcRipple,
                            { provide: MdcFormFieldControl, useExisting: MdcCheckbox }
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCheckbox.ctorParameters = function () { return [
            { type: Platform },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: MdcRipple },
            { type: MdcFormField, decorators: [{ type: core.Optional }] }
        ]; };
        MdcCheckbox.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            indeterminate: [{ type: core.Input }],
            indeterminateToChecked: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            change: [{ type: core.Output }],
            indeterminateChange: [{ type: core.Output }],
            _inputElement: [{ type: core.ViewChild, args: ['input',] }]
        };
        return MdcCheckbox;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcCheckboxModule = /** @class */ (function () {
        function MdcCheckboxModule() {
        }
        MdcCheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [MdcFormFieldModule],
                        exports: [
                            MdcFormFieldModule,
                            MdcCheckbox
                        ],
                        declarations: [MdcCheckbox]
                    },] },
        ];
        return MdcCheckboxModule;
    }());

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$3 = {
      ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
      INTERACTION_EVENT: 'MDCChip:interaction',
      SELECTION_EVENT: 'MDCChip:selection',
      TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
      REMOVAL_EVENT: 'MDCChip:removal',
      CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
      LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
      TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
    };
    /** @enum {string} */

    var cssClasses$3 = {
      CHECKMARK: 'mdc-chip__checkmark',
      CHIP_EXIT: 'mdc-chip--exit',
      HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
      LEADING_ICON: 'mdc-chip__icon--leading',
      TRAILING_ICON: 'mdc-chip__icon--trailing',
      SELECTED: 'mdc-chip--selected'
    };

    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$3(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$3(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$3(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$3(subClass, superClass);
    }

    function _getPrototypeOf$3(o) {
      _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$3(o);
    }

    function _setPrototypeOf$3(o, p) {
      _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$3(o, p);
    }

    function _assertThisInitialized$3(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$3(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$3(self);
    }

    function _superPropBase$1(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$3(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$1(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$1 = Reflect.get;
      } else {
        _get$1 = function _get(target, property, receiver) {
          var base = _superPropBase$1(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$1(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$3 =
    /*#__PURE__*/
    function () {
      _createClass$3(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$3(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$3(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$3 =
    /*#__PURE__*/
    function () {
      _createClass$3(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$3());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$3(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$3(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$3(this, MDCRippleAdapter);
      }

      _createClass$3(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1$2 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$2 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$2 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$2;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$2;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$2(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$2(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$2;

      if (typeof supportsCssVariables_$2 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$2(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$2 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$2() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$2 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$2 = isSupported;
      }

      return supportsPassive_$2 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$2(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$2(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$3 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$3 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$2 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$3(MDCRippleFoundation, _MDCFoundation);

      _createClass$3(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$2;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$2;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$2;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$3(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$3(this, _getPrototypeOf$3(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$3(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$3.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$3.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$3.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$3.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$2.length > 0 && activatedTargets$2.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$2.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$2 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$2(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$2.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$3);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$3(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$3(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$3(this, (_getPrototypeOf2 = _getPrototypeOf$3(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$3(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$2(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$2(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$2(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$2());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$2());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$2());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$2());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$3);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$2 = function RippleCapableSurface() {
      _classCallCheck$3(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$2.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$2.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$2.prototype.disabled;

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Chip.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Chip into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCChipAdapter =
    /*#__PURE__*/
    function () {
      function MDCChipAdapter() {
        _classCallCheck$3(this, MDCChipAdapter);
      }

      _createClass$3(MDCChipAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Adds a class to the leading icon element.
         * @param {string} className
         */

      }, {
        key: "addClassToLeadingIcon",
        value: function addClassToLeadingIcon(className) {}
        /**
         * Removes a class from the leading icon element.
         * @param {string} className
         */

      }, {
        key: "removeClassFromLeadingIcon",
        value: function removeClassFromLeadingIcon(className) {}
        /**
         * Returns true if target has className, false otherwise.
         * @param {!EventTarget} target
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "eventTargetHasClass",
        value: function eventTargetHasClass(target, className) {}
        /**
         * Emits a custom "MDCChip:interaction" event denoting the chip has been
         * interacted with (typically on click or keydown).
         */

      }, {
        key: "notifyInteraction",
        value: function notifyInteraction() {}
        /**
         * Emits a custom "MDCChip:selection" event denoting the chip has been selected or deselected.
         * @param {boolean} selected
         */

      }, {
        key: "notifySelection",
        value: function notifySelection(selected) {}
        /**
         * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
         * interacted with (typically on click or keydown).
         */

      }, {
        key: "notifyTrailingIconInteraction",
        value: function notifyTrailingIconInteraction() {}
        /**
         * Emits a custom event "MDCChip:removal" denoting the chip will be removed.
         */

      }, {
        key: "notifyRemoval",
        value: function notifyRemoval() {}
        /**
         * Returns the computed property value of the given style property on the root element.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getComputedStyleValue",
        value: function getComputedStyleValue(propertyName) {}
        /**
         * Sets the property value of the given style property on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyleProperty",
        value: function setStyleProperty(propertyName, value) {}
        /**
         * Returns whether the chip has a leading icon.
         * @return {boolean}
         */

      }, {
        key: "hasLeadingIcon",
        value: function hasLeadingIcon() {}
        /**
         * Returns the bounding client rect of the root element.
         * @return {!ClientRect}
         */

      }, {
        key: "getRootBoundingClientRect",
        value: function getRootBoundingClientRect() {}
        /**
         * Returns the bounding client rect of the checkmark element or null if it doesn't exist.
         * @return {?ClientRect}
         */

      }, {
        key: "getCheckmarkBoundingClientRect",
        value: function getCheckmarkBoundingClientRect() {}
      }]);

      return MDCChipAdapter;
    }();

    /**
     * @extends {MDCFoundation<!MDCChipAdapter>}
     * @final
     */

    var MDCChipFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$3(MDCChipFoundation, _MDCFoundation);

      _createClass$3(MDCChipFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$3;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$3;
        }
        /**
         * {@see MDCChipAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCChipAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCChipAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              addClassToLeadingIcon: function addClassToLeadingIcon() {},
              removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
              eventTargetHasClass: function eventTargetHasClass() {},
              notifyInteraction: function notifyInteraction() {},
              notifySelection: function notifySelection() {},
              notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {},
              notifyRemoval: function notifyRemoval() {},
              getComputedStyleValue: function getComputedStyleValue() {},
              setStyleProperty: function setStyleProperty() {},
              hasLeadingIcon: function hasLeadingIcon() {},
              getRootBoundingClientRect: function getRootBoundingClientRect() {},
              getCheckmarkBoundingClientRect: function getCheckmarkBoundingClientRect() {}
            }
          );
        }
        /**
         * @param {!MDCChipAdapter} adapter
         */

      }]);

      function MDCChipFoundation(adapter) {
        var _this;

        _classCallCheck$3(this, MDCChipFoundation);

        _this = _possibleConstructorReturn$3(this, _getPrototypeOf$3(MDCChipFoundation).call(this, Object.assign(MDCChipFoundation.defaultAdapter, adapter)));
        /**
         * Whether a trailing icon click should immediately trigger exit/removal of the chip.
         * @private {boolean}
         * */

        _this.shouldRemoveOnTrailingIconClick_ = true;
        return _this;
      }
      /**
       * @return {boolean}
       */


      _createClass$3(MDCChipFoundation, [{
        key: "isSelected",
        value: function isSelected() {
          return this.adapter_.hasClass(cssClasses$3.SELECTED);
        }
        /**
         * @param {boolean} selected
         */

      }, {
        key: "setSelected",
        value: function setSelected(selected) {
          if (selected) {
            this.adapter_.addClass(cssClasses$3.SELECTED);
          } else {
            this.adapter_.removeClass(cssClasses$3.SELECTED);
          }

          this.adapter_.notifySelection(selected);
        }
        /**
         * @return {boolean}
         */

      }, {
        key: "getShouldRemoveOnTrailingIconClick",
        value: function getShouldRemoveOnTrailingIconClick() {
          return this.shouldRemoveOnTrailingIconClick_;
        }
        /**
         * @param {boolean} shouldRemove
         */

      }, {
        key: "setShouldRemoveOnTrailingIconClick",
        value: function setShouldRemoveOnTrailingIconClick(shouldRemove) {
          this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
        }
        /** @return {!ClientRect} */

      }, {
        key: "getDimensions",
        value: function getDimensions() {
          // When a chip has a checkmark and not a leading icon, the bounding rect changes in size depending on the current
          // size of the checkmark.
          if (!this.adapter_.hasLeadingIcon() && this.adapter_.getCheckmarkBoundingClientRect() !== null) {
            var height = this.adapter_.getRootBoundingClientRect().height; // The checkmark's width is initially set to 0, so use the checkmark's height as a proxy since the checkmark
            // should always be square.

            var width = this.adapter_.getRootBoundingClientRect().width + this.adapter_.getCheckmarkBoundingClientRect().height;
            return (
              /** @type {!ClientRect} */
              {
                height: height,
                width: width
              }
            );
          } else {
            return this.adapter_.getRootBoundingClientRect();
          }
        }
        /**
         * Begins the exit animation which leads to removal of the chip.
         */

      }, {
        key: "beginExit",
        value: function beginExit() {
          this.adapter_.addClass(cssClasses$3.CHIP_EXIT);
        }
        /**
         * Handles an interaction event on the root element.
         * @param {!Event} evt
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction(evt) {
          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyInteraction();
          }
        }
        /**
         * Handles a transition end event on the root element.
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          var _this2 = this;

          // Handle transition end event on the chip when it is about to be removed.
          if (this.adapter_.eventTargetHasClass(
          /** @type {!EventTarget} */
          evt.target, cssClasses$3.CHIP_EXIT)) {
            if (evt.propertyName === 'width') {
              this.adapter_.notifyRemoval();
            } else if (evt.propertyName === 'opacity') {
              // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
              var chipWidth = this.adapter_.getComputedStyleValue('width'); // On the next frame (once we get the computed width), explicitly set the chip's width
              // to its current pixel width, so we aren't transitioning out of 'auto'.

              requestAnimationFrame(function () {
                _this2.adapter_.setStyleProperty('width', chipWidth); // To mitigate jitter, start transitioning padding and margin before width.


                _this2.adapter_.setStyleProperty('padding', '0');

                _this2.adapter_.setStyleProperty('margin', '0'); // On the next frame (once width is explicitly set), transition width to 0.


                requestAnimationFrame(function () {
                  _this2.adapter_.setStyleProperty('width', '0');
                });
              });
            }

            return;
          } // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.


          if (evt.propertyName !== 'opacity') {
            return;
          }

          if (this.adapter_.eventTargetHasClass(
          /** @type {!EventTarget} */
          evt.target, cssClasses$3.LEADING_ICON) && this.adapter_.hasClass(cssClasses$3.SELECTED)) {
            this.adapter_.addClassToLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
          } else if (this.adapter_.eventTargetHasClass(
          /** @type {!EventTarget} */
          evt.target, cssClasses$3.CHECKMARK) && !this.adapter_.hasClass(cssClasses$3.SELECTED)) {
            this.adapter_.removeClassFromLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
          }
        }
        /**
         * Handles an interaction event on the trailing icon element. This is used to
         * prevent the ripple from activating on interaction with the trailing icon.
         * @param {!Event} evt
         */

      }, {
        key: "handleTrailingIconInteraction",
        value: function handleTrailingIconInteraction(evt) {
          evt.stopPropagation();

          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyTrailingIconInteraction();

            if (this.shouldRemoveOnTrailingIconClick_) {
              this.beginExit();
            }
          }
        }
      }]);

      return MDCChipFoundation;
    }(MDCFoundation$3);

    var INTERACTION_EVENTS = ['click', 'keydown'];
    /**
     * @extends {MDCComponent<!MDCChipFoundation>}
     * @final
     */

    var MDCChip =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$3(MDCChip, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCChip() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$3(this, MDCChip);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$3(this, (_getPrototypeOf2 = _getPrototypeOf$3(MDCChip)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {string} */

        _this.id;
        /** @private {?Element} */

        _this.leadingIcon_;
        /** @private {?Element} */

        _this.trailingIcon_;
        /** @private {?Element} */

        _this.checkmark_;
        /** @private {!MDCRipple} */

        _this.ripple_;
        /** @private {?function(?Event): undefined} */

        _this.handleInteraction_;
        /** @private {?function(!Event): undefined} */

        _this.handleTransitionEnd_;
        /** @private {function(!Event): undefined} */

        _this.handleTrailingIconInteraction_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCChip}
       */


      _createClass$3(MDCChip, [{
        key: "initialize",
        value: function initialize() {
          var _this2 = this;

          var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el, foundation) {
            return new MDCRipple$2(el, foundation);
          };
          this.id = this.root_.id;
          this.leadingIcon_ = this.root_.querySelector(strings$3.LEADING_ICON_SELECTOR);
          this.trailingIcon_ = this.root_.querySelector(strings$3.TRAILING_ICON_SELECTOR);
          this.checkmark_ = this.root_.querySelector(strings$3.CHECKMARK_SELECTOR);
          var adapter = Object.assign(MDCRipple$2.createAdapter(this), {
            computeBoundingRect: function computeBoundingRect() {
              return _this2.foundation_.getDimensions();
            }
          });
          this.ripple_ = rippleFactory(this.root_, new MDCRippleFoundation$2(adapter));
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this3 = this;

          this.handleInteraction_ = function (evt) {
            return _this3.foundation_.handleInteraction(evt);
          };

          this.handleTransitionEnd_ = function (evt) {
            return _this3.foundation_.handleTransitionEnd(evt);
          };

          this.handleTrailingIconInteraction_ = function (evt) {
            return _this3.foundation_.handleTrailingIconInteraction(evt);
          };

          INTERACTION_EVENTS.forEach(function (evtType) {
            _this3.root_.addEventListener(evtType, _this3.handleInteraction_);
          });
          this.root_.addEventListener('transitionend', this.handleTransitionEnd_);

          if (this.trailingIcon_) {
            INTERACTION_EVENTS.forEach(function (evtType) {
              _this3.trailingIcon_.addEventListener(evtType, _this3.handleTrailingIconInteraction_);
            });
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this4 = this;

          this.ripple_.destroy();
          INTERACTION_EVENTS.forEach(function (evtType) {
            _this4.root_.removeEventListener(evtType, _this4.handleInteraction_);
          });
          this.root_.removeEventListener('transitionend', this.handleTransitionEnd_);

          if (this.trailingIcon_) {
            INTERACTION_EVENTS.forEach(function (evtType) {
              _this4.trailingIcon_.removeEventListener(evtType, _this4.handleTrailingIconInteraction_);
            });
          }

          _get$1(_getPrototypeOf$3(MDCChip.prototype), "destroy", this).call(this);
        }
        /**
         * Returns whether the chip is selected.
         * @return {boolean}
         */

      }, {
        key: "beginExit",

        /**
         * Begins the exit animation which leads to removal of the chip.
         */
        value: function beginExit() {
          this.foundation_.beginExit();
        }
        /**
         * @return {!MDCChipFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this5 = this;

          return new MDCChipFoundation(
          /** @type {!MDCChipAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this5.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this5.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this5.root_.classList.contains(className);
            },
            addClassToLeadingIcon: function addClassToLeadingIcon(className) {
              if (_this5.leadingIcon_) {
                _this5.leadingIcon_.classList.add(className);
              }
            },
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
              if (_this5.leadingIcon_) {
                _this5.leadingIcon_.classList.remove(className);
              }
            },
            eventTargetHasClass: function eventTargetHasClass(target, className) {
              return target.classList.contains(className);
            },
            notifyInteraction: function notifyInteraction() {
              return _this5.emit(strings$3.INTERACTION_EVENT, {
                chipId: _this5.id
              }, true
              /* shouldBubble */
              );
            },
            notifySelection: function notifySelection(selected) {
              return _this5.emit(strings$3.SELECTION_EVENT, {
                chipId: _this5.id,
                selected: selected
              }, true
              /* shouldBubble */
              );
            },
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
              return _this5.emit(strings$3.TRAILING_ICON_INTERACTION_EVENT, {
                chipId: _this5.id
              }, true
              /* shouldBubble */
              );
            },
            notifyRemoval: function notifyRemoval() {
              return _this5.emit(strings$3.REMOVAL_EVENT, {
                chipId: _this5.id,
                root: _this5.root_
              }, true
              /* shouldBubble */
              );
            },
            getComputedStyleValue: function getComputedStyleValue(propertyName) {
              return window.getComputedStyle(_this5.root_).getPropertyValue(propertyName);
            },
            setStyleProperty: function setStyleProperty(propertyName, value) {
              return _this5.root_.style.setProperty(propertyName, value);
            },
            hasLeadingIcon: function hasLeadingIcon() {
              return !!_this5.leadingIcon_;
            },
            getRootBoundingClientRect: function getRootBoundingClientRect() {
              return _this5.root_.getBoundingClientRect();
            },
            getCheckmarkBoundingClientRect: function getCheckmarkBoundingClientRect() {
              return _this5.checkmark_ ? _this5.checkmark_.getBoundingClientRect() : null;
            }
          }));
        }
        /** @return {!MDCRipple} */

      }, {
        key: "selected",
        get: function get() {
          return this.foundation_.isSelected();
        }
        /**
         * Sets selected state on the chip.
         * @param {boolean} selected
         */
        ,
        set: function set(selected) {
          this.foundation_.setSelected(selected);
        }
        /**
         * Returns whether a trailing icon click should trigger exit/removal of the chip.
         * @return {boolean}
         */

      }, {
        key: "shouldRemoveOnTrailingIconClick",
        get: function get() {
          return this.foundation_.getShouldRemoveOnTrailingIconClick();
        }
        /**
         * Sets whether a trailing icon click should trigger exit/removal of the chip.
         * @param {boolean} shouldRemove
         */
        ,
        set: function set(shouldRemove) {
          this.foundation_.setShouldRemoveOnTrailingIconClick(shouldRemove);
        }
      }, {
        key: "ripple",
        get: function get() {
          return this.ripple_;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCChip(root);
        }
      }]);

      return MDCChip;
    }(MDCComponent$3);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token used to provide the parent MdcChipSet component to MdcChip.
     * @type {?}
     */
    var MDC_CHIPSET_PARENT_COMPONENT = new core.InjectionToken('MDC_CHIPSET_PARENT_COMPONENT');
    /** @type {?} */
    var nextUniqueId$1 = 0;
    var MdcChipCheckmark = /** @class */ (function () {
        function MdcChipCheckmark(elementRef) {
            this.elementRef = elementRef;
        }
        MdcChipCheckmark.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip-checkmark',
                        exportAs: 'mdcChipCheckmark',
                        template: "\n  <div class=\"mdc-chip__checkmark\">\n    <svg\n      class=\"mdc-chip__checkmark-svg\"\n      viewBox=\"-2 -3 30 30\"\n      focusable=\"false\">\n      <path class=\"mdc-chip__checkmark-path\" fill=\"none\" stroke=\"black\" d=\"M1.73,12.91 8.1,19.28 22.79,4.59\"/>\n    </svg>\n  </div>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcChipCheckmark.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcChipCheckmark;
    }());
    var MdcChipText = /** @class */ (function () {
        function MdcChipText(elementRef) {
            this.elementRef = elementRef;
        }
        MdcChipText.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-chip-text, [mdcChipText]',
                        host: { 'class': 'mdc-chip__text' }
                    },] },
        ];
        /** @nocollapse */
        MdcChipText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcChipText;
    }());
    var MdcChip = /** @class */ (function () {
        function MdcChip(_platform, _ngZone, _changeDetectorRef, _ripple, elementRef, _parent) {
            this._platform = _platform;
            this._ngZone = _ngZone;
            this._changeDetectorRef = _changeDetectorRef;
            this._ripple = _ripple;
            this.elementRef = elementRef;
            this._parent = _parent;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroyed = new rxjs.Subject();
            this._id = "mdc-chip-" + nextUniqueId$1++;
            this._selected = false;
            this._filter = false;
            this._choice = false;
            this._input = false;
            this._primary = false;
            this._secondary = false;
            this._removable = true;
            this._disabled = false;
            this._disableRipple = false;
            /**
             * Emitted when the chip is selected or deselected.
             */
            this.selectionChange = new core.EventEmitter();
            /**
             * Emitted when the chip icon is interacted with.
             */
            this.trailingIconInteraction = new core.EventEmitter();
            /**
             * Emitted when a chip is to be removed.
             */
            this.removed = new core.EventEmitter();
            this._foundation = new MDCChipFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcChip.prototype, "id", {
            /** The unique ID of the chip. */
            get: /**
             * The unique ID of the chip.
             * @return {?}
             */
            function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "leadingIcon", {
            get: /**
             * @return {?}
             */
            function () {
                return this._icons.find((/**
                 * @param {?} _
                 * @return {?}
                 */
                function (_) { return _.leading; }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "selected", {
            get: /**
             * @return {?}
             */
            function () { return this._selected; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                this._selected = newValue;
                this._foundation.setSelected(newValue);
                if (this.filter && this.leadingIcon) {
                    this.leadingIcon.elementRef.nativeElement.classList.remove(cssClasses$3.HIDDEN_LEADING_ICON);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "filter", {
            get: /**
             * @return {?}
             */
            function () { return this._filter; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._filter) {
                    this._filter = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "choice", {
            get: /**
             * @return {?}
             */
            function () { return this._choice; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._choice = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "input", {
            get: /**
             * @return {?}
             */
            function () { return this._input; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._input = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._primary = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._secondary = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "removable", {
            /** Determines whether or not the chip displays the remove styling and emits (removed) events. */
            get: /**
             * Determines whether or not the chip displays the remove styling and emits (removed) events.
             * @return {?}
             */
            function () { return this._removable; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._removable) {
                    this._removable = value;
                    this._foundation.setShouldRemoveOnTrailingIconClick(this._removable);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "disabled", {
            /** Whether the chip is disabled. */
            get: /**
             * Whether the chip is disabled.
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "disableRipple", {
            /** Whether the chip ripple is disabled. */
            get: /**
             * Whether the chip ripple is disabled.
             * @return {?}
             */
            function () { return this._disableRipple; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disableRipple = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "value", {
            /** The value of the chip. Defaults to the content inside `<mdc-chip>` tags. */
            get: /**
             * The value of the chip. Defaults to the content inside `<mdc-chip>` tags.
             * @return {?}
             */
            function () {
                return this._value !== undefined
                    ? this._value
                    : this.elementRef.nativeElement.textContent;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) { this._value = value; },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcChip.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                addClassToLeadingIcon: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) {
                    if (_this.leadingIcon) {
                        _this.leadingIcon.elementRef.nativeElement.classList.add(className);
                    }
                }),
                removeClassFromLeadingIcon: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) {
                    if (_this.leadingIcon) {
                        _this.leadingIcon.elementRef.nativeElement.classList.remove(className);
                    }
                }),
                eventTargetHasClass: (/**
                 * @param {?} target
                 * @param {?} className
                 * @return {?}
                 */
                function (target, className) { return target.classList.contains(className); }),
                notifyInteraction: (/**
                 * @return {?}
                 */
                function () { return _this._emitSelectionChangeEvent(true); }),
                notifyTrailingIconInteraction: (/**
                 * @return {?}
                 */
                function () { return _this.trailingIconInteraction.emit({ detail: { chipId: _this.id } }); }),
                notifyRemoval: (/**
                 * @return {?}
                 */
                function () { return _this.removed.emit({ detail: { chipId: _this.id, root: _this } }); }),
                getComputedStyleValue: (/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                function (propertyName) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    return window.getComputedStyle(_this._getHostElement()).getPropertyValue(propertyName);
                }),
                setStyleProperty: (/**
                 * @param {?} propertyName
                 * @param {?} value
                 * @return {?}
                 */
                function (propertyName, value) {
                    return _this._getHostElement().style.setProperty(propertyName, value);
                }),
                hasLeadingIcon: (/**
                 * @return {?}
                 */
                function () { return !!_this.leadingIcon; }),
                getRootBoundingClientRect: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().getBoundingClientRect(); }),
                getCheckmarkBoundingClientRect: (/**
                 * @return {?}
                 */
                function () { return _this._checkmark ?
                    _this._checkmark.elementRef.nativeElement.getBoundingClientRect() : null; })
            };
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._setVariantFromChipSet();
            this._initRipple();
            this._loadListeners();
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
            this._ripple.destroy();
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /** Selects the chip. */
        /**
         * Selects the chip.
         * @return {?}
         */
        MdcChip.prototype.select = /**
         * Selects the chip.
         * @return {?}
         */
        function () {
            if (!this._selected) {
                this._selected = true;
                this._emitSelectionChangeEvent();
            }
        };
        /** Deselects the chip. */
        /**
         * Deselects the chip.
         * @return {?}
         */
        MdcChip.prototype.deselect = /**
         * Deselects the chip.
         * @return {?}
         */
        function () {
            if (this._selected) {
                this._selected = false;
                this._emitSelectionChangeEvent();
            }
        };
        /** Select this chip and emit selected event */
        /**
         * Select this chip and emit selected event
         * @return {?}
         */
        MdcChip.prototype.selectViaInteraction = /**
         * Select this chip and emit selected event
         * @return {?}
         */
        function () {
            if (!this._selected) {
                this._selected = true;
                this._emitSelectionChangeEvent(true);
            }
        };
        /** Allows for programmatic focusing of the chip. */
        /**
         * Allows for programmatic focusing of the chip.
         * @return {?}
         */
        MdcChip.prototype.focus = /**
         * Allows for programmatic focusing of the chip.
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcChip.prototype._handleInteraction = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._selected = !this._selected;
            this._foundation.handleInteraction(evt);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcChip.prototype._handleTrailingIconInteraction = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleTrailingIconInteraction(evt);
        };
        /**
         * @private
         * @return {?}
         */
        MdcChip.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ripple.init({
                surface: this._getHostElement()
            }, Object.assign(this._ripple.createAdapter(), {
                isSurfaceDisabled: (/**
                 * @return {?}
                 */
                function () { return _this._disableRipple; }),
                computeBoundingRect: (/**
                 * @return {?}
                 */
                function () { return _this._foundation.getDimensions(); })
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcChip.prototype._setVariantFromChipSet = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._parent) {
                this.input = this._parent.input;
                this.filter = this._parent.filter;
                this.choice = this._parent.choice;
                this._changeDetectorRef.detectChanges();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcChip.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._getHostElement(), 'transitionend')
                    .pipe(operators.takeUntil(_this._destroyed))
                    .subscribe((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this._foundation.handleTransitionEnd(evt); })); }));
            }));
        };
        /** Emits the removed event. */
        /**
         * Emits the removed event.
         * @return {?}
         */
        MdcChip.prototype._emitRemovedEvent = /**
         * Emits the removed event.
         * @return {?}
         */
        function () {
            this.removed.emit({ detail: { chipId: this.id, root: this } });
        };
        /** Emits the selection change event. */
        /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcChip.prototype._emitSelectionChangeEvent = /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        function (isUserInput) {
            this.selectionChange.emit({
                isUserInput: isUserInput,
                detail: { chipId: this.id, selected: this._selected, value: this._value }
            });
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcChip.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcChip.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip',
                        exportAs: 'mdcChip',
                        host: {
                            '[id]': 'id',
                            '[attr.tabindex]': 'disabled ? null : 0',
                            'class': 'mdc-chip',
                            '[class.ngx-mdc-chip--primary]': 'primary',
                            '[class.ngx-mdc-chip--secondary]': 'secondary',
                            '(click)': '_handleInteraction($event)',
                            '(keydown)': '_handleInteraction($event)'
                        },
                        template: "\n  <ng-content select=\"mdc-chip-icon[leading]\"></ng-content>\n  <mdc-chip-checkmark *ngIf=\"filter\"></mdc-chip-checkmark>\n  <div class=\"mdc-chip__text\" *ngIf=\"label\">{{label}}</div>\n  <ng-content></ng-content>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcChip.ctorParameters = function () { return [
            { type: Platform },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_CHIPSET_PARENT_COMPONENT,] }] }
        ]; };
        MdcChip.propDecorators = {
            label: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            filter: [{ type: core.Input }],
            choice: [{ type: core.Input }],
            input: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            removable: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            disableRipple: [{ type: core.Input }],
            value: [{ type: core.Input }],
            selectionChange: [{ type: core.Output }],
            trailingIconInteraction: [{ type: core.Output }],
            removed: [{ type: core.Output }],
            _checkmark: [{ type: core.ContentChild, args: [MdcChipCheckmark,] }],
            _icons: [{ type: core.ContentChildren, args: [core.forwardRef((/**
                         * @return {?}
                         */
                        function () { return MdcChipIcon; })), { descendants: true },] }]
        };
        return MdcChip;
    }());
    var MdcChipIcon = /** @class */ (function (_super) {
        __extends(MdcChipIcon, _super);
        function MdcChipIcon(_parentChip, elementRef, iconRegistry, ariaHidden, location) {
            var _this = _super.call(this, elementRef, iconRegistry, ariaHidden, location) || this;
            _this._parentChip = _parentChip;
            _this._leading = false;
            _this._trailing = false;
            return _this;
        }
        Object.defineProperty(MdcChipIcon.prototype, "leading", {
            get: /**
             * @return {?}
             */
            function () { return this._leading; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._leading = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipIcon.prototype, "trailing", {
            get: /**
             * @return {?}
             */
            function () { return this._trailing; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._trailing = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcChipIcon.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.trailing) {
                this.tabIndex = 0;
                this.role = 'button';
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcChipIcon.prototype._onIconInteraction = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (this.trailing) {
                this._parentChip._handleTrailingIconInteraction(evt);
                if (this._parentChip.removable && this._parentChip.input) {
                    this._parentChip._emitRemovedEvent();
                }
            }
        };
        MdcChipIcon.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip-icon, [mdcChipIcon]',
                        exportAs: 'mdcChipIcon',
                        host: {
                            'class': 'mdc-chip__icon ngx-mdc-icon',
                            '[attr.role]': 'role',
                            '[attr.tabindex]': 'tabIndex',
                            '[class.ngx-mdc-icon--clickable]': 'clickable',
                            '[class.ngx-mdc-icon--inline]': 'inline',
                            '[class.mdc-chip__icon--leading]': 'leading',
                            '[class.mdc-chip__icon--trailing]': 'trailing',
                            '(click)': '_onIconInteraction($event)',
                            '(keydown)': '_onIconInteraction($event)'
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcChipIcon.ctorParameters = function () { return [
            { type: MdcChip },
            { type: core.ElementRef },
            { type: MdcIconRegistry },
            { type: String, decorators: [{ type: core.Attribute, args: ['aria-hidden',] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [MDC_ICON_LOCATION,] }] }
        ]; };
        MdcChipIcon.propDecorators = {
            leading: [{ type: core.Input }],
            trailing: [{ type: core.Input }]
        };
        return MdcChipIcon;
    }(MdcIcon));

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Chip Set.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Chip Set into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCChipSetAdapter =
    /*#__PURE__*/
    function () {
      function MDCChipSetAdapter() {
        _classCallCheck$3(this, MDCChipSetAdapter);
      }

      _createClass$3(MDCChipSetAdapter, [{
        key: "hasClass",

        /**
         * Returns true if the root element contains the given class name.
         * @param {string} className
         * @return {boolean}
         */
        value: function hasClass(className) {}
        /**
         * Removes the chip with the given id from the chip set.
         * @param {string} chipId
         */

      }, {
        key: "removeChip",
        value: function removeChip(chipId) {}
        /**
         * Sets the selected state of the chip with the given id.
         * @param {string} chipId
         * @param {boolean} selected
         */

      }, {
        key: "setSelected",
        value: function setSelected(chipId, selected) {}
      }]);

      return MDCChipSetAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$2$1 = {
      CHIP_SELECTOR: '.mdc-chip'
    };
    /** @enum {string} */

    var cssClasses$2$1 = {
      CHOICE: 'mdc-chip-set--choice',
      FILTER: 'mdc-chip-set--filter'
    };

    /**
     * @extends {MDCFoundation<!MDCChipSetAdapter>}
     * @final
     */

    var MDCChipSetFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$3(MDCChipSetFoundation, _MDCFoundation);

      _createClass$3(MDCChipSetFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$2$1;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$2$1;
        }
        /**
         * {@see MDCChipSetAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCChipSetAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCChipSetAdapter} */
            {
              hasClass: function hasClass() {},
              removeChip: function removeChip() {},
              setSelected: function setSelected() {}
            }
          );
        }
        /**
         * @param {!MDCChipSetAdapter} adapter
         */

      }]);

      function MDCChipSetFoundation(adapter) {
        var _this;

        _classCallCheck$3(this, MDCChipSetFoundation);

        _this = _possibleConstructorReturn$3(this, _getPrototypeOf$3(MDCChipSetFoundation).call(this, Object.assign(MDCChipSetFoundation.defaultAdapter, adapter)));
        /**
         * The ids of the selected chips in the set. Only used for choice chip set or filter chip set.
         * @private {!Array<string>}
         */

        _this.selectedChipIds_ = [];
        return _this;
      }
      /**
       * Returns an array of the IDs of all selected chips.
       * @return {!Array<string>}
       */


      _createClass$3(MDCChipSetFoundation, [{
        key: "getSelectedChipIds",
        value: function getSelectedChipIds() {
          return this.selectedChipIds_;
        }
        /**
         * Toggles selection of the chip with the given id.
         * @private
         * @param {string} chipId
         */

      }, {
        key: "toggleSelect_",
        value: function toggleSelect_(chipId) {
          if (this.selectedChipIds_.indexOf(chipId) >= 0) {
            this.deselect_(chipId);
          } else {
            this.select(chipId);
          }
        }
        /**
         * Selects the chip with the given id. Deselects all other chips if the chip set is of the choice variant.
         * @param {string} chipId
         */

      }, {
        key: "select",
        value: function select(chipId) {
          if (this.selectedChipIds_.indexOf(chipId) >= 0) {
            return;
          }

          if (this.adapter_.hasClass(cssClasses$2$1.CHOICE) && this.selectedChipIds_.length > 0) {
            var previouslySelectedChip = this.selectedChipIds_[0];
            this.selectedChipIds_.length = 0;
            this.adapter_.setSelected(previouslySelectedChip, false);
          }

          this.selectedChipIds_.push(chipId);
          this.adapter_.setSelected(chipId, true);
        }
        /**
         * Deselects the chip with the given id.
         * @private
         * @param {string} chipId
         */

      }, {
        key: "deselect_",
        value: function deselect_(chipId) {
          var index = this.selectedChipIds_.indexOf(chipId);

          if (index >= 0) {
            this.selectedChipIds_.splice(index, 1);
            this.adapter_.setSelected(chipId, false);
          }
        }
        /**
         * Handles a chip interaction event
         * @param {string} chipId
         */

      }, {
        key: "handleChipInteraction",
        value: function handleChipInteraction(chipId) {
          if (this.adapter_.hasClass(cssClasses$2$1.CHOICE) || this.adapter_.hasClass(cssClasses$2$1.FILTER)) {
            this.toggleSelect_(chipId);
          }
        }
        /**
         * Handles a chip selection event, used to handle discrepancy when selection state is set directly on the Chip.
         * @param {string} chipId
         * @param {boolean} selected
         */

      }, {
        key: "handleChipSelection",
        value: function handleChipSelection(chipId, selected) {
          var chipIsSelected = this.selectedChipIds_.indexOf(chipId) >= 0;

          if (selected && !chipIsSelected) {
            this.select(chipId);
          } else if (!selected && chipIsSelected) {
            this.deselect_(chipId);
          }
        }
        /**
         * Handles the event when a chip is removed.
         * @param {string} chipId
         */

      }, {
        key: "handleChipRemoval",
        value: function handleChipRemoval(chipId) {
          this.deselect_(chipId);
          this.adapter_.removeChip(chipId);
        }
      }]);

      return MDCChipSetFoundation;
    }(MDCFoundation$3);

    var idCounter = 0;
    /**
     * @extends {MDCComponent<!MDCChipSetFoundation>}
     * @final
     */

    var MDCChipSet =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$3(MDCChipSet, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCChipSet() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$3(this, MDCChipSet);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$3(this, (_getPrototypeOf2 = _getPrototypeOf$3(MDCChipSet)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {!Array<!MDCChip>} */

        _this.chips;
        /** @private {(function(!Element): !MDCChip)} */

        _this.chipFactory_;
        /** @private {?function(?Event): undefined} */

        _this.handleChipInteraction_;
        /** @private {?function(?Event): undefined} */

        _this.handleChipSelection_;
        /** @private {?function(?Event): undefined} */

        _this.handleChipRemoval_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCChipSet}
       */


      _createClass$3(MDCChipSet, [{
        key: "initialize",

        /**
         * @param {(function(!Element): !MDCChip)=} chipFactory A function which
         * creates a new MDCChip.
         */
        value: function initialize() {
          var chipFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCChip(el);
          };
          this.chipFactory_ = chipFactory;
          this.chips = this.instantiateChips_(this.chipFactory_);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.chips.forEach(function (chip) {
            if (chip.selected) {
              _this2.foundation_.select(chip.id);
            }
          });

          this.handleChipInteraction_ = function (evt) {
            return _this2.foundation_.handleChipInteraction(evt.detail.chipId);
          };

          this.handleChipSelection_ = function (evt) {
            return _this2.foundation_.handleChipSelection(evt.detail.chipId, evt.detail.selected);
          };

          this.handleChipRemoval_ = function (evt) {
            return _this2.foundation_.handleChipRemoval(evt.detail.chipId);
          };

          this.root_.addEventListener(MDCChipFoundation.strings.INTERACTION_EVENT, this.handleChipInteraction_);
          this.root_.addEventListener(MDCChipFoundation.strings.SELECTION_EVENT, this.handleChipSelection_);
          this.root_.addEventListener(MDCChipFoundation.strings.REMOVAL_EVENT, this.handleChipRemoval_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.chips.forEach(function (chip) {
            chip.destroy();
          });
          this.root_.removeEventListener(MDCChipFoundation.strings.INTERACTION_EVENT, this.handleChipInteraction_);
          this.root_.removeEventListener(MDCChipFoundation.strings.SELECTION_EVENT, this.handleChipSelection_);
          this.root_.removeEventListener(MDCChipFoundation.strings.REMOVAL_EVENT, this.handleChipRemoval_);

          _get$1(_getPrototypeOf$3(MDCChipSet.prototype), "destroy", this).call(this);
        }
        /**
         * Adds a new chip object to the chip set from the given chip element.
         * @param {!Element} chipEl
         */

      }, {
        key: "addChip",
        value: function addChip(chipEl) {
          chipEl.id = chipEl.id || "mdc-chip-".concat(++idCounter);
          this.chips.push(this.chipFactory_(chipEl));
        }
        /**
         * Returns an array of the IDs of all selected chips.
         * @return {!Array<string>}
         */

      }, {
        key: "getDefaultFoundation",

        /**
         * @return {!MDCChipSetFoundation}
         */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCChipSetFoundation(
          /** @type {!MDCChipSetAdapter} */
          Object.assign({
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            removeChip: function removeChip(chipId) {
              var index = _this3.findChipIndex_(chipId);

              if (index >= 0) {
                _this3.chips[index].destroy();

                _this3.chips.splice(index, 1);
              }
            },
            setSelected: function setSelected(chipId, selected) {
              var index = _this3.findChipIndex_(chipId);

              if (index >= 0) {
                _this3.chips[index].selected = selected;
              }
            }
          }));
        }
        /**
         * Instantiates chip components on all of the chip set's child chip elements.
         * @param {(function(!Element): !MDCChip)} chipFactory
         * @return {!Array<!MDCChip>}
         */

      }, {
        key: "instantiateChips_",
        value: function instantiateChips_(chipFactory) {
          var chipElements = [].slice.call(this.root_.querySelectorAll(MDCChipSetFoundation.strings.CHIP_SELECTOR));
          return chipElements.map(function (el) {
            el.id = el.id || "mdc-chip-".concat(++idCounter);
            return chipFactory(el);
          });
        }
        /**
         * Returns the index of the chip with the given id, or -1 if the chip does not exist.
         * @param {string} chipId
         * @return {number}
         */

      }, {
        key: "findChipIndex_",
        value: function findChipIndex_(chipId) {
          for (var i = 0; i < this.chips.length; i++) {
            if (this.chips[i].id === chipId) {
              return i;
            }
          }

          return -1;
        }
      }, {
        key: "selectedChipIds",
        get: function get() {
          return this.foundation_.getSelectedChipIds();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCChipSet(root);
        }
      }]);

      return MDCChipSet;
    }(MDCComponent$3);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcChipSetChange = /** @class */ (function () {
        function MdcChipSetChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return MdcChipSetChange;
    }());
    var MdcChipSet = /** @class */ (function () {
        function MdcChipSet(_changeDetectorRef, elementRef, _parentForm, _parentFormGroup, ngControl) {
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this.ngControl = ngControl;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroyed = new rxjs.Subject();
            this._choice = false;
            this._filter = false;
            this._input = false;
            /**
             * A function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             */
            this._compareWith = (/**
             * @param {?} o1
             * @param {?} o2
             * @return {?}
             */
            function (o1, o2) { return o1 === o2; });
            this.change = new core.EventEmitter();
            /**
             * Function when touched
             */
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
            /**
             * Function when changed
             */
            this._onChange = (/**
             * @return {?}
             */
            function () { });
            /**
             * Subscription to selection events in chips.
             */
            this._chipSelectionSubscription = null;
            /**
             * Subscription to remove changes in chips.
             */
            this._chipRemoveSubscription = null;
            /**
             * Subscription to interaction events in chips.
             */
            this._chipInteractionSubscription = null;
            this._foundation = new MDCChipSetFoundation(this._createAdapter());
            if (this.ngControl) {
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(MdcChipSet.prototype, "choice", {
            /**
            * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
            */
            get: /**
             * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
             * @return {?}
             */
            function () { return this._choice; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._choice = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "filter", {
            /**
            * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
            */
            get: /**
             * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
             * @return {?}
             */
            function () { return this._filter; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._filter = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "input", {
            /**
            * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
            */
            get: /**
             * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
             * @return {?}
             */
            function () { return this._input; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._input = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.writeValue(value);
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "chipSelections", {
            /** Combined stream of all of the chip selection events. */
            get: /**
             * Combined stream of all of the chip selection events.
             * @return {?}
             */
            function () {
                return rxjs.merge.apply(void 0, this.chips.map((/**
                 * @param {?} chip
                 * @return {?}
                 */
                function (chip) { return chip.selectionChange; })));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "chipInteractions", {
            /** Combined stream of all of the chip interaction events. */
            get: /**
             * Combined stream of all of the chip interaction events.
             * @return {?}
             */
            function () {
                return rxjs.merge.apply(void 0, this.chips.map((/**
                 * @param {?} chip
                 * @return {?}
                 */
                function (chip) { return chip.trailingIconInteraction; })));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "chipRemoveChanges", {
            /** Combined stream of all of the chip remove events. */
            get: /**
             * Combined stream of all of the chip remove events.
             * @return {?}
             */
            function () {
                return rxjs.merge.apply(void 0, this.chips.map((/**
                 * @param {?} chip
                 * @return {?}
                 */
                function (chip) { return chip.removed; })));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                removeChip: (/**
                 * @param {?} chipId
                 * @return {?}
                 */
                function (chipId) {
                    /** @type {?} */
                    var index = _this._findChipIndex(chipId);
                    _this.chips.toArray().splice(index, 1);
                }),
                setSelected: (/**
                 * @param {?} chipId
                 * @param {?} selected
                 * @return {?}
                 */
                function (chipId, selected) {
                    /** @type {?} */
                    var chip = _this.getChipById(chipId);
                    if (chip) {
                        chip.selected = selected;
                    }
                })
            };
        };
        /**
         * @return {?}
         */
        MdcChipSet.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            // When chips change, re-subscribe
            this.chips.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                if (_this.chips.length > 0) {
                    _this._resetChipSet();
                    _this._initializeSelection();
                }
            }));
        };
        /**
         * @return {?}
         */
        MdcChipSet.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
            this._dropSubscriptions();
            if (this._chipRemoveSubscription) {
                this._chipRemoveSubscription.unsubscribe();
            }
            this._foundation.destroy();
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        MdcChipSet.prototype.writeValue = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.chips) {
                this.selectByValue(value, false);
            }
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcChipSet.prototype.registerOnChange = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcChipSet.prototype.registerOnTouched = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @return {?}
         */
        MdcChipSet.prototype.getSelectedChipIds = /**
         * @return {?}
         */
        function () {
            return this._foundation.getSelectedChipIds();
        };
        /**
         * @param {?} chipId
         * @return {?}
         */
        MdcChipSet.prototype.select = /**
         * @param {?} chipId
         * @return {?}
         */
        function (chipId) {
            this._foundation.select(chipId);
        };
        /**
         * @param {?} chipId
         * @return {?}
         */
        MdcChipSet.prototype.getChipById = /**
         * @param {?} chipId
         * @return {?}
         */
        function (chipId) {
            return this.chips.find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.id === chipId; }));
        };
        /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcChipSet.prototype.selectByValue = /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        function (value, isUserInput) {
            var _this = this;
            if (isUserInput === void 0) { isUserInput = true; }
            this.chips.forEach((/**
             * @param {?} chip
             * @return {?}
             */
            function (chip) { return chip.deselect(); }));
            if (Array.isArray(value)) {
                value.forEach((/**
                 * @param {?} currentValue
                 * @return {?}
                 */
                function (currentValue) { return _this._selectValue(currentValue, isUserInput); }));
            }
            else {
                this._selectValue(value, isUserInput);
            }
        };
        /**
         * Finds and selects the chip based on its value.
         * @returns Chip that has the corresponding value.
         */
        /**
         * Finds and selects the chip based on its value.
         * @private
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?} Chip that has the corresponding value.
         */
        MdcChipSet.prototype._selectValue = /**
         * Finds and selects the chip based on its value.
         * @private
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?} Chip that has the corresponding value.
         */
        function (value, isUserInput) {
            var _this = this;
            if (isUserInput === void 0) { isUserInput = true; }
            /** @type {?} */
            var correspondingChip = this.chips.find((/**
             * @param {?} chip
             * @return {?}
             */
            function (chip) {
                return chip.value != null && _this._compareWith(chip.value, value);
            }));
            if (correspondingChip) {
                isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
            }
            return correspondingChip;
        };
        /**
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._initializeSelection = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                if (_this.ngControl || _this._value) {
                    _this.selectByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);
                }
            }));
        };
        /**
         * @private
         * @param {?} evt
         * @return {?}
         */
        MdcChipSet.prototype._propagateChanges = /**
         * @private
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._value = evt.detail.value;
            this.change.emit(new MdcChipSetChange(this, evt.detail));
            this._onChange(this._value);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._resetChipSet = /**
         * @private
         * @return {?}
         */
        function () {
            this._dropSubscriptions();
            this._listenForChipSelection();
            this._listenToChipsInteraction();
            this._listenToChipsRemoved();
        };
        /**
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._dropSubscriptions = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._chipSelectionSubscription) {
                this._chipSelectionSubscription.unsubscribe();
                this._chipSelectionSubscription = null;
            }
            if (this._chipInteractionSubscription) {
                this._chipInteractionSubscription.unsubscribe();
                this._chipInteractionSubscription = null;
            }
            if (this._chipRemoveSubscription) {
                this._chipRemoveSubscription.unsubscribe();
                this._chipRemoveSubscription = null;
            }
        };
        /** Listens to selected events on each chip. */
        /**
         * Listens to selected events on each chip.
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._listenForChipSelection = /**
         * Listens to selected events on each chip.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._chipSelectionSubscription = this.chipSelections
                .subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                _this._foundation.handleChipSelection(event.detail.chipId, event.detail.selected);
                if (event.isUserInput) {
                    _this._propagateChanges(event);
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._listenToChipsInteraction = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._chipInteractionSubscription = this.chipInteractions
                .subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                return _this._foundation.handleChipInteraction(event.detail.chipId);
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._listenToChipsRemoved = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._chipRemoveSubscription = this.chipRemoveChanges
                .subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) { return _this._foundation.handleChipRemoval(event.detail.chipId); }));
        };
        /**
         * @private
         * @param {?} chipId
         * @return {?}
         */
        MdcChipSet.prototype._findChipIndex = /**
         * @private
         * @param {?} chipId
         * @return {?}
         */
        function (chipId) {
            return this.chips.toArray().findIndex((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.id === chipId; }));
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcChipSet.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcChipSet.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip-set',
                        exportAs: 'mdcChipSet',
                        host: {
                            'class': 'mdc-chip-set',
                            '[class.mdc-chip-set--choice]': 'choice',
                            '[class.mdc-chip-set--filter]': 'filter',
                            '[class.mdc-chip-set--input]': 'input'
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [{ provide: MDC_CHIPSET_PARENT_COMPONENT, useExisting: MdcChipSet }]
                    },] },
        ];
        /** @nocollapse */
        MdcChipSet.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
            { type: forms.NgControl, decorators: [{ type: core.Optional }] }
        ]; };
        MdcChipSet.propDecorators = {
            choice: [{ type: core.Input }],
            filter: [{ type: core.Input }],
            input: [{ type: core.Input }],
            value: [{ type: core.Input }],
            change: [{ type: core.Output }],
            chips: [{ type: core.ContentChildren, args: [MdcChip, { descendants: true },] }]
        };
        return MdcChipSet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CHIP_DECLARATIONS = [
        MdcChip,
        MdcChipCheckmark,
        MdcChipIcon,
        MdcChipSet,
        MdcChipText
    ];
    var MdcChipsModule = /** @class */ (function () {
        function MdcChipsModule() {
        }
        MdcChipsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, MdcIconModule],
                        exports: CHIP_DECLARATIONS,
                        declarations: CHIP_DECLARATIONS
                    },] },
        ];
        return MdcChipsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Throws an exception when attempting to attach a null portal to a host.
     * \@docs-private
     * @return {?}
     */
    function throwNullPortalError() {
        throw Error('Must provide a portal to attach');
    }
    /**
     * Throws an exception when attempting to attach a portal to a host that is already attached.
     * \@docs-private
     * @return {?}
     */
    function throwPortalAlreadyAttachedError() {
        throw Error('Host already has a portal attached');
    }
    /**
     * Throws an exception when attempting to attach a portal to an already-disposed host.
     * \@docs-private
     * @return {?}
     */
    function throwPortalOutletAlreadyDisposedError() {
        throw Error('This PortalOutlet has already been disposed');
    }
    /**
     * Throws an exception when attempting to attach an unknown portal type.
     * \@docs-private
     * @return {?}
     */
    function throwUnknownPortalTypeError() {
        throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +
            'a ComponentPortal or a TemplatePortal.');
    }
    /**
     * Throws an exception when attempting to attach a portal to a null host.
     * \@docs-private
     * @return {?}
     */
    function throwNullPortalOutletError() {
        throw Error('Attempting to attach a portal to a null PortalOutlet');
    }
    /**
     * Throws an exception when attempting to detach a portal that is not attached.
     * \@docs-private
     * @return {?}
     */
    function throwNoPortalAttachedError() {
        throw Error('Attempting to detach a portal that is not attached to a host');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A `Portal` is something that you want to render somewhere else.
     * It can be attach to / detached from a `PortalOutlet`.
     * @abstract
     * @template T
     */
    var   /**
     * A `Portal` is something that you want to render somewhere else.
     * It can be attach to / detached from a `PortalOutlet`.
     * @abstract
     * @template T
     */
    Portal = /** @class */ (function () {
        function Portal() {
            this._attachedHost = null;
        }
        /** Attach this portal to a host. */
        /**
         * Attach this portal to a host.
         * @param {?} host
         * @return {?}
         */
        Portal.prototype.attach = /**
         * Attach this portal to a host.
         * @param {?} host
         * @return {?}
         */
        function (host) {
            if (host == null) {
                throwNullPortalOutletError();
            }
            if (host.hasAttached()) {
                throwPortalAlreadyAttachedError();
            }
            return (/** @type {?} */ (host.attach(this)));
        };
        /** Detach this portal from its host */
        /**
         * Detach this portal from its host
         * @return {?}
         */
        Portal.prototype.detach = /**
         * Detach this portal from its host
         * @return {?}
         */
        function () {
            /** @type {?} */
            var host = this._attachedHost;
            if (host == null) {
                throwNoPortalAttachedError();
            }
            else {
                this._attachedHost = null;
                host.detach();
            }
        };
        Object.defineProperty(Portal.prototype, "isAttached", {
            /** Whether this portal is attached to a host. */
            get: /**
             * Whether this portal is attached to a host.
             * @return {?}
             */
            function () {
                return !!this._attachedHost;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         */
        /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         * @param {?} host
         * @return {?}
         */
        Portal.prototype.setAttachedHost = /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         * @param {?} host
         * @return {?}
         */
        function (host) {
            this._attachedHost = host;
        };
        return Portal;
    }());
    /**
     * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
     * @template T
     */
    var   /**
     * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
     * @template T
     */
    ComponentPortal = /** @class */ (function (_super) {
        __extends(ComponentPortal, _super);
        function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {
            var _this = _super.call(this) || this;
            _this.component = component;
            _this.viewContainerRef = viewContainerRef;
            _this.injector = injector;
            _this.componentFactoryResolver = componentFactoryResolver;
            return _this;
        }
        return ComponentPortal;
    }(Portal));
    /**
     * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
     * @template C
     */
    var   /**
     * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
     * @template C
     */
    TemplatePortal = /** @class */ (function (_super) {
        __extends(TemplatePortal, _super);
        function TemplatePortal(template, viewContainerRef, context) {
            var _this = _super.call(this) || this;
            _this.templateRef = template;
            _this.viewContainerRef = viewContainerRef;
            _this.context = context;
            return _this;
        }
        Object.defineProperty(TemplatePortal.prototype, "origin", {
            get: /**
             * @return {?}
             */
            function () {
                return this.templateRef.elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Attach the portal to the provided `PortalOutlet`.
         * When a context is provided it will override the `context` property of the `TemplatePortal`
         * instance.
         */
        /**
         * Attach the portal to the provided `PortalOutlet`.
         * When a context is provided it will override the `context` property of the `TemplatePortal`
         * instance.
         * @param {?} host
         * @param {?=} context
         * @return {?}
         */
        TemplatePortal.prototype.attach = /**
         * Attach the portal to the provided `PortalOutlet`.
         * When a context is provided it will override the `context` property of the `TemplatePortal`
         * instance.
         * @param {?} host
         * @param {?=} context
         * @return {?}
         */
        function (host, context) {
            if (context === void 0) { context = this.context; }
            this.context = context;
            return _super.prototype.attach.call(this, host);
        };
        /**
         * @return {?}
         */
        TemplatePortal.prototype.detach = /**
         * @return {?}
         */
        function () {
            this.context = undefined;
            return _super.prototype.detach.call(this);
        };
        return TemplatePortal;
    }(Portal));
    /**
     * Partial implementation of PortalOutlet that handles attaching
     * ComponentPortal and TemplatePortal.
     * @abstract
     */
    var   /**
     * Partial implementation of PortalOutlet that handles attaching
     * ComponentPortal and TemplatePortal.
     * @abstract
     */
    BasePortalOutlet = /** @class */ (function () {
        function BasePortalOutlet() {
            /**
             * The portal currently attached to the host.
             */
            this._attachedPortal = null;
            /**
             * A function that will permanently dispose this host.
             */
            this._disposeFn = null;
            /**
             * Whether this host has already been permanently disposed.
             */
            this._isDisposed = false;
        }
        /** Whether this host has an attached portal. */
        /**
         * Whether this host has an attached portal.
         * @return {?}
         */
        BasePortalOutlet.prototype.hasAttached = /**
         * Whether this host has an attached portal.
         * @return {?}
         */
        function () {
            return !!this._attachedPortal;
        };
        /** Attaches a portal. */
        /**
         * Attaches a portal.
         * @param {?} portal
         * @return {?}
         */
        BasePortalOutlet.prototype.attach = /**
         * Attaches a portal.
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            if (!portal) {
                throwNullPortalError();
            }
            if (this.hasAttached()) {
                throwPortalAlreadyAttachedError();
            }
            if (this._isDisposed) {
                throwPortalOutletAlreadyDisposedError();
            }
            if (portal instanceof ComponentPortal) {
                this._attachedPortal = portal;
                portal._attachedHost = this;
                return this.attachComponentPortal(portal);
            }
            else if (portal instanceof TemplatePortal) {
                this._attachedPortal = portal;
                portal._attachedHost = this;
                return this.attachTemplatePortal(portal);
            }
            throwUnknownPortalTypeError();
        };
        /** Detaches a previously attached portal. */
        /**
         * Detaches a previously attached portal.
         * @return {?}
         */
        BasePortalOutlet.prototype.detach = /**
         * Detaches a previously attached portal.
         * @return {?}
         */
        function () {
            if (this._attachedPortal) {
                this._attachedPortal.setAttachedHost(null);
                this._attachedPortal = null;
            }
            this._invokeDisposeFn();
        };
        /** Permanently dispose of this portal host. */
        /**
         * Permanently dispose of this portal host.
         * @return {?}
         */
        BasePortalOutlet.prototype.dispose = /**
         * Permanently dispose of this portal host.
         * @return {?}
         */
        function () {
            if (this.hasAttached()) {
                this.detach();
            }
            this._invokeDisposeFn();
            this._isDisposed = true;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        BasePortalOutlet.prototype.setDisposeFn = /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._disposeFn = fn;
        };
        /**
         * @private
         * @return {?}
         */
        BasePortalOutlet.prototype._invokeDisposeFn = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._disposeFn) {
                this._disposeFn();
                this._disposeFn = null;
            }
        };
        return BasePortalOutlet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
     * application context.
     */
    var   /**
     * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
     * application context.
     */
    DomPortalOutlet = /** @class */ (function (_super) {
        __extends(DomPortalOutlet, _super);
        function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
            var _this = _super.call(this) || this;
            _this.outletElement = outletElement;
            _this._componentFactoryResolver = _componentFactoryResolver;
            _this._appRef = _appRef;
            _this._defaultInjector = _defaultInjector;
            return _this;
        }
        /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @param portal Portal to be attached
         * @returns Reference to the created component.
         */
        /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @template T
         * @param {?} portal Portal to be attached
         * @return {?} Reference to the created component.
         */
        DomPortalOutlet.prototype.attachComponentPortal = /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @template T
         * @param {?} portal Portal to be attached
         * @return {?} Reference to the created component.
         */
        function (portal) {
            var _this = this;
            /** @type {?} */
            var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
            /** @type {?} */
            var componentFactory = resolver.resolveComponentFactory(portal.component);
            /** @type {?} */
            var componentRef;
            // If the portal specifies a ViewContainerRef, we will use that as the attachment point
            // for the component (in terms of Angular's component tree, not rendering).
            // When the ViewContainerRef is missing, we use the factory to create the component directly
            // and then manually attach the view to the application.
            if (portal.viewContainerRef) {
                componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
                this.setDisposeFn((/**
                 * @return {?}
                 */
                function () { return componentRef.destroy(); }));
            }
            else {
                componentRef = componentFactory.create(portal.injector || this._defaultInjector);
                this._appRef.attachView(componentRef.hostView);
                this.setDisposeFn((/**
                 * @return {?}
                 */
                function () {
                    _this._appRef.detachView(componentRef.hostView);
                    componentRef.destroy();
                }));
            }
            // At this point the component has been instantiated, so we move it to the location in the DOM
            // where we want it to be rendered.
            this.outletElement.appendChild(this._getComponentRootNode(componentRef));
            return componentRef;
        };
        /**
         * Attaches a template portal to the DOM as an embedded view.
         * @param portal Portal to be attached.
         * @returns Reference to the created embedded view.
         */
        /**
         * Attaches a template portal to the DOM as an embedded view.
         * @template C
         * @param {?} portal Portal to be attached.
         * @return {?} Reference to the created embedded view.
         */
        DomPortalOutlet.prototype.attachTemplatePortal = /**
         * Attaches a template portal to the DOM as an embedded view.
         * @template C
         * @param {?} portal Portal to be attached.
         * @return {?} Reference to the created embedded view.
         */
        function (portal) {
            var _this = this;
            /** @type {?} */
            var viewContainer = portal.viewContainerRef;
            /** @type {?} */
            var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
            viewRef.detectChanges();
            // The method `createEmbeddedView` will add the view as a child of the viewContainer.
            // But for the DomPortalOutlet the view can be added everywhere in the DOM
            // (e.g Overlay Container) To move the view to the specified host element. We just
            // re-append the existing root nodes.
            viewRef.rootNodes.forEach((/**
             * @param {?} rootNode
             * @return {?}
             */
            function (rootNode) { return _this.outletElement.appendChild(rootNode); }));
            this.setDisposeFn(((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var index = viewContainer.indexOf(viewRef);
                if (index !== -1) {
                    viewContainer.remove(index);
                }
            })));
            // TODO(jelbourn): Return locals from view.
            return viewRef;
        };
        /**
         * Clears out a portal from the DOM.
         */
        /**
         * Clears out a portal from the DOM.
         * @return {?}
         */
        DomPortalOutlet.prototype.dispose = /**
         * Clears out a portal from the DOM.
         * @return {?}
         */
        function () {
            _super.prototype.dispose.call(this);
            if (this.outletElement.parentNode != null) {
                this.outletElement.parentNode.removeChild(this.outletElement);
            }
        };
        /** Gets the root HTMLElement for an instantiated component. */
        /**
         * Gets the root HTMLElement for an instantiated component.
         * @private
         * @param {?} componentRef
         * @return {?}
         */
        DomPortalOutlet.prototype._getComponentRootNode = /**
         * Gets the root HTMLElement for an instantiated component.
         * @private
         * @param {?} componentRef
         * @return {?}
         */
        function (componentRef) {
            return (/** @type {?} */ (((/** @type {?} */ (componentRef.hostView))).rootNodes[0]));
        };
        return DomPortalOutlet;
    }(BasePortalOutlet));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
     * the directive instance itself can be attached to a host, enabling declarative use of portals.
     */
    var CdkPortal = /** @class */ (function (_super) {
        __extends(CdkPortal, _super);
        function CdkPortal(templateRef, viewContainerRef) {
            return _super.call(this, templateRef, viewContainerRef) || this;
        }
        CdkPortal.decorators = [
            { type: core.Directive, args: [{
                        selector: '[cdk-portal], [cdkPortal], [portal]',
                        exportAs: 'cdkPortal',
                    },] },
        ];
        /** @nocollapse */
        CdkPortal.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef }
        ]; };
        return CdkPortal;
    }(TemplatePortal));
    /**
     * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
     * directly attached to it, enabling declarative use.
     *
     * Usage:
     * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
     */
    var CdkPortalOutlet = /** @class */ (function (_super) {
        __extends(CdkPortalOutlet, _super);
        function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {
            var _this = _super.call(this) || this;
            _this._componentFactoryResolver = _componentFactoryResolver;
            _this._viewContainerRef = _viewContainerRef;
            /**
             * Whether the portal component is initialized.
             */
            _this._isInitialized = false;
            /**
             * Reference to the currently-attached component/view ref.
             */
            _this._attachedRef = null;
            /**
             * Emits when a portal is attached to the outlet.
             */
            _this.attached = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(CdkPortalOutlet.prototype, "portal", {
            /** Portal associated with the Portal outlet. */
            get: /**
             * Portal associated with the Portal outlet.
             * @return {?}
             */
            function () {
                return this._attachedPortal;
            },
            set: /**
             * @param {?} portal
             * @return {?}
             */
            function (portal) {
                // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
                // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
                // and attach a portal programmatically in the parent component. When Angular does the first CD
                // round, it will fire the setter with empty string, causing the user's content to be cleared.
                if (this.hasAttached() && !portal && !this._isInitialized) {
                    return;
                }
                if (this.hasAttached()) {
                    _super.prototype.detach.call(this);
                }
                if (portal) {
                    _super.prototype.attach.call(this, portal);
                }
                this._attachedPortal = portal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CdkPortalOutlet.prototype, "attachedRef", {
            /** Component or view reference that is attached to the portal. */
            get: /**
             * Component or view reference that is attached to the portal.
             * @return {?}
             */
            function () {
                return this._attachedRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CdkPortalOutlet.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._isInitialized = true;
        };
        /**
         * @return {?}
         */
        CdkPortalOutlet.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            _super.prototype.dispose.call(this);
            this._attachedPortal = null;
            this._attachedRef = null;
        };
        /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @param portal Portal to be attached to the portal outlet.
         * @returns Reference to the created component.
         */
        /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @template T
         * @param {?} portal Portal to be attached to the portal outlet.
         * @return {?} Reference to the created component.
         */
        CdkPortalOutlet.prototype.attachComponentPortal = /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @template T
         * @param {?} portal Portal to be attached to the portal outlet.
         * @return {?} Reference to the created component.
         */
        function (portal) {
            portal.setAttachedHost(this);
            // If the portal specifies an origin, use that as the logical location of the component
            // in the application tree. Otherwise use the location of this PortalOutlet.
            /** @type {?} */
            var viewContainerRef = portal.viewContainerRef != null ?
                portal.viewContainerRef :
                this._viewContainerRef;
            /** @type {?} */
            var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
            /** @type {?} */
            var componentFactory = resolver.resolveComponentFactory(portal.component);
            /** @type {?} */
            var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);
            _super.prototype.setDisposeFn.call(this, (/**
             * @return {?}
             */
            function () { return ref.destroy(); }));
            this._attachedPortal = portal;
            this._attachedRef = ref;
            this.attached.emit(ref);
            return ref;
        };
        /**
         * Attach the given TemplatePortal to this PortlHost as an embedded View.
         * @param portal Portal to be attached.
         * @returns Reference to the created embedded view.
         */
        /**
         * Attach the given TemplatePortal to this PortlHost as an embedded View.
         * @template C
         * @param {?} portal Portal to be attached.
         * @return {?} Reference to the created embedded view.
         */
        CdkPortalOutlet.prototype.attachTemplatePortal = /**
         * Attach the given TemplatePortal to this PortlHost as an embedded View.
         * @template C
         * @param {?} portal Portal to be attached.
         * @return {?} Reference to the created embedded view.
         */
        function (portal) {
            var _this = this;
            portal.setAttachedHost(this);
            /** @type {?} */
            var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
            _super.prototype.setDisposeFn.call(this, (/**
             * @return {?}
             */
            function () { return _this._viewContainerRef.clear(); }));
            this._attachedPortal = portal;
            this._attachedRef = viewRef;
            this.attached.emit(viewRef);
            return viewRef;
        };
        CdkPortalOutlet.decorators = [
            { type: core.Directive, args: [{
                        selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',
                        exportAs: 'cdkPortalOutlet, cdkPortalHost',
                        inputs: ['portal: cdkPortalOutlet']
                    },] },
        ];
        /** @nocollapse */
        CdkPortalOutlet.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: core.ViewContainerRef }
        ]; };
        CdkPortalOutlet.propDecorators = {
            attached: [{ type: core.Output }]
        };
        return CdkPortalOutlet;
    }(BasePortalOutlet));
    var PortalModule = /** @class */ (function () {
        function PortalModule() {
        }
        PortalModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [CdkPortal, CdkPortalOutlet],
                        declarations: [CdkPortal, CdkPortalOutlet],
                    },] },
        ];
        return PortalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Custom injector to be used when providing custom
     * injection tokens to components inside a portal.
     * \@docs-private
     */
    var   /**
     * Custom injector to be used when providing custom
     * injection tokens to components inside a portal.
     * \@docs-private
     */
    PortalInjector = /** @class */ (function () {
        function PortalInjector(_parentInjector, _customTokens) {
            this._parentInjector = _parentInjector;
            this._customTokens = _customTokens;
        }
        /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        PortalInjector.prototype.get = /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        function (token, notFoundValue) {
            /** @type {?} */
            var value = this._customTokens.get(token);
            if (typeof value !== 'undefined') {
                return value;
            }
            return this._parentInjector.get(token, notFoundValue);
        };
        return PortalInjector;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Initial configuration used when creating an overlay.
     */
    var   /**
     * Initial configuration used when creating an overlay.
     */
    OverlayConfig = /** @class */ (function () {
        function OverlayConfig(config) {
            var _this = this;
            /**
             * Whether the overlay should be disposed of when the user goes backwards/forwards in history.
             * Note that this usually doesn't include clicking on links (unless the user is using
             * the `HashLocationStrategy`).
             */
            this.disposeOnNavigation = false;
            if (config) {
                Object.keys(config).forEach((/**
                 * @param {?} k
                 * @return {?}
                 */
                function (k) {
                    /** @type {?} */
                    var key = (/** @type {?} */ (k));
                    if (typeof config[key] !== 'undefined') {
                        _this[key] = config[key];
                    }
                }));
            }
        }
        return OverlayConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Container inside which all overlays will render.
     */
    var OverlayContainer = /** @class */ (function () {
        function OverlayContainer(_document) {
            this._document = _document;
            this._containerElement = null;
        }
        /**
         * @return {?}
         */
        OverlayContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._containerElement && this._containerElement.parentNode) {
                this._containerElement.parentNode.removeChild(this._containerElement);
            }
        };
        /**
         * This method returns the overlay container element. It will lazily
         * create the element the first time  it is called to facilitate using
         * the container in non-browser environments.
         * @returns the container element
         */
        /**
         * This method returns the overlay container element. It will lazily
         * create the element the first time  it is called to facilitate using
         * the container in non-browser environments.
         * @return {?} the container element
         */
        OverlayContainer.prototype.getContainerElement = /**
         * This method returns the overlay container element. It will lazily
         * create the element the first time  it is called to facilitate using
         * the container in non-browser environments.
         * @return {?} the container element
         */
        function () {
            if (!this._containerElement) {
                this._createContainer();
            }
            return (/** @type {?} */ (this._containerElement));
        };
        /**
         * Create the overlay container element, which is simply a div
         * with the 'cdk-overlay-container' class on the document body.
         */
        /**
         * Create the overlay container element, which is simply a div
         * with the 'cdk-overlay-container' class on the document body.
         * @protected
         * @return {?}
         */
        OverlayContainer.prototype._createContainer = /**
         * Create the overlay container element, which is simply a div
         * with the 'cdk-overlay-container' class on the document body.
         * @protected
         * @return {?}
         */
        function () {
            /** @type {?} */
            var container = this._document.createElement('div');
            container.classList.add('cdk-overlay-container');
            (/** @type {?} */ (this._document.body)).appendChild(container);
            this._containerElement = container;
        };
        OverlayContainer.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] },
        ];
        /** @nocollapse */
        OverlayContainer.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        /** @nocollapse */ OverlayContainer.ngInjectableDef = core.defineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(core.inject(common.DOCUMENT)); }, token: OverlayContainer, providedIn: "root" });
        return OverlayContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Reference to an overlay that has been created with the Overlay service.
     * Used to manipulate or dispose of said overlay.
     */
    var   /**
     * Reference to an overlay that has been created with the Overlay service.
     * Used to manipulate or dispose of said overlay.
     */
    OverlayRef = /** @class */ (function () {
        function OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _document, _location) {
            this._portalOutlet = _portalOutlet;
            this._host = _host;
            this._pane = _pane;
            this._config = _config;
            this._ngZone = _ngZone;
            this._document = _document;
            this._location = _location;
            this._attachments = new rxjs.Subject();
            this._detachments = new rxjs.Subject();
            this._locationChanges = rxjs.Subscription.EMPTY;
            /**
             * Reference to the parent of the `_host` at the time it was detached. Used to restore
             * the `_host` to its original position in the DOM when it gets re-attached.
             */
            this._previousHostParent = null;
        }
        Object.defineProperty(OverlayRef.prototype, "overlayElement", {
            /** The overlay's HTML element */
            get: /**
             * The overlay's HTML element
             * @return {?}
             */
            function () {
                return this._pane;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OverlayRef.prototype, "hostElement", {
            /**
             * Wrapper around the panel element. Can be used for advanced
             * positioning where a wrapper with specific styling is
             * required around the overlay pane.
             */
            get: /**
             * Wrapper around the panel element. Can be used for advanced
             * positioning where a wrapper with specific styling is
             * required around the overlay pane.
             * @return {?}
             */
            function () {
                return this._host;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Attaches content, given via a Portal, to the overlay.
         * If the overlay is configured to have a backdrop, it will be created.
         *
         * @param portal Portal instance to which to attach the overlay.
         * @returns The portal attachment result.
         */
        /**
         * Attaches content, given via a Portal, to the overlay.
         * If the overlay is configured to have a backdrop, it will be created.
         *
         * @param {?} portal Portal instance to which to attach the overlay.
         * @return {?} The portal attachment result.
         */
        OverlayRef.prototype.attach = /**
         * Attaches content, given via a Portal, to the overlay.
         * If the overlay is configured to have a backdrop, it will be created.
         *
         * @param {?} portal Portal instance to which to attach the overlay.
         * @return {?} The portal attachment result.
         */
        function (portal) {
            var _this = this;
            /** @type {?} */
            var attachResult = this._portalOutlet.attach(portal);
            // Update the pane element with the given configuration.
            if (!this._host.parentElement && this._previousHostParent) {
                this._previousHostParent.appendChild(this._host);
            }
            this._updateStackingOrder();
            // Enable pointer events for the overlay pane element.
            this._togglePointerEvents(true);
            // Only emit the `attachments` event once all other setup is done.
            this._attachments.next();
            // @breaking-change 8.0.0 remove the null check for `_location`
            // once the constructor parameter is made required.
            if (this._config.disposeOnNavigation && this._location) {
                this._locationChanges = this._location.subscribe((/**
                 * @return {?}
                 */
                function () { return _this.dispose(); }));
            }
            return attachResult;
        };
        /**
         * Detaches an overlay from a portal.
         * @returns The portal detachment result.
         */
        /**
         * Detaches an overlay from a portal.
         * @return {?} The portal detachment result.
         */
        OverlayRef.prototype.detach = /**
         * Detaches an overlay from a portal.
         * @return {?} The portal detachment result.
         */
        function () {
            if (!this.hasAttached()) {
                return;
            }
            // When the overlay is detached, the pane element should disable pointer events.
            // This is necessary because otherwise the pane element will cover the page and disable
            // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
            this._togglePointerEvents(false);
            /** @type {?} */
            var detachmentResult = this._portalOutlet.detach();
            // Only emit after everything is detached.
            this._detachments.next();
            // Keeping the host element in DOM the can cause scroll jank, because it still gets
            // rendered, even though it's transparent and unclickable which is why we remove it.
            this._detachContentWhenStable();
            // Stop listening for location changes.
            this._locationChanges.unsubscribe();
            return detachmentResult;
        };
        /** Cleans up the overlay from the DOM. */
        /**
         * Cleans up the overlay from the DOM.
         * @return {?}
         */
        OverlayRef.prototype.dispose = /**
         * Cleans up the overlay from the DOM.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var isAttached = this.hasAttached();
            this._locationChanges.unsubscribe();
            this._portalOutlet.dispose();
            this._attachments.complete();
            if (this._host && this._host.parentNode) {
                this._host.parentNode.removeChild(this._host);
                this._host = (/** @type {?} */ (null));
            }
            this._previousHostParent = this._pane = (/** @type {?} */ (null));
            if (isAttached) {
                this._detachments.next();
            }
            this._detachments.complete();
        };
        /** Whether the overlay has attached content. */
        /**
         * Whether the overlay has attached content.
         * @return {?}
         */
        OverlayRef.prototype.hasAttached = /**
         * Whether the overlay has attached content.
         * @return {?}
         */
        function () {
            return this._portalOutlet.hasAttached();
        };
        /** Gets an observable that emits when the overlay has been attached. */
        /**
         * Gets an observable that emits when the overlay has been attached.
         * @return {?}
         */
        OverlayRef.prototype.attachments = /**
         * Gets an observable that emits when the overlay has been attached.
         * @return {?}
         */
        function () {
            return this._attachments.asObservable();
        };
        /** Gets an observable that emits when the overlay has been detached. */
        /**
         * Gets an observable that emits when the overlay has been detached.
         * @return {?}
         */
        OverlayRef.prototype.detachments = /**
         * Gets an observable that emits when the overlay has been detached.
         * @return {?}
         */
        function () {
            return this._detachments.asObservable();
        };
        /** Gets the the current overlay configuration, which is immutable. */
        /**
         * Gets the the current overlay configuration, which is immutable.
         * @return {?}
         */
        OverlayRef.prototype.getConfig = /**
         * Gets the the current overlay configuration, which is immutable.
         * @return {?}
         */
        function () {
            return this._config;
        };
        /** Toggles the pointer events for the overlay pane element. */
        /**
         * Toggles the pointer events for the overlay pane element.
         * @private
         * @param {?} enablePointer
         * @return {?}
         */
        OverlayRef.prototype._togglePointerEvents = /**
         * Toggles the pointer events for the overlay pane element.
         * @private
         * @param {?} enablePointer
         * @return {?}
         */
        function (enablePointer) {
            this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
        };
        /**
         * Updates the stacking order of the element, moving it to the top if necessary.
         * This is required in cases where one overlay was detached, while another one,
         * that should be behind it, was destroyed. The next time both of them are opened,
         * the stacking will be wrong, because the detached element's pane will still be
         * in its original DOM position.
         */
        /**
         * Updates the stacking order of the element, moving it to the top if necessary.
         * This is required in cases where one overlay was detached, while another one,
         * that should be behind it, was destroyed. The next time both of them are opened,
         * the stacking will be wrong, because the detached element's pane will still be
         * in its original DOM position.
         * @private
         * @return {?}
         */
        OverlayRef.prototype._updateStackingOrder = /**
         * Updates the stacking order of the element, moving it to the top if necessary.
         * This is required in cases where one overlay was detached, while another one,
         * that should be behind it, was destroyed. The next time both of them are opened,
         * the stacking will be wrong, because the detached element's pane will still be
         * in its original DOM position.
         * @private
         * @return {?}
         */
        function () {
            if (this._host.nextSibling) {
                (/** @type {?} */ (this._host.parentNode)).appendChild(this._host);
            }
        };
        /** Detaches the overlay content next time the zone stabilizes. */
        /**
         * Detaches the overlay content next time the zone stabilizes.
         * @private
         * @return {?}
         */
        OverlayRef.prototype._detachContentWhenStable = /**
         * Detaches the overlay content next time the zone stabilizes.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Normally we wouldn't have to explicitly run this outside the `NgZone`, however
            // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will
            // be patched to run inside the zone, which will throw us into an infinite loop.
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                // We can't remove the host here immediately, because the overlay pane's content
                // might still be animating. This stream helps us avoid interrupting the animation
                // by waiting for the pane to become empty.
                /** @type {?} */
                var subscription = _this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.takeUntil(rxjs.merge(_this._attachments, _this._detachments)))
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    // Needs a couple of checks for the pane and host, because
                    // they may have been removed by the time the zone stabilizes.
                    if (!_this._pane || !_this._host || _this._pane.children.length === 0) {
                        if (_this._host && _this._host.parentElement) {
                            _this._previousHostParent = _this._host.parentElement;
                            _this._previousHostParent.removeChild(_this._host);
                        }
                        subscription.unsubscribe();
                    }
                }));
            }));
        };
        return OverlayRef;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Next overlay unique ID.
     * @type {?}
     */
    var nextUniqueId$2 = 0;
    // Note that Overlay is *not* scoped to the app root because the ComponentFactoryResolver
    // it needs is different based on where OverlayModule is imported.
    /**
     * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
     * used as a low-level building block for other components. Dialogs, tooltips, menus,
     * selects, etc. can all be built using overlays. The service should primarily be used by authors
     * of re-usable components rather than developers building end-user applications.
     *
     * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.
     */
    var Overlay = /** @class */ (function () {
        function Overlay(_overlayContainer, _componentFactoryResolver, _injector, _ngZone, _document, _location) {
            this._overlayContainer = _overlayContainer;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._injector = _injector;
            this._ngZone = _ngZone;
            this._document = _document;
            this._location = _location;
        }
        /**
         * Creates an overlay.
         * @param config Configuration applied to the overlay.
         * @returns Reference to the created overlay.
         */
        /**
         * Creates an overlay.
         * @param {?=} config Configuration applied to the overlay.
         * @return {?} Reference to the created overlay.
         */
        Overlay.prototype.create = /**
         * Creates an overlay.
         * @param {?=} config Configuration applied to the overlay.
         * @return {?} Reference to the created overlay.
         */
        function (config) {
            /** @type {?} */
            var host = this._createHostElement();
            /** @type {?} */
            var pane = this._createPaneElement(host);
            /** @type {?} */
            var portalOutlet = this._createPortalOutlet(pane);
            /** @type {?} */
            var overlayConfig = new OverlayConfig(config);
            return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._document, this._location);
        };
        /**
         * Creates the DOM element for an overlay and appends it to the overlay container.
         * @returns Newly-created pane element
         */
        /**
         * Creates the DOM element for an overlay and appends it to the overlay container.
         * @private
         * @param {?} host
         * @return {?} Newly-created pane element
         */
        Overlay.prototype._createPaneElement = /**
         * Creates the DOM element for an overlay and appends it to the overlay container.
         * @private
         * @param {?} host
         * @return {?} Newly-created pane element
         */
        function (host) {
            /** @type {?} */
            var pane = this._document.createElement('div');
            pane.id = "cdk-overlay-" + nextUniqueId$2++;
            host.appendChild(pane);
            return pane;
        };
        /**
         * Creates the host element that wraps around an overlay
         * and can be used for advanced positioning.
         * @returns Newly-create host element.
         */
        /**
         * Creates the host element that wraps around an overlay
         * and can be used for advanced positioning.
         * @private
         * @return {?} Newly-create host element.
         */
        Overlay.prototype._createHostElement = /**
         * Creates the host element that wraps around an overlay
         * and can be used for advanced positioning.
         * @private
         * @return {?} Newly-create host element.
         */
        function () {
            /** @type {?} */
            var host = this._document.createElement('div');
            this._overlayContainer.getContainerElement().appendChild(host);
            return host;
        };
        /**
         * Create a DomPortalOutlet into which the overlay content can be loaded.
         * @param pane The DOM element to turn into a portal outlet.
         * @returns A portal outlet for the given DOM element.
         */
        /**
         * Create a DomPortalOutlet into which the overlay content can be loaded.
         * @private
         * @param {?} pane The DOM element to turn into a portal outlet.
         * @return {?} A portal outlet for the given DOM element.
         */
        Overlay.prototype._createPortalOutlet = /**
         * Create a DomPortalOutlet into which the overlay content can be loaded.
         * @private
         * @param {?} pane The DOM element to turn into a portal outlet.
         * @return {?} A portal outlet for the given DOM element.
         */
        function (pane) {
            // We have to resolve the ApplicationRef later in order to allow people
            // to use overlay-based providers during app initialization.
            if (!this._appRef) {
                this._appRef = this._injector.get(core.ApplicationRef);
            }
            return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);
        };
        Overlay.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        Overlay.ctorParameters = function () { return [
            { type: OverlayContainer },
            { type: core.ComponentFactoryResolver },
            { type: core.Injector },
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: common.Location, decorators: [{ type: core.Optional }] }
        ]; };
        return Overlay;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OverlayModule = /** @class */ (function () {
        function OverlayModule() {
        }
        OverlayModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [PortalModule],
                        providers: [Overlay]
                    },] },
        ];
        return OverlayModule;
    }());

    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'];
    var candidateSelector = candidateSelectors.join(',');
    var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    function tabbable(el, options) {
      options = options || {};
      var elementDocument = el.ownerDocument || el;
      var regularTabbables = [];
      var orderedTabbables = [];
      var untouchabilityChecker = new UntouchabilityChecker(elementDocument);
      var candidates = el.querySelectorAll(candidateSelector);

      if (options.includeContainer) {
        if (matches.call(el, candidateSelector)) {
          candidates = Array.prototype.slice.apply(candidates);
          candidates.unshift(el);
        }
      }

      var i, candidate, candidateTabindex;

      for (i = 0; i < candidates.length; i++) {
        candidate = candidates[i];
        if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;
        candidateTabindex = getTabindex(candidate);

        if (candidateTabindex === 0) {
          regularTabbables.push(candidate);
        } else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            node: candidate
          });
        }
      }

      var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {
        return a.node;
      }).concat(regularTabbables);
      return tabbableNodes;
    }

    tabbable.isTabbable = isTabbable;
    tabbable.isFocusable = isFocusable;

    function isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {
      if (!isNodeMatchingSelectorFocusable(node, untouchabilityChecker) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
        return false;
      }

      return true;
    }

    function isTabbable(node, untouchabilityChecker) {
      if (!node) throw new Error('No node provided');
      if (matches.call(node, candidateSelector) === false) return false;
      return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);
    }

    function isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {
      untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);

      if (node.disabled || isHiddenInput(node) || untouchabilityChecker.isUntouchable(node)) {
        return false;
      }

      return true;
    }

    var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');

    function isFocusable(node, untouchabilityChecker) {
      if (!node) throw new Error('No node provided');
      if (matches.call(node, focusableCandidateSelector) === false) return false;
      return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);
    }

    function getTabindex(node) {
      var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
      if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;
      // so if they don't have a tabindex attribute specifically set, assume it's 0.

      if (isContentEditable(node)) return 0;
      return node.tabIndex;
    }

    function sortOrderedTabbables(a, b) {
      return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
    } // Array.prototype.find not available in IE.


    function find(list, predicate) {
      for (var i = 0, length = list.length; i < length; i++) {
        if (predicate(list[i])) return list[i];
      }
    }

    function isContentEditable(node) {
      return node.contentEditable === 'true';
    }

    function isInput(node) {
      return node.tagName === 'INPUT';
    }

    function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    }

    function isRadio(node) {
      return isInput(node) && node.type === 'radio';
    }

    function isNonTabbableRadio(node) {
      return isRadio(node) && !isTabbableRadio(node);
    }

    function getCheckedRadio(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked) {
          return nodes[i];
        }
      }
    }

    function isTabbableRadio(node) {
      if (!node.name) return true; // This won't account for the edge case where you have radio groups with the same
      // in separate forms on the same page.

      var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
      var checked = getCheckedRadio(radioSet);
      return !checked || checked === node;
    } // An element is "untouchable" if *it or one of its ancestors* has
    // `visibility: hidden` or `display: none`.


    function UntouchabilityChecker(elementDocument) {
      this.doc = elementDocument; // Node cache must be refreshed on every check, in case
      // the content of the element has changed. The cache contains tuples
      // mapping nodes to their boolean result.

      this.cache = [];
    } // getComputedStyle accurately reflects `visibility: hidden` of ancestors
    // but not `display: none`, so we need to recursively check parents.


    UntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {
      if (node.nodeType !== Node.ELEMENT_NODE) return false; // Search for a cached result.

      var cached = find(this.cache, function (item) {
        return item === node;
      });
      if (cached) return cached[1];
      nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);
      var result = false;

      if (nodeComputedStyle.display === 'none') {
        result = true;
      } else if (node.parentNode) {
        result = this.hasDisplayNone(node.parentNode);
      }

      this.cache.push([node, result]);
      return result;
    };

    UntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {
      if (node === this.doc.documentElement) return false;
      var computedStyle = this.doc.defaultView.getComputedStyle(node);
      if (this.hasDisplayNone(node, computedStyle)) return true;
      return computedStyle.visibility === 'hidden';
    };

    var tabbable_1 = tabbable;

    var immutable = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend() {
      var target = {};

      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    }

    var activeFocusTraps = function () {
      var trapQueue = [];
      return {
        activateTrap: function activateTrap(trap) {
          if (trapQueue.length > 0) {
            var activeTrap = trapQueue[trapQueue.length - 1];

            if (activeTrap !== trap) {
              activeTrap.pause();
            }
          }

          var trapIndex = trapQueue.indexOf(trap);

          if (trapIndex === -1) {
            trapQueue.push(trap);
          } else {
            // move this existing trap to the front of the queue
            trapQueue.splice(trapIndex, 1);
            trapQueue.push(trap);
          }
        },
        deactivateTrap: function deactivateTrap(trap) {
          var trapIndex = trapQueue.indexOf(trap);

          if (trapIndex !== -1) {
            trapQueue.splice(trapIndex, 1);
          }

          if (trapQueue.length > 0) {
            trapQueue[trapQueue.length - 1].unpause();
          }
        }
      };
    }();

    function focusTrap(element, userOptions) {
      var doc = document;
      var container = typeof element === 'string' ? doc.querySelector(element) : element;
      var config = immutable({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true
      }, userOptions);
      var state = {
        firstTabbableNode: null,
        lastTabbableNode: null,
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false
      };
      var trap = {
        activate: activate,
        deactivate: deactivate,
        pause: pause,
        unpause: unpause
      };
      return trap;

      function activate(activateOptions) {
        if (state.active) return;
        updateTabbableNodes();
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;

        if (onActivate) {
          onActivate();
        }

        addListeners();
        return trap;
      }

      function deactivate(deactivateOptions) {
        if (!state.active) return;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;

        if (onDeactivate) {
          onDeactivate();
        }

        var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;

        if (returnFocus) {
          delay(function () {
            tryFocus(state.nodeFocusedBeforeActivation);
          });
        }

        return trap;
      }

      function pause() {
        if (state.paused || !state.active) return;
        state.paused = true;
        removeListeners();
      }

      function unpause() {
        if (!state.paused || !state.active) return;
        state.paused = false;
        addListeners();
      }

      function addListeners() {
        if (!state.active) return; // There can be only one listening focus trap at a time

        activeFocusTraps.activateTrap(trap);
        updateTabbableNodes(); // Delay ensures that the focused element doesn't capture the event
        // that caused the focus trap activation.

        delay(function () {
          tryFocus(getInitialFocusNode());
        });
        doc.addEventListener('focusin', checkFocusIn, true);
        doc.addEventListener('mousedown', checkPointerDown, true);
        doc.addEventListener('touchstart', checkPointerDown, true);
        doc.addEventListener('click', checkClick, true);
        doc.addEventListener('keydown', checkKey, true);
        return trap;
      }

      function removeListeners() {
        if (!state.active) return;
        doc.removeEventListener('focusin', checkFocusIn, true);
        doc.removeEventListener('mousedown', checkPointerDown, true);
        doc.removeEventListener('touchstart', checkPointerDown, true);
        doc.removeEventListener('click', checkClick, true);
        doc.removeEventListener('keydown', checkKey, true);
        return trap;
      }

      function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        var node = optionValue;

        if (!optionValue) {
          return null;
        }

        if (typeof optionValue === 'string') {
          node = doc.querySelector(optionValue);

          if (!node) {
            throw new Error('`' + optionName + '` refers to no known node');
          }
        }

        if (typeof optionValue === 'function') {
          node = optionValue();

          if (!node) {
            throw new Error('`' + optionName + '` did not return a node');
          }
        }

        return node;
      }

      function getInitialFocusNode() {
        var node;

        if (getNodeForOption('initialFocus') !== null) {
          node = getNodeForOption('initialFocus');
        } else if (container.contains(doc.activeElement)) {
          node = doc.activeElement;
        } else {
          node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
        }

        if (!node) {
          throw new Error("You can't have a focus-trap without at least one focusable element");
        }

        return node;
      } // This needs to be done on mousedown and touchstart instead of click
      // so that it precedes the focus event.


      function checkPointerDown(e) {
        if (container.contains(e.target)) return;

        if (config.clickOutsideDeactivates) {
          deactivate({
            returnFocus: !tabbable_1.isFocusable(e.target)
          });
        } else {
          e.preventDefault();
        }
      } // In case focus escapes the trap for some strange reason, pull it back in.


      function checkFocusIn(e) {
        // In Firefox when you Tab out of an iframe the Document is briefly focused.
        if (container.contains(e.target) || e.target instanceof Document) {
          return;
        }

        e.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }

      function checkKey(e) {
        if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
          e.preventDefault();
          deactivate();
          return;
        }

        if (isTabEvent(e)) {
          checkTab(e);
          return;
        }
      } // Hijack Tab events on the first and last focusable nodes of the trap,
      // in order to prevent focus from escaping. If it escapes for even a
      // moment it can end up scrolling the page and causing confusion so we
      // kind of need to capture the action at the keydown phase.


      function checkTab(e) {
        updateTabbableNodes();

        if (e.shiftKey && e.target === state.firstTabbableNode) {
          e.preventDefault();
          tryFocus(state.lastTabbableNode);
          return;
        }

        if (!e.shiftKey && e.target === state.lastTabbableNode) {
          e.preventDefault();
          tryFocus(state.firstTabbableNode);
          return;
        }
      }

      function checkClick(e) {
        if (config.clickOutsideDeactivates) return;
        if (container.contains(e.target)) return;
        e.preventDefault();
        e.stopImmediatePropagation();
      }

      function updateTabbableNodes() {
        var tabbableNodes = tabbable_1(container);
        state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
        state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
      }

      function tryFocus(node) {
        if (node === doc.activeElement) return;

        if (!node || !node.focus) {
          tryFocus(getInitialFocusNode());
          return;
        }

        node.focus();
        state.mostRecentlyFocusedNode = node;

        if (isSelectableInput(node)) {
          node.select();
        }
      }
    }

    function isSelectableInput(node) {
      return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
    }

    function isEscapeEvent(e) {
      return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
    }

    function isTabEvent(e) {
      return e.key === 'Tab' || e.keyCode === 9;
    }

    function delay(fn) {
      return setTimeout(fn, 0);
    }

    var focusTrap_1 = focusTrap;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcDialogAction = /** @class */ (function () {
        function MdcDialogAction(elementRef) {
            this.elementRef = elementRef;
            this._action = '';
        }
        Object.defineProperty(MdcDialogAction.prototype, "action", {
            get: /**
             * @return {?}
             */
            function () { return this._action; },
            set: /**
             * @param {?} action
             * @return {?}
             */
            function (action) {
                // If the directive is set without a name (updated programatically), then this setter will
                // trigger with an empty string and should not overwrite the programatically set value.
                if (!action) {
                    return;
                }
                this._action = action;
                this.elementRef.nativeElement.setAttribute('data-mdc-dialog-action', this._action);
            },
            enumerable: true,
            configurable: true
        });
        MdcDialogAction.decorators = [
            { type: core.Directive, args: [{ selector: '[mdcDialogAction]' },] },
        ];
        /** @nocollapse */
        MdcDialogAction.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDialogAction.propDecorators = {
            action: [{ type: core.Input, args: ['mdcDialogAction',] }]
        };
        return MdcDialogAction;
    }());
    var MdcDialogScrim = /** @class */ (function () {
        function MdcDialogScrim(elementRef) {
            this.elementRef = elementRef;
        }
        MdcDialogScrim.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-dialog-scrim',
                        host: { 'class': 'mdc-dialog__scrim' }
                    },] },
        ];
        /** @nocollapse */
        MdcDialogScrim.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcDialogScrim;
    }());
    var MdcDialogContainer = /** @class */ (function () {
        function MdcDialogContainer(elementRef) {
            this.elementRef = elementRef;
        }
        MdcDialogContainer.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogContainer], mdc-dialog-container',
                        host: { 'class': 'mdc-dialog__container' }
                    },] },
        ];
        /** @nocollapse */
        MdcDialogContainer.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcDialogContainer;
    }());
    var MdcDialogSurface = /** @class */ (function () {
        function MdcDialogSurface(elementRef) {
            this.elementRef = elementRef;
        }
        MdcDialogSurface.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogSurface], mdc-dialog-surface',
                        host: { 'class': 'mdc-dialog__surface' }
                    },] },
        ];
        /** @nocollapse */
        MdcDialogSurface.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcDialogSurface;
    }());
    var MdcDialogTitle = /** @class */ (function () {
        function MdcDialogTitle(elementRef) {
            this.elementRef = elementRef;
        }
        MdcDialogTitle.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogTitle], mdc-dialog-title',
                        host: { 'class': 'mdc-dialog__title' }
                    },] },
        ];
        /** @nocollapse */
        MdcDialogTitle.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcDialogTitle;
    }());
    var MdcDialogContent = /** @class */ (function () {
        function MdcDialogContent(elementRef) {
            this.elementRef = elementRef;
        }
        MdcDialogContent.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogContent], mdc-dialog-content',
                        host: { 'class': 'mdc-dialog__content' }
                    },] },
        ];
        /** @nocollapse */
        MdcDialogContent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcDialogContent;
    }());
    var MdcDialogActions = /** @class */ (function () {
        function MdcDialogActions(elementRef) {
            this.elementRef = elementRef;
            this._stacked = false;
        }
        Object.defineProperty(MdcDialogActions.prototype, "stacked", {
            get: /**
             * @return {?}
             */
            function () { return this._stacked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._stacked = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcDialogActions.decorators = [
            { type: core.Component, args: [{selector: 'mdc-dialog-actions, [mdcDialogActions]',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcDialogActions',
                        host: {
                            'class': 'mdc-dialog__actions',
                            '[class.mdc-dialog--stacked]': 'stacked'
                        },
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcDialogActions.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDialogActions.propDecorators = {
            stacked: [{ type: core.Input }]
        };
        return MdcDialogActions;
    }());
    var MdcDialogButton = /** @class */ (function (_super) {
        __extends(MdcDialogButton, _super);
        function MdcDialogButton() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._default = false;
            return _this;
        }
        Object.defineProperty(MdcDialogButton.prototype, "default", {
            get: /**
             * @return {?}
             */
            function () { return this._default; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._default = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcDialogButton.decorators = [
            { type: core.Component, args: [{selector: '[mdcDialogButton]',
                        exportAs: 'mdcDialogButton',
                        host: {
                            'class': 'mdc-dialog__button',
                            '[class.mdc-button]': 'true',
                            '[class.mdc-dialog__button--default]': 'default'
                        },
                        template: '<ng-content></ng-content>',
                        providers: [MdcRipple],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        MdcDialogButton.propDecorators = {
            default: [{ type: core.Input }]
        };
        return MdcDialogButton;
    }(MdcButton));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Unique id for the created dialog.
     * @type {?}
     */
    var uniqueId = 0;
    /**
     * Reference to a dialog dispatched from the MdcDialog service.
     * @template T, R
     */
    var   /**
     * Reference to a dialog dispatched from the MdcDialog service.
     * @template T, R
     */
    MdcDialogRef = /** @class */ (function () {
        function MdcDialogRef(_overlayRef, _portalInstance, id) {
            if (id === void 0) { id = "mdc-dialog-" + uniqueId++; }
            var _this = this;
            this._overlayRef = _overlayRef;
            this._portalInstance = _portalInstance;
            this.id = id;
            /**
             * Subject for notifying the user that the dialog has finished opening.
             */
            this._afterOpened = new rxjs.Subject();
            /**
             * Subject for notifying the user that the dialog has started closing.
             */
            this._beforeClosed = new rxjs.Subject();
            /**
             * Subject for notifying the user that the dialog has finished closing.
             */
            this._afterClosed = new rxjs.Subject();
            // Pass the id along to the portal.
            _portalInstance._id = id;
            _overlayRef.detachments().subscribe((/**
             * @return {?}
             */
            function () {
                _this._beforeClosed.next(_this._result);
                _this._beforeClosed.complete();
                _this._afterClosed.next(_this._result);
                _this._afterClosed.complete();
                _this.componentInstance = (/** @type {?} */ (null));
                _this._overlayRef.dispose();
            }));
        }
        /**
         * Close the dialog.
         * @param dialogResult Optional result to return to the dialog opener.
         */
        /**
         * Close the dialog.
         * @param {?=} dialogResult Optional result to return to the dialog opener.
         * @return {?}
         */
        MdcDialogRef.prototype.close = /**
         * Close the dialog.
         * @param {?=} dialogResult Optional result to return to the dialog opener.
         * @return {?}
         */
        function (dialogResult) {
            this._result = dialogResult;
            this._overlayRef.dispose();
        };
        /** Marks the dialog as opened. */
        /**
         * Marks the dialog as opened.
         * @return {?}
         */
        MdcDialogRef.prototype.opened = /**
         * Marks the dialog as opened.
         * @return {?}
         */
        function () {
            if (!this._afterOpened.closed) {
                this._afterOpened.next();
                this._afterOpened.complete();
            }
        };
        /** Gets an observable that is notified when the dialog is finished opening. */
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         * @return {?}
         */
        MdcDialogRef.prototype.afterOpened = /**
         * Gets an observable that is notified when the dialog is finished opening.
         * @return {?}
         */
        function () {
            return this._afterOpened.asObservable();
        };
        /** Gets an observable that is notified when the dialog has started closing. */
        /**
         * Gets an observable that is notified when the dialog has started closing.
         * @return {?}
         */
        MdcDialogRef.prototype.beforeClosed = /**
         * Gets an observable that is notified when the dialog has started closing.
         * @return {?}
         */
        function () {
            return this._beforeClosed.asObservable();
        };
        /** Gets an observable that is notified when the dialog is finished closing. */
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         * @return {?}
         */
        MdcDialogRef.prototype.afterClosed = /**
         * Gets an observable that is notified when the dialog is finished closing.
         * @return {?}
         */
        function () {
            return this._afterClosed.asObservable();
        };
        return MdcDialogRef;
    }());

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @param {!Element} surfaceEl
     * @param {?Element=} initialFocusEl
     * @param {function(!Element, !FocusTrapCreateOptions): !FocusTrapInstance} focusTrapFactory
     * @return {!FocusTrapInstance}
     */

    function createFocusTrapInstance(surfaceEl) {
      var focusTrapFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : focusTrap_1;
      var initialFocusEl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return focusTrapFactory(surfaceEl, {
        initialFocus: initialFocusEl,
        escapeDeactivates: false,
        // Dialog foundation handles escape key
        clickOutsideDeactivates: true // Allow handling of scrim clicks

      });
    }
    /**
     * @param {!Element} el
     * @return {boolean}
     */


    function isScrollable(el) {
      return el.scrollHeight > el.offsetHeight;
    }
    /**
     * @param {!Array<!Element>|!NodeList} els
     * @return {boolean}
     */


    function areTopsMisaligned(els) {
      var tops = new Set();
      [].forEach.call(els, function (el) {
        return tops.add(el.offsetTop);
      });
      return tops.size > 1;
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$4 = {
      OPEN: 'mdc-dialog--open',
      OPENING: 'mdc-dialog--opening',
      CLOSING: 'mdc-dialog--closing',
      SCROLLABLE: 'mdc-dialog--scrollable',
      STACKED: 'mdc-dialog--stacked',
      SCROLL_LOCK: 'mdc-dialog-scroll-lock'
    };
    var strings$4 = {
      SCRIM_SELECTOR: '.mdc-dialog__scrim',
      CONTAINER_SELECTOR: '.mdc-dialog__container',
      SURFACE_SELECTOR: '.mdc-dialog__surface',
      CONTENT_SELECTOR: '.mdc-dialog__content',
      BUTTON_SELECTOR: '.mdc-dialog__button',
      DEFAULT_BUTTON_SELECTOR: '.mdc-dialog__button--default',
      SUPPRESS_DEFAULT_PRESS_SELECTOR: ['textarea', '.mdc-menu .mdc-list-item'].join(', '),
      OPENING_EVENT: 'MDCDialog:opening',
      OPENED_EVENT: 'MDCDialog:opened',
      CLOSING_EVENT: 'MDCDialog:closing',
      CLOSED_EVENT: 'MDCDialog:closed',
      ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
      CLOSE_ACTION: 'close',
      DESTROY_ACTION: 'destroy'
    };
    var numbers$3 = {
      DIALOG_ANIMATION_OPEN_TIME_MS: 150,
      DIALOG_ANIMATION_CLOSE_TIME_MS: 75
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
     * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
     */

    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {?Element}
     */
    function closest(element, selector) {
      if (element.closest) {
        return element.closest(selector);
      }

      var el = element;

      while (el) {
        if (matches$1(el, selector)) {
          return el;
        }

        el = el.parentElement;
      }

      return null;
    }
    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {boolean}
     */


    function matches$1(element, selector) {
      var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      return nativeMatches.call(element, selector);
    }

    function _classCallCheck$4(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$4(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$4(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$4(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$4(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$4(subClass, superClass);
    }

    function _getPrototypeOf$4(o) {
      _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$4(o);
    }

    function _setPrototypeOf$4(o, p) {
      _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$4(o, p);
    }

    function _assertThisInitialized$4(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$4(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$4(self);
    }

    function _superPropBase$2(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$4(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$2(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$2 = Reflect.get;
      } else {
        _get$2 = function _get(target, property, receiver) {
          var base = _superPropBase$2(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$2(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$4 =
    /*#__PURE__*/
    function () {
      _createClass$4(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$4(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$4(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$4 =
    /*#__PURE__*/
    function () {
      _createClass$4(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$4());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$4(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$4(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$3 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$4(this, MDCRippleAdapter);
      }

      _createClass$4(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1$3 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$3 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$1$2 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$3;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$3;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$3(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$3(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$3;

      if (typeof supportsCssVariables_$3 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$3(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$3 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$3() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$3 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$3 = isSupported;
      }

      return supportsPassive_$3 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$3(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$3(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$4 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$4 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$3 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$3 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$4(MDCRippleFoundation, _MDCFoundation);

      _createClass$4(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$3;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$3;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$2;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$4(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$4(this, _getPrototypeOf$4(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$4(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$4.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$4.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$4.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$4.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$3.length > 0 && activatedTargets$3.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$3.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$3 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$3(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$1$2.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$4);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$3 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$4(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$4(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$4(this, (_getPrototypeOf2 = _getPrototypeOf$4(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$4(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$3(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$3(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$3(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$3());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$3());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$3());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$3());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$4);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$3 = function RippleCapableSurface() {
      _classCallCheck$4(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$3.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$3.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$3.prototype.disabled;

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Dialog. Provides an interface for managing:
     * - CSS classes
     * - DOM
     * - Event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCDialogAdapter =
    /*#__PURE__*/
    function () {
      function MDCDialogAdapter() {
        _classCallCheck$4(this, MDCDialogAdapter);
      }

      _createClass$4(MDCDialogAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /** @param {string} className */

      }, {
        key: "addBodyClass",
        value: function addBodyClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeBodyClass",
        value: function removeBodyClass(className) {}
        /**
         * @param {!EventTarget} target
         * @param {string} selector
         * @return {boolean}
         */

      }, {
        key: "eventTargetMatches",
        value: function eventTargetMatches(target, selector) {}
      }, {
        key: "trapFocus",
        value: function trapFocus() {}
      }, {
        key: "releaseFocus",
        value: function releaseFocus() {}
        /** @return {boolean} */

      }, {
        key: "isContentScrollable",
        value: function isContentScrollable() {}
        /** @return {boolean} */

      }, {
        key: "areButtonsStacked",
        value: function areButtonsStacked() {}
        /**
         * @param {!Event} event
         * @return {?string}
         */

      }, {
        key: "getActionFromEvent",
        value: function getActionFromEvent(event) {}
      }, {
        key: "clickDefaultButton",
        value: function clickDefaultButton() {}
      }, {
        key: "reverseButtons",
        value: function reverseButtons() {}
      }, {
        key: "notifyOpening",
        value: function notifyOpening() {}
      }, {
        key: "notifyOpened",
        value: function notifyOpened() {}
        /**
         * @param {string} action
         */

      }, {
        key: "notifyClosing",
        value: function notifyClosing(action) {}
        /**
         * @param {string} action
         */

      }, {
        key: "notifyClosed",
        value: function notifyClosed(action) {}
      }]);

      return MDCDialogAdapter;
    }();

    var MDCDialogFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$4(MDCDialogFoundation, _MDCFoundation);

      _createClass$4(MDCDialogFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$4;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$4;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$3;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCDialogAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              hasClass: function hasClass()
              /* className: string */
              {},
              addBodyClass: function addBodyClass()
              /* className: string */
              {},
              removeBodyClass: function removeBodyClass()
              /* className: string */
              {},
              eventTargetMatches: function eventTargetMatches()
              /* target: !EventTarget, selector: string */
              {},
              trapFocus: function trapFocus() {},
              releaseFocus: function releaseFocus() {},
              isContentScrollable: function isContentScrollable() {},
              areButtonsStacked: function areButtonsStacked() {},
              getActionFromEvent: function getActionFromEvent()
              /* event: !Event */
              {},
              clickDefaultButton: function clickDefaultButton() {},
              reverseButtons: function reverseButtons() {},
              notifyOpening: function notifyOpening() {},
              notifyOpened: function notifyOpened() {},
              notifyClosing: function notifyClosing()
              /* action: ?string */
              {},
              notifyClosed: function notifyClosed()
              /* action: ?string */
              {}
            }
          );
        }
        /**
         * @param {!MDCDialogAdapter=} adapter
         */

      }]);

      function MDCDialogFoundation(adapter) {
        var _this;

        _classCallCheck$4(this, MDCDialogFoundation);

        _this = _possibleConstructorReturn$4(this, _getPrototypeOf$4(MDCDialogFoundation).call(this, Object.assign(MDCDialogFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.isOpen_ = false;
        /** @private {number} */

        _this.animationFrame_ = 0;
        /** @private {number} */

        _this.animationTimer_ = 0;
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {string} */

        _this.escapeKeyAction_ = strings$4.CLOSE_ACTION;
        /** @private {string} */

        _this.scrimClickAction_ = strings$4.CLOSE_ACTION;
        /** @private {boolean} */

        _this.autoStackButtons_ = true;
        /** @private {boolean} */

        _this.areButtonsStacked_ = false;
        return _this;
      }

      _createClass$4(MDCDialogFoundation, [{
        key: "init",
        value: function init() {
          if (this.adapter_.hasClass(cssClasses$4.STACKED)) {
            this.setAutoStackButtons(false);
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.isOpen_) {
            this.close(strings$4.DESTROY_ACTION);
          }

          if (this.animationTimer_) {
            clearTimeout(this.animationTimer_);
            this.handleAnimationTimerEnd_();
          }

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
            this.layoutFrame_ = 0;
          }
        }
      }, {
        key: "open",
        value: function open() {
          var _this2 = this;

          this.isOpen_ = true;
          this.adapter_.notifyOpening();
          this.adapter_.addClass(cssClasses$4.OPENING); // Wait a frame once display is no longer "none", to establish basis for animation

          this.runNextAnimationFrame_(function () {
            _this2.adapter_.addClass(cssClasses$4.OPEN);

            _this2.adapter_.addBodyClass(cssClasses$4.SCROLL_LOCK);

            _this2.layout();

            _this2.animationTimer_ = setTimeout(function () {
              _this2.handleAnimationTimerEnd_();

              _this2.adapter_.trapFocus();

              _this2.adapter_.notifyOpened();
            }, numbers$3.DIALOG_ANIMATION_OPEN_TIME_MS);
          });
        }
        /**
         * @param {string=} action
         */

      }, {
        key: "close",
        value: function close() {
          var _this3 = this;

          var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          if (!this.isOpen_) {
            // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
            return;
          }

          this.isOpen_ = false;
          this.adapter_.notifyClosing(action);
          this.adapter_.addClass(cssClasses$4.CLOSING);
          this.adapter_.removeClass(cssClasses$4.OPEN);
          this.adapter_.removeBodyClass(cssClasses$4.SCROLL_LOCK);
          cancelAnimationFrame(this.animationFrame_);
          this.animationFrame_ = 0;
          clearTimeout(this.animationTimer_);
          this.animationTimer_ = setTimeout(function () {
            _this3.adapter_.releaseFocus();

            _this3.handleAnimationTimerEnd_();

            _this3.adapter_.notifyClosed(action);
          }, numbers$3.DIALOG_ANIMATION_CLOSE_TIME_MS);
        }
      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
        /** @return {string} */

      }, {
        key: "getEscapeKeyAction",
        value: function getEscapeKeyAction() {
          return this.escapeKeyAction_;
        }
        /** @param {string} action */

      }, {
        key: "setEscapeKeyAction",
        value: function setEscapeKeyAction(action) {
          this.escapeKeyAction_ = action;
        }
        /** @return {string} */

      }, {
        key: "getScrimClickAction",
        value: function getScrimClickAction() {
          return this.scrimClickAction_;
        }
        /** @param {string} action */

      }, {
        key: "setScrimClickAction",
        value: function setScrimClickAction(action) {
          this.scrimClickAction_ = action;
        }
        /** @return {boolean} */

      }, {
        key: "getAutoStackButtons",
        value: function getAutoStackButtons() {
          return this.autoStackButtons_;
        }
        /** @param {boolean} autoStack */

      }, {
        key: "setAutoStackButtons",
        value: function setAutoStackButtons(autoStack) {
          this.autoStackButtons_ = autoStack;
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this4 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this4.layoutInternal_();

            _this4.layoutFrame_ = 0;
          });
        }
      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          if (this.autoStackButtons_) {
            this.detectStackedButtons_();
          }

          this.detectScrollableContent_();
        }
        /** @private */

      }, {
        key: "detectStackedButtons_",
        value: function detectStackedButtons_() {
          // Remove the class first to let us measure the buttons' natural positions.
          this.adapter_.removeClass(cssClasses$4.STACKED);
          var areButtonsStacked = this.adapter_.areButtonsStacked();

          if (areButtonsStacked) {
            this.adapter_.addClass(cssClasses$4.STACKED);
          }

          if (areButtonsStacked !== this.areButtonsStacked_) {
            this.adapter_.reverseButtons();
            this.areButtonsStacked_ = areButtonsStacked;
          }
        }
        /** @private */

      }, {
        key: "detectScrollableContent_",
        value: function detectScrollableContent_() {
          // Remove the class first to let us measure the natural height of the content.
          this.adapter_.removeClass(cssClasses$4.SCROLLABLE);

          if (this.adapter_.isContentScrollable()) {
            this.adapter_.addClass(cssClasses$4.SCROLLABLE);
          }
        }
        /**
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction(evt) {
          var isClick = evt.type === 'click';
          var isEnter = evt.key === 'Enter' || evt.keyCode === 13; // Check for scrim click first since it doesn't require querying ancestors

          if (isClick && this.adapter_.eventTargetMatches(evt.target, strings$4.SCRIM_SELECTOR) && this.scrimClickAction_ !== '') {
            this.close(this.scrimClickAction_);
          } else if (isClick || evt.key === 'Space' || evt.keyCode === 32 || isEnter) {
            var action = this.adapter_.getActionFromEvent(evt);

            if (action) {
              this.close(action);
            } else if (isEnter && !this.adapter_.eventTargetMatches(evt.target, strings$4.SUPPRESS_DEFAULT_PRESS_SELECTOR)) {
              this.adapter_.clickDefaultButton();
            }
          }
        }
        /**
         * @param {!KeyboardEvent} evt
         * @private
         */

      }, {
        key: "handleDocumentKeydown",
        value: function handleDocumentKeydown(evt) {
          if ((evt.key === 'Escape' || evt.keyCode === 27) && this.escapeKeyAction_ !== '') {
            this.close(this.escapeKeyAction_);
          }
        }
        /** @private */

      }, {
        key: "handleAnimationTimerEnd_",
        value: function handleAnimationTimerEnd_() {
          this.animationTimer_ = 0;
          this.adapter_.removeClass(cssClasses$4.OPENING);
          this.adapter_.removeClass(cssClasses$4.CLOSING);
        }
        /**
         * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
         * @param {Function} callback
         * @private
         */

      }, {
        key: "runNextAnimationFrame_",
        value: function runNextAnimationFrame_(callback) {
          var _this5 = this;

          cancelAnimationFrame(this.animationFrame_);
          this.animationFrame_ = requestAnimationFrame(function () {
            _this5.animationFrame_ = 0;
            clearTimeout(_this5.animationTimer_);
            _this5.animationTimer_ = setTimeout(callback, 0);
          });
        }
      }]);

      return MDCDialogFoundation;
    }(MDCFoundation$4);

    var strings$2$2 = MDCDialogFoundation.strings;

    var MDCDialog =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$4(MDCDialog, _MDCComponent);

      function MDCDialog() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$4(this, MDCDialog);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$4(this, (_getPrototypeOf2 = _getPrototypeOf$4(MDCDialog)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /**
         * @type {!Array<!MDCRipple>}
         * @private
         */

        _this.buttonRipples_;
        /** @private {!Array<!Element>} */

        _this.buttons_;
        /** @private {?Element} */

        _this.defaultButton_;
        /** @private {!Element} */

        _this.container_;
        /** @private {?Element} */

        _this.content_;
        /** @private {?Element} */

        _this.initialFocusEl_;
        /** @private {!Function} */

        _this.focusTrapFactory_;
        /** @private {!FocusTrapInstance} */

        _this.focusTrap_;
        /** @private {!Function} */

        _this.handleInteraction_;
        /** @private {!Function} */

        _this.handleDocumentKeydown_;
        /** @private {!Function} */

        _this.handleOpening_;
        /** @private {!Function} */

        _this.handleClosing_;
        /** @private {Function} */

        _this.layout_;
        return _this;
      }

      _createClass$4(MDCDialog, [{
        key: "initialize",
        value: function initialize() {
          var focusTrapFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : focusTrap_1;
          var initialFocusEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          this.container_ =
          /** @type {!Element} */
          this.root_.querySelector(strings$2$2.CONTAINER_SELECTOR);
          this.content_ = this.root_.querySelector(strings$2$2.CONTENT_SELECTOR);
          this.buttons_ = [].slice.call(this.root_.querySelectorAll(strings$2$2.BUTTON_SELECTOR));
          this.defaultButton_ = this.root_.querySelector(strings$2$2.DEFAULT_BUTTON_SELECTOR);
          this.buttonRipples_ = [];
          this.focusTrapFactory_ = focusTrapFactory;
          this.initialFocusEl_ = initialFocusEl;

          for (var i = 0, buttonEl; buttonEl = this.buttons_[i]; i++) {
            this.buttonRipples_.push(new MDCRipple$3(buttonEl));
          }
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.focusTrap_ = createFocusTrapInstance(this.container_, this.focusTrapFactory_, this.initialFocusEl_);
          this.handleInteraction_ = this.foundation_.handleInteraction.bind(this.foundation_);
          this.handleDocumentKeydown_ = this.foundation_.handleDocumentKeydown.bind(this.foundation_);
          this.layout_ = this.layout.bind(this);
          var LAYOUT_EVENTS = ['resize', 'orientationchange'];

          this.handleOpening_ = function () {
            LAYOUT_EVENTS.forEach(function (type) {
              return window.addEventListener(type, _this2.layout_);
            });
            document.addEventListener('keydown', _this2.handleDocumentKeydown_);
          };

          this.handleClosing_ = function () {
            LAYOUT_EVENTS.forEach(function (type) {
              return window.removeEventListener(type, _this2.layout_);
            });
            document.removeEventListener('keydown', _this2.handleDocumentKeydown_);
          };

          this.listen('click', this.handleInteraction_);
          this.listen('keydown', this.handleInteraction_);
          this.listen(strings$2$2.OPENING_EVENT, this.handleOpening_);
          this.listen(strings$2$2.CLOSING_EVENT, this.handleClosing_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.unlisten('click', this.handleInteraction_);
          this.unlisten('keydown', this.handleInteraction_);
          this.unlisten(strings$2$2.OPENING_EVENT, this.handleOpening_);
          this.unlisten(strings$2$2.CLOSING_EVENT, this.handleClosing_);
          this.handleClosing_();
          this.buttonRipples_.forEach(function (ripple) {
            return ripple.destroy();
          });

          _get$2(_getPrototypeOf$4(MDCDialog.prototype), "destroy", this).call(this);
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
      }, {
        key: "open",
        value: function open() {
          this.foundation_.open();
        }
        /**
         * @param {string=} action
         */

      }, {
        key: "close",
        value: function close() {
          var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          this.foundation_.close(action);
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCDialogFoundation({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            addBodyClass: function addBodyClass(className) {
              return document.body.classList.add(className);
            },
            removeBodyClass: function removeBodyClass(className) {
              return document.body.classList.remove(className);
            },
            eventTargetMatches: function eventTargetMatches(target, selector) {
              return matches$1(target, selector);
            },
            trapFocus: function trapFocus() {
              return _this3.focusTrap_.activate();
            },
            releaseFocus: function releaseFocus() {
              return _this3.focusTrap_.deactivate();
            },
            isContentScrollable: function isContentScrollable() {
              return !!_this3.content_ && isScrollable(
              /** @type {!Element} */
              _this3.content_);
            },
            areButtonsStacked: function areButtonsStacked() {
              return areTopsMisaligned(_this3.buttons_);
            },
            getActionFromEvent: function getActionFromEvent(event) {
              var element = closest(event.target, "[".concat(strings$2$2.ACTION_ATTRIBUTE, "]"));
              return element && element.getAttribute(strings$2$2.ACTION_ATTRIBUTE);
            },
            clickDefaultButton: function clickDefaultButton() {
              if (_this3.defaultButton_) {
                _this3.defaultButton_.click();
              }
            },
            reverseButtons: function reverseButtons() {
              _this3.buttons_.reverse();

              _this3.buttons_.forEach(function (button) {
                return button.parentElement.appendChild(button);
              });
            },
            notifyOpening: function notifyOpening() {
              return _this3.emit(strings$2$2.OPENING_EVENT, {});
            },
            notifyOpened: function notifyOpened() {
              return _this3.emit(strings$2$2.OPENED_EVENT, {});
            },
            notifyClosing: function notifyClosing(action) {
              return _this3.emit(strings$2$2.CLOSING_EVENT, action ? {
                action: action
              } : {});
            },
            notifyClosed: function notifyClosed(action) {
              return _this3.emit(strings$2$2.CLOSED_EVENT, action ? {
                action: action
              } : {});
            }
          });
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this.foundation_.isOpen();
        }
      }, {
        key: "escapeKeyAction",
        get: function get() {
          return this.foundation_.getEscapeKeyAction();
        },
        set: function set(action) {
          this.foundation_.setEscapeKeyAction(action);
        }
      }, {
        key: "scrimClickAction",
        get: function get() {
          return this.foundation_.getScrimClickAction();
        },
        set: function set(action) {
          this.foundation_.setScrimClickAction(action);
        }
      }, {
        key: "autoStackButtons",
        get: function get() {
          return this.foundation_.getAutoStackButtons();
        },
        set: function set(autoStack) {
          this.foundation_.setAutoStackButtons(autoStack);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCDialog(root);
        }
      }]);

      return MDCDialog;
    }(MDCComponent$4);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LAYOUT_EVENTS = ['resize', 'orientationchange'];
    var MdcDialogComponent = /** @class */ (function () {
        function MdcDialogComponent(_ngZone, _platform, _elementRef, dialogRef) {
            this._ngZone = _ngZone;
            this._platform = _platform;
            this._elementRef = _elementRef;
            this.dialogRef = dialogRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._focusTrapInstance = null;
            this._scrollable = true;
            this._layoutEventSubscription = null;
            this.config = dialogRef._portalInstance._config;
        }
        Object.defineProperty(MdcDialogComponent.prototype, "layoutEvents", {
            /** Combined stream of all of the dialog layout events. */
            get: /**
             * Combined stream of all of the dialog layout events.
             * @return {?}
             */
            function () {
                return rxjs.merge.apply(void 0, LAYOUT_EVENTS.map((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) { return rxjs.fromEvent(window, evt); })));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcDialogComponent.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getDialog().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getDialog().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getDialog().classList.contains(className); }),
                addBodyClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) {
                    if (_this._platform.isBrowser) {
                        (/** @type {?} */ (document.body)).classList.add(className);
                    }
                }),
                removeBodyClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) {
                    if (_this._platform.isBrowser) {
                        (/** @type {?} */ (document.body)).classList.remove(className);
                    }
                }),
                eventTargetMatches: (/**
                 * @param {?} target
                 * @param {?} selector
                 * @return {?}
                 */
                function (target, selector) { return matches$1(target, selector); }),
                trapFocus: (/**
                 * @return {?}
                 */
                function () { return (/** @type {?} */ (_this._focusTrapInstance)).activate(); }),
                releaseFocus: (/**
                 * @return {?}
                 */
                function () { return (/** @type {?} */ (_this._focusTrapInstance)).deactivate(); }),
                isContentScrollable: (/**
                 * @return {?}
                 */
                function () {
                    return !!_this._content && _this._scrollable && isScrollable(_this._content.elementRef.nativeElement);
                }),
                areButtonsStacked: (/**
                 * @return {?}
                 */
                function () { return areTopsMisaligned(_this._buttons); }),
                getActionFromEvent: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) {
                    /** @type {?} */
                    var element = closest(event.target, "[" + strings$4.ACTION_ATTRIBUTE + "]");
                    return element && element.getAttribute(strings$4.ACTION_ATTRIBUTE);
                }),
                clickDefaultButton: (/**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var defaultBtn = _this._getDefaultButton();
                    if (defaultBtn) {
                        defaultBtn.click();
                    }
                }),
                reverseButtons: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._buttons) {
                        return;
                    }
                    _this._buttons.toArray().reverse();
                    _this._buttons.forEach((/**
                     * @param {?} button
                     * @return {?}
                     */
                    function (button) { return (/** @type {?} */ (button.getHostElement().parentElement)).appendChild(button.getHostElement()); }));
                }),
                notifyOpened: (/**
                 * @return {?}
                 */
                function () { return _this.dialogRef.opened(); }),
                notifyClosed: (/**
                 * @param {?} action
                 * @return {?}
                 */
                function (action) { return _this._closeDialogByRef(action); })
            };
        };
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation = new MDCDialogFoundation(this._createAdapter());
            this._focusTrapInstance = this._createFocusTrapInstance();
            this._initialize();
            this._loadListeners();
            this._foundation.open();
        };
        /**
         * @private
         * @return {?}
         */
        MdcDialogComponent.prototype._initialize = /**
         * @private
         * @return {?}
         */
        function () {
            this._scrollable = !!this.config.scrollable;
            if (!this.config.clickOutsideToClose) {
                this._foundation.setScrimClickAction('');
            }
            if (!this.config.escapeToClose) {
                this._foundation.setEscapeKeyAction('');
            }
            if (!this.config.buttonsStacked) {
                this._foundation.setAutoStackButtons(false);
            }
        };
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            if (this._layoutEventSubscription) {
                this._layoutEventSubscription.unsubscribe();
            }
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcDialogComponent.prototype._onInteraction = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleInteraction(evt);
        };
        /**
         * @private
         * @return {?}
         */
        MdcDialogComponent.prototype._getDefaultButton = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var defaultBtn = this._buttons ? this._buttons.find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.default; })) : undefined;
            return defaultBtn ? defaultBtn.getHostElement() : undefined;
        };
        /**
         * @private
         * @param {?=} action
         * @return {?}
         */
        MdcDialogComponent.prototype._closeDialogByRef = /**
         * @private
         * @param {?=} action
         * @return {?}
         */
        function (action) {
            this.dialogRef.close(action);
        };
        /**
         * @private
         * @return {?}
         */
        MdcDialogComponent.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._layoutEventSubscription = this.layoutEvents.pipe()
                .subscribe((/**
             * @return {?}
             */
            function () { return _this._foundation.layout(); }));
            if (this._platform.isBrowser) {
                this._ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    return rxjs.fromEvent(document, 'keydown').pipe(operators.takeUntil(_this._destroy))
                        .subscribe((/**
                     * @param {?} evt
                     * @return {?}
                     */
                    function (evt) { return _this._ngZone.run((/**
                     * @return {?}
                     */
                    function () { return _this._foundation.handleDocumentKeydown(evt); })); }));
                }));
            }
        };
        /**
         * @private
         * @param {?=} focusTrapFactory
         * @return {?}
         */
        MdcDialogComponent.prototype._createFocusTrapInstance = /**
         * @private
         * @param {?=} focusTrapFactory
         * @return {?}
         */
        function (focusTrapFactory) {
            if (focusTrapFactory === void 0) { focusTrapFactory = focusTrap_1; }
            return focusTrapFactory(this._getDialog(), {
                initialFocus: this._getDefaultButton(),
                clickOutsideDeactivates: true,
                // Allow handling of scrim clicks
                escapeDeactivates: false // Dialog foundation handles escape key
            });
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcDialogComponent.prototype._getDialog = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this._elementRef.nativeElement;
        };
        MdcDialogComponent.decorators = [
            { type: core.Component, args: [{selector: 'mdc-dialog',
                        exportAs: 'mdc-dialog',
                        host: {
                            '[attr.id]': 'config?.id',
                            'role': 'alertdialog',
                            'class': 'mdc-dialog',
                            '[attr.aria-modal]': 'true',
                            '[attr.aria-labelledby]': 'config?.ariaLabel',
                            '[attr.aria-label]': 'config?.ariaLabel',
                            '[attr.aria-describedby]': 'config?.ariaDescribedBy || null',
                            '(click)': '_onInteraction($event)',
                            '(keydown)': '_onInteraction($event)'
                        },
                        template: "\n  <mdc-dialog-scrim></mdc-dialog-scrim>\n  <ng-content></ng-content>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcDialogComponent.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: Platform },
            { type: core.ElementRef },
            { type: MdcDialogRef }
        ]; };
        MdcDialogComponent.propDecorators = {
            _surface: [{ type: core.ContentChild, args: [MdcDialogSurface,] }],
            _content: [{ type: core.ContentChild, args: [MdcDialogContent,] }],
            _buttons: [{ type: core.ContentChildren, args: [MdcDialogButton, { descendants: true },] }]
        };
        return MdcDialogComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template D
     */
    var   /**
     * @template D
     */
    MdcDialogConfig = /** @class */ (function () {
        function MdcDialogConfig() {
            /**
             * ID of the element that describes the dialog.
             */
            this.ariaDescribedBy = null;
            /**
             * Aria label to assign to the dialog element
             */
            this.ariaLabel = null;
            /**
             * Whether the user can use escape key to close the dialog
             */
            this.escapeToClose = true;
            /**
             * Whether the user can click outside to close the dialog
             */
            this.clickOutsideToClose = true;
            /**
             * Applied automatically when the dialog has overflowing content to warrant scrolling.
             */
            this.scrollable = true;
            /**
             * Applied automatically when the dialog's action buttons can't fit on a single line and must be stacked.
             */
            this.buttonsStacked = true;
            /**
             * Data to be injected into the dialog content.
             */
            this.data = null;
        }
        return MdcDialogConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Throws an exception for the case when a ComponentPortal is
     * attached to a DomPortalOutlet without an origin.
     * @return {?}
     */
    function throwMdcDialogContentAlreadyAttachedError() {
        throw Error('Attempting to attach dialog content after content is already attached');
    }
    var MdcDialogPortal = /** @class */ (function (_super) {
        __extends(MdcDialogPortal, _super);
        function MdcDialogPortal(_config) {
            var _this = _super.call(this) || this;
            _this._config = _config;
            /**
             * A subject emitting after the dialog exits the view.
             */
            _this._afterExit = new rxjs.Subject();
            return _this;
        }
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @template T
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        MdcDialogPortal.prototype.attachComponentPortal = /**
         * Attach a ComponentPortal as content to this dialog container.
         * @template T
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throwMdcDialogContentAlreadyAttachedError();
            }
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @template C
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        MdcDialogPortal.prototype.attachTemplatePortal = /**
         * Attach a TemplatePortal as content to this dialog container.
         * @template C
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throwMdcDialogContentAlreadyAttachedError();
            }
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        MdcDialogPortal.decorators = [
            { type: core.Component, args: [{selector: 'mdc-dialog-portal',
                        host: {
                            '[attr.id]': '_id'
                        },
                        template: '<ng-template cdkPortalOutlet></ng-template>',
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcDialogPortal.ctorParameters = function () { return [
            { type: MdcDialogConfig }
        ]; };
        MdcDialogPortal.propDecorators = {
            _portalOutlet: [{ type: core.ViewChild, args: [CdkPortalOutlet,] }]
        };
        return MdcDialogPortal;
    }(BasePortalOutlet));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to access the data that was passed in to a dialog.
     * @type {?}
     */
    var MDC_DIALOG_DATA = new core.InjectionToken('MdcDialogData');
    /**
     * Injection token that can be used to specify default dialog options.
     * @type {?}
     */
    var MDC_DIALOG_DEFAULT_OPTIONS = new core.InjectionToken('mdc-dialog-default-options');
    var MdcDialog = /** @class */ (function () {
        function MdcDialog(_overlay, _injector, _defaultOptions, _parentDialog) {
            var _this = this;
            this._overlay = _overlay;
            this._injector = _injector;
            this._defaultOptions = _defaultOptions;
            this._parentDialog = _parentDialog;
            this._openDialogsAtThisLevel = [];
            this._afterAllClosedAtThisLevel = new rxjs.Subject();
            this._afterOpenedAtThisLevel = new rxjs.Subject();
            this._ariaHiddenElements = new Map();
            /**
             * Stream that emits when all open dialog have finished closing.
             * Will emit on subscribe if there are no open dialogs to begin with.
             */
            this.afterAllClosed = rxjs.defer((/**
             * @return {?}
             */
            function () { return _this.openDialogs.length ?
                _this._afterAllClosed :
                _this._afterAllClosed.pipe(operators.startWith(undefined)); }));
        }
        Object.defineProperty(MdcDialog.prototype, "openDialogs", {
            /** Keeps track of the currently-open dialogs. */
            get: /**
             * Keeps track of the currently-open dialogs.
             * @return {?}
             */
            function () {
                return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDialog.prototype, "afterOpened", {
            /** Stream that emits when a dialog has been opened. */
            get: /**
             * Stream that emits when a dialog has been opened.
             * @return {?}
             */
            function () {
                return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDialog.prototype, "_afterAllClosed", {
            get: /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var parent = this._parentDialog;
                return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Opens a modal dialog containing the given template.
         * @param componentOrTemplateRef Type of the component to load into the dialog,
         *     or a TemplateRef to instantiate as the dialog content.
         * @param config Extra configuration options.
         * @returns Reference to the newly-opened dialog.
         */
        /**
         * Opens a modal dialog containing the given template.
         * @template T, D
         * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
         *     or a TemplateRef to instantiate as the dialog content.
         * @param {?=} config Extra configuration options.
         * @return {?} Reference to the newly-opened dialog.
         */
        MdcDialog.prototype.open = /**
         * Opens a modal dialog containing the given template.
         * @template T, D
         * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
         *     or a TemplateRef to instantiate as the dialog content.
         * @param {?=} config Extra configuration options.
         * @return {?} Reference to the newly-opened dialog.
         */
        function (componentOrTemplateRef, config) {
            var _this = this;
            config = _applyConfigDefaults(config, this._defaultOptions || new MdcDialogConfig());
            if (config.id && this.getDialogById(config.id)) {
                throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
            }
            /** @type {?} */
            var overlayRef = this._createOverlay();
            /** @type {?} */
            var dialogContainer = this._attachDialogContainer(overlayRef, config);
            /** @type {?} */
            var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
            this.openDialogs.push(dialogRef);
            dialogRef.afterClosed().subscribe((/**
             * @return {?}
             */
            function () { return _this._removeOpenDialog(dialogRef); }));
            this.afterOpened.next(dialogRef);
            return dialogRef;
        };
        /** Closes all of the currently-open dialogs. */
        /**
         * Closes all of the currently-open dialogs.
         * @return {?}
         */
        MdcDialog.prototype.closeAll = /**
         * Closes all of the currently-open dialogs.
         * @return {?}
         */
        function () {
            this._closeDialogs(this.openDialogs);
        };
        /**
         * Finds an open dialog by its id.
         * @param id ID to use when looking up the dialog.
         */
        /**
         * Finds an open dialog by its id.
         * @param {?} id ID to use when looking up the dialog.
         * @return {?}
         */
        MdcDialog.prototype.getDialogById = /**
         * Finds an open dialog by its id.
         * @param {?} id ID to use when looking up the dialog.
         * @return {?}
         */
        function (id) {
            return this.openDialogs.find((/**
             * @param {?} dialog
             * @return {?}
             */
            function (dialog) { return dialog.id === id; }));
        };
        /**
         * @return {?}
         */
        MdcDialog.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            // Only close the dialogs at this level on destroy
            // since the parent service may still be active.
            this._closeDialogs(this._openDialogsAtThisLevel);
            this._afterAllClosedAtThisLevel.complete();
            this._afterOpenedAtThisLevel.complete();
        };
        /**
         * Creates the overlay into which the dialog will be loaded.
         * @returns A promise resolving to the OverlayRef for the created overlay.
         */
        /**
         * Creates the overlay into which the dialog will be loaded.
         * @private
         * @return {?} A promise resolving to the OverlayRef for the created overlay.
         */
        MdcDialog.prototype._createOverlay = /**
         * Creates the overlay into which the dialog will be loaded.
         * @private
         * @return {?} A promise resolving to the OverlayRef for the created overlay.
         */
        function () {
            return this._overlay.create();
        };
        /**
         * Attaches an MdcDialogPortal to a dialog's already-created overlay.
         * @param overlay Reference to the dialog's underlying overlay.
         * @param config The dialog configuration.
         * @returns A promise resolving to a ComponentRef for the attached container.
         */
        /**
         * Attaches an MdcDialogPortal to a dialog's already-created overlay.
         * @private
         * @param {?} overlay Reference to the dialog's underlying overlay.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to a ComponentRef for the attached container.
         */
        MdcDialog.prototype._attachDialogContainer = /**
         * Attaches an MdcDialogPortal to a dialog's already-created overlay.
         * @private
         * @param {?} overlay Reference to the dialog's underlying overlay.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to a ComponentRef for the attached container.
         */
        function (overlay, config) {
            /** @type {?} */
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            /** @type {?} */
            var injector = new PortalInjector(userInjector || this._injector, new WeakMap([
                [MdcDialogConfig, config]
            ]));
            /** @type {?} */
            var containerPortal = new ComponentPortal(MdcDialogPortal, config.viewContainerRef, injector);
            /** @type {?} */
            var containerRef = overlay.attach(containerPortal);
            return containerRef.instance;
        };
        /**
         * Attaches the user-provided component to the already-created MdcDialogPortal.
         * @param componentOrTemplateRef The type of component being loaded into the dialog,
         *     or a TemplateRef to instantiate as the content.
         * @param dialogContainer Reference to the wrapping MdcDialogPortal.
         * @param overlayRef Reference to the overlay in which the dialog resides.
         * @param config The dialog configuration.
         * @returns A promise resolving to the MdcDialogRef that should be returned to the user.
         */
        /**
         * Attaches the user-provided component to the already-created MdcDialogPortal.
         * @private
         * @template T
         * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
         *     or a TemplateRef to instantiate as the content.
         * @param {?} dialogContainer Reference to the wrapping MdcDialogPortal.
         * @param {?} overlayRef Reference to the overlay in which the dialog resides.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to the MdcDialogRef that should be returned to the user.
         */
        MdcDialog.prototype._attachDialogContent = /**
         * Attaches the user-provided component to the already-created MdcDialogPortal.
         * @private
         * @template T
         * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
         *     or a TemplateRef to instantiate as the content.
         * @param {?} dialogContainer Reference to the wrapping MdcDialogPortal.
         * @param {?} overlayRef Reference to the overlay in which the dialog resides.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to the MdcDialogRef that should be returned to the user.
         */
        function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
            // Create a reference to the dialog we're creating in order to give the user a handle
            // to modify and close it.
            /** @type {?} */
            var dialogRef = new MdcDialogRef(overlayRef, dialogContainer, config.id);
            if (componentOrTemplateRef instanceof core.TemplateRef) {
                dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, (/** @type {?} */ (null)), (/** @type {?} */ ({ $implicit: config.data, dialogRef: dialogRef }))));
            }
            else {
                /** @type {?} */
                var injector = this._createInjector(config, dialogRef, dialogContainer);
                /** @type {?} */
                var contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, undefined, injector));
                dialogRef.componentInstance = contentRef.instance;
            }
            return dialogRef;
        };
        /**
         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
         * of a dialog to close itself and, optionally, to return a value.
         * @param config Config object that is used to construct the dialog.
         * @param dialogRef Reference to the dialog.
         * @param container Dialog container element that wraps all of the contents.
         * @returns The custom injector that can be used inside the dialog.
         */
        /**
         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
         * of a dialog to close itself and, optionally, to return a value.
         * @private
         * @template T
         * @param {?} config Config object that is used to construct the dialog.
         * @param {?} dialogRef Reference to the dialog.
         * @param {?} portalContainer
         * @return {?} The custom injector that can be used inside the dialog.
         */
        MdcDialog.prototype._createInjector = /**
         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
         * of a dialog to close itself and, optionally, to return a value.
         * @private
         * @template T
         * @param {?} config Config object that is used to construct the dialog.
         * @param {?} dialogRef Reference to the dialog.
         * @param {?} portalContainer
         * @return {?} The custom injector that can be used inside the dialog.
         */
        function (config, dialogRef, portalContainer) {
            /** @type {?} */
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            // The MdcDialogPortal is injected in the portal as the MdcDialogPortal and the dialog's
            // content are created out of the same ViewContainerRef and as such, are siblings for injector
            // purposes. To allow the hierarchy that is expected, the MdcDialogPortal is explicitly
            // added to the injection tokens.
            /** @type {?} */
            var injectionTokens = new WeakMap([
                [MdcDialogPortal, portalContainer],
                [MDC_DIALOG_DATA, config.data],
                [MdcDialogRef, dialogRef]
            ]);
            return new PortalInjector(userInjector || this._injector, injectionTokens);
        };
        /**
         * Removes a dialog from the array of open dialogs.
         * @param dialogRef Dialog to be removed.
         */
        /**
         * Removes a dialog from the array of open dialogs.
         * @private
         * @param {?} dialogRef Dialog to be removed.
         * @return {?}
         */
        MdcDialog.prototype._removeOpenDialog = /**
         * Removes a dialog from the array of open dialogs.
         * @private
         * @param {?} dialogRef Dialog to be removed.
         * @return {?}
         */
        function (dialogRef) {
            /** @type {?} */
            var index = this.openDialogs.indexOf(dialogRef);
            if (index > -1) {
                this.openDialogs.splice(index, 1);
                // If all the dialogs were closed, remove/restore the `aria-hidden`
                // to a the siblings and emit to the `afterAllClosed` stream.
                if (!this.openDialogs.length) {
                    this._ariaHiddenElements.forEach((/**
                     * @param {?} previousValue
                     * @param {?} element
                     * @return {?}
                     */
                    function (previousValue, element) {
                        if (previousValue) {
                            element.setAttribute('aria-hidden', previousValue);
                        }
                        else {
                            element.removeAttribute('aria-hidden');
                        }
                    }));
                    this._ariaHiddenElements.clear();
                    this._afterAllClosed.next();
                }
            }
        };
        /** Closes all of the dialogs in an array. */
        /**
         * Closes all of the dialogs in an array.
         * @private
         * @param {?} dialogs
         * @return {?}
         */
        MdcDialog.prototype._closeDialogs = /**
         * Closes all of the dialogs in an array.
         * @private
         * @param {?} dialogs
         * @return {?}
         */
        function (dialogs) {
            /** @type {?} */
            var i = dialogs.length;
            while (i--) {
                // The `_openDialogs` property isn't updated after close until the rxjs subscription
                // runs on the next microtask, in addition to modifying the array as we're going
                // through it. We loop through all of them and call close without assuming that
                // they'll be removed from the list instantaneously.
                dialogs[i].close();
            }
        };
        MdcDialog.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MdcDialog.ctorParameters = function () { return [
            { type: Overlay },
            { type: core.Injector },
            { type: MdcDialogConfig, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_DIALOG_DEFAULT_OPTIONS,] }] },
            { type: MdcDialog, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
        ]; };
        return MdcDialog;
    }());
    /**
     * Applies default options to the dialog config.
     * @param {?=} config Config to be modified.
     * @param {?=} defaultOptions Default options provided.
     * @return {?} The new configuration object.
     */
    function _applyConfigDefaults(config, defaultOptions) {
        return _assign({}, defaultOptions, config);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DIALOG_DECLARATIONS = [
        MdcDialogAction,
        MdcDialogActions,
        MdcDialogButton,
        MdcDialogComponent,
        MdcDialogContainer,
        MdcDialogPortal,
        MdcDialogContent,
        MdcDialogScrim,
        MdcDialogSurface,
        MdcDialogSurface,
        MdcDialogTitle
    ];
    var MdcDialogModule = /** @class */ (function () {
        function MdcDialogModule() {
        }
        MdcDialogModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            OverlayModule,
                            PortalModule
                        ],
                        exports: DIALOG_DECLARATIONS,
                        declarations: DIALOG_DECLARATIONS,
                        providers: [MdcDialog],
                        entryComponents: [
                            MdcDialogPortal,
                            MdcDialogComponent
                        ]
                    },] },
        ];
        return MdcDialogModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Change event that is fired whenever the selected state of an option changes.
     */
    var   /**
     * Change event that is fired whenever the selected state of an option changes.
     */
    MdcListSelectionChange = /** @class */ (function () {
        function MdcListSelectionChange(source) {
            this.source = source;
        }
        return MdcListSelectionChange;
    }());
    /**
     * Injection token used to provide the parent MdcList component to MdcListItem.
     * @type {?}
     */
    var MDC_LIST_PARENT_COMPONENT = new core.InjectionToken('MDC_LIST_PARENT_COMPONENT');
    /** @type {?} */
    var uniqueIdCounter = 0;
    var MdcListItemGraphic = /** @class */ (function () {
        function MdcListItemGraphic(elementRef) {
            this.elementRef = elementRef;
        }
        MdcListItemGraphic.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListItemGraphic], mdc-list-item-graphic',
                        exportAs: 'mdcListItemGraphic',
                        host: {
                            'role': 'presentation',
                            'class': 'mdc-list-item__graphic',
                            '[attr.aria-hidden]': 'true'
                        }
                    },] },
        ];
        /** @nocollapse */
        MdcListItemGraphic.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcListItemGraphic;
    }());
    var MdcListItemMeta = /** @class */ (function () {
        function MdcListItemMeta(elementRef) {
            this.elementRef = elementRef;
        }
        MdcListItemMeta.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListItemMeta], mdc-list-item-meta',
                        exportAs: 'mdcListItemMeta',
                        host: { 'class': 'mdc-list-item__meta' }
                    },] },
        ];
        /** @nocollapse */
        MdcListItemMeta.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcListItemMeta;
    }());
    var MdcListItemText = /** @class */ (function () {
        function MdcListItemText(elementRef) {
            this.elementRef = elementRef;
        }
        MdcListItemText.decorators = [
            { type: core.Component, args: [{selector: '[mdcListItemText], mdc-list-item-text',
                        exportAs: 'mdcListItemText',
                        host: { 'class': 'mdc-list-item__text' },
                        template: "\n  <ng-container>\n    <span class=\"mdc-list-item__primary-text\"><ng-content></ng-content></span>\n    <span class=\"mdc-list-item__secondary-text\" *ngIf=\"secondaryText\">{{secondaryText}}</span>\n  </ng-container>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcListItemText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListItemText.propDecorators = {
            secondaryText: [{ type: core.Input }]
        };
        return MdcListItemText;
    }());
    var MdcListItemSecondary = /** @class */ (function () {
        function MdcListItemSecondary(elementRef) {
            this.elementRef = elementRef;
        }
        MdcListItemSecondary.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListItemSecondary], mdc-list-item-secondary',
                        exportAs: 'mdcListItemSecondary',
                        host: { 'class': 'mdc-list-item__secondary-text' }
                    },] },
        ];
        /** @nocollapse */
        MdcListItemSecondary.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcListItemSecondary;
    }());
    var MdcListItem = /** @class */ (function () {
        function MdcListItem(ripple, _changeDetectorRef, elementRef, _parent) {
            this.ripple = ripple;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._parent = _parent;
            this._id = "mdc-list-item-" + uniqueIdCounter++;
            this.tabIndex = -1;
            this._selected = false;
            this._activated = false;
            this._disabled = false;
            this.selectionChange = new core.EventEmitter();
        }
        Object.defineProperty(MdcListItem.prototype, "id", {
            /** The unique ID of the list item. */
            get: /**
             * The unique ID of the list item.
             * @return {?}
             */
            function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcListItem.prototype, "selected", {
            /** Whether the list item is selected. */
            get: /**
             * Whether the list item is selected.
             * @return {?}
             */
            function () { return this._selected; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._selected) {
                    this._selected = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcListItem.prototype, "activated", {
            /** Whether the list item is activated. */
            get: /**
             * Whether the list item is activated.
             * @return {?}
             */
            function () { return this._activated; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._activated) {
                    this._activated = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcListItem.prototype, "disabled", {
            /** Whether the list item is disabled. */
            get: /**
             * Whether the list item is disabled.
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._disabled) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcListItem.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._initRipple();
        };
        /**
         * @return {?}
         */
        MdcListItem.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
        };
        /**
         * @private
         * @return {?}
         */
        MdcListItem.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.ripple.init({
                surface: this.elementRef.nativeElement
            }, Object.assign(this.ripple.createAdapter(), {
                isSurfaceDisabled: (/**
                 * @return {?}
                 */
                function () { return _this._disabled || _this._parent.disableRipple; })
            }));
        };
        /**
         * @return {?}
         */
        MdcListItem.prototype.focus = /**
         * @return {?}
         */
        function () {
            this.getListItemElement().focus();
        };
        /**
         * @param {?} role
         * @return {?}
         */
        MdcListItem.prototype.setRole = /**
         * @param {?} role
         * @return {?}
         */
        function (role) {
            this.getListItemElement().setAttribute('role', role);
        };
        /**
         * @return {?}
         */
        MdcListItem.prototype.getListItemElement = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcListItem.prototype._onKeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (evt.keyCode === ENTER || evt.keyCode === SPACE) {
                this._emitChangeEvent();
            }
        };
        /** Emits a change event if the selected state of an option changed. */
        /**
         * Emits a change event if the selected state of an option changed.
         * @return {?}
         */
        MdcListItem.prototype._emitChangeEvent = /**
         * Emits a change event if the selected state of an option changed.
         * @return {?}
         */
        function () {
            if (this._disabled) {
                return;
            }
            this.selectionChange.emit(new MdcListSelectionChange(this));
        };
        MdcListItem.decorators = [
            { type: core.Component, args: [{selector: 'mdc-list-item, a[mdc-list-item]',
                        exportAs: 'mdcListItem',
                        host: {
                            'role': 'listitem',
                            '[id]': 'id',
                            '[tabIndex]': 'tabIndex',
                            'class': 'mdc-list-item',
                            '[class.mdc-list-item--selected]': 'selected',
                            '[class.mdc-list-item--activated]': 'activated',
                            '[class.mdc-list-item--disabled]': 'disabled',
                            '(click)': '_emitChangeEvent()',
                            '(keydown)': '_onKeydown($event)'
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcListItem.ctorParameters = function () { return [
            { type: MdcRipple },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_LIST_PARENT_COMPONENT,] }] }
        ]; };
        MdcListItem.propDecorators = {
            value: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            activated: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            selectionChange: [{ type: core.Output }]
        };
        return MdcListItem;
    }());

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$5 = {
      ROOT: 'mdc-list',
      LIST_ITEM_CLASS: 'mdc-list-item',
      LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
      LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated'
    };
    /** @enum {string} */

    var strings$5 = {
      ARIA_ORIENTATION: 'aria-orientation',
      ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
      ARIA_SELECTED: 'aria-selected',
      ARIA_CHECKED: 'aria-checked',
      ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
      ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
      ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
      RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
      CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
      CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
      CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: ".".concat(cssClasses$5.LIST_ITEM_CLASS, " button:not(:disabled),\n  .").concat(cssClasses$5.LIST_ITEM_CLASS, " a"),
      FOCUSABLE_CHILD_ELEMENTS: ".".concat(cssClasses$5.LIST_ITEM_CLASS, " button:not(:disabled), .").concat(cssClasses$5.LIST_ITEM_CLASS, " a,\n  .").concat(cssClasses$5.LIST_ITEM_CLASS, " input[type=\"radio\"]:not(:disabled),\n  .").concat(cssClasses$5.LIST_ITEM_CLASS, " input[type=\"checkbox\"]:not(:disabled)"),
      ENABLED_ITEMS_SELECTOR: '.mdc-list-item:not(.mdc-list-item--disabled)',
      ACTION_EVENT: 'MDCList:action'
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {boolean}
     */


    function matches$2(element, selector) {
      var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      return nativeMatches.call(element, selector);
    }

    function _classCallCheck$5(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$5(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$5(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$5(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$5(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$5(subClass, superClass);
    }

    function _getPrototypeOf$5(o) {
      _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$5(o);
    }

    function _setPrototypeOf$5(o, p) {
      _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$5(o, p);
    }

    function _assertThisInitialized$5(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$5(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$5(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$5 =
    /*#__PURE__*/
    function () {
      _createClass$5(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$5(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$5(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$5 =
    /*#__PURE__*/
    function () {
      _createClass$5(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$5());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$5(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$5(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC List. Provides an interface for managing focus.
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCListAdapter =
    /*#__PURE__*/
    function () {
      function MDCListAdapter() {
        _classCallCheck$5(this, MDCListAdapter);
      }

      _createClass$5(MDCListAdapter, [{
        key: "getListItemCount",

        /** @return {number} */
        value: function getListItemCount() {}
        /**
         * @return {number} */

      }, {
        key: "getFocusedElementIndex",
        value: function getFocusedElementIndex() {}
        /**
         * @param {number} index
         * @param {string} attribute
         * @param {string} value
         */

      }, {
        key: "setAttributeForElementIndex",
        value: function setAttributeForElementIndex(index, attribute, value) {}
        /**
         * @param {number} index
         * @param {string} attribute
         */

      }, {
        key: "removeAttributeForElementIndex",
        value: function removeAttributeForElementIndex(index, attribute) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "addClassForElementIndex",
        value: function addClassForElementIndex(index, className) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "removeClassForElementIndex",
        value: function removeClassForElementIndex(index, className) {}
        /**
         * Focuses list item at the index specified.
         * @param {number} index
         */

      }, {
        key: "focusItemAtIndex",
        value: function focusItemAtIndex(index) {}
        /**
         * Sets the tabindex to the value specified for all button/a element children of
         * the list item at the index specified.
         * @param {number} listItemIndex
         * @param {number} tabIndexValue
         */

      }, {
        key: "setTabIndexForListItemChildren",
        value: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if radio button is present at given list item index.
         */

      }, {
        key: "hasRadioAtIndex",
        value: function hasRadioAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox is present at given list item index.
         */

      }, {
        key: "hasCheckboxAtIndex",
        value: function hasCheckboxAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox inside a list item is checked.
         */

      }, {
        key: "isCheckboxCheckedAtIndex",
        value: function isCheckboxCheckedAtIndex(index) {}
        /**
         * Sets the checked status of checkbox or radio at given list item index.
         * @param {number} index
         * @param {boolean} isChecked
         */

      }, {
        key: "setCheckedCheckboxOrRadioAtIndex",
        value: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {}
        /**
         * Notifies user action on list item.
         */

      }, {
        key: "notifyAction",
        value: function notifyAction(index) {}
        /**
         * @return {boolean} Returns true when the current focused element is inside list root.
         */

      }, {
        key: "isFocusInsideList",
        value: function isFocusInsideList() {}
      }]);

      return MDCListAdapter;
    }();

    var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];

    var MDCListFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$5(MDCListFoundation, _MDCFoundation);

      _createClass$5(MDCListFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$5;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$5;
        }
        /**
         * {@see MDCListAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCListAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCListAdapter} */
            {
              getListItemCount: function getListItemCount() {},
              getFocusedElementIndex: function getFocusedElementIndex() {},
              setAttributeForElementIndex: function setAttributeForElementIndex() {},
              removeAttributeForElementIndex: function removeAttributeForElementIndex() {},
              addClassForElementIndex: function addClassForElementIndex() {},
              removeClassForElementIndex: function removeClassForElementIndex() {},
              focusItemAtIndex: function focusItemAtIndex() {},
              setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {},
              hasRadioAtIndex: function hasRadioAtIndex() {},
              hasCheckboxAtIndex: function hasCheckboxAtIndex() {},
              isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {},
              setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {},
              notifyAction: function notifyAction() {},
              isFocusInsideList: function isFocusInsideList() {}
            }
          );
        }
        /**
         * @param {!MDCListAdapter=} adapter
         */

      }]);

      function MDCListFoundation(adapter) {
        var _this;

        _classCallCheck$5(this, MDCListFoundation);

        _this = _possibleConstructorReturn$5(this, _getPrototypeOf$5(MDCListFoundation).call(this, Object.assign(MDCListFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.wrapFocus_ = false;
        /** @private {boolean} */

        _this.isVertical_ = true;
        /** @private {boolean} */

        _this.isSingleSelectionList_ = false;
        /** @private {!Index} */

        _this.selectedIndex_ = -1;
        /** @private {number} */

        _this.focusedItemIndex_ = -1;
        /** @private {boolean} */

        _this.useActivatedClass_ = false;
        /** @private {boolean} */

        _this.isCheckboxList_ = false;
        /** @private {boolean} */

        _this.isRadioList_ = false;
        return _this;
      }

      _createClass$5(MDCListFoundation, [{
        key: "layout",
        value: function layout() {
          if (this.adapter_.getListItemCount() === 0) return;

          if (this.adapter_.hasCheckboxAtIndex(0)) {
            this.isCheckboxList_ = true;
          } else if (this.adapter_.hasRadioAtIndex(0)) {
            this.isRadioList_ = true;
          }
        }
        /**
         * Sets the private wrapFocus_ variable.
         * @param {boolean} value
         */

      }, {
        key: "setWrapFocus",
        value: function setWrapFocus(value) {
          this.wrapFocus_ = value;
        }
        /**
         * Sets the isVertical_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setVerticalOrientation",
        value: function setVerticalOrientation(value) {
          this.isVertical_ = value;
        }
        /**
         * Sets the isSingleSelectionList_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setSingleSelection",
        value: function setSingleSelection(value) {
          this.isSingleSelectionList_ = value;
        }
        /**
         * Sets the useActivatedClass_ private variable.
         * @param {boolean} useActivated
         */

      }, {
        key: "setUseActivatedClass",
        value: function setUseActivatedClass(useActivated) {
          this.useActivatedClass_ = useActivated;
        }
        /** @return {!Index} */

      }, {
        key: "getSelectedIndex",
        value: function getSelectedIndex() {
          return this.selectedIndex_;
        }
        /** @param {!Index} index */

      }, {
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {
          if (!this.isIndexValid_(index)) return;

          if (this.isCheckboxList_) {
            this.setCheckboxAtIndex_(
            /** @type {!Array<number>} */
            index);
          } else if (this.isRadioList_) {
            this.setRadioAtIndex_(
            /** @type {number} */
            index);
          } else {
            this.setSingleSelectionAtIndex_(
            /** @type {number} */
            index);
          }
        }
        /**
         * Focus in handler for the list items.
         * @param evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusIn",
        value: function handleFocusIn(evt, listItemIndex) {
          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, 0);
          }
        }
        /**
         * Focus out handler for the list items.
         * @param {Event} evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusOut",
        value: function handleFocusOut(evt, listItemIndex) {
          var _this2 = this;

          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, -1);
          }
          /**
           * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
           * is moved to next element.
           */


          setTimeout(function () {
            if (!_this2.adapter_.isFocusInsideList()) {
              _this2.setTabindexToFirstSelectedItem_();
            }
          }, 0);
        }
        /**
         * Key handler for the list.
         * @param {Event} evt
         * @param {boolean} isRootListItem
         * @param {number} listItemIndex
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt, isRootListItem, listItemIndex) {
          var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
          var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
          var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
          var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
          var isHome = evt.key === 'Home' || evt.keyCode === 36;
          var isEnd = evt.key === 'End' || evt.keyCode === 35;
          var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
          var isSpace = evt.key === 'Space' || evt.keyCode === 32;
          var currentIndex = this.adapter_.getFocusedElementIndex();
          var nextIndex = -1;

          if (currentIndex === -1) {
            currentIndex = listItemIndex;

            if (currentIndex < 0) {
              // If this event doesn't have a mdc-list-item ancestor from the
              // current list (not from a sublist), return early.
              return;
            }
          }

          if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusNextElement(currentIndex);
          } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusPrevElement(currentIndex);
          } else if (isHome) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusFirstElement();
          } else if (isEnd) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusLastElement();
          } else if (isEnter || isSpace) {
            if (isRootListItem) {
              // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
              if (evt.target.tagName === 'A' && isEnter) return;
              this.preventDefaultEvent_(evt);

              if (this.isSelectableList_()) {
                this.setSelectedIndexOnAction_(currentIndex);
              }

              this.adapter_.notifyAction(currentIndex);
            }
          }

          this.focusedItemIndex_ = currentIndex;

          if (nextIndex >= 0) {
            this.setTabindexAtIndex_(nextIndex);
            this.focusedItemIndex_ = nextIndex;
          }
        }
        /**
         * Click handler for the list.
         * @param {number} index
         * @param {boolean} toggleCheckbox
         */

      }, {
        key: "handleClick",
        value: function handleClick(index, toggleCheckbox) {
          if (index === -1) return;

          if (this.isSelectableList_()) {
            this.setSelectedIndexOnAction_(index, toggleCheckbox);
          }

          this.adapter_.notifyAction(index);
          this.setTabindexAtIndex_(index);
          this.focusedItemIndex_ = index;
        }
        /**
         * Ensures that preventDefault is only called if the containing element doesn't
         * consume the event, and it will cause an unintended scroll.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "preventDefaultEvent_",
        value: function preventDefaultEvent_(evt) {
          var tagName = "".concat(evt.target.tagName).toLowerCase();

          if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
            evt.preventDefault();
          }
        }
        /**
         * Focuses the next element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusNextElement",
        value: function focusNextElement(index) {
          var count = this.adapter_.getListItemCount();
          var nextIndex = index + 1;

          if (nextIndex >= count) {
            if (this.wrapFocus_) {
              nextIndex = 0;
            } else {
              // Return early because last item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(nextIndex);
          return nextIndex;
        }
        /**
         * Focuses the previous element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusPrevElement",
        value: function focusPrevElement(index) {
          var prevIndex = index - 1;

          if (prevIndex < 0) {
            if (this.wrapFocus_) {
              prevIndex = this.adapter_.getListItemCount() - 1;
            } else {
              // Return early because first item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(prevIndex);
          return prevIndex;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {
          this.adapter_.focusItemAtIndex(0);
          return 0;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusLastElement",
        value: function focusLastElement() {
          var lastIndex = this.adapter_.getListItemCount() - 1;
          this.adapter_.focusItemAtIndex(lastIndex);
          return lastIndex;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setSingleSelectionAtIndex_",
        value: function setSingleSelectionAtIndex_(index) {
          var selectedClassName = cssClasses$5.LIST_ITEM_SELECTED_CLASS;

          if (this.useActivatedClass_) {
            selectedClassName = cssClasses$5.LIST_ITEM_ACTIVATED_CLASS;
          }

          if (this.selectedIndex_ >= 0 && this.selectedIndex_ !== index) {
            this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$5.ARIA_SELECTED, 'false');
          }

          this.adapter_.addClassForElementIndex(index, selectedClassName);
          this.adapter_.setAttributeForElementIndex(index, strings$5.ARIA_SELECTED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
         * @param {number} index
         * @private
         */

      }, {
        key: "setRadioAtIndex_",
        value: function setRadioAtIndex_(index) {
          this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);

          if (this.selectedIndex_ >= 0) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$5.ARIA_CHECKED, 'false');
          }

          this.adapter_.setAttributeForElementIndex(index, strings$5.ARIA_CHECKED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * @param {!Array<number>} index
         * @private
         */

      }, {
        key: "setCheckboxAtIndex_",
        value: function setCheckboxAtIndex_(index) {
          for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
            var isChecked = false;

            if (index.indexOf(i) >= 0) {
              isChecked = true;
            }

            this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
            this.adapter_.setAttributeForElementIndex(i, strings$5.ARIA_CHECKED, isChecked ? 'true' : 'false');
          }

          this.selectedIndex_ = index;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setTabindexAtIndex_",
        value: function setTabindexAtIndex_(index) {
          if (this.focusedItemIndex_ === -1 && index !== 0) {
            // If no list item was selected set first list item's tabindex to -1.
            // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
            this.adapter_.setAttributeForElementIndex(0, 'tabindex', -1);
          } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
            this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', -1);
          }

          this.adapter_.setAttributeForElementIndex(index, 'tabindex', 0);
        }
        /**
         * @return {boolean} Return true if it is single selectin list, checkbox list or radio list.
         * @private
         */

      }, {
        key: "isSelectableList_",
        value: function isSelectableList_() {
          return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
        }
        /** @private */

      }, {
        key: "setTabindexToFirstSelectedItem_",
        value: function setTabindexToFirstSelectedItem_() {
          var targetIndex = 0;

          if (this.isSelectableList_()) {
            if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== -1) {
              targetIndex = this.selectedIndex_;
            } else if (this.selectedIndex_ instanceof Array && this.selectedIndex_.length > 0) {
              targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
                return Math.min(currentIndex, minIndex);
              });
            }
          }

          this.setTabindexAtIndex_(targetIndex);
        }
        /**
         * @param {!Index} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexValid_",
        value: function isIndexValid_(index) {
          var _this3 = this;

          if (index instanceof Array) {
            if (!this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
            }

            if (index.length === 0) {
              return true;
            } else {
              return index.some(function (i) {
                return _this3.isIndexInRange_(i);
              });
            }
          } else if (typeof index === 'number') {
            if (this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
            }

            return this.isIndexInRange_(index);
          } else {
            return false;
          }
        }
        /**
         * @param {number} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexInRange_",
        value: function isIndexInRange_(index) {
          var listSize = this.adapter_.getListItemCount();
          return index >= 0 && index < listSize;
        }
        /**
         * @param {number} index
         * @param {boolean=} toggleCheckbox
         * @private
         */

      }, {
        key: "setSelectedIndexOnAction_",
        value: function setSelectedIndexOnAction_(index) {
          var toggleCheckbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (this.isCheckboxList_) {
            this.toggleCheckboxAtIndex_(index, toggleCheckbox);
          } else {
            this.setSelectedIndex(index);
          }
        }
        /**
         * @param {number} index
         * @param {boolean} toggleCheckbox
         * @private
         */

      }, {
        key: "toggleCheckboxAtIndex_",
        value: function toggleCheckboxAtIndex_(index, toggleCheckbox) {
          var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);

          if (toggleCheckbox) {
            isChecked = !isChecked;
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
          }

          this.adapter_.setAttributeForElementIndex(index, strings$5.ARIA_CHECKED, isChecked ? 'true' : 'false'); // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.

          if (this.selectedIndex_ === -1) {
            this.selectedIndex_ = [];
          }

          if (isChecked) {
            this.selectedIndex_.push(index);
          } else {
            this.selectedIndex_ = this.selectedIndex_.filter(function (i) {
              return i !== index;
            });
          }
        }
      }]);

      return MDCListFoundation;
    }(MDCFoundation$5);

    /**
     * @extends MDCComponent<!MDCListFoundation>
     */

    var MDCList =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$5(MDCList, _MDCComponent);

      /** @param {...?} args */
      function MDCList() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$5(this, MDCList);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$5(this, (_getPrototypeOf2 = _getPrototypeOf$5(MDCList)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleClick_;
        /** @private {!Function} */

        _this.focusInEventListener_;
        /** @private {!Function} */

        _this.focusOutEventListener_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCList}
       */


      _createClass$5(MDCList, [{
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener('click', this.handleClick_);
          this.root_.removeEventListener('focusin', this.focusInEventListener_);
          this.root_.removeEventListener('focusout', this.focusOutEventListener_);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.handleClick_ = this.handleClickEvent_.bind(this);
          this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
          this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
          this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener('focusin', this.focusInEventListener_);
          this.root_.addEventListener('focusout', this.focusOutEventListener_);
          this.root_.addEventListener('click', this.handleClick_);
          this.layout();
          this.initializeListType();
        }
      }, {
        key: "layout",
        value: function layout() {
          var direction = this.root_.getAttribute(strings$5.ARIA_ORIENTATION);
          this.vertical = direction !== strings$5.ARIA_ORIENTATION_HORIZONTAL; // List items need to have at least tabindex=-1 to be focusable.

          [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
            ele.setAttribute('tabindex', -1);
          }); // Child button/a elements are not tabbable until the list item is focused.

          [].slice.call(this.root_.querySelectorAll(strings$5.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
            return ele.setAttribute('tabindex', -1);
          });
          this.foundation_.layout();
        }
        /**
         * Used to figure out which list item this event is targetting. Or returns -1 if
         * there is no list item
         * @param {Event} evt
         * @private
         */

      }, {
        key: "getListItemIndex_",
        value: function getListItemIndex_(evt) {
          var eventTarget =
          /** @type {HTMLElement} */
          evt.target;
          var index = -1; // Find the first ancestor that is a list item or the list.

          while (!eventTarget.classList.contains(cssClasses$5.LIST_ITEM_CLASS) && !eventTarget.classList.contains(cssClasses$5.ROOT)) {
            eventTarget = eventTarget.parentElement;
          } // Get the index of the element if it is a list item.


          if (eventTarget.classList.contains(cssClasses$5.LIST_ITEM_CLASS)) {
            index = this.listElements.indexOf(eventTarget);
          }

          return index;
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusInEvent_",
        value: function handleFocusInEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusIn(evt, index);
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusOutEvent_",
        value: function handleFocusOutEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusOut(evt, index);
        }
        /**
         * Used to figure out which element was focused when keydown event occurred before sending the event to the
         * foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleKeydownEvent_",
        value: function handleKeydownEvent_(evt) {
          var index = this.getListItemIndex_(evt);

          if (index >= 0) {
            this.foundation_.handleKeydown(evt, evt.target.classList.contains(cssClasses$5.LIST_ITEM_CLASS), index);
          }
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleClickEvent_",
        value: function handleClickEvent_(evt) {
          var index = this.getListItemIndex_(evt); // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.

          var toggleCheckbox = !matches$2(
          /** @type {!Element} */
          evt.target, strings$5.CHECKBOX_RADIO_SELECTOR);
          this.foundation_.handleClick(index, toggleCheckbox);
        }
        /**
         * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
         */

      }, {
        key: "initializeListType",
        value: function initializeListType() {
          var _this2 = this;

          var checkboxListItems = this.root_.querySelectorAll(strings$5.ARIA_ROLE_CHECKBOX_SELECTOR);
          var singleSelectedListItem = this.root_.querySelector(".".concat(cssClasses$5.LIST_ITEM_ACTIVATED_CLASS, ",\n        .").concat(cssClasses$5.LIST_ITEM_SELECTED_CLASS));
          var radioSelectedListItem = this.root_.querySelector(strings$5.ARIA_CHECKED_RADIO_SELECTOR);

          if (checkboxListItems.length) {
            var preselectedItems = this.root_.querySelectorAll(strings$5.ARIA_CHECKED_CHECKBOX_SELECTOR);
            this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
              return _this2.listElements.indexOf(listItem);
            });
          } else if (singleSelectedListItem) {
            if (singleSelectedListItem.classList.contains(cssClasses$5.LIST_ITEM_ACTIVATED_CLASS)) {
              this.foundation_.setUseActivatedClass(true);
            }

            this.singleSelection = true;
            this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
          } else if (radioSelectedListItem) {
            this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
          }
        }
        /** @param {boolean} value */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCListFoundation} */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCListFoundation(
          /** @type {!MDCListAdapter} */
          Object.assign({
            getListItemCount: function getListItemCount() {
              return _this3.listElements.length;
            },
            getFocusedElementIndex: function getFocusedElementIndex() {
              return _this3.listElements.indexOf(document.activeElement);
            },
            setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
              var element = _this3.listElements[index];

              if (element) {
                element.setAttribute(attr, value);
              }
            },
            removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
              var element = _this3.listElements[index];

              if (element) {
                element.removeAttribute(attr);
              }
            },
            addClassForElementIndex: function addClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.add(className);
              }
            },
            removeClassForElementIndex: function removeClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.remove(className);
              }
            },
            focusItemAtIndex: function focusItemAtIndex(index) {
              var element = _this3.listElements[index];

              if (element) {
                element.focus();
              }
            },
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
              var element = _this3.listElements[listItemIndex];
              var listItemChildren = [].slice.call(element.querySelectorAll(strings$5.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
              listItemChildren.forEach(function (ele) {
                return ele.setAttribute('tabindex', tabIndexValue);
              });
            },
            hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$5.CHECKBOX_SELECTOR);
            },
            hasRadioAtIndex: function hasRadioAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$5.RADIO_SELECTOR);
            },
            isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$5.CHECKBOX_SELECTOR);
              return toggleEl.checked;
            },
            setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$5.CHECKBOX_RADIO_SELECTOR);
              toggleEl.checked = isChecked;
              var event = document.createEvent('Event');
              event.initEvent('change', true, true);
              toggleEl.dispatchEvent(event);
            },
            notifyAction: function notifyAction(index) {
              _this3.emit(strings$5.ACTION_EVENT, index,
              /** shouldBubble */
              true);
            },
            isFocusInsideList: function isFocusInsideList() {
              return _this3.root_.contains(document.activeElement);
            }
          }));
        }
      }, {
        key: "vertical",
        set: function set(value) {
          this.foundation_.setVerticalOrientation(value);
        }
        /** @return Array<!Element>*/

      }, {
        key: "listElements",
        get: function get() {
          return [].slice.call(this.root_.querySelectorAll(strings$5.ENABLED_ITEMS_SELECTOR));
        }
        /** @param {boolean} value */

      }, {
        key: "wrapFocus",
        set: function set(value) {
          this.foundation_.setWrapFocus(value);
        }
        /** @param {boolean} isSingleSelectionList */

      }, {
        key: "singleSelection",
        set: function set(isSingleSelectionList) {
          this.foundation_.setSingleSelection(isSingleSelectionList);
        }
        /** @return {!Index} */

      }, {
        key: "selectedIndex",
        get: function get() {
          return this.foundation_.getSelectedIndex();
        }
        /** @param {!Index} index */
        ,
        set: function set(index) {
          this.foundation_.setSelectedIndex(index);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCList(root);
        }
      }]);

      return MDCList;
    }(MDCComponent$5);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Change event that is being fired whenever the selected state of an option changes.
     */
    var   /**
     * Change event that is being fired whenever the selected state of an option changes.
     */
    MdcListItemChange = /** @class */ (function () {
        function MdcListItemChange(source, option) {
            this.source = source;
            this.option = option;
        }
        return MdcListItemChange;
    }());
    var MdcListGroup = /** @class */ (function () {
        function MdcListGroup(elementRef) {
            this.elementRef = elementRef;
        }
        MdcListGroup.decorators = [
            { type: core.Component, args: [{selector: '[mdcListGroup], mdc-list-group',
                        exportAs: 'mdcListGroup',
                        host: { 'class': 'mdc-list-group' },
                        template: "\n  <h3 class=\"mdc-list-group__subheader\" *ngIf=\"subheader\">{{subheader}}</h3>\n  <ng-content></ng-content>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcListGroup.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListGroup.propDecorators = {
            subheader: [{ type: core.Input }]
        };
        return MdcListGroup;
    }());
    var MdcListGroupSubheader = /** @class */ (function () {
        function MdcListGroupSubheader(elementRef) {
            this.elementRef = elementRef;
        }
        MdcListGroupSubheader.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListGroupSubheader], mdc-list-group-subheader',
                        exportAs: 'mdcListGroupSubheader',
                        host: { 'class': 'mdc-list-group__subheader' }
                    },] },
        ];
        /** @nocollapse */
        MdcListGroupSubheader.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcListGroupSubheader;
    }());
    var MdcList = /** @class */ (function () {
        function MdcList(_platform, _changeDetectorRef, elementRef) {
            this._platform = _platform;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._twoLine = false;
            this._dense = false;
            this._border = false;
            this._avatar = false;
            this._interactive = true;
            this._disableRipple = false;
            this._useActivatedClass = false;
            this._useSelectedClass = false;
            this._verticalOrientation = true;
            this._wrapFocus = false;
            /**
             * Emits a change event whenever the selected state of an option changes.
             */
            this.selectionChange = new core.EventEmitter();
            /**
             * Emits an event for keyboard and mouse actions.
             */
            this.actionEvent = new core.EventEmitter();
            /**
             * Subscription to changes in list items.
             */
            this._changeSubscription = null;
            /**
             * Subscription to selection events in list items.
             */
            this.itemSelectionSubscription = null;
            this._foundation = new MDCListFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcList.prototype, "twoLine", {
            get: /**
             * @return {?}
             */
            function () { return this._twoLine; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._twoLine = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "dense", {
            get: /**
             * @return {?}
             */
            function () { return this._dense; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._dense = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "border", {
            get: /**
             * @return {?}
             */
            function () { return this._border; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._border = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "avatar", {
            get: /**
             * @return {?}
             */
            function () { return this._avatar; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._avatar = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "interactive", {
            get: /**
             * @return {?}
             */
            function () { return this._interactive; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._interactive) {
                    this._interactive = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "disableRipple", {
            get: /**
             * @return {?}
             */
            function () { return this._disableRipple; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._disableRipple) {
                    this._disableRipple = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "singleSelection", {
            get: /**
             * @return {?}
             */
            function () { return this._singleSelection; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== undefined) {
                    /** @type {?} */
                    var newValue = toBoolean(value);
                    if (newValue !== this._singleSelection) {
                        this._singleSelection = newValue;
                        this._foundation.setSingleSelection(this._singleSelection);
                        if (this.getSelectedIndex() > -1) {
                            this.setSelectedIndex(this.getSelectedIndex());
                        }
                        this._changeDetectorRef.markForCheck();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "useActivatedClass", {
            get: /**
             * @return {?}
             */
            function () { return this._useActivatedClass; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._useActivatedClass = toBoolean(value);
                this._foundation.setUseActivatedClass(this._useActivatedClass);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "useSelectedClass", {
            get: /**
             * @return {?}
             */
            function () { return this._useSelectedClass; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._useSelectedClass = toBoolean(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "verticalOrientation", {
            get: /**
             * @return {?}
             */
            function () { return this._verticalOrientation; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._verticalOrientation = toBoolean(value);
                this._foundation.setVerticalOrientation(this._verticalOrientation);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "wrapFocus", {
            get: /**
             * @return {?}
             */
            function () { return this._wrapFocus; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._wrapFocus = toBoolean(value);
                this._foundation.setWrapFocus(this._wrapFocus);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "listItemSelections", {
            /** Combined stream of all of the list item selection events. */
            get: /**
             * Combined stream of all of the list item selection events.
             * @return {?}
             */
            function () {
                return rxjs.merge.apply(void 0, this.items.map((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return item.selectionChange; })));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcList.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                getListItemCount: (/**
                 * @return {?}
                 */
                function () { return _this.items.length; }),
                getFocusedElementIndex: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._platform.isBrowser && (/** @type {?} */ (document.activeElement))) {
                        return -1;
                    }
                    return _this.items.toArray().findIndex((/**
                     * @param {?} _
                     * @return {?}
                     */
                    function (_) { return _.getListItemElement() === (/** @type {?} */ (document.activeElement)); })) || -1;
                }),
                setAttributeForElementIndex: (/**
                 * @param {?} index
                 * @param {?} attr
                 * @param {?} value
                 * @return {?}
                 */
                function (index, attr, value) {
                    /** @type {?} */
                    var item = _this.getListItemByIndex(index);
                    if (item) {
                        item.getListItemElement().setAttribute(attr, value);
                    }
                }),
                removeAttributeForElementIndex: (/**
                 * @param {?} index
                 * @param {?} attr
                 * @return {?}
                 */
                function (index, attr) {
                    return _this.items.toArray()[index].getListItemElement().removeAttribute(attr);
                }),
                addClassForElementIndex: (/**
                 * @param {?} index
                 * @param {?} className
                 * @return {?}
                 */
                function (index, className) {
                    return _this.items.toArray()[index].getListItemElement().classList.add(className);
                }),
                removeClassForElementIndex: (/**
                 * @param {?} index
                 * @param {?} className
                 * @return {?}
                 */
                function (index, className) {
                    /** @type {?} */
                    var item = _this.getListItemByIndex(index);
                    if (item) {
                        item.getListItemElement().classList.remove(className);
                    }
                }),
                focusItemAtIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) { return _this.focusItemAtIndex(index); }),
                setTabIndexForListItemChildren: (/**
                 * @param {?} listItemIndex
                 * @param {?} tabIndexValue
                 * @return {?}
                 */
                function (listItemIndex, tabIndexValue) {
                    /** @type {?} */
                    var listItemChildren = [].slice.call(_this.items.toArray()[listItemIndex].getListItemElement()
                        .querySelectorAll(strings$5.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
                    listItemChildren.forEach((/**
                     * @param {?} ele
                     * @return {?}
                     */
                    function (ele) { return ele.setAttribute('tabindex', "" + tabIndexValue); }));
                }),
                hasCheckboxAtIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) {
                    /** @type {?} */
                    var listItem = _this.items.toArray()[index].getListItemElement();
                    return !!listItem.querySelector(strings$5.CHECKBOX_SELECTOR);
                }),
                hasRadioAtIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) {
                    /** @type {?} */
                    var listItem = _this.items.toArray()[index].getListItemElement();
                    return !!listItem.querySelector(strings$5.RADIO_SELECTOR);
                }),
                isCheckboxCheckedAtIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) {
                    /** @type {?} */
                    var listItem = _this.items.toArray()[index].getListItemElement();
                    /** @type {?} */
                    var toggleEl = listItem.querySelector(strings$5.CHECKBOX_SELECTOR);
                    return toggleEl.checked;
                }),
                setCheckedCheckboxOrRadioAtIndex: (/**
                 * @param {?} index
                 * @param {?} isChecked
                 * @return {?}
                 */
                function (index, isChecked) {
                    /** @type {?} */
                    var listItem = _this.items.toArray()[index].getListItemElement();
                    /** @type {?} */
                    var toggleEl = listItem.querySelector(strings$5.CHECKBOX_RADIO_SELECTOR);
                    toggleEl.checked = isChecked;
                    if (_this._platform.isBrowser) {
                        /** @type {?} */
                        var event_1 = document.createEvent('Event');
                        event_1.initEvent('change', true, true);
                        toggleEl.dispatchEvent(event_1);
                    }
                }),
                isFocusInsideList: (/**
                 * @return {?}
                 */
                function () { return _this._platform.isBrowser ?
                    _this.elementRef.nativeElement.contains(document.activeElement) : false; }),
                notifyAction: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) {
                    _this.actionEvent.emit({ index: index });
                })
            };
        };
        /**
         * @return {?}
         */
        MdcList.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            this._foundation.layout();
            // When list items change, re-subscribe
            this._changeSubscription = this.items.changes.pipe(operators.startWith(null))
                .subscribe((/**
             * @return {?}
             */
            function () {
                if (_this.items.length) {
                    _this._resetListItems();
                }
            }));
        };
        /**
         * @return {?}
         */
        MdcList.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._dropSubscriptions();
            if (this._changeSubscription) {
                this._changeSubscription.unsubscribe();
            }
            this._foundation.destroy();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcList.prototype.setSelectedIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.reset();
            this._foundation.setSelectedIndex(index);
            if (index === -1) {
                return;
            }
            /** @type {?} */
            var selectedItem = this.items.toArray()[index];
            if (selectedItem) {
                this._applySelectionState(selectedItem);
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcList.prototype.setSelectedValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.reset();
            if (value === null) {
                return;
            }
            /** @type {?} */
            var selectedItem = this.getListItemByValue(value);
            this._foundation.setSelectedIndex(this.getListItemIndexByValue(value));
            if (selectedItem) {
                this._applySelectionState(selectedItem);
            }
        };
        /**
         * @return {?}
         */
        MdcList.prototype.getSelectedItem = /**
         * @return {?}
         */
        function () {
            return this.items ? this.items.toArray().find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.selected || _.activated; })) : undefined;
        };
        /**
         * @return {?}
         */
        MdcList.prototype.getSelectedIndex = /**
         * @return {?}
         */
        function () {
            return this.items ? this.items.toArray().findIndex((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.selected || _.activated; })) : -1;
        };
        /**
         * @return {?}
         */
        MdcList.prototype.getSelectedValue = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var item = this.items ? this.items.find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.selected; })) : null;
            return item && item.value ? item.value : null;
        };
        /**
         * @return {?}
         */
        MdcList.prototype.getSelectedText = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var selectedItem = this.getSelectedItem();
            return selectedItem && selectedItem.getListItemElement().textContent || '';
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcList.prototype.getListItemByValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return this.items ? this.items.toArray().find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.value === value; })) : undefined;
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcList.prototype.getListItemByIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return this.items ? this.items.toArray()[index] : undefined;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcList.prototype.getListItemIndexByValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return this.items ? this.items.toArray().findIndex((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.value === value; })) : -1;
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcList.prototype.focusItemAtIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.items.toArray()[index].getListItemElement().focus();
        };
        /**
         * @return {?}
         */
        MdcList.prototype.focusFirstElement = /**
         * @return {?}
         */
        function () {
            return this._foundation.focusFirstElement();
        };
        /**
         * @return {?}
         */
        MdcList.prototype.focusLastElement = /**
         * @return {?}
         */
        function () {
            return this._foundation.focusLastElement();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcList.prototype.focusNextElement = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return this._foundation.focusNextElement(index);
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcList.prototype.focusPrevElement = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return this._foundation.focusPrevElement(index);
        };
        /**
         * @param {?} role
         * @return {?}
         */
        MdcList.prototype.setRole = /**
         * @param {?} role
         * @return {?}
         */
        function (role) {
            this._getHostElement().setAttribute('role', role);
        };
        /**
         * @return {?}
         */
        MdcList.prototype.reset = /**
         * @return {?}
         */
        function () {
            this.items.forEach((/**
             * @param {?} _
             * @return {?}
             */
            function (_) {
                _.selected = false;
                _.activated = false;
            }));
        };
        /**
         * @private
         * @param {?} item
         * @return {?}
         */
        MdcList.prototype._applySelectionState = /**
         * @private
         * @param {?} item
         * @return {?}
         */
        function (item) {
            if (this.useActivatedClass) {
                item.activated = true;
            }
            else if (this.useSelectedClass) {
                item.selected = true;
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcList.prototype._resetListItems = /**
         * @private
         * @return {?}
         */
        function () {
            this._dropSubscriptions();
            this._listenForListItemSelection();
        };
        /**
         * @private
         * @return {?}
         */
        MdcList.prototype._dropSubscriptions = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.itemSelectionSubscription) {
                this.itemSelectionSubscription.unsubscribe();
                this.itemSelectionSubscription = null;
            }
        };
        /** Listens to selected events on each list item. */
        /**
         * Listens to selected events on each list item.
         * @private
         * @return {?}
         */
        MdcList.prototype._listenForListItemSelection = /**
         * Listens to selected events on each list item.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.itemSelectionSubscription = this.listItemSelections.subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                if (_this.singleSelection) {
                    _this.items.filter((/**
                     * @param {?} _
                     * @return {?}
                     */
                    function (_) { return _.id !== event.source.id && (_.activated || _.selected); }))
                        .forEach((/**
                     * @param {?} _
                     * @return {?}
                     */
                    function (_) {
                        _.selected = false;
                        _.activated = false;
                    }));
                }
                _this._applySelectionState(event.source);
                if (!_this.singleSelection) {
                    event.source.ripple.handleBlur();
                }
                _this.selectionChange.emit(new MdcListItemChange(_this, event.source));
            }));
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype._onFocusIn = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var index = this._getListItemIndexByEvent(evt);
            this._foundation.handleFocusIn(evt, index);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype._onFocusOut = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var index = this._getListItemIndexByEvent(evt);
            if (index >= 0) {
                this._foundation.handleFocusOut(evt, index);
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype._onKeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var index = this._getListItemIndexByEvent(evt);
            if (index >= 0) {
                this._foundation.handleKeydown(evt, ((/** @type {?} */ (evt.target))).classList.contains(cssClasses$5.LIST_ITEM_CLASS), index);
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype._handleClickEvent = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var index = this._getListItemIndexByEvent(evt);
            /** @type {?} */
            var listItem = this._getListItemByEventTarget((/** @type {?} */ (evt.target)));
            if (listItem && listItem.disabled) {
                return;
            }
            // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.
            /** @type {?} */
            var toggleCheckbox = !matches$2((evt.target), strings$5.CHECKBOX_RADIO_SELECTOR);
            this._foundation.handleClick(index, toggleCheckbox);
        };
        /**
         * @private
         * @param {?} target
         * @return {?}
         */
        MdcList.prototype._getListItemByEventTarget = /**
         * @private
         * @param {?} target
         * @return {?}
         */
        function (target) {
            return this.items.toArray().find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.getListItemElement() === target; }));
        };
        /**
         * @private
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype._getListItemIndexByEvent = /**
         * @private
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            return this.items.toArray().findIndex((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.getListItemElement() === evt.target; }));
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcList.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcList.decorators = [
            { type: core.Component, args: [{selector: 'mdc-list',
                        exportAs: 'mdcList',
                        host: {
                            'role': 'list',
                            'class': 'mdc-list',
                            '[attr.aria-orientation]': 'verticalOrientation ? "vertical" : "horizontal"',
                            '[class.mdc-list--dense]': 'dense',
                            '[class.mdc-list--avatar-list]': 'avatar',
                            '[class.ngx-mdc-list--border]': 'border',
                            '[class.mdc-list--non-interactive]': '!interactive',
                            '[class.mdc-list--two-line]': 'twoLine',
                            '(click)': '_handleClickEvent($event)',
                            '(keydown)': '_onKeydown($event)',
                            '(focusin)': '_onFocusIn($event)',
                            '(focusout)': '_onFocusOut($event)'
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [{ provide: MDC_LIST_PARENT_COMPONENT, useExisting: MdcList }]
                    },] },
        ];
        /** @nocollapse */
        MdcList.ctorParameters = function () { return [
            { type: Platform },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcList.propDecorators = {
            twoLine: [{ type: core.Input }],
            dense: [{ type: core.Input }],
            border: [{ type: core.Input }],
            avatar: [{ type: core.Input }],
            interactive: [{ type: core.Input }],
            disableRipple: [{ type: core.Input }],
            singleSelection: [{ type: core.Input }],
            useActivatedClass: [{ type: core.Input }],
            useSelectedClass: [{ type: core.Input }],
            verticalOrientation: [{ type: core.Input }],
            wrapFocus: [{ type: core.Input }],
            items: [{ type: core.ContentChildren, args: [MdcListItem, { descendants: true },] }],
            selectionChange: [{ type: core.Output }],
            actionEvent: [{ type: core.Output }]
        };
        return MdcList;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcListDivider = /** @class */ (function () {
        function MdcListDivider(elementRef) {
            this.elementRef = elementRef;
            this._inset = false;
            this._padded = false;
        }
        Object.defineProperty(MdcListDivider.prototype, "inset", {
            get: /**
             * @return {?}
             */
            function () { return this._inset; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._inset = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcListDivider.prototype, "padded", {
            get: /**
             * @return {?}
             */
            function () { return this._padded; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._padded = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcListDivider.decorators = [
            { type: core.Component, args: [{selector: '[mdcListDivider], mdc-list-divider',
                        exportAs: 'mdcListDivider',
                        host: {
                            'role': 'separator',
                            'class': 'mdc-list-divider',
                            '[class.mdc-list-divider--inset]': 'inset',
                            '[class.mdc-list-divider--padded]': 'padded'
                        },
                        template: '',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcListDivider.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListDivider.propDecorators = {
            inset: [{ type: core.Input }],
            padded: [{ type: core.Input }]
        };
        return MdcListDivider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LIST_DECLARATIONS = [
        MdcList,
        MdcListDivider,
        MdcListGroup,
        MdcListGroupSubheader,
        MdcListItem,
        MdcListItemGraphic,
        MdcListItemMeta,
        MdcListItemSecondary,
        MdcListItemText
    ];
    var MdcListModule = /** @class */ (function () {
        function MdcListModule() {
        }
        MdcListModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: LIST_DECLARATIONS,
                        declarations: LIST_DECLARATIONS,
                    },] },
        ];
        return MdcListModule;
    }());

    var candidateSelectors$1 = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'];
    var candidateSelector$1 = candidateSelectors$1.join(',');
    var matches$3 = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    function tabbable$1(el, options) {
      options = options || {};
      var elementDocument = el.ownerDocument || el;
      var regularTabbables = [];
      var orderedTabbables = [];
      var untouchabilityChecker = new UntouchabilityChecker$1(elementDocument);
      var candidates = el.querySelectorAll(candidateSelector$1);

      if (options.includeContainer) {
        if (matches$3.call(el, candidateSelector$1)) {
          candidates = Array.prototype.slice.apply(candidates);
          candidates.unshift(el);
        }
      }

      var i, candidate, candidateTabindex;

      for (i = 0; i < candidates.length; i++) {
        candidate = candidates[i];
        if (!isNodeMatchingSelectorTabbable$1(candidate, untouchabilityChecker)) continue;
        candidateTabindex = getTabindex$1(candidate);

        if (candidateTabindex === 0) {
          regularTabbables.push(candidate);
        } else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            node: candidate
          });
        }
      }

      var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables$1).map(function (a) {
        return a.node;
      }).concat(regularTabbables);
      return tabbableNodes;
    }

    tabbable$1.isTabbable = isTabbable$1;
    tabbable$1.isFocusable = isFocusable$1;

    function isNodeMatchingSelectorTabbable$1(node, untouchabilityChecker) {
      if (!isNodeMatchingSelectorFocusable$1(node, untouchabilityChecker) || isNonTabbableRadio$1(node) || getTabindex$1(node) < 0) {
        return false;
      }

      return true;
    }

    function isTabbable$1(node, untouchabilityChecker) {
      if (!node) throw new Error('No node provided');
      if (matches$3.call(node, candidateSelector$1) === false) return false;
      return isNodeMatchingSelectorTabbable$1(node, untouchabilityChecker);
    }

    function isNodeMatchingSelectorFocusable$1(node, untouchabilityChecker) {
      untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker$1(node.ownerDocument || node);

      if (node.disabled || isHiddenInput$1(node) || untouchabilityChecker.isUntouchable(node)) {
        return false;
      }

      return true;
    }

    var focusableCandidateSelector$1 = candidateSelectors$1.concat('iframe').join(',');

    function isFocusable$1(node, untouchabilityChecker) {
      if (!node) throw new Error('No node provided');
      if (matches$3.call(node, focusableCandidateSelector$1) === false) return false;
      return isNodeMatchingSelectorFocusable$1(node, untouchabilityChecker);
    }

    function getTabindex$1(node) {
      var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
      if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;
      // so if they don't have a tabindex attribute specifically set, assume it's 0.

      if (isContentEditable$1(node)) return 0;
      return node.tabIndex;
    }

    function sortOrderedTabbables$1(a, b) {
      return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
    } // Array.prototype.find not available in IE.


    function find$1(list, predicate) {
      for (var i = 0, length = list.length; i < length; i++) {
        if (predicate(list[i])) return list[i];
      }
    }

    function isContentEditable$1(node) {
      return node.contentEditable === 'true';
    }

    function isInput$1(node) {
      return node.tagName === 'INPUT';
    }

    function isHiddenInput$1(node) {
      return isInput$1(node) && node.type === 'hidden';
    }

    function isRadio$1(node) {
      return isInput$1(node) && node.type === 'radio';
    }

    function isNonTabbableRadio$1(node) {
      return isRadio$1(node) && !isTabbableRadio$1(node);
    }

    function getCheckedRadio$1(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked) {
          return nodes[i];
        }
      }
    }

    function isTabbableRadio$1(node) {
      if (!node.name) return true; // This won't account for the edge case where you have radio groups with the same
      // in separate forms on the same page.

      var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
      var checked = getCheckedRadio$1(radioSet);
      return !checked || checked === node;
    } // An element is "untouchable" if *it or one of its ancestors* has
    // `visibility: hidden` or `display: none`.


    function UntouchabilityChecker$1(elementDocument) {
      this.doc = elementDocument; // Node cache must be refreshed on every check, in case
      // the content of the element has changed. The cache contains tuples
      // mapping nodes to their boolean result.

      this.cache = [];
    } // getComputedStyle accurately reflects `visibility: hidden` of ancestors
    // but not `display: none`, so we need to recursively check parents.


    UntouchabilityChecker$1.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {
      if (node.nodeType !== Node.ELEMENT_NODE) return false; // Search for a cached result.

      var cached = find$1(this.cache, function (item) {
        return item === node;
      });
      if (cached) return cached[1];
      nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);
      var result = false;

      if (nodeComputedStyle.display === 'none') {
        result = true;
      } else if (node.parentNode) {
        result = this.hasDisplayNone(node.parentNode);
      }

      this.cache.push([node, result]);
      return result;
    };

    UntouchabilityChecker$1.prototype.isUntouchable = function isUntouchable(node) {
      if (node === this.doc.documentElement) return false;
      var computedStyle = this.doc.defaultView.getComputedStyle(node);
      if (this.hasDisplayNone(node, computedStyle)) return true;
      return computedStyle.visibility === 'hidden';
    };

    var tabbable_1$1 = tabbable$1;

    var immutable$1 = extend$1;
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

    function extend$1() {
      var target = {};

      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (hasOwnProperty$1.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    }

    var activeFocusTraps$1 = function () {
      var trapQueue = [];
      return {
        activateTrap: function activateTrap(trap) {
          if (trapQueue.length > 0) {
            var activeTrap = trapQueue[trapQueue.length - 1];

            if (activeTrap !== trap) {
              activeTrap.pause();
            }
          }

          var trapIndex = trapQueue.indexOf(trap);

          if (trapIndex === -1) {
            trapQueue.push(trap);
          } else {
            // move this existing trap to the front of the queue
            trapQueue.splice(trapIndex, 1);
            trapQueue.push(trap);
          }
        },
        deactivateTrap: function deactivateTrap(trap) {
          var trapIndex = trapQueue.indexOf(trap);

          if (trapIndex !== -1) {
            trapQueue.splice(trapIndex, 1);
          }

          if (trapQueue.length > 0) {
            trapQueue[trapQueue.length - 1].unpause();
          }
        }
      };
    }();

    function focusTrap$1(element, userOptions) {
      var doc = document;
      var container = typeof element === 'string' ? doc.querySelector(element) : element;
      var config = immutable$1({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true
      }, userOptions);
      var state = {
        firstTabbableNode: null,
        lastTabbableNode: null,
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false
      };
      var trap = {
        activate: activate,
        deactivate: deactivate,
        pause: pause,
        unpause: unpause
      };
      return trap;

      function activate(activateOptions) {
        if (state.active) return;
        updateTabbableNodes();
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;

        if (onActivate) {
          onActivate();
        }

        addListeners();
        return trap;
      }

      function deactivate(deactivateOptions) {
        if (!state.active) return;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps$1.deactivateTrap(trap);
        var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;

        if (onDeactivate) {
          onDeactivate();
        }

        var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;

        if (returnFocus) {
          delay$1(function () {
            tryFocus(state.nodeFocusedBeforeActivation);
          });
        }

        return trap;
      }

      function pause() {
        if (state.paused || !state.active) return;
        state.paused = true;
        removeListeners();
      }

      function unpause() {
        if (!state.paused || !state.active) return;
        state.paused = false;
        addListeners();
      }

      function addListeners() {
        if (!state.active) return; // There can be only one listening focus trap at a time

        activeFocusTraps$1.activateTrap(trap);
        updateTabbableNodes(); // Delay ensures that the focused element doesn't capture the event
        // that caused the focus trap activation.

        delay$1(function () {
          tryFocus(getInitialFocusNode());
        });
        doc.addEventListener('focusin', checkFocusIn, true);
        doc.addEventListener('mousedown', checkPointerDown, true);
        doc.addEventListener('touchstart', checkPointerDown, true);
        doc.addEventListener('click', checkClick, true);
        doc.addEventListener('keydown', checkKey, true);
        return trap;
      }

      function removeListeners() {
        if (!state.active) return;
        doc.removeEventListener('focusin', checkFocusIn, true);
        doc.removeEventListener('mousedown', checkPointerDown, true);
        doc.removeEventListener('touchstart', checkPointerDown, true);
        doc.removeEventListener('click', checkClick, true);
        doc.removeEventListener('keydown', checkKey, true);
        return trap;
      }

      function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        var node = optionValue;

        if (!optionValue) {
          return null;
        }

        if (typeof optionValue === 'string') {
          node = doc.querySelector(optionValue);

          if (!node) {
            throw new Error('`' + optionName + '` refers to no known node');
          }
        }

        if (typeof optionValue === 'function') {
          node = optionValue();

          if (!node) {
            throw new Error('`' + optionName + '` did not return a node');
          }
        }

        return node;
      }

      function getInitialFocusNode() {
        var node;

        if (getNodeForOption('initialFocus') !== null) {
          node = getNodeForOption('initialFocus');
        } else if (container.contains(doc.activeElement)) {
          node = doc.activeElement;
        } else {
          node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
        }

        if (!node) {
          throw new Error("You can't have a focus-trap without at least one focusable element");
        }

        return node;
      } // This needs to be done on mousedown and touchstart instead of click
      // so that it precedes the focus event.


      function checkPointerDown(e) {
        if (container.contains(e.target)) return;

        if (config.clickOutsideDeactivates) {
          deactivate({
            returnFocus: !tabbable_1$1.isFocusable(e.target)
          });
        } else {
          e.preventDefault();
        }
      } // In case focus escapes the trap for some strange reason, pull it back in.


      function checkFocusIn(e) {
        // In Firefox when you Tab out of an iframe the Document is briefly focused.
        if (container.contains(e.target) || e.target instanceof Document) {
          return;
        }

        e.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }

      function checkKey(e) {
        if (config.escapeDeactivates !== false && isEscapeEvent$1(e)) {
          e.preventDefault();
          deactivate();
          return;
        }

        if (isTabEvent$1(e)) {
          checkTab(e);
          return;
        }
      } // Hijack Tab events on the first and last focusable nodes of the trap,
      // in order to prevent focus from escaping. If it escapes for even a
      // moment it can end up scrolling the page and causing confusion so we
      // kind of need to capture the action at the keydown phase.


      function checkTab(e) {
        updateTabbableNodes();

        if (e.shiftKey && e.target === state.firstTabbableNode) {
          e.preventDefault();
          tryFocus(state.lastTabbableNode);
          return;
        }

        if (!e.shiftKey && e.target === state.lastTabbableNode) {
          e.preventDefault();
          tryFocus(state.firstTabbableNode);
          return;
        }
      }

      function checkClick(e) {
        if (config.clickOutsideDeactivates) return;
        if (container.contains(e.target)) return;
        e.preventDefault();
        e.stopImmediatePropagation();
      }

      function updateTabbableNodes() {
        var tabbableNodes = tabbable_1$1(container);
        state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
        state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
      }

      function tryFocus(node) {
        if (node === doc.activeElement) return;

        if (!node || !node.focus) {
          tryFocus(getInitialFocusNode());
          return;
        }

        node.focus();
        state.mostRecentlyFocusedNode = node;

        if (isSelectableInput$1(node)) {
          node.select();
        }
      }
    }

    function isSelectableInput$1(node) {
      return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
    }

    function isEscapeEvent$1(e) {
      return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
    }

    function isTabEvent$1(e) {
      return e.key === 'Tab' || e.keyCode === 9;
    }

    function delay$1(fn) {
      return setTimeout(fn, 0);
    }

    var focusTrap_1$1 = focusTrap$1;

    function _classCallCheck$6(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$6(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$6(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$6(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$6(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$6(subClass, superClass);
    }

    function _getPrototypeOf$6(o) {
      _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$6(o);
    }

    function _setPrototypeOf$6(o, p) {
      _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$6(o, p);
    }

    function _assertThisInitialized$6(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$6(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$6(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$6 =
    /*#__PURE__*/
    function () {
      _createClass$6(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$6(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$6(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$6 =
    /*#__PURE__*/
    function () {
      _createClass$6(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$6());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$6(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$6(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Drawer
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Drawer into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCDrawerAdapter =
    /*#__PURE__*/
    function () {
      function MDCDrawerAdapter() {
        _classCallCheck$6(this, MDCDrawerAdapter);
      }

      _createClass$6(MDCDrawerAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root Element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root Element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root Element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * @param {!Element} element target element to verify class name
         * @param {string} className class name
         */

      }, {
        key: "elementHasClass",
        value: function elementHasClass(element, className) {}
        /**
         * Saves the focus of currently active element.
         */

      }, {
        key: "saveFocus",
        value: function saveFocus() {}
        /**
         * Restores focus to element previously saved with 'saveFocus'.
         */

      }, {
        key: "restoreFocus",
        value: function restoreFocus() {}
        /**
         * Focuses the active / selected navigation item.
         */

      }, {
        key: "focusActiveNavigationItem",
        value: function focusActiveNavigationItem() {}
        /**
         * Emits a custom event "MDCDrawer:closed" denoting the drawer has closed.
         */

      }, {
        key: "notifyClose",
        value: function notifyClose() {}
        /**
         * Emits a custom event "MDCDrawer:opened" denoting the drawer has opened.
         */

      }, {
        key: "notifyOpen",
        value: function notifyOpen() {}
        /**
         * Traps focus on root element and focuses the active navigation element.
         */

      }, {
        key: "trapFocus",
        value: function trapFocus() {}
        /**
         * Releases focus trap from root element which was set by `trapFocus`
         * and restores focus to where it was prior to calling `trapFocus`.
         */

      }, {
        key: "releaseFocus",
        value: function releaseFocus() {}
      }]);

      return MDCDrawerAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$6 = {
      ROOT: 'mdc-drawer',
      DISMISSIBLE: 'mdc-drawer--dismissible',
      MODAL: 'mdc-drawer--modal',
      OPEN: 'mdc-drawer--open',
      ANIMATE: 'mdc-drawer--animate',
      OPENING: 'mdc-drawer--opening',
      CLOSING: 'mdc-drawer--closing'
    };
    /** @enum {string} */

    var strings$6 = {
      APP_CONTENT_SELECTOR: '.mdc-drawer-app-content',
      SCRIM_SELECTOR: '.mdc-drawer-scrim',
      CLOSE_EVENT: 'MDCDrawer:closed',
      OPEN_EVENT: 'MDCDrawer:opened'
    };

    /**
     * @extends {MDCFoundation<!MDCDrawerAdapter>}
     */

    var MDCDismissibleDrawerFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$6(MDCDismissibleDrawerFoundation, _MDCFoundation);

      _createClass$6(MDCDismissibleDrawerFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$6;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$6;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCDrawerAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              hasClass: function hasClass()
              /* className: string */
              {},
              elementHasClass: function elementHasClass()
              /* element: !Element, className: string */
              {},
              notifyClose: function notifyClose() {},
              notifyOpen: function notifyOpen() {},
              saveFocus: function saveFocus() {},
              restoreFocus: function restoreFocus() {},
              focusActiveNavigationItem: function focusActiveNavigationItem() {},
              trapFocus: function trapFocus() {},
              releaseFocus: function releaseFocus() {}
            }
          );
        }
      }]);

      function MDCDismissibleDrawerFoundation(adapter) {
        var _this;

        _classCallCheck$6(this, MDCDismissibleDrawerFoundation);

        _this = _possibleConstructorReturn$6(this, _getPrototypeOf$6(MDCDismissibleDrawerFoundation).call(this, Object.assign(MDCDismissibleDrawerFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.animationFrame_ = 0;
        /** @private {number} */

        _this.animationTimer_ = 0;
        return _this;
      }

      _createClass$6(MDCDismissibleDrawerFoundation, [{
        key: "destroy",
        value: function destroy() {
          if (this.animationFrame_) {
            cancelAnimationFrame(this.animationFrame_);
          }

          if (this.animationTimer_) {
            clearTimeout(this.animationTimer_);
          }
        }
        /**
         * Function to open the drawer.
         */

      }, {
        key: "open",
        value: function open() {
          var _this2 = this;

          if (this.isOpen() || this.isOpening() || this.isClosing()) {
            return;
          }

          this.adapter_.addClass(cssClasses$6.OPEN);
          this.adapter_.addClass(cssClasses$6.ANIMATE); // Wait a frame once display is no longer "none", to establish basis for animation

          this.runNextAnimationFrame_(function () {
            _this2.adapter_.addClass(cssClasses$6.OPENING);
          });
          this.adapter_.saveFocus();
        }
        /**
         * Function to close the drawer.
         */

      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen() || this.isOpening() || this.isClosing()) {
            return;
          }

          this.adapter_.addClass(cssClasses$6.CLOSING);
        }
        /**
         * Extension point for when drawer finishes open animation.
         * @protected
         */

      }, {
        key: "opened",
        value: function opened() {}
        /**
         * Extension point for when drawer finishes close animation.
         * @protected
         */

      }, {
        key: "closed",
        value: function closed() {}
        /**
         * Returns true if drawer is in open state.
         * @return {boolean}
         */

      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.adapter_.hasClass(cssClasses$6.OPEN);
        }
        /**
         * Returns true if drawer is animating open.
         * @return {boolean}
         */

      }, {
        key: "isOpening",
        value: function isOpening() {
          return this.adapter_.hasClass(cssClasses$6.OPENING) || this.adapter_.hasClass(cssClasses$6.ANIMATE);
        }
        /**
         * Returns true if drawer is animating closed.
         * @return {boolean}
         */

      }, {
        key: "isClosing",
        value: function isClosing() {
          return this.adapter_.hasClass(cssClasses$6.CLOSING);
        }
        /**
         * Keydown handler to close drawer when key is escape.
         * @param evt
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt) {
          var keyCode = evt.keyCode,
              key = evt.key;
          var isEscape = key === 'Escape' || keyCode === 27;

          if (isEscape) {
            this.close();
          }
        }
        /**
         * Handles a transition end event on the root element.
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          var OPENING = cssClasses$6.OPENING,
              CLOSING = cssClasses$6.CLOSING,
              OPEN = cssClasses$6.OPEN,
              ANIMATE = cssClasses$6.ANIMATE,
              ROOT = cssClasses$6.ROOT; // In Edge, transitionend on ripple pseudo-elements yields a target without classList, so check for Element first.

          var isElement = evt.target instanceof Element;

          if (!isElement || !this.adapter_.elementHasClass(
          /** @type {!Element} */
          evt.target, ROOT)) {
            return;
          }

          if (this.isClosing()) {
            this.adapter_.removeClass(OPEN);
            this.closed();
            this.adapter_.restoreFocus();
            this.adapter_.notifyClose();
          } else {
            this.adapter_.focusActiveNavigationItem();
            this.opened();
            this.adapter_.notifyOpen();
          }

          this.adapter_.removeClass(ANIMATE);
          this.adapter_.removeClass(OPENING);
          this.adapter_.removeClass(CLOSING);
        }
        /**
         * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
         * @param {Function} callback
         * @private
         */

      }, {
        key: "runNextAnimationFrame_",
        value: function runNextAnimationFrame_(callback) {
          var _this3 = this;

          cancelAnimationFrame(this.animationFrame_);
          this.animationFrame_ = requestAnimationFrame(function () {
            _this3.animationFrame_ = 0;
            clearTimeout(_this3.animationTimer_);
            _this3.animationTimer_ = setTimeout(callback, 0);
          });
        }
      }]);

      return MDCDismissibleDrawerFoundation;
    }(MDCFoundation$6);

    /**
     * @extends {MDCDismissibleDrawerFoundation}
     */

    var MDCModalDrawerFoundation =
    /*#__PURE__*/
    function (_MDCDismissibleDrawer) {
      _inherits$6(MDCModalDrawerFoundation, _MDCDismissibleDrawer);

      function MDCModalDrawerFoundation() {
        _classCallCheck$6(this, MDCModalDrawerFoundation);

        return _possibleConstructorReturn$6(this, _getPrototypeOf$6(MDCModalDrawerFoundation).apply(this, arguments));
      }

      _createClass$6(MDCModalDrawerFoundation, [{
        key: "opened",

        /**
         * Called when drawer finishes open animation.
         * @override
         */
        value: function opened() {
          this.adapter_.trapFocus();
        }
        /**
         * Called when drawer finishes close animation.
         * @override
         */

      }, {
        key: "closed",
        value: function closed() {
          this.adapter_.releaseFocus();
        }
        /**
         * Handles click event on scrim.
         */

      }, {
        key: "handleScrimClick",
        value: function handleScrimClick() {
          this.close();
        }
      }]);

      return MDCModalDrawerFoundation;
    }(MDCDismissibleDrawerFoundation);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC List. Provides an interface for managing focus.
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCListAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCListAdapter() {
        _classCallCheck$6(this, MDCListAdapter);
      }

      _createClass$6(MDCListAdapter, [{
        key: "getListItemCount",

        /** @return {number} */
        value: function getListItemCount() {}
        /**
         * @return {number} */

      }, {
        key: "getFocusedElementIndex",
        value: function getFocusedElementIndex() {}
        /**
         * @param {number} index
         * @param {string} attribute
         * @param {string} value
         */

      }, {
        key: "setAttributeForElementIndex",
        value: function setAttributeForElementIndex(index, attribute, value) {}
        /**
         * @param {number} index
         * @param {string} attribute
         */

      }, {
        key: "removeAttributeForElementIndex",
        value: function removeAttributeForElementIndex(index, attribute) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "addClassForElementIndex",
        value: function addClassForElementIndex(index, className) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "removeClassForElementIndex",
        value: function removeClassForElementIndex(index, className) {}
        /**
         * Focuses list item at the index specified.
         * @param {number} index
         */

      }, {
        key: "focusItemAtIndex",
        value: function focusItemAtIndex(index) {}
        /**
         * Sets the tabindex to the value specified for all button/a element children of
         * the list item at the index specified.
         * @param {number} listItemIndex
         * @param {number} tabIndexValue
         */

      }, {
        key: "setTabIndexForListItemChildren",
        value: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if radio button is present at given list item index.
         */

      }, {
        key: "hasRadioAtIndex",
        value: function hasRadioAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox is present at given list item index.
         */

      }, {
        key: "hasCheckboxAtIndex",
        value: function hasCheckboxAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox inside a list item is checked.
         */

      }, {
        key: "isCheckboxCheckedAtIndex",
        value: function isCheckboxCheckedAtIndex(index) {}
        /**
         * Sets the checked status of checkbox or radio at given list item index.
         * @param {number} index
         * @param {boolean} isChecked
         */

      }, {
        key: "setCheckedCheckboxOrRadioAtIndex",
        value: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {}
        /**
         * Notifies user action on list item.
         */

      }, {
        key: "notifyAction",
        value: function notifyAction(index) {}
        /**
         * @return {boolean} Returns true when the current focused element is inside list root.
         */

      }, {
        key: "isFocusInsideList",
        value: function isFocusInsideList() {}
      }]);

      return MDCListAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1$4 = {
      ROOT: 'mdc-list',
      LIST_ITEM_CLASS: 'mdc-list-item',
      LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
      LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated'
    };
    /** @enum {string} */

    var strings$1$4 = {
      ARIA_ORIENTATION: 'aria-orientation',
      ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
      ARIA_SELECTED: 'aria-selected',
      ARIA_CHECKED: 'aria-checked',
      ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
      ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
      ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
      RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
      CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
      CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
      CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: ".".concat(cssClasses$1$4.LIST_ITEM_CLASS, " button:not(:disabled),\n  .").concat(cssClasses$1$4.LIST_ITEM_CLASS, " a"),
      FOCUSABLE_CHILD_ELEMENTS: ".".concat(cssClasses$1$4.LIST_ITEM_CLASS, " button:not(:disabled), .").concat(cssClasses$1$4.LIST_ITEM_CLASS, " a,\n  .").concat(cssClasses$1$4.LIST_ITEM_CLASS, " input[type=\"radio\"]:not(:disabled),\n  .").concat(cssClasses$1$4.LIST_ITEM_CLASS, " input[type=\"checkbox\"]:not(:disabled)"),
      ENABLED_ITEMS_SELECTOR: '.mdc-list-item:not(.mdc-list-item--disabled)',
      ACTION_EVENT: 'MDCList:action'
    };

    var ELEMENTS_KEY_ALLOWED_IN$1 = ['input', 'button', 'textarea', 'select'];

    var MDCListFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$6(MDCListFoundation, _MDCFoundation);

      _createClass$6(MDCListFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$1$4;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$4;
        }
        /**
         * {@see MDCListAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCListAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCListAdapter} */
            {
              getListItemCount: function getListItemCount() {},
              getFocusedElementIndex: function getFocusedElementIndex() {},
              setAttributeForElementIndex: function setAttributeForElementIndex() {},
              removeAttributeForElementIndex: function removeAttributeForElementIndex() {},
              addClassForElementIndex: function addClassForElementIndex() {},
              removeClassForElementIndex: function removeClassForElementIndex() {},
              focusItemAtIndex: function focusItemAtIndex() {},
              setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {},
              hasRadioAtIndex: function hasRadioAtIndex() {},
              hasCheckboxAtIndex: function hasCheckboxAtIndex() {},
              isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {},
              setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {},
              notifyAction: function notifyAction() {},
              isFocusInsideList: function isFocusInsideList() {}
            }
          );
        }
        /**
         * @param {!MDCListAdapter=} adapter
         */

      }]);

      function MDCListFoundation(adapter) {
        var _this;

        _classCallCheck$6(this, MDCListFoundation);

        _this = _possibleConstructorReturn$6(this, _getPrototypeOf$6(MDCListFoundation).call(this, Object.assign(MDCListFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.wrapFocus_ = false;
        /** @private {boolean} */

        _this.isVertical_ = true;
        /** @private {boolean} */

        _this.isSingleSelectionList_ = false;
        /** @private {!Index} */

        _this.selectedIndex_ = -1;
        /** @private {number} */

        _this.focusedItemIndex_ = -1;
        /** @private {boolean} */

        _this.useActivatedClass_ = false;
        /** @private {boolean} */

        _this.isCheckboxList_ = false;
        /** @private {boolean} */

        _this.isRadioList_ = false;
        return _this;
      }

      _createClass$6(MDCListFoundation, [{
        key: "layout",
        value: function layout() {
          if (this.adapter_.getListItemCount() === 0) return;

          if (this.adapter_.hasCheckboxAtIndex(0)) {
            this.isCheckboxList_ = true;
          } else if (this.adapter_.hasRadioAtIndex(0)) {
            this.isRadioList_ = true;
          }
        }
        /**
         * Sets the private wrapFocus_ variable.
         * @param {boolean} value
         */

      }, {
        key: "setWrapFocus",
        value: function setWrapFocus(value) {
          this.wrapFocus_ = value;
        }
        /**
         * Sets the isVertical_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setVerticalOrientation",
        value: function setVerticalOrientation(value) {
          this.isVertical_ = value;
        }
        /**
         * Sets the isSingleSelectionList_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setSingleSelection",
        value: function setSingleSelection(value) {
          this.isSingleSelectionList_ = value;
        }
        /**
         * Sets the useActivatedClass_ private variable.
         * @param {boolean} useActivated
         */

      }, {
        key: "setUseActivatedClass",
        value: function setUseActivatedClass(useActivated) {
          this.useActivatedClass_ = useActivated;
        }
        /** @return {!Index} */

      }, {
        key: "getSelectedIndex",
        value: function getSelectedIndex() {
          return this.selectedIndex_;
        }
        /** @param {!Index} index */

      }, {
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {
          if (!this.isIndexValid_(index)) return;

          if (this.isCheckboxList_) {
            this.setCheckboxAtIndex_(
            /** @type {!Array<number>} */
            index);
          } else if (this.isRadioList_) {
            this.setRadioAtIndex_(
            /** @type {number} */
            index);
          } else {
            this.setSingleSelectionAtIndex_(
            /** @type {number} */
            index);
          }
        }
        /**
         * Focus in handler for the list items.
         * @param evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusIn",
        value: function handleFocusIn(evt, listItemIndex) {
          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, 0);
          }
        }
        /**
         * Focus out handler for the list items.
         * @param {Event} evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusOut",
        value: function handleFocusOut(evt, listItemIndex) {
          var _this2 = this;

          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, -1);
          }
          /**
           * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
           * is moved to next element.
           */


          setTimeout(function () {
            if (!_this2.adapter_.isFocusInsideList()) {
              _this2.setTabindexToFirstSelectedItem_();
            }
          }, 0);
        }
        /**
         * Key handler for the list.
         * @param {Event} evt
         * @param {boolean} isRootListItem
         * @param {number} listItemIndex
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt, isRootListItem, listItemIndex) {
          var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
          var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
          var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
          var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
          var isHome = evt.key === 'Home' || evt.keyCode === 36;
          var isEnd = evt.key === 'End' || evt.keyCode === 35;
          var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
          var isSpace = evt.key === 'Space' || evt.keyCode === 32;
          var currentIndex = this.adapter_.getFocusedElementIndex();
          var nextIndex = -1;

          if (currentIndex === -1) {
            currentIndex = listItemIndex;

            if (currentIndex < 0) {
              // If this event doesn't have a mdc-list-item ancestor from the
              // current list (not from a sublist), return early.
              return;
            }
          }

          if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusNextElement(currentIndex);
          } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusPrevElement(currentIndex);
          } else if (isHome) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusFirstElement();
          } else if (isEnd) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusLastElement();
          } else if (isEnter || isSpace) {
            if (isRootListItem) {
              // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
              if (evt.target.tagName === 'A' && isEnter) return;
              this.preventDefaultEvent_(evt);

              if (this.isSelectableList_()) {
                this.setSelectedIndexOnAction_(currentIndex);
              }

              this.adapter_.notifyAction(currentIndex);
            }
          }

          this.focusedItemIndex_ = currentIndex;

          if (nextIndex >= 0) {
            this.setTabindexAtIndex_(nextIndex);
            this.focusedItemIndex_ = nextIndex;
          }
        }
        /**
         * Click handler for the list.
         * @param {number} index
         * @param {boolean} toggleCheckbox
         */

      }, {
        key: "handleClick",
        value: function handleClick(index, toggleCheckbox) {
          if (index === -1) return;

          if (this.isSelectableList_()) {
            this.setSelectedIndexOnAction_(index, toggleCheckbox);
          }

          this.adapter_.notifyAction(index);
          this.setTabindexAtIndex_(index);
          this.focusedItemIndex_ = index;
        }
        /**
         * Ensures that preventDefault is only called if the containing element doesn't
         * consume the event, and it will cause an unintended scroll.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "preventDefaultEvent_",
        value: function preventDefaultEvent_(evt) {
          var tagName = "".concat(evt.target.tagName).toLowerCase();

          if (ELEMENTS_KEY_ALLOWED_IN$1.indexOf(tagName) === -1) {
            evt.preventDefault();
          }
        }
        /**
         * Focuses the next element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusNextElement",
        value: function focusNextElement(index) {
          var count = this.adapter_.getListItemCount();
          var nextIndex = index + 1;

          if (nextIndex >= count) {
            if (this.wrapFocus_) {
              nextIndex = 0;
            } else {
              // Return early because last item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(nextIndex);
          return nextIndex;
        }
        /**
         * Focuses the previous element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusPrevElement",
        value: function focusPrevElement(index) {
          var prevIndex = index - 1;

          if (prevIndex < 0) {
            if (this.wrapFocus_) {
              prevIndex = this.adapter_.getListItemCount() - 1;
            } else {
              // Return early because first item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(prevIndex);
          return prevIndex;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {
          this.adapter_.focusItemAtIndex(0);
          return 0;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusLastElement",
        value: function focusLastElement() {
          var lastIndex = this.adapter_.getListItemCount() - 1;
          this.adapter_.focusItemAtIndex(lastIndex);
          return lastIndex;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setSingleSelectionAtIndex_",
        value: function setSingleSelectionAtIndex_(index) {
          var selectedClassName = cssClasses$1$4.LIST_ITEM_SELECTED_CLASS;

          if (this.useActivatedClass_) {
            selectedClassName = cssClasses$1$4.LIST_ITEM_ACTIVATED_CLASS;
          }

          if (this.selectedIndex_ >= 0 && this.selectedIndex_ !== index) {
            this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$1$4.ARIA_SELECTED, 'false');
          }

          this.adapter_.addClassForElementIndex(index, selectedClassName);
          this.adapter_.setAttributeForElementIndex(index, strings$1$4.ARIA_SELECTED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
         * @param {number} index
         * @private
         */

      }, {
        key: "setRadioAtIndex_",
        value: function setRadioAtIndex_(index) {
          this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);

          if (this.selectedIndex_ >= 0) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$1$4.ARIA_CHECKED, 'false');
          }

          this.adapter_.setAttributeForElementIndex(index, strings$1$4.ARIA_CHECKED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * @param {!Array<number>} index
         * @private
         */

      }, {
        key: "setCheckboxAtIndex_",
        value: function setCheckboxAtIndex_(index) {
          for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
            var isChecked = false;

            if (index.indexOf(i) >= 0) {
              isChecked = true;
            }

            this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
            this.adapter_.setAttributeForElementIndex(i, strings$1$4.ARIA_CHECKED, isChecked ? 'true' : 'false');
          }

          this.selectedIndex_ = index;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setTabindexAtIndex_",
        value: function setTabindexAtIndex_(index) {
          if (this.focusedItemIndex_ === -1 && index !== 0) {
            // If no list item was selected set first list item's tabindex to -1.
            // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
            this.adapter_.setAttributeForElementIndex(0, 'tabindex', -1);
          } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
            this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', -1);
          }

          this.adapter_.setAttributeForElementIndex(index, 'tabindex', 0);
        }
        /**
         * @return {boolean} Return true if it is single selectin list, checkbox list or radio list.
         * @private
         */

      }, {
        key: "isSelectableList_",
        value: function isSelectableList_() {
          return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
        }
        /** @private */

      }, {
        key: "setTabindexToFirstSelectedItem_",
        value: function setTabindexToFirstSelectedItem_() {
          var targetIndex = 0;

          if (this.isSelectableList_()) {
            if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== -1) {
              targetIndex = this.selectedIndex_;
            } else if (this.selectedIndex_ instanceof Array && this.selectedIndex_.length > 0) {
              targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
                return Math.min(currentIndex, minIndex);
              });
            }
          }

          this.setTabindexAtIndex_(targetIndex);
        }
        /**
         * @param {!Index} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexValid_",
        value: function isIndexValid_(index) {
          var _this3 = this;

          if (index instanceof Array) {
            if (!this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
            }

            if (index.length === 0) {
              return true;
            } else {
              return index.some(function (i) {
                return _this3.isIndexInRange_(i);
              });
            }
          } else if (typeof index === 'number') {
            if (this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
            }

            return this.isIndexInRange_(index);
          } else {
            return false;
          }
        }
        /**
         * @param {number} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexInRange_",
        value: function isIndexInRange_(index) {
          var listSize = this.adapter_.getListItemCount();
          return index >= 0 && index < listSize;
        }
        /**
         * @param {number} index
         * @param {boolean=} toggleCheckbox
         * @private
         */

      }, {
        key: "setSelectedIndexOnAction_",
        value: function setSelectedIndexOnAction_(index) {
          var toggleCheckbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (this.isCheckboxList_) {
            this.toggleCheckboxAtIndex_(index, toggleCheckbox);
          } else {
            this.setSelectedIndex(index);
          }
        }
        /**
         * @param {number} index
         * @param {boolean} toggleCheckbox
         * @private
         */

      }, {
        key: "toggleCheckboxAtIndex_",
        value: function toggleCheckboxAtIndex_(index, toggleCheckbox) {
          var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);

          if (toggleCheckbox) {
            isChecked = !isChecked;
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
          }

          this.adapter_.setAttributeForElementIndex(index, strings$1$4.ARIA_CHECKED, isChecked ? 'true' : 'false'); // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.

          if (this.selectedIndex_ === -1) {
            this.selectedIndex_ = [];
          }

          if (isChecked) {
            this.selectedIndex_.push(index);
          } else {
            this.selectedIndex_ = this.selectedIndex_.filter(function (i) {
              return i !== index;
            });
          }
        }
      }]);

      return MDCListFoundation;
    }(MDCFoundation$6);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {boolean}
     */


    function matches$1$1(element, selector) {
      var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      return nativeMatches.call(element, selector);
    }

    /**
     * @extends MDCComponent<!MDCListFoundation>
     */

    var MDCList$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$6(MDCList, _MDCComponent);

      /** @param {...?} args */
      function MDCList() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$6(this, MDCList);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$6(this, (_getPrototypeOf2 = _getPrototypeOf$6(MDCList)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleClick_;
        /** @private {!Function} */

        _this.focusInEventListener_;
        /** @private {!Function} */

        _this.focusOutEventListener_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCList}
       */


      _createClass$6(MDCList, [{
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener('click', this.handleClick_);
          this.root_.removeEventListener('focusin', this.focusInEventListener_);
          this.root_.removeEventListener('focusout', this.focusOutEventListener_);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.handleClick_ = this.handleClickEvent_.bind(this);
          this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
          this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
          this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener('focusin', this.focusInEventListener_);
          this.root_.addEventListener('focusout', this.focusOutEventListener_);
          this.root_.addEventListener('click', this.handleClick_);
          this.layout();
          this.initializeListType();
        }
      }, {
        key: "layout",
        value: function layout() {
          var direction = this.root_.getAttribute(strings$1$4.ARIA_ORIENTATION);
          this.vertical = direction !== strings$1$4.ARIA_ORIENTATION_HORIZONTAL; // List items need to have at least tabindex=-1 to be focusable.

          [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
            ele.setAttribute('tabindex', -1);
          }); // Child button/a elements are not tabbable until the list item is focused.

          [].slice.call(this.root_.querySelectorAll(strings$1$4.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
            return ele.setAttribute('tabindex', -1);
          });
          this.foundation_.layout();
        }
        /**
         * Used to figure out which list item this event is targetting. Or returns -1 if
         * there is no list item
         * @param {Event} evt
         * @private
         */

      }, {
        key: "getListItemIndex_",
        value: function getListItemIndex_(evt) {
          var eventTarget =
          /** @type {HTMLElement} */
          evt.target;
          var index = -1; // Find the first ancestor that is a list item or the list.

          while (!eventTarget.classList.contains(cssClasses$1$4.LIST_ITEM_CLASS) && !eventTarget.classList.contains(cssClasses$1$4.ROOT)) {
            eventTarget = eventTarget.parentElement;
          } // Get the index of the element if it is a list item.


          if (eventTarget.classList.contains(cssClasses$1$4.LIST_ITEM_CLASS)) {
            index = this.listElements.indexOf(eventTarget);
          }

          return index;
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusInEvent_",
        value: function handleFocusInEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusIn(evt, index);
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusOutEvent_",
        value: function handleFocusOutEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusOut(evt, index);
        }
        /**
         * Used to figure out which element was focused when keydown event occurred before sending the event to the
         * foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleKeydownEvent_",
        value: function handleKeydownEvent_(evt) {
          var index = this.getListItemIndex_(evt);

          if (index >= 0) {
            this.foundation_.handleKeydown(evt, evt.target.classList.contains(cssClasses$1$4.LIST_ITEM_CLASS), index);
          }
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleClickEvent_",
        value: function handleClickEvent_(evt) {
          var index = this.getListItemIndex_(evt); // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.

          var toggleCheckbox = !matches$1$1(
          /** @type {!Element} */
          evt.target, strings$1$4.CHECKBOX_RADIO_SELECTOR);
          this.foundation_.handleClick(index, toggleCheckbox);
        }
        /**
         * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
         */

      }, {
        key: "initializeListType",
        value: function initializeListType() {
          var _this2 = this;

          var checkboxListItems = this.root_.querySelectorAll(strings$1$4.ARIA_ROLE_CHECKBOX_SELECTOR);
          var singleSelectedListItem = this.root_.querySelector(".".concat(cssClasses$1$4.LIST_ITEM_ACTIVATED_CLASS, ",\n        .").concat(cssClasses$1$4.LIST_ITEM_SELECTED_CLASS));
          var radioSelectedListItem = this.root_.querySelector(strings$1$4.ARIA_CHECKED_RADIO_SELECTOR);

          if (checkboxListItems.length) {
            var preselectedItems = this.root_.querySelectorAll(strings$1$4.ARIA_CHECKED_CHECKBOX_SELECTOR);
            this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
              return _this2.listElements.indexOf(listItem);
            });
          } else if (singleSelectedListItem) {
            if (singleSelectedListItem.classList.contains(cssClasses$1$4.LIST_ITEM_ACTIVATED_CLASS)) {
              this.foundation_.setUseActivatedClass(true);
            }

            this.singleSelection = true;
            this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
          } else if (radioSelectedListItem) {
            this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
          }
        }
        /** @param {boolean} value */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCListFoundation} */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCListFoundation$1(
          /** @type {!MDCListAdapter} */
          Object.assign({
            getListItemCount: function getListItemCount() {
              return _this3.listElements.length;
            },
            getFocusedElementIndex: function getFocusedElementIndex() {
              return _this3.listElements.indexOf(document.activeElement);
            },
            setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
              var element = _this3.listElements[index];

              if (element) {
                element.setAttribute(attr, value);
              }
            },
            removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
              var element = _this3.listElements[index];

              if (element) {
                element.removeAttribute(attr);
              }
            },
            addClassForElementIndex: function addClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.add(className);
              }
            },
            removeClassForElementIndex: function removeClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.remove(className);
              }
            },
            focusItemAtIndex: function focusItemAtIndex(index) {
              var element = _this3.listElements[index];

              if (element) {
                element.focus();
              }
            },
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
              var element = _this3.listElements[listItemIndex];
              var listItemChildren = [].slice.call(element.querySelectorAll(strings$1$4.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
              listItemChildren.forEach(function (ele) {
                return ele.setAttribute('tabindex', tabIndexValue);
              });
            },
            hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$1$4.CHECKBOX_SELECTOR);
            },
            hasRadioAtIndex: function hasRadioAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$1$4.RADIO_SELECTOR);
            },
            isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$1$4.CHECKBOX_SELECTOR);
              return toggleEl.checked;
            },
            setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$1$4.CHECKBOX_RADIO_SELECTOR);
              toggleEl.checked = isChecked;
              var event = document.createEvent('Event');
              event.initEvent('change', true, true);
              toggleEl.dispatchEvent(event);
            },
            notifyAction: function notifyAction(index) {
              _this3.emit(strings$1$4.ACTION_EVENT, index,
              /** shouldBubble */
              true);
            },
            isFocusInsideList: function isFocusInsideList() {
              return _this3.root_.contains(document.activeElement);
            }
          }));
        }
      }, {
        key: "vertical",
        set: function set(value) {
          this.foundation_.setVerticalOrientation(value);
        }
        /** @return Array<!Element>*/

      }, {
        key: "listElements",
        get: function get() {
          return [].slice.call(this.root_.querySelectorAll(strings$1$4.ENABLED_ITEMS_SELECTOR));
        }
        /** @param {boolean} value */

      }, {
        key: "wrapFocus",
        set: function set(value) {
          this.foundation_.setWrapFocus(value);
        }
        /** @param {boolean} isSingleSelectionList */

      }, {
        key: "singleSelection",
        set: function set(isSingleSelectionList) {
          this.foundation_.setSingleSelection(isSingleSelectionList);
        }
        /** @return {!Index} */

      }, {
        key: "selectedIndex",
        get: function get() {
          return this.foundation_.getSelectedIndex();
        }
        /** @param {!Index} index */
        ,
        set: function set(index) {
          this.foundation_.setSelectedIndex(index);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCList(root);
        }
      }]);

      return MDCList;
    }(MDCComponent$6);

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @param {!Element} surfaceEl
     * @param {!Function} focusTrapFactory
     * @return {!FocusTrapInstance}
     */

    function createFocusTrapInstance$1(surfaceEl) {
      var focusTrapFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : focusTrap_1$1;
      return focusTrapFactory(surfaceEl, {
        clickOutsideDeactivates: true,
        initialFocus: false,
        // Navigation drawer handles focusing on active nav item.
        escapeDeactivates: false,
        // Navigation drawer handles ESC.
        returnFocusOnDeactivate: false // Navigation drawer handles restore focus.

      });
    }

    /**
     * @extends {MDCComponent<!MDCDismissibleDrawerFoundation>}
     * @final
     */

    var MDCDrawer =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$6(MDCDrawer, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCDrawer() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$6(this, MDCDrawer);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$6(this, (_getPrototypeOf2 = _getPrototypeOf$6(MDCDrawer)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Element} */

        _this.previousFocus_;
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleTransitionEnd_;
        /** @private {!Function} */

        _this.focusTrapFactory_;
        /** @private {!FocusTrapInstance} */

        _this.focusTrap_;
        /** @private {?Element} */

        _this.scrim_;
        /** @private {?Function} */

        _this.handleScrimClick_;
        /** @private {?MDCList} */

        _this.list_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCDrawer}
       */


      _createClass$6(MDCDrawer, [{
        key: "initialize",
        value: function initialize() {
          var focusTrapFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : focusTrap_1$1;
          var listFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCList$1(el);
          };
          var listEl =
          /** @type {!Element} */
          this.root_.querySelector(".".concat(MDCListFoundation$1.cssClasses.ROOT));

          if (listEl) {
            this.list_ = listFactory(listEl);
            this.list_.wrapFocus = true;
          }

          this.focusTrapFactory_ = focusTrapFactory;
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          var MODAL = MDCDismissibleDrawerFoundation.cssClasses.MODAL;

          if (this.root_.classList.contains(MODAL)) {
            var SCRIM_SELECTOR = MDCDismissibleDrawerFoundation.strings.SCRIM_SELECTOR;
            this.scrim_ =
            /** @type {!Element} */
            this.root_.parentNode.querySelector(SCRIM_SELECTOR);

            this.handleScrimClick_ = function () {
              return (
                /** @type {!MDCModalDrawerFoundation} */
                _this2.foundation_.handleScrimClick()
              );
            };

            this.scrim_.addEventListener('click', this.handleScrimClick_);
            this.focusTrap_ = createFocusTrapInstance$1(this.root_, this.focusTrapFactory_);
          }

          this.handleKeydown_ = function (evt) {
            return _this2.foundation_.handleKeydown(evt);
          };

          this.handleTransitionEnd_ = function (evt) {
            return _this2.foundation_.handleTransitionEnd(evt);
          };

          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener('transitionend', this.handleTransitionEnd_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener('transitionend', this.handleTransitionEnd_);

          if (this.list_) {
            this.list_.destroy();
          }

          var MODAL = MDCDismissibleDrawerFoundation.cssClasses.MODAL;

          if (this.root_.classList.contains(MODAL)) {
            this.scrim_.removeEventListener('click',
            /** @type {!Function} */
            this.handleScrimClick_); // Ensure drawer is closed to hide scrim and release focus

            this.open = false;
          }
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          /** @type {!MDCDrawerAdapter} */
          var adapter =
          /** @type {!MDCDrawerAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            elementHasClass: function elementHasClass(element, className) {
              return element.classList.contains(className);
            },
            saveFocus: function saveFocus() {
              _this3.previousFocus_ = document.activeElement;
            },
            restoreFocus: function restoreFocus() {
              var previousFocus = _this3.previousFocus_ && _this3.previousFocus_.focus;

              if (_this3.root_.contains(document.activeElement) && previousFocus) {
                _this3.previousFocus_.focus();
              }
            },
            focusActiveNavigationItem: function focusActiveNavigationItem() {
              var activeNavItemEl = _this3.root_.querySelector(".".concat(MDCListFoundation$1.cssClasses.LIST_ITEM_ACTIVATED_CLASS));

              if (activeNavItemEl) {
                activeNavItemEl.focus();
              }
            },
            notifyClose: function notifyClose() {
              return _this3.emit(strings$6.CLOSE_EVENT, {}, true
              /* shouldBubble */
              );
            },
            notifyOpen: function notifyOpen() {
              return _this3.emit(strings$6.OPEN_EVENT, {}, true
              /* shouldBubble */
              );
            },
            trapFocus: function trapFocus() {
              return _this3.focusTrap_.activate();
            },
            releaseFocus: function releaseFocus() {
              return _this3.focusTrap_.deactivate();
            }
          });
          var _MDCDismissibleDrawer = MDCDismissibleDrawerFoundation.cssClasses,
              DISMISSIBLE = _MDCDismissibleDrawer.DISMISSIBLE,
              MODAL = _MDCDismissibleDrawer.MODAL;

          if (this.root_.classList.contains(DISMISSIBLE)) {
            return new MDCDismissibleDrawerFoundation(adapter);
          } else if (this.root_.classList.contains(MODAL)) {
            return new MDCModalDrawerFoundation(adapter);
          } else {
            throw new Error("MDCDrawer: Failed to instantiate component. Supported variants are ".concat(DISMISSIBLE, " and ").concat(MODAL, "."));
          }
        }
      }, {
        key: "open",

        /**
         * Returns true if drawer is in the open position.
         * @return {boolean}
         */
        get: function get() {
          return this.foundation_.isOpen();
        }
        /**
         * Toggles the drawer open and closed.
         * @param {boolean} isOpen
         */
        ,
        set: function set(isOpen) {
          if (isOpen) {
            this.foundation_.open();
          } else {
            this.foundation_.close();
          }
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCDrawer(root);
        }
      }]);

      return MDCDrawer;
    }(MDCComponent$6);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcDrawerHeader = /** @class */ (function () {
        function MdcDrawerHeader(elementRef) {
            this.elementRef = elementRef;
        }
        MdcDrawerHeader.decorators = [
            { type: core.Component, args: [{selector: 'mdc-drawer-header',
                        template: "\n  <ng-content></ng-content>\n  <h3 class=\"mdc-drawer__title\" *ngIf=\"title\">{{title}}</h3>\n  <h6 class=\"mdc-drawer__subtitle\" *ngIf=\"subtitle\">{{subtitle}}</h6>",
                        host: { 'class': 'mdc-drawer__header' },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcDrawerHeader.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDrawerHeader.propDecorators = {
            title: [{ type: core.Input }],
            subtitle: [{ type: core.Input }]
        };
        return MdcDrawerHeader;
    }());
    var MdcDrawerTitle = /** @class */ (function () {
        function MdcDrawerTitle() {
        }
        MdcDrawerTitle.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDrawerTitle]',
                        host: { 'class': 'mdc-drawer__title' }
                    },] },
        ];
        return MdcDrawerTitle;
    }());
    var MdcDrawerSubtitle = /** @class */ (function () {
        function MdcDrawerSubtitle() {
        }
        MdcDrawerSubtitle.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDrawerSubtitle]',
                        host: { 'class': 'mdc-drawer__subtitle' }
                    },] },
        ];
        return MdcDrawerSubtitle;
    }());
    var MdcDrawerContent = /** @class */ (function () {
        function MdcDrawerContent() {
        }
        MdcDrawerContent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-drawer-content, [mdcDrawerContent]',
                        host: { 'class': 'mdc-drawer__content' }
                    },] },
        ];
        return MdcDrawerContent;
    }());
    var MdcDrawerAppContent = /** @class */ (function () {
        function MdcDrawerAppContent() {
        }
        MdcDrawerAppContent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-drawer-app-content, [mdcDrawerAppContent]',
                        host: { 'class': 'mdc-drawer-app-content' }
                    },] },
        ];
        return MdcDrawerAppContent;
    }());
    var MdcDrawer = /** @class */ (function () {
        function MdcDrawer(_platform, _ngZone, _changeDetectorRef, elementRef) {
            this._platform = _platform;
            this._ngZone = _ngZone;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._initialized = false;
            this._previousFocus = null;
            this._scrimElement = null;
            this._focusTrapInstance = null;
            this._open = false;
            this._drawer = 'permanent';
            this.opened = new core.EventEmitter();
            this.closed = new core.EventEmitter();
            this._transitionEndSubscription = null;
            this._scrimSubscription = null;
            this._foundation = new MDCDismissibleDrawerFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcDrawer.prototype, "open", {
            get: /**
             * @return {?}
             */
            function () { return this._open; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._open = toBoolean(value);
                if (this._platform.isBrowser) {
                    this._open ? this._foundation.open() : this._foundation.close();
                }
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "drawer", {
            get: /**
             * @return {?}
             */
            function () { return this._drawer; },
            set: /**
             * @param {?} drawer
             * @return {?}
             */
            function (drawer) {
                if (this._drawer !== drawer) {
                    this._initialized = false;
                    this.setDrawer(drawer);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "fixedAdjustElement", {
            get: /**
             * @return {?}
             */
            function () { return this._fixedAdjustElement; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                this.setFixedAdjustElement(element);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "modal", {
            get: /**
             * @return {?}
             */
            function () { return this.drawer === 'modal'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "dismissible", {
            get: /**
             * @return {?}
             */
            function () { return this.drawer === 'dismissible'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "permanent", {
            get: /**
             * @return {?}
             */
            function () { return this.drawer === 'permanent'; },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                elementHasClass: (/**
                 * @param {?} element
                 * @param {?} className
                 * @return {?}
                 */
                function (element, className) { return element.classList.contains(className); }),
                saveFocus: (/**
                 * @return {?}
                 */
                function () { return _this._previousFocus = _this._platform.isBrowser ? (/** @type {?} */ (document.activeElement)) : null; }),
                restoreFocus: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    /** @type {?} */
                    var previousFocus = _this._previousFocus && ((/** @type {?} */ (_this._previousFocus))).focus;
                    if (_this._getHostElement().contains((/** @type {?} */ (document.activeElement))) && previousFocus) {
                        ((/** @type {?} */ (_this._previousFocus))).focus();
                    }
                }),
                focusActiveNavigationItem: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._platform.isBrowser || !_this._list) {
                        return;
                    }
                    /** @type {?} */
                    var selectedItem = _this._list.getSelectedItem();
                    if (selectedItem) {
                        selectedItem.focus();
                    }
                }),
                notifyClose: (/**
                 * @return {?}
                 */
                function () { return _this.closed.emit(); }),
                notifyOpen: (/**
                 * @return {?}
                 */
                function () { return _this.opened.emit(); }),
                trapFocus: (/**
                 * @return {?}
                 */
                function () { return (/** @type {?} */ (_this._focusTrapInstance)).activate(); }),
                releaseFocus: (/**
                 * @return {?}
                 */
                function () { return (/** @type {?} */ (_this._focusTrapInstance)).deactivate(); })
            };
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._initListType();
            if (!this._initialized) {
                this._initFoundation();
            }
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.open = false;
            if (this._scrimElement) {
                this._scrimElement.remove();
            }
            this._unloadListeners();
            if (this._foundation && this._platform.isBrowser) {
                this._foundation.destroy();
            }
        };
        /**
         * @param {?} drawer
         * @return {?}
         */
        MdcDrawer.prototype.setDrawer = /**
         * @param {?} drawer
         * @return {?}
         */
        function (drawer) {
            if (!drawer) {
                drawer = 'permanent';
            }
            if (this.drawer !== drawer) {
                this._drawer = drawer;
                this._initFoundation();
            }
        };
        /**
         * @param {?} element
         * @return {?}
         */
        MdcDrawer.prototype.setFixedAdjustElement = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            this._fixedAdjustElement = element;
            element ? this._getHostElement().style.setProperty('position', 'absolute') :
                this._getHostElement().style.removeProperty('position');
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcDrawer.prototype._onKeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleKeydown(evt);
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            this._unloadListeners();
            if (this.modal && this._platform.isBrowser) {
                this._createScrim();
                this._focusTrapInstance = this._createFocusTrapInstance();
            }
            else if (this._scrimElement) {
                this._scrimElement.remove();
            }
            this._initTransitionEndListener();
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._unloadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._scrimSubscription) {
                this._scrimSubscription.unsubscribe();
            }
            if (this._transitionEndSubscription) {
                this._transitionEndSubscription.unsubscribe();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._createScrim = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._scrimElement = document.createElement('div');
            this._scrimElement.classList.add('mdc-drawer-scrim');
            this._getHostElement().insertAdjacentElement('afterend', this._scrimElement);
            this._scrimSubscription =
                this._ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    return rxjs.fromEvent((/** @type {?} */ (_this._scrimElement)), 'click')
                        .subscribe((/**
                     * @return {?}
                     */
                    function () { return _this._ngZone.run((/**
                     * @return {?}
                     */
                    function () { return _this.open = false; })); }));
                }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._initFoundation = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._initialized) {
                return;
            }
            this._initialized = true;
            this._removeDrawerModifiers();
            if (this.modal) {
                this._foundation = new MDCModalDrawerFoundation(this._createAdapter());
            }
            else {
                this._foundation = new MDCDismissibleDrawerFoundation(this._createAdapter());
            }
            if (!this.permanent) {
                this._getHostElement().classList.add("mdc-drawer--" + this.drawer);
            }
            this._loadListeners();
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._initListType = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._list && (this._list.singleSelection || this._list.singleSelection === undefined)) {
                this._list.wrapFocus = true;
                this._list.singleSelection = true;
                this._list.useActivatedClass = true;
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._removeDrawerModifiers = /**
         * @private
         * @return {?}
         */
        function () {
            this._getHostElement().classList.remove('mdc-drawer--modal');
            this._getHostElement().classList.remove('mdc-drawer--dismissible');
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._initTransitionEndListener = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._transitionEndSubscription =
                this._ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    return rxjs.fromEvent(_this._getHostElement(), 'transitionend').pipe(operators.filter((/**
                     * @param {?} e
                     * @return {?}
                     */
                    function (e) { return e.target === _this._getHostElement(); })))
                        .subscribe((/**
                     * @param {?} evt
                     * @return {?}
                     */
                    function (evt) { return _this._ngZone.run((/**
                     * @return {?}
                     */
                    function () { return _this._foundation.handleTransitionEnd(evt); })); }));
                }));
        };
        /**
         * @private
         * @param {?=} focusTrapFactory
         * @return {?}
         */
        MdcDrawer.prototype._createFocusTrapInstance = /**
         * @private
         * @param {?=} focusTrapFactory
         * @return {?}
         */
        function (focusTrapFactory) {
            if (focusTrapFactory === void 0) { focusTrapFactory = focusTrap_1$1; }
            return focusTrapFactory(this._getHostElement(), {
                clickOutsideDeactivates: true,
                initialFocus: this._getHostElement(),
                // Navigation drawer sets focus to activated item
                escapeDeactivates: false,
                // Navigation drawer handles ESC.
                returnFocusOnDeactivate: false,
            });
        };
        /**
         * @private
         * @return {?}
         */
        MdcDrawer.prototype._getHostElement = /**
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcDrawer.decorators = [
            { type: core.Component, args: [{selector: 'mdc-drawer',
                        exportAs: 'mdcDrawer',
                        host: {
                            'role': 'navigation',
                            'class': 'mdc-drawer',
                            '(keydown)': '_onKeydown($event)'
                        },
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcDrawer.ctorParameters = function () { return [
            { type: Platform },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcDrawer.propDecorators = {
            open: [{ type: core.Input }],
            drawer: [{ type: core.Input }],
            fixedAdjustElement: [{ type: core.Input }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }],
            _list: [{ type: core.ContentChild, args: [MdcList,] }]
        };
        return MdcDrawer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DRAWER_DECLARATIONS = [
        MdcDrawer,
        MdcDrawerAppContent,
        MdcDrawerContent,
        MdcDrawerHeader,
        MdcDrawerSubtitle,
        MdcDrawerTitle
    ];
    var MdcDrawerModule = /** @class */ (function () {
        function MdcDrawerModule() {
        }
        MdcDrawerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [DRAWER_DECLARATIONS],
                        declarations: [DRAWER_DECLARATIONS]
                    },] },
        ];
        return MdcDrawerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcElevation = /** @class */ (function () {
        function MdcElevation(elementRef) {
            this.elementRef = elementRef;
            this._mdcElevation = 0;
        }
        Object.defineProperty(MdcElevation.prototype, "mdcElevation", {
            get: /**
             * @return {?}
             */
            function () { return this._mdcElevation; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._mdcElevation = toNumber(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        MdcElevation.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            /** @type {?} */
            var change = changes['mdcElevation'];
            if (change.currentValue < 0 || change.currentValue > 24) {
                throw new Error("Valid mdc-elevation values are 0 through 24");
            }
            if (!change.isFirstChange()) {
                this.elementRef.nativeElement.classList.remove("mdc-elevation--z" + change.previousValue);
            }
            this.elementRef.nativeElement.classList.add("mdc-elevation--z" + change.currentValue);
        };
        MdcElevation.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcElevation]',
                        exportAs: 'mdcElevation'
                    },] },
        ];
        /** @nocollapse */
        MdcElevation.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcElevation.propDecorators = {
            mdcElevation: [{ type: core.Input }]
        };
        return MdcElevation;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcElevationModule = /** @class */ (function () {
        function MdcElevationModule() {
        }
        MdcElevationModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcElevation],
                        declarations: [MdcElevation]
                    },] },
        ];
        return MdcElevationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcFabLabel = /** @class */ (function () {
        function MdcFabLabel() {
        }
        MdcFabLabel.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-fab-label, [mdcFabLabel]',
                        host: { 'class': 'mdc-fab__label' }
                    },] },
        ];
        return MdcFabLabel;
    }());
    var MdcFab = /** @class */ (function () {
        function MdcFab(_changeDetectionRef, elementRef, _ripple) {
            this._changeDetectionRef = _changeDetectionRef;
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this._mini = false;
            this._exited = false;
            this._extended = false;
            this._fluid = false;
            this._position = null;
        }
        Object.defineProperty(MdcFab.prototype, "mini", {
            get: /**
             * @return {?}
             */
            function () { return this._mini; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._mini = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "exited", {
            get: /**
             * @return {?}
             */
            function () { return this._exited; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._exited = toBoolean(value);
                this._changeDetectionRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "extended", {
            get: /**
             * @return {?}
             */
            function () { return this._extended; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._extended = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "fluid", {
            get: /**
             * @return {?}
             */
            function () { return this._fluid; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fluid = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "position", {
            get: /**
             * @return {?}
             */
            function () { return this._position; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._position) {
                    this._getHostElement().classList.remove("ngx-mdc-fab--" + this._convertPosition(this._position));
                }
                if (value) {
                    this._getHostElement().classList.add("ngx-mdc-fab--" + this._convertPosition(value));
                }
                this._position = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcFab.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.fabIcon) {
                this.fabIcon.elementRef.nativeElement.classList.add('mdc-fab__icon');
            }
            this._ripple.init({ surface: this._getHostElement() });
        };
        /**
         * @private
         * @param {?} position
         * @return {?}
         */
        MdcFab.prototype._convertPosition = /**
         * @private
         * @param {?} position
         * @return {?}
         */
        function (position) {
            switch (position) {
                case 'bottomLeft': {
                    return 'bottom-left';
                }
                case 'bottomRight': {
                    return 'bottom-right';
                }
                default: {
                    return null;
                }
            }
        };
        /**
         * @return {?}
         */
        MdcFab.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._ripple.destroy();
        };
        /**
         * @param {?=} exited
         * @return {?}
         */
        MdcFab.prototype.toggleExited = /**
         * @param {?=} exited
         * @return {?}
         */
        function (exited) {
            this._exited = exited ? exited : !this._exited;
        };
        /** Focuses the button. */
        /**
         * Focuses the button.
         * @return {?}
         */
        MdcFab.prototype.focus = /**
         * Focuses the button.
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
        };
        /**
         * @private
         * @return {?}
         */
        MdcFab.prototype._getHostElement = /**
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcFab.decorators = [
            { type: core.Component, args: [{selector: 'button[mdc-fab], a[mdc-fab]',
                        host: {
                            '[attr.tabindex]': 'exited ? -1 : 0',
                            'class': 'mdc-fab',
                            '[class.mdc-fab--mini]': 'mini',
                            '[class.mdc-fab--exited]': 'exited',
                            '[class.mdc-fab--extended]': 'extended',
                            '[class.ngx-mdc-fab-extended--fluid]': 'fluid'
                        },
                        template: "\n  <ng-content></ng-content>\n  <mdc-icon class=\"mdc-fab__icon\" *ngIf=\"icon\">{{icon}}</mdc-icon>\n  <span class=\"mdc-fab__label\" *ngIf=\"label\">{{label}}</span>\n  ",
                        providers: [MdcRipple],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcFab.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcFab.propDecorators = {
            mini: [{ type: core.Input }],
            exited: [{ type: core.Input }],
            extended: [{ type: core.Input }],
            fluid: [{ type: core.Input }],
            position: [{ type: core.Input }],
            label: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            fabIcon: [{ type: core.ContentChild, args: [MdcIcon,] }]
        };
        return MdcFab;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcFabModule = /** @class */ (function () {
        function MdcFabModule() {
        }
        MdcFabModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            MdcIconModule
                        ],
                        exports: [
                            MdcFab,
                            MdcFabLabel
                        ],
                        declarations: [MdcFab, MdcFabLabel]
                    },] },
        ];
        return MdcFabModule;
    }());

    function _classCallCheck$7(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$7(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$7(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$7(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$7(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$7(subClass, superClass);
    }

    function _getPrototypeOf$7(o) {
      _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$7(o);
    }

    function _setPrototypeOf$7(o, p) {
      _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$7(o, p);
    }

    function _assertThisInitialized$7(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$7(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$7(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$7 =
    /*#__PURE__*/
    function () {
      _createClass$7(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$7(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$7(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$7 =
    /*#__PURE__*/
    function () {
      _createClass$7(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$7());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$7(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$7(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter =
    /*#__PURE__*/
    function () {
      function MDCFloatingLabelAdapter() {
        _classCallCheck$7(this, MDCFloatingLabelAdapter);
      }

      _createClass$7(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);

      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$7 = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake',
      ROOT: 'mdc-floating-label'
    };

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$7(MDCFloatingLabelFoundation, _MDCFoundation);

      _createClass$7(MDCFloatingLabelFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$7;
        }
        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCFloatingLabelAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }
        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        var _this;

        _classCallCheck$7(this, MDCFloatingLabelFoundation);

        _this = _possibleConstructorReturn$7(this, _getPrototypeOf$7(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };

        return _this;
      }

      _createClass$7(MDCFloatingLabelFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.adapter_.getWidth();
        }
        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: "shake",
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: "handleShakeAnimationEnd_",
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);

      return MDCFloatingLabelFoundation;
    }(MDCFoundation$7);

    /**
     * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
     * @final
     */

    var MDCFloatingLabel =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$7(MDCFloatingLabel, _MDCComponent);

      function MDCFloatingLabel() {
        _classCallCheck$7(this, MDCFloatingLabel);

        return _possibleConstructorReturn$7(this, _getPrototypeOf$7(MDCFloatingLabel).apply(this, arguments));
      }

      _createClass$7(MDCFloatingLabel, [{
        key: "shake",

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake styles the label to shake by adding shake class
         * if true, otherwise will stop shaking by removing shake class.
         */
        value: function shake(shouldShake) {
          this.foundation_.shake(shouldShake);
        }
        /**
         * Styles label to float/dock.
         * @param {boolean} shouldFloat styles the label to float by adding float class
         * if true, otherwise docks the label by removing the float class.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          this.foundation_.float(shouldFloat);
        }
        /**
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.foundation_.getWidth();
        }
        /**
         * @return {!MDCFloatingLabelFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCFloatingLabelFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
              return _this.root_.scrollWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCFloatingLabel}
         */
        value: function attachTo(root) {
          return new MDCFloatingLabel(root);
        }
      }]);

      return MDCFloatingLabel;
    }(MDCComponent$7);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcFloatingLabel = /** @class */ (function () {
        function MdcFloatingLabel(_ngZone, elementRef) {
            this._ngZone = _ngZone;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
        }
        /**
         * @private
         * @return {?}
         */
        MdcFloatingLabel.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                getWidth: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().scrollWidth; })
            };
        };
        /**
         * @return {?}
         */
        MdcFloatingLabel.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._foundation = new MDCFloatingLabelFoundation(this._createAdapter());
            this._loadListeners();
        };
        /**
         * @return {?}
         */
        MdcFloatingLabel.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
        };
        /** Returns the width of the label element. */
        /**
         * Returns the width of the label element.
         * @return {?}
         */
        MdcFloatingLabel.prototype.getWidth = /**
         * Returns the width of the label element.
         * @return {?}
         */
        function () {
            return this._foundation.getWidth();
        };
        /** Styles the label to produce the label shake for errors. */
        /**
         * Styles the label to produce the label shake for errors.
         * @param {?} shouldShake
         * @return {?}
         */
        MdcFloatingLabel.prototype.shake = /**
         * Styles the label to produce the label shake for errors.
         * @param {?} shouldShake
         * @return {?}
         */
        function (shouldShake) {
            this._foundation.shake(shouldShake);
        };
        /** Styles the label to float or dock. */
        /**
         * Styles the label to float or dock.
         * @param {?} shouldFloat
         * @return {?}
         */
        MdcFloatingLabel.prototype.float = /**
         * Styles the label to float or dock.
         * @param {?} shouldFloat
         * @return {?}
         */
        function (shouldFloat) {
            this._foundation.float(shouldFloat);
        };
        /**
         * @private
         * @return {?}
         */
        MdcFloatingLabel.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._getHostElement(), 'animationend')
                    .pipe(operators.takeUntil(_this._destroy), operators.filter((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    return e.target === _this._getHostElement();
                })))
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this._foundation.handleShakeAnimationEnd_(); })); }));
            }));
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcFloatingLabel.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcFloatingLabel.decorators = [
            { type: core.Directive, args: [{
                        selector: 'label[mdcFloatingLabel], mdc-floating-label',
                        exportAs: 'mdcFloatingLabel',
                        host: {
                            'class': 'mdc-floating-label',
                            '[for]': 'for'
                        }
                    },] },
        ];
        /** @nocollapse */
        MdcFloatingLabel.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ElementRef }
        ]; };
        MdcFloatingLabel.propDecorators = {
            for: [{ type: core.Input }]
        };
        return MdcFloatingLabel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcFloatingLabelModule = /** @class */ (function () {
        function MdcFloatingLabelModule() {
        }
        MdcFloatingLabelModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcFloatingLabel],
                        declarations: [MdcFloatingLabel]
                    },] },
        ];
        return MdcFloatingLabelModule;
    }());

    function _classCallCheck$8(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$8(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$8(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$8(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$8(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$8(subClass, superClass);
    }

    function _getPrototypeOf$8(o) {
      _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$8(o);
    }

    function _setPrototypeOf$8(o, p) {
      _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$8(o, p);
    }

    function _assertThisInitialized$8(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$8(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$8(self);
    }

    function _superPropBase$3(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$8(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$3(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$3 = Reflect.get;
      } else {
        _get$3 = function _get(target, property, receiver) {
          var base = _superPropBase$3(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$3(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$8 =
    /*#__PURE__*/
    function () {
      _createClass$8(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$8(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$8(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$8 =
    /*#__PURE__*/
    function () {
      _createClass$8(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$8());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$8(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$8(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Icon Button Toggle. Provides an interface for managing
     * - classes
     * - dom
     * - inner text
     * - event handlers
     * - event dispatch
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCIconButtonToggleAdapter =
    /*#__PURE__*/
    function () {
      function MDCIconButtonToggleAdapter() {
        _classCallCheck$8(this, MDCIconButtonToggleAdapter);
      }

      _createClass$8(MDCIconButtonToggleAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         * */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * @param {string} attrName
         * @param {string} attrValue
         */

      }, {
        key: "setAttr",
        value: function setAttr(attrName, attrValue) {}
        /** @param {!IconButtonToggleEvent} evtData */

      }, {
        key: "notifyChange",
        value: function notifyChange(evtData) {}
      }]);

      return MDCIconButtonToggleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$8 = {
      ROOT: 'mdc-icon-button',
      ICON_BUTTON_ON: 'mdc-icon-button--on'
    };
    /** @enum {string} */

    var strings$7 = {
      ARIA_PRESSED: 'aria-pressed',
      CHANGE_EVENT: 'MDCIconButtonToggle:change'
    };

    /**
     * @extends {MDCFoundation<!MDCIconButtonToggleAdapter>}
     */

    var MDCIconButtonToggleFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$8(MDCIconButtonToggleFoundation, _MDCFoundation);

      _createClass$8(MDCIconButtonToggleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$8;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$7;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            notifyChange: function notifyChange() {}
          };
        }
      }]);

      function MDCIconButtonToggleFoundation(adapter) {
        var _this;

        _classCallCheck$8(this, MDCIconButtonToggleFoundation);

        _this = _possibleConstructorReturn$8(this, _getPrototypeOf$8(MDCIconButtonToggleFoundation).call(this, Object.assign(MDCIconButtonToggleFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.disabled_ = false;
        return _this;
      }

      _createClass$8(MDCIconButtonToggleFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.setAttr(strings$7.ARIA_PRESSED, "".concat(this.isOn()));
        }
      }, {
        key: "handleClick",
        value: function handleClick() {
          this.toggle();
          this.adapter_.notifyChange(
          /** @type {!IconButtonToggleEvent} */
          {
            isOn: this.isOn()
          });
        }
        /** @return {boolean} */

      }, {
        key: "isOn",
        value: function isOn() {
          return this.adapter_.hasClass(cssClasses$8.ICON_BUTTON_ON);
        }
        /** @param {boolean=} isOn */

      }, {
        key: "toggle",
        value: function toggle() {
          var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.isOn();

          if (isOn) {
            this.adapter_.addClass(cssClasses$8.ICON_BUTTON_ON);
          } else {
            this.adapter_.removeClass(cssClasses$8.ICON_BUTTON_ON);
          }

          this.adapter_.setAttr(strings$7.ARIA_PRESSED, "".concat(isOn));
        }
      }]);

      return MDCIconButtonToggleFoundation;
    }(MDCFoundation$8);

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$4 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$8(this, MDCRippleAdapter);
      }

      _createClass$8(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1$5 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$5 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$4 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$4;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$4;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$4(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$4(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$4;

      if (typeof supportsCssVariables_$4 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$4(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$4 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$4() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$4 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$4 = isSupported;
      }

      return supportsPassive_$4 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$4(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$4(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$5 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$5 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$4 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$4 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$8(MDCRippleFoundation, _MDCFoundation);

      _createClass$8(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$5;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$5;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$4;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$8(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$8(this, _getPrototypeOf$8(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$8(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$5.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$5.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$5.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$5.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$4.length > 0 && activatedTargets$4.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$4.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$4 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$4(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$4.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$8);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$4 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$8(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$8(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$8(this, (_getPrototypeOf2 = _getPrototypeOf$8(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$8(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$4(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$4(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$4(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$4());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$4());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$4());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$4());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$8);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$4 = function RippleCapableSurface() {
      _classCallCheck$8(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$4.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$4.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$4.prototype.disabled;

    /**
     * @extends {MDCComponent<!MDCIconButtonToggleFoundation>}
     */

    var MDCIconButtonToggle =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$8(MDCIconButtonToggle, _MDCComponent);

      _createClass$8(MDCIconButtonToggle, null, [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCIconButtonToggle(root);
        }
      }]);

      function MDCIconButtonToggle() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$8(this, MDCIconButtonToggle);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$8(this, (_getPrototypeOf2 = _getPrototypeOf$8(MDCIconButtonToggle)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        /** @private {!Function} */

        _this.handleClick_;
        return _this;
      }
      /**
       * @return {!MDCRipple}
       * @private
       */


      _createClass$8(MDCIconButtonToggle, [{
        key: "initRipple_",
        value: function initRipple_() {
          var ripple = new MDCRipple$4(this.root_);
          ripple.unbounded = true;
          return ripple;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('click', this.handleClick_);
          this.ripple_.destroy();

          _get$3(_getPrototypeOf$8(MDCIconButtonToggle.prototype), "destroy", this).call(this);
        }
        /** @return {!MDCIconButtonToggleFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCIconButtonToggleFoundation({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            setAttr: function setAttr(attrName, attrValue) {
              return _this2.root_.setAttribute(attrName, attrValue);
            },
            notifyChange: function notifyChange(evtData) {
              return _this2.emit(MDCIconButtonToggleFoundation.strings.CHANGE_EVENT, evtData);
            }
          });
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
          this.root_.addEventListener('click', this.handleClick_);
        }
        /** @return {!MDCRipple} */

      }, {
        key: "ripple",
        get: function get() {
          return this.ripple_;
        }
        /** @return {boolean} */

      }, {
        key: "on",
        get: function get() {
          return this.foundation_.isOn();
        }
        /** @param {boolean} isOn */
        ,
        set: function set(isOn) {
          this.foundation_.toggle(isOn);
        }
      }]);

      return MDCIconButtonToggle;
    }(MDCComponent$8);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return MdcIconButton; })),
        multi: true
    };
    /**
     * Change event object emitted by MdcIconButton.
     */
    var   /**
     * Change event object emitted by MdcIconButton.
     */
    MdcIconButtonChange = /** @class */ (function () {
        function MdcIconButtonChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return MdcIconButtonChange;
    }());
    /** @type {?} */
    var nextUniqueId$3 = 0;
    var MdcIconOn = /** @class */ (function () {
        function MdcIconOn() {
        }
        MdcIconOn.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcIconOn]',
                        host: { 'class': 'mdc-icon-button__icon--on' }
                    },] },
        ];
        return MdcIconOn;
    }());
    var MdcIconButton = /** @class */ (function () {
        function MdcIconButton(_changeDetectorRef, elementRef, ripple) {
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this.ripple = ripple;
            this._uniqueId = "mdc-icon-button-" + ++nextUniqueId$3;
            this.id = this._uniqueId;
            this.name = null;
            this.icon = null;
            this._on = false;
            this._disabled = false;
            this.change = new core.EventEmitter();
            /**
             * Subscription to changes in icons.
             */
            this._changeSubscription = null;
            this._onChange = (/**
             * @return {?}
             */
            function () { });
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
            this._foundation = new MDCIconButtonToggleFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcIconButton.prototype, "inputId", {
            get: /**
             * @return {?}
             */
            function () { return "" + (this.id || this._uniqueId); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "on", {
            get: /**
             * @return {?}
             */
            function () { return this._on; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setOn(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcIconButton.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                setAttr: (/**
                 * @param {?} name
                 * @param {?} value
                 * @return {?}
                 */
                function (name, value) { return _this._getHostElement().setAttribute(name, value); }),
                notifyChange: (/**
                 * @param {?} evtData
                 * @return {?}
                 */
                function (evtData) {
                    _this.change.emit(new MdcIconButtonChange(_this, evtData.isOn));
                    _this._onChange(_this._foundation.isOn());
                })
            };
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            this._foundation.toggle(this._on || this._foundation.isOn());
            this.ripple.init({ surface: this._getHostElement(), unbounded: true });
            this._changeDetectorRef.detectChanges();
            // When the icons change, re-subscribe
            this._changeSubscription = this.icons.changes.pipe(operators.startWith(null)).subscribe((/**
             * @return {?}
             */
            function () {
                _this.icons.forEach((/**
                 * @param {?} icon
                 * @return {?}
                 */
                function (icon) {
                    icon.elementRef.nativeElement.classList.add('mdc-icon-button__icon');
                    icon.tabIndex = null;
                    icon.role = null;
                }));
            }));
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._changeSubscription) {
                this._changeSubscription.unsubscribe();
            }
            this.ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcIconButton.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._onChange(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcIconButton.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcIconButton.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?=} isOn
         * @return {?}
         */
        MdcIconButton.prototype.toggle = /**
         * @param {?=} isOn
         * @return {?}
         */
        function (isOn) {
            this.on = isOn ? toBoolean(isOn) : !this.on;
            this._foundation.toggle(this.on);
        };
        /**
         * @param {?} on
         * @return {?}
         */
        MdcIconButton.prototype.setOn = /**
         * @param {?} on
         * @return {?}
         */
        function (on) {
            this._on = toBoolean(on);
            this._foundation.toggle(this.on);
            this._changeDetectorRef.markForCheck();
        };
        /** Sets the button disabled state */
        /**
         * Sets the button disabled state
         * @param {?} disabled
         * @return {?}
         */
        MdcIconButton.prototype.setDisabled = /**
         * Sets the button disabled state
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = toBoolean(disabled);
            this.disabled ? this._getHostElement().setAttribute('disabled', '') :
                this._getHostElement().removeAttribute('disabled');
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype.handleClick = /**
         * @return {?}
         */
        function () {
            if (this.icons.length === 1) {
                return;
            }
            this.on = !this.on;
            this._foundation.handleClick();
        };
        /**
         * @private
         * @return {?}
         */
        MdcIconButton.prototype._getHostElement = /**
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcIconButton.decorators = [
            { type: core.Component, args: [{selector: '[mdc-icon-button], button[mdcIconButton], a[mdcIconButton]',
                        exportAs: 'mdcIconButton',
                        host: {
                            '[id]': 'id',
                            'class': 'mdc-icon-button',
                            '[class.mdc-icon-button--on]': 'on',
                            'attr.aria-pressed': 'false',
                            '(click)': 'handleClick()'
                        },
                        template: "\n  <mdc-icon *ngIf=\"icon\">{{icon}}</mdc-icon>\n  <ng-content></ng-content>",
                        providers: [
                            MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR,
                            MdcRipple
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcIconButton.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcIconButton.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            on: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            change: [{ type: core.Output }],
            icons: [{ type: core.ContentChildren, args: [MdcIcon, { descendants: true },] }]
        };
        return MdcIconButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICON_BUTTON_DECLARATIONS = [
        MdcIconButton,
        MdcIconOn
    ];
    var MdcIconButtonModule = /** @class */ (function () {
        function MdcIconButtonModule() {
        }
        MdcIconButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            MdcIconModule
                        ],
                        exports: ICON_BUTTON_DECLARATIONS.concat([
                            MdcIconModule
                        ]),
                        declarations: ICON_BUTTON_DECLARATIONS
                    },] },
        ];
        return MdcIconButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcImageListItem = /** @class */ (function () {
        function MdcImageListItem(elementRef) {
            this.elementRef = elementRef;
        }
        MdcImageListItem.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListItem], mdc-image-list-item',
                        exportAs: 'mdcImageListItem',
                        host: { 'class': 'mdc-image-list__item' }
                    },] },
        ];
        /** @nocollapse */
        MdcImageListItem.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcImageListItem;
    }());
    var MdcImageListImageAspect = /** @class */ (function () {
        function MdcImageListImageAspect(elementRef) {
            this.elementRef = elementRef;
        }
        MdcImageListImageAspect.decorators = [
            { type: core.Component, args: [{selector: '[mdcImageListImageAspect], mdc-image-list-image-aspect',
                        exportAs: 'mdcImageListImageAspect',
                        template: "\n  <div class=\"mdc-image-list__image-aspect-container\">\n    <ng-content></ng-content>\n  </div>\n  ",
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcImageListImageAspect.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcImageListImageAspect;
    }());
    var MdcImageListImage = /** @class */ (function () {
        function MdcImageListImage(elementRef) {
            this.elementRef = elementRef;
        }
        MdcImageListImage.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListImage], mdc-image-list-image',
                        exportAs: 'mdcImageListImage',
                        host: { 'class': 'mdc-image-list__image' }
                    },] },
        ];
        /** @nocollapse */
        MdcImageListImage.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcImageListImage;
    }());
    var MdcImageListSupporting = /** @class */ (function () {
        function MdcImageListSupporting(elementRef) {
            this.elementRef = elementRef;
        }
        MdcImageListSupporting.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListSupporting], mdc-image-list-supporting',
                        exportAs: 'mdcImageListSupporting',
                        host: { 'class': 'mdc-image-list__supporting' }
                    },] },
        ];
        /** @nocollapse */
        MdcImageListSupporting.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcImageListSupporting;
    }());
    var MdcImageListLabel = /** @class */ (function () {
        function MdcImageListLabel(elementRef) {
            this.elementRef = elementRef;
        }
        MdcImageListLabel.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListLabel], mdc-image-list-label',
                        exportAs: 'mdcImageListLabel',
                        host: { 'class': 'mdc-image-list__label' }
                    },] },
        ];
        /** @nocollapse */
        MdcImageListLabel.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcImageListLabel;
    }());
    var MdcImageList = /** @class */ (function () {
        function MdcImageList(elementRef) {
            this.elementRef = elementRef;
            this._masonry = false;
            this._textProtection = false;
        }
        Object.defineProperty(MdcImageList.prototype, "masonry", {
            get: /**
             * @return {?}
             */
            function () { return this._masonry; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._masonry = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcImageList.prototype, "textProtection", {
            get: /**
             * @return {?}
             */
            function () { return this._textProtection; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._textProtection = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcImageList.decorators = [
            { type: core.Component, args: [{selector: '[mdc-image-list], mdc-image-list',
                        exportAs: 'mdcImageList',
                        host: {
                            'class': 'mdc-image-list',
                            '[class.mdc-image-list--masonry]': 'masonry',
                            '[class.mdc-image-list--with-text-protection]': 'textProtection'
                        },
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcImageList.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcImageList.propDecorators = {
            masonry: [{ type: core.Input }],
            textProtection: [{ type: core.Input }]
        };
        return MdcImageList;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var IMAGE_LIST_DECLARATIONS = [
        MdcImageList,
        MdcImageListImage,
        MdcImageListImageAspect,
        MdcImageListItem,
        MdcImageListLabel,
        MdcImageListSupporting
    ];
    var MdcImageListModule = /** @class */ (function () {
        function MdcImageListModule() {
        }
        MdcImageListModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: IMAGE_LIST_DECLARATIONS,
                        declarations: IMAGE_LIST_DECLARATIONS,
                    },] },
        ];
        return MdcImageListModule;
    }());

    function _classCallCheck$9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$9(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$9(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$9(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$9(subClass, superClass);
    }

    function _getPrototypeOf$9(o) {
      _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$9(o);
    }

    function _setPrototypeOf$9(o, p) {
      _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$9(o, p);
    }

    function _assertThisInitialized$9(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$9(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$9(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$9 =
    /*#__PURE__*/
    function () {
      _createClass$9(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$9(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$9(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$9 =
    /*#__PURE__*/
    function () {
      _createClass$9(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$9());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$9(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$9(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC TextField Line Ripple.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the line ripple into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCLineRippleAdapter =
    /*#__PURE__*/
    function () {
      function MDCLineRippleAdapter() {
        _classCallCheck$9(this, MDCLineRippleAdapter);
      }

      _createClass$9(MDCLineRippleAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the line ripple element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the line ripple element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the style property with propertyName to value on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(propertyName, value) {}
        /**
         * Registers an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
      }]);

      return MDCLineRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$9 = {
      LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
      LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
    };

    /**
     * @extends {MDCFoundation<!MDCLineRippleAdapter>}
     * @final
     */

    var MDCLineRippleFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$9(MDCLineRippleFoundation, _MDCFoundation);

      _createClass$9(MDCLineRippleFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$9;
        }
        /**
         * {@see MDCLineRippleAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCLineRippleAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCLineRippleAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setStyle: function setStyle() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {}
            }
          );
        }
        /**
         * @param {!MDCLineRippleAdapter=} adapter
         */

      }]);

      function MDCLineRippleFoundation(adapter) {
        var _this;

        _classCallCheck$9(this, MDCLineRippleFoundation);

        _this = _possibleConstructorReturn$9(this, _getPrototypeOf$9(MDCLineRippleFoundation).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };

        return _this;
      }

      _createClass$9(MDCLineRippleFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        }
        /**
         * Activates the line ripple
         */

      }, {
        key: "activate",
        value: function activate() {
          this.adapter_.removeClass(cssClasses$9.LINE_RIPPLE_DEACTIVATING);
          this.adapter_.addClass(cssClasses$9.LINE_RIPPLE_ACTIVE);
        }
        /**
         * Sets the center of the ripple animation to the given X coordinate.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.addClass(cssClasses$9.LINE_RIPPLE_DEACTIVATING);
        }
        /**
         * Handles a transition end event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Wait for the line ripple to be either transparent or opaque
          // before emitting the animation end event
          var isDeactivating = this.adapter_.hasClass(cssClasses$9.LINE_RIPPLE_DEACTIVATING);

          if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
              this.adapter_.removeClass(cssClasses$9.LINE_RIPPLE_ACTIVE);
              this.adapter_.removeClass(cssClasses$9.LINE_RIPPLE_DEACTIVATING);
            }
          }
        }
      }]);

      return MDCLineRippleFoundation;
    }(MDCFoundation$9);

    /**
     * @extends {MDCComponent<!MDCLineRippleFoundation>}
     * @final
     */

    var MDCLineRipple =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$9(MDCLineRipple, _MDCComponent);

      function MDCLineRipple() {
        _classCallCheck$9(this, MDCLineRipple);

        return _possibleConstructorReturn$9(this, _getPrototypeOf$9(MDCLineRipple).apply(this, arguments));
      }

      _createClass$9(MDCLineRipple, [{
        key: "activate",

        /**
         * Activates the line ripple
         */
        value: function activate() {
          this.foundation_.activate();
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Sets the transform origin given a user's click location. The `rippleCenter` is the
         * x-coordinate of the middle of the ripple.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.foundation_.setRippleCenter(xCoordinate);
        }
        /**
         * @return {!MDCLineRippleFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLineRippleFoundation(
          /** @type {!MDCLineRippleAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setStyle: function setStyle(propertyName, value) {
              return _this.root_.style[propertyName] = value;
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          }));
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCLineRipple}
         */
        value: function attachTo(root) {
          return new MDCLineRipple(root);
        }
      }]);

      return MDCLineRipple;
    }(MDCComponent$9);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcLineRipple = /** @class */ (function () {
        function MdcLineRipple(_ngZone, elementRef) {
            this._ngZone = _ngZone;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._foundation = new MDCLineRippleFoundation(this._createAdapter());
        }
        /**
         * @private
         * @return {?}
         */
        MdcLineRipple.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                setStyle: (/**
                 * @param {?} propertyName
                 * @param {?} value
                 * @return {?}
                 */
                function (propertyName, value) { return _this._getHostElement().style.setProperty(propertyName, value); })
            };
        };
        /**
         * @return {?}
         */
        MdcLineRipple.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._loadListeners();
        };
        /**
         * @return {?}
         */
        MdcLineRipple.prototype.destroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
        };
        /**
         * @return {?}
         */
        MdcLineRipple.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroy();
        };
        /** Activates the line ripple */
        /**
         * Activates the line ripple
         * @return {?}
         */
        MdcLineRipple.prototype.activate = /**
         * Activates the line ripple
         * @return {?}
         */
        function () {
            this._foundation.activate();
        };
        /** Deactivates the line ripple */
        /**
         * Deactivates the line ripple
         * @return {?}
         */
        MdcLineRipple.prototype.deactivate = /**
         * Deactivates the line ripple
         * @return {?}
         */
        function () {
            this._foundation.deactivate();
        };
        /**
         * Sets the transform origin given a user's click location.
         * The `rippleCenter` is the x-coordinate of the middle of the ripple.
         */
        /**
         * Sets the transform origin given a user's click location.
         * The `rippleCenter` is the x-coordinate of the middle of the ripple.
         * @param {?} xCoordinate
         * @return {?}
         */
        MdcLineRipple.prototype.setRippleCenter = /**
         * Sets the transform origin given a user's click location.
         * The `rippleCenter` is the x-coordinate of the middle of the ripple.
         * @param {?} xCoordinate
         * @return {?}
         */
        function (xCoordinate) {
            this._foundation.setRippleCenter(xCoordinate);
        };
        /**
         * @private
         * @return {?}
         */
        MdcLineRipple.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._getHostElement(), 'transitionend')
                    .pipe(operators.takeUntil(_this._destroy), operators.filter((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    return e.target === _this._getHostElement();
                })))
                    .subscribe((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this._foundation.handleTransitionEnd(evt); })); }));
            }));
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcLineRipple.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcLineRipple.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcLineRipple], mdc-line-ripple',
                        exportAs: 'mdcLineRipple',
                        host: { 'class': 'mdc-line-ripple' }
                    },] },
        ];
        /** @nocollapse */
        MdcLineRipple.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ElementRef }
        ]; };
        return MdcLineRipple;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcLineRippleModule = /** @class */ (function () {
        function MdcLineRippleModule() {
        }
        MdcLineRippleModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcLineRipple],
                        declarations: [MdcLineRipple]
                    },] },
        ];
        return MdcLineRippleModule;
    }());

    function _classCallCheck$a(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$a(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$a(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$a(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$a(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$a(subClass, superClass);
    }

    function _getPrototypeOf$a(o) {
      _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$a(o);
    }

    function _setPrototypeOf$a(o, p) {
      _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$a(o, p);
    }

    function _assertThisInitialized$a(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$a(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$a(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$a =
    /*#__PURE__*/
    function () {
      _createClass$a(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$a(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$a(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$a =
    /*#__PURE__*/
    function () {
      _createClass$a(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$a());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$a(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$a(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    // property names.


    var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$a = {
      CLOSED_CLASS: 'mdc-linear-progress--closed',
      INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
      REVERSED_CLASS: 'mdc-linear-progress--reversed'
    };
    var strings$8 = {
      PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
      BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
    };

    var MDCLinearProgressFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$a(MDCLinearProgressFoundation, _MDCFoundation);

      _createClass$a(MDCLinearProgressFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$a;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$8;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            getPrimaryBar: function getPrimaryBar()
            /* el: Element */
            {},
            getBuffer: function getBuffer()
            /* el: Element */
            {},
            hasClass: function hasClass() {
              return (
                /* className: string */
                false
              );
            },
            removeClass: function removeClass()
            /* className: string */
            {},
            setStyle: function setStyle()
            /* el: Element, styleProperty: string, value: string */
            {}
          };
        }
      }]);

      function MDCLinearProgressFoundation(adapter) {
        _classCallCheck$a(this, MDCLinearProgressFoundation);

        return _possibleConstructorReturn$a(this, _getPrototypeOf$a(MDCLinearProgressFoundation).call(this, Object.assign(MDCLinearProgressFoundation.defaultAdapter, adapter)));
      }

      _createClass$a(MDCLinearProgressFoundation, [{
        key: "init",
        value: function init() {
          this.determinate_ = !this.adapter_.hasClass(cssClasses$a.INDETERMINATE_CLASS);
          this.reverse_ = this.adapter_.hasClass(cssClasses$a.REVERSED_CLASS);
          this.progress_ = 0;
        }
      }, {
        key: "setDeterminate",
        value: function setDeterminate(isDeterminate) {
          this.determinate_ = isDeterminate;

          if (this.determinate_) {
            this.adapter_.removeClass(cssClasses$a.INDETERMINATE_CLASS);
            this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
          } else {
            this.adapter_.addClass(cssClasses$a.INDETERMINATE_CLASS);
            this.setScale_(this.adapter_.getPrimaryBar(), 1);
            this.setScale_(this.adapter_.getBuffer(), 1);
          }
        }
      }, {
        key: "setProgress",
        value: function setProgress(value) {
          this.progress_ = value;

          if (this.determinate_) {
            this.setScale_(this.adapter_.getPrimaryBar(), value);
          }
        }
      }, {
        key: "setBuffer",
        value: function setBuffer(value) {
          if (this.determinate_) {
            this.setScale_(this.adapter_.getBuffer(), value);
          }
        }
      }, {
        key: "setReverse",
        value: function setReverse(isReversed) {
          this.reverse_ = isReversed;

          if (this.reverse_) {
            this.adapter_.addClass(cssClasses$a.REVERSED_CLASS);
          } else {
            this.adapter_.removeClass(cssClasses$a.REVERSED_CLASS);
          }
        }
      }, {
        key: "open",
        value: function open() {
          this.adapter_.removeClass(cssClasses$a.CLOSED_CLASS);
        }
      }, {
        key: "close",
        value: function close() {
          this.adapter_.addClass(cssClasses$a.CLOSED_CLASS);
        }
      }, {
        key: "setScale_",
        value: function setScale_(el, scaleValue) {
          var _this = this;

          var value = 'scaleX(' + scaleValue + ')';
          transformStyleProperties.forEach(function (transformStyleProperty) {
            _this.adapter_.setStyle(el, transformStyleProperty, value);
          });
        }
      }]);

      return MDCLinearProgressFoundation;
    }(MDCFoundation$a);

    var MDCLinearProgress =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$a(MDCLinearProgress, _MDCComponent);

      function MDCLinearProgress() {
        _classCallCheck$a(this, MDCLinearProgress);

        return _possibleConstructorReturn$a(this, _getPrototypeOf$a(MDCLinearProgress).apply(this, arguments));
      }

      _createClass$a(MDCLinearProgress, [{
        key: "open",
        value: function open() {
          this.foundation_.open();
        }
      }, {
        key: "close",
        value: function close() {
          this.foundation_.close();
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLinearProgressFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            getPrimaryBar: function getPrimaryBar() {
              return _this.root_.querySelector(MDCLinearProgressFoundation.strings.PRIMARY_BAR_SELECTOR);
            },
            getBuffer: function getBuffer() {
              return _this.root_.querySelector(MDCLinearProgressFoundation.strings.BUFFER_SELECTOR);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            setStyle: function setStyle(el, styleProperty, value) {
              return el.style[styleProperty] = value;
            }
          });
        }
      }, {
        key: "determinate",
        set: function set(value) {
          this.foundation_.setDeterminate(value);
        }
      }, {
        key: "progress",
        set: function set(value) {
          this.foundation_.setProgress(value);
        }
      }, {
        key: "buffer",
        set: function set(value) {
          this.foundation_.setBuffer(value);
        }
      }, {
        key: "reverse",
        set: function set(value) {
          this.foundation_.setReverse(value);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCLinearProgress(root);
        }
      }]);

      return MDCLinearProgress;
    }(MDCComponent$a);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcLinearProgress = /** @class */ (function () {
        function MdcLinearProgress(_changeDetectorRef, elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._open = true;
            this._determinate = false;
            this._reversed = false;
            this.secondary = false;
            this._progress = 0;
            this._buffer = 0;
            this._foundation = new MDCLinearProgressFoundation(this.createAdapter());
        }
        Object.defineProperty(MdcLinearProgress.prototype, "open", {
            get: /**
             * @return {?}
             */
            function () { return this._open; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._open !== value) {
                    this._open = toBoolean(value);
                    this._open ? this._foundation.open() : this._foundation.close();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "determinate", {
            get: /**
             * @return {?}
             */
            function () { return this._determinate; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._determinate = toBoolean(value);
                this._foundation.setDeterminate(this._determinate);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "reversed", {
            get: /**
             * @return {?}
             */
            function () { return this._reversed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._reversed = toBoolean(value);
                this._foundation.setReverse(this._reversed);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "progress", {
            get: /**
             * @return {?}
             */
            function () { return this._progress; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._progress = toNumber(value);
                this._foundation.setProgress(this._progress);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "buffer", {
            get: /**
             * @return {?}
             */
            function () { return this._buffer; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._buffer = toNumber(value);
                this._foundation.setBuffer(this._buffer);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcLinearProgress.prototype.createAdapter = /**
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                getPrimaryBar: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().querySelector('.mdc-linear-progress__primary-bar'); }),
                getBuffer: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().querySelector('.mdc-linear-progress__buffer'); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                setStyle: (/**
                 * @param {?} el
                 * @param {?} styleProperty
                 * @param {?} value
                 * @return {?}
                 */
                function (el, styleProperty, value) { return el.style.setProperty(styleProperty, value); })
            };
        };
        /**
         * @return {?}
         */
        MdcLinearProgress.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcLinearProgress.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._foundation.destroy();
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcLinearProgress.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcLinearProgress.decorators = [
            { type: core.Component, args: [{selector: 'mdc-linear-progress',
                        exportAs: 'mdcLinearProgress',
                        host: {
                            'role': 'progressbar',
                            'class': 'mdc-linear-progress',
                            '[class.mdc-linear-progress--secondary]': 'secondary',
                            '[class.mdc-linear-progress--indeterminate]': '!determinate'
                        },
                        template: "\n  <div class=\"mdc-linear-progress__buffering-dots\"></div>\n  <div class=\"mdc-linear-progress__buffer\"></div>\n  <div class=\"mdc-linear-progress__bar mdc-linear-progress__primary-bar\">\n   <span class=\"mdc-linear-progress__bar-inner\"></span>\n  </div>\n  <div class=\"mdc-linear-progress__bar mdc-linear-progress__secondary-bar\">\n   <span class=\"mdc-linear-progress__bar-inner\"></span>\n  </div>\n  ",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcLinearProgress.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcLinearProgress.propDecorators = {
            open: [{ type: core.Input }],
            determinate: [{ type: core.Input }],
            reversed: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            progress: [{ type: core.Input }],
            buffer: [{ type: core.Input }]
        };
        return MdcLinearProgress;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcLinearProgressModule = /** @class */ (function () {
        function MdcLinearProgressModule() {
        }
        MdcLinearProgressModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcLinearProgress],
                        declarations: [MdcLinearProgress]
                    },] },
        ];
        return MdcLinearProgressModule;
    }());

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @type {string|undefined} */
    var storedTransformPropertyName_;
    /**
     * Returns the name of the correct transform property to use on the current browser.
     * @param {!Window} globalObj
     * @param {boolean=} forceRefresh
     * @return {string}
     */

    function getTransformPropertyName(globalObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (storedTransformPropertyName_ === undefined || forceRefresh) {
        var el = globalObj.document.createElement('div');
        var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
        storedTransformPropertyName_ = transformPropertyName;
      }

      return storedTransformPropertyName_;
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$b = {
      ANCHOR: 'mdc-menu-surface--anchor',
      ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
      ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
      FIXED: 'mdc-menu-surface--fixed',
      OPEN: 'mdc-menu-surface--open',
      ROOT: 'mdc-menu-surface'
    };
    /** @enum {string} */

    var strings$9 = {
      CLOSED_EVENT: 'MDCMenuSurface:closed',
      OPENED_EVENT: 'MDCMenuSurface:opened',
      FOCUSABLE_ELEMENTS: 'button:not(:disabled), [href]:not([aria-disabled="true"]), input:not(:disabled), ' + 'select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
    };
    /** @enum {number} */

    var numbers$5 = {
      // Total duration of menu-surface open animation.
      TRANSITION_OPEN_DURATION: 120,
      // Total duration of menu-surface close animation.
      TRANSITION_CLOSE_DURATION: 75,
      // Margin left to the edge of the viewport when menu-surface is at maximum possible height.
      MARGIN_TO_EDGE: 32,
      // Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning.
      ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
    };
    /**
     * Enum for bits in the {@see Corner) bitmap.
     * @enum {number}
     */

    var CornerBit = {
      BOTTOM: 1,
      CENTER: 2,
      RIGHT: 4,
      FLIP_RTL: 8
    };
    /**
     * Enum for representing an element corner for positioning the menu-surface.
     *
     * The START constants map to LEFT if element directionality is left
     * to right and RIGHT if the directionality is right to left.
     * Likewise END maps to RIGHT or LEFT depending on the directionality.
     *
     * @enum {number}
     */

    var Corner = {
      TOP_LEFT: 0,
      TOP_RIGHT: CornerBit.RIGHT,
      BOTTOM_LEFT: CornerBit.BOTTOM,
      BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
      TOP_START: CornerBit.FLIP_RTL,
      TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
      BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
      BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
    };

    function _classCallCheck$b(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$b(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$b(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$b(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits$b(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$b(subClass, superClass);
    }

    function _getPrototypeOf$b(o) {
      _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$b(o);
    }

    function _setPrototypeOf$b(o, p) {
      _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$b(o, p);
    }

    function _assertThisInitialized$b(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$b(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$b(self);
    }

    function _superPropBase$4(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$b(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$4(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$4 = Reflect.get;
      } else {
        _get$4 = function _get(target, property, receiver) {
          var base = _superPropBase$4(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$4(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$b =
    /*#__PURE__*/
    function () {
      _createClass$b(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$b(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$b(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$b =
    /*#__PURE__*/
    function () {
      _createClass$b(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$b());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$b(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$b(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDCMenuSurface. Provides an interface for managing
     * - classes
     * - dom
     * - focus
     * - position
     * - dimensions
     * - event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCMenuSurfaceAdapter =
    /*#__PURE__*/
    function () {
      function MDCMenuSurfaceAdapter() {
        _classCallCheck$b(this, MDCMenuSurfaceAdapter);
      }

      _createClass$b(MDCMenuSurfaceAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /** @return {boolean} */

      }, {
        key: "hasAnchor",
        value: function hasAnchor() {}
        /** Emits an event when the menu surface is closed. */

      }, {
        key: "notifyClose",
        value: function notifyClose() {}
        /** Emits an event when the menu surface is opened. */

      }, {
        key: "notifyOpen",
        value: function notifyOpen() {}
        /**
         * @return {boolean}
         * @param {EventTarget} el
         */

      }, {
        key: "isElementInContainer",
        value: function isElementInContainer(el) {}
        /** @return {boolean} */

      }, {
        key: "isRtl",
        value: function isRtl() {}
        /** @param {string} origin */

      }, {
        key: "setTransformOrigin",
        value: function setTransformOrigin(origin) {}
        /** @return {boolean} */

      }, {
        key: "isFocused",
        value: function isFocused() {}
        /** Saves the element that was focused before the menu surface was opened. */

      }, {
        key: "saveFocus",
        value: function saveFocus() {}
        /** Restores focus to the element that was focused before the menu surface was opened. */

      }, {
        key: "restoreFocus",
        value: function restoreFocus() {}
        /** @return {boolean} */

      }, {
        key: "isFirstElementFocused",
        value: function isFirstElementFocused() {}
        /** @return {boolean} */

      }, {
        key: "isLastElementFocused",
        value: function isLastElementFocused() {}
        /** Focuses the first focusable element in the menu-surface. */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {}
        /** Focuses the first focusable element in the menu-surface. */

      }, {
        key: "focusLastElement",
        value: function focusLastElement() {}
        /** @return {!{width: number, height: number}} */

      }, {
        key: "getInnerDimensions",
        value: function getInnerDimensions() {}
        /** @return {!{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

      }, {
        key: "getAnchorDimensions",
        value: function getAnchorDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getWindowDimensions",
        value: function getWindowDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getBodyDimensions",
        value: function getBodyDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getWindowScroll",
        value: function getWindowScroll() {}
        /** @param {!{
        *   top: (string|undefined),
        *   right: (string|undefined),
        *   bottom: (string|undefined),
        *   left: (string|undefined)
        * }} position */

      }, {
        key: "setPosition",
        value: function setPosition(position) {}
        /** @param {string} height */

      }, {
        key: "setMaxHeight",
        value: function setMaxHeight(height) {}
      }]);

      return MDCMenuSurfaceAdapter;
    }();

    /**
     * @extends {MDCFoundation<!MDCMenuSurfaceAdapter>}
     */

    var MDCMenuSurfaceFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$b(MDCMenuSurfaceFoundation, _MDCFoundation);

      _createClass$b(MDCMenuSurfaceFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          return cssClasses$b;
        }
        /** @return enum{string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$9;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$5;
        }
        /** @return enum{number} */

      }, {
        key: "Corner",
        get: function get() {
          return Corner;
        }
        /**
         * {@see MDCMenuSurfaceAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCMenuSurfaceAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCMenuSurfaceAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {
                return false;
              },
              hasAnchor: function hasAnchor() {
                return false;
              },
              notifyClose: function notifyClose() {},
              notifyOpen: function notifyOpen() {},
              isElementInContainer: function isElementInContainer() {
                return false;
              },
              isRtl: function isRtl() {
                return false;
              },
              setTransformOrigin: function setTransformOrigin() {},
              isFocused: function isFocused() {
                return false;
              },
              saveFocus: function saveFocus() {},
              restoreFocus: function restoreFocus() {},
              isFirstElementFocused: function isFirstElementFocused() {},
              isLastElementFocused: function isLastElementFocused() {},
              focusFirstElement: function focusFirstElement() {},
              focusLastElement: function focusLastElement() {},
              getInnerDimensions: function getInnerDimensions() {
                return {};
              },
              getAnchorDimensions: function getAnchorDimensions() {
                return {};
              },
              getWindowDimensions: function getWindowDimensions() {
                return {};
              },
              getBodyDimensions: function getBodyDimensions() {
                return {};
              },
              getWindowScroll: function getWindowScroll() {
                return {};
              },
              setPosition: function setPosition() {},
              setMaxHeight: function setMaxHeight() {}
            }
          );
        }
        /** @param {!MDCMenuSurfaceAdapter} adapter */

      }]);

      function MDCMenuSurfaceFoundation(adapter) {
        var _this;

        _classCallCheck$b(this, MDCMenuSurfaceFoundation);

        _this = _possibleConstructorReturn$b(this, _getPrototypeOf$b(MDCMenuSurfaceFoundation).call(this, Object.assign(MDCMenuSurfaceFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.isOpen_ = false;
        /** @private {number} */

        _this.openAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.closeAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.animationRequestId_ = 0;
        /** @private {!{ width: number, height: number }} */

        _this.dimensions_;
        /** @private {!Corner} */

        _this.anchorCorner_ = Corner.TOP_START;
        /** @private {!AnchorMargin} */

        _this.anchorMargin_ = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        /** @private {?AutoLayoutMeasurements} */

        _this.measures_ = null;
        /** @private {boolean} */

        _this.quickOpen_ = false;
        /** @private {boolean} */

        _this.hoistedElement_ = false;
        /** @private {boolean} */

        _this.isFixedPosition_ = false;
        /** @private {!{x: number, y: number}} */

        _this.position_ = {
          x: 0,
          y: 0
        };
        return _this;
      }

      _createClass$b(MDCMenuSurfaceFoundation, [{
        key: "init",
        value: function init() {
          var _MDCMenuSurfaceFounda = MDCMenuSurfaceFoundation.cssClasses,
              ROOT = _MDCMenuSurfaceFounda.ROOT,
              OPEN = _MDCMenuSurfaceFounda.OPEN;

          if (!this.adapter_.hasClass(ROOT)) {
            throw new Error("".concat(ROOT, " class required in root element."));
          }

          if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          clearTimeout(this.openAnimationEndTimerId_);
          clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.

          cancelAnimationFrame(this.animationRequestId_);
        }
        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left menu surface corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.anchorCorner_ = corner;
        }
        /**
         * @param {!AnchorMargin} margin set of margin values from anchor.
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
          this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
          this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
          this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
        }
        /**
         * Used to indicate if the menu-surface is hoisted to the body.
         * @param {boolean} isHoisted
         */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.hoistedElement_ = isHoisted;
        }
        /**
         * Used to set the menu-surface calculations based on a fixed position menu.
         * @param {boolean} isFixedPosition
         */

      }, {
        key: "setFixedPosition",
        value: function setFixedPosition(isFixedPosition) {
          this.isFixedPosition_ = isFixedPosition;
        }
        /**
         * Sets the menu-surface position on the page.
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.position_.x = this.typeCheckisFinite_(x) ? x : 0;
          this.position_.y = this.typeCheckisFinite_(y) ? y : 0;
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "setQuickOpen",
        value: function setQuickOpen(quickOpen) {
          this.quickOpen_ = quickOpen;
        }
        /**
         * Handle clicks and close if not within menu-surface element.
         * @param {!Event} evt
         */

      }, {
        key: "handleBodyClick",
        value: function handleBodyClick(evt) {
          var el = evt.target;

          if (this.adapter_.isElementInContainer(el)) {
            return;
          }

          this.close();
        }
      }, {
        key: "handleKeydown",

        /**
         * Handle keys that close the surface.
         * @param {!Event} evt
         */
        value: function handleKeydown(evt) {
          var keyCode = evt.keyCode,
              key = evt.key,
              shiftKey = evt.shiftKey;
          var isEscape = key === 'Escape' || keyCode === 27;
          var isTab = key === 'Tab' || keyCode === 9;

          if (isEscape) {
            this.close();
          } else if (isTab) {
            if (this.adapter_.isLastElementFocused() && !shiftKey) {
              this.adapter_.focusFirstElement();
              evt.preventDefault();
            } else if (this.adapter_.isFirstElementFocused() && shiftKey) {
              this.adapter_.focusLastElement();
              evt.preventDefault();
            }
          }
        }
        /**
         * @return {!AutoLayoutMeasurements} Measurements used to position menu surface popup.
         */

      }, {
        key: "getAutoLayoutMeasurements_",
        value: function getAutoLayoutMeasurements_() {
          var anchorRect = this.adapter_.getAnchorDimensions();
          var viewport = this.adapter_.getWindowDimensions();
          var bodyDimensions = this.adapter_.getBodyDimensions();
          var windowScroll = this.adapter_.getWindowScroll();

          if (!anchorRect) {
            anchorRect =
            /** @type {ClientRect} */
            {
              x: this.position_.x,
              y: this.position_.y,
              top: this.position_.y,
              bottom: this.position_.y,
              left: this.position_.x,
              right: this.position_.x,
              height: 0,
              width: 0
            };
          }

          return {
            viewport: viewport,
            bodyDimensions: bodyDimensions,
            windowScroll: windowScroll,
            viewportDistance: {
              top: anchorRect.top,
              right: viewport.width - anchorRect.right,
              left: anchorRect.left,
              bottom: viewport.height - anchorRect.bottom
            },
            anchorHeight: anchorRect.height,
            anchorWidth: anchorRect.width,
            surfaceHeight: this.dimensions_.height,
            surfaceWidth: this.dimensions_.width
          };
        }
        /**
         * Computes the corner of the anchor from which to animate and position the menu surface.
         * @return {!Corner}
         * @private
         */

      }, {
        key: "getOriginCorner_",
        value: function getOriginCorner_() {
          // Defaults: open from the top left.
          var corner = Corner.TOP_LEFT;
          var _this$measures_ = this.measures_,
              viewportDistance = _this$measures_.viewportDistance,
              anchorHeight = _this$measures_.anchorHeight,
              anchorWidth = _this$measures_.anchorWidth,
              surfaceHeight = _this$measures_.surfaceHeight,
              surfaceWidth = _this$measures_.surfaceWidth;
          var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
          var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
          var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;
          var topOverflow = surfaceHeight - availableTop;
          var bottomOverflow = surfaceHeight - availableBottom;

          if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
            corner |= CornerBit.BOTTOM;
          }

          var isRtl = this.adapter_.isRtl();
          var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
          var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
          var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
          var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;
          var leftOverflow = surfaceWidth - availableLeft;
          var rightOverflow = surfaceWidth - availableRight;

          if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
            corner |= CornerBit.RIGHT;
          }

          return (
            /** @type {Corner} */
            corner
          );
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Horizontal offset of menu surface origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getHorizontalOriginOffset_",
        value: function getHorizontalOriginOffset_(corner) {
          var anchorWidth = this.measures_.anchorWidth; // isRightAligned corresponds to using the 'right' property on the surface.

          var isRightAligned = Boolean(corner & CornerBit.RIGHT);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);

          if (isRightAligned) {
            var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right; // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
            // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
            // the right property is correct.

            if (this.hoistedElement_ || this.isFixedPosition_) {
              return rightOffset - (this.measures_.viewport.width - this.measures_.bodyDimensions.width);
            }

            return rightOffset;
          }

          return avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Vertical offset of menu surface origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getVerticalOriginOffset_",
        value: function getVerticalOriginOffset_(corner) {
          var anchorHeight = this.measures_.anchorHeight;
          var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
          var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
          var y = 0;

          if (isBottomAligned) {
            y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
          } else {
            y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
          }

          return y;
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Maximum height of the menu surface, based on available space. 0 indicates should not be set.
         * @private
         */

      }, {
        key: "getMenuSurfaceMaxHeight_",
        value: function getMenuSurfaceMaxHeight_(corner) {
          var maxHeight = 0;
          var viewportDistance = this.measures_.viewportDistance;
          var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
          var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE; // When maximum height is not specified, it is handled from css.

          if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;

            if (!(this.anchorCorner_ & CornerBit.BOTTOM)) {
              maxHeight += this.measures_.anchorHeight;
            }
          } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measures_.anchorHeight - MARGIN_TO_EDGE;

            if (this.anchorCorner_ & CornerBit.BOTTOM) {
              maxHeight -= this.measures_.anchorHeight;
            }
          }

          return maxHeight;
        }
        /** @private */

      }, {
        key: "autoPosition_",
        value: function autoPosition_() {
          var _position;

          // Compute measurements for autoposition methods reuse.
          this.measures_ = this.getAutoLayoutMeasurements_();
          var corner = this.getOriginCorner_();
          var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
          var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
          var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
          var horizontalOffset = this.getHorizontalOriginOffset_(corner);
          var verticalOffset = this.getVerticalOriginOffset_(corner);
          var position = (_position = {}, _defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset : '0'), _defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset : '0'), _position);
          var _this$measures_2 = this.measures_,
              anchorWidth = _this$measures_2.anchorWidth,
              surfaceWidth = _this$measures_2.surfaceWidth; // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.

          if (anchorWidth / surfaceWidth > numbers$5.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
            horizontalAlignment = 'center';
          } // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element


          if (this.hoistedElement_ || this.isFixedPosition_) {
            position = this.adjustPositionForHoistedElement_(position);
          }

          for (var prop in position) {
            if (position.hasOwnProperty(prop) && position[prop] !== '0') {
              position[prop] = "".concat(parseInt(position[prop], 10), "px");
            }
          }

          this.adapter_.setTransformOrigin("".concat(horizontalAlignment, " ").concat(verticalAlignment));
          this.adapter_.setPosition(position);
          this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : ''); // Clear measures after positioning is complete.

          this.measures_ = null;
        }
        /**
         * Calculates the offsets for positioning the menu-surface when the menu-surface has been
         * hoisted to the body.
         * @param {!{
         *   top: (string|undefined),
         *   right: (string|undefined),
         *   bottom: (string|undefined),
         *   left: (string|undefined)
         * }} position
         * @return {!{
         *   top: (string|undefined),
         *   right: (string|undefined),
         *   bottom: (string|undefined),
         *   left: (string|undefined)
         * }} position
         * @private
         */

      }, {
        key: "adjustPositionForHoistedElement_",
        value: function adjustPositionForHoistedElement_(position) {
          var _this$measures_3 = this.measures_,
              windowScroll = _this$measures_3.windowScroll,
              viewportDistance = _this$measures_3.viewportDistance;

          for (var prop in position) {
            if (position.hasOwnProperty(prop)) {
              // Hoisted surfaces need to have the anchor elements location on the page added to the
              // position properties for proper alignment on the body.
              if (viewportDistance.hasOwnProperty(prop)) {
                position[prop] = parseInt(position[prop], 10) + viewportDistance[prop];
              } // Surfaces that are absolutely positioned need to have additional calculations for scroll
              // and bottom positioning.


              if (!this.isFixedPosition_) {
                if (prop === 'top') {
                  position[prop] = parseInt(position[prop], 10) + windowScroll.y;
                } else if (prop === 'bottom') {
                  position[prop] = parseInt(position[prop], 10) - windowScroll.y;
                } else if (prop === 'left') {
                  position[prop] = parseInt(position[prop], 10) + windowScroll.x;
                } else if (prop === 'right') {
                  position[prop] = parseInt(position[prop], 10) - windowScroll.x;
                }
              }
            }
          }

          return position;
        }
        /**
         * Open the menu surface.
         */

      }, {
        key: "open",
        value: function open() {
          var _this2 = this;

          this.adapter_.saveFocus();

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
          }

          this.animationRequestId_ = requestAnimationFrame(function () {
            _this2.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

            _this2.dimensions_ = _this2.adapter_.getInnerDimensions();

            _this2.autoPosition_();

            if (_this2.quickOpen_) {
              _this2.adapter_.notifyOpen();
            } else {
              _this2.openAnimationEndTimerId_ = setTimeout(function () {
                _this2.openAnimationEndTimerId_ = 0;

                _this2.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);

                _this2.adapter_.notifyOpen();
              }, numbers$5.TRANSITION_OPEN_DURATION);
            }
          });
          this.isOpen_ = true;
        }
        /**
         * Closes the menu surface.
         */

      }, {
        key: "close",
        value: function close() {
          var _this3 = this;

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
          }

          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

            if (_this3.quickOpen_) {
              _this3.adapter_.notifyClose();
            } else {
              _this3.closeAnimationEndTimerId_ = setTimeout(function () {
                _this3.closeAnimationEndTimerId_ = 0;

                _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);

                _this3.adapter_.notifyClose();
              }, numbers$5.TRANSITION_CLOSE_DURATION);
            }
          });
          this.isOpen_ = false;
          this.maybeRestoreFocus_();
        }
        /**
         * The last focused element when the menu surface was opened should regain focus, if the user is
         * focused on or within the menu surface when it is closed.
         * @private
         */

      }, {
        key: "maybeRestoreFocus_",
        value: function maybeRestoreFocus_() {
          if (this.adapter_.isFocused() || this.adapter_.isElementInContainer(document.activeElement)) {
            this.adapter_.restoreFocus();
          }
        }
        /** @return {boolean} */

      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
        /**
         * isFinite that doesn't force conversion to number type.
         * Equivalent to Number.isFinite in ES2015, but is not included in IE11.
         * @param {number} num
         * @return {boolean}
         * @private
         */

      }, {
        key: "typeCheckisFinite_",
        value: function typeCheckisFinite_(num) {
          return typeof num === 'number' && isFinite(num);
        }
      }]);

      return MDCMenuSurfaceFoundation;
    }(MDCFoundation$b);

    /**
     * @extends MDCComponent<!MDCMenuSurfaceFoundation>
     */

    var MDCMenuSurface =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$b(MDCMenuSurface, _MDCComponent);

      /** @param {...?} args */
      function MDCMenuSurface() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$b(this, MDCMenuSurface);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$b(this, (_getPrototypeOf2 = _getPrototypeOf$b(MDCMenuSurface)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Element} */

        _this.previousFocus_;
        /** @private {!Element} */

        _this.anchorElement;
        /** @private {Element} */

        _this.firstFocusableElement_;
        /** @private {Element} */

        _this.lastFocusableElement_;
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleBodyClick_;
        /** @private {!Function} */

        _this.registerBodyClickListener_;
        /** @private {!Function} */

        _this.deregisterBodyClickListener_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCMenuSurface}
       */


      _createClass$b(MDCMenuSurface, [{
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          if (this.root_.parentElement && this.root_.parentElement.classList.contains(cssClasses$b.ANCHOR)) {
            this.anchorElement = this.root_.parentElement;
          }

          if (this.root_.classList.contains(cssClasses$b.FIXED)) {
            this.setFixedPosition(true);
          }

          this.handleKeydown_ = function (evt) {
            return _this2.foundation_.handleKeydown(evt);
          };

          this.handleBodyClick_ = function (evt) {
            return _this2.foundation_.handleBodyClick(evt);
          };

          this.registerBodyClickListener_ = function () {
            return document.body.addEventListener('click', _this2.handleBodyClick_);
          };

          this.deregisterBodyClickListener_ = function () {
            return document.body.removeEventListener('click', _this2.handleBodyClick_);
          };

          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener(strings$9.OPENED_EVENT, this.registerBodyClickListener_);
          this.root_.addEventListener(strings$9.CLOSED_EVENT, this.deregisterBodyClickListener_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener(strings$9.OPENED_EVENT, this.registerBodyClickListener_);
          this.root_.removeEventListener(strings$9.CLOSED_EVENT, this.deregisterBodyClickListener_);

          _get$4(_getPrototypeOf$b(MDCMenuSurface.prototype), "destroy", this).call(this);
        }
        /** @return {boolean} */

      }, {
        key: "hoistMenuToBody",

        /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         */
        value: function hoistMenuToBody() {
          document.body.appendChild(this.root_.parentElement.removeChild(this.root_));
          this.setIsHoisted(true);
        }
        /**
         * Sets the foundation to use page offsets for an positioning when the menu
         * is hoisted to the body.
         * @param {boolean} isHoisted
         */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.foundation_.setIsHoisted(isHoisted);
        }
        /**
         * Sets the element that the menu-surface is anchored to.
         * @param {!Element} element
         */

      }, {
        key: "setMenuSurfaceAnchorElement",
        value: function setMenuSurfaceAnchorElement(element) {
          this.anchorElement = element;
        }
        /**
         * Sets the menu-surface to position: fixed.
         * @param {boolean} isFixed
         */

      }, {
        key: "setFixedPosition",
        value: function setFixedPosition(isFixed) {
          if (isFixed) {
            this.root_.classList.add(cssClasses$b.FIXED);
          } else {
            this.root_.classList.remove(cssClasses$b.FIXED);
          }

          this.foundation_.setFixedPosition(isFixed);
        }
        /**
         * Sets the absolute x/y position to position based on. Requires the menu to be hoisted.
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.foundation_.setAbsolutePosition(x, y);
          this.setIsHoisted(true);
        }
        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left
         *     surface corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.foundation_.setAnchorCorner(corner);
        }
        /**
         * @param {!AnchorMargin} margin
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.foundation_.setAnchorMargin(margin);
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCMenuSurfaceFoundation} */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCMenuSurfaceFoundation(
          /** @type {!MDCMenuSurfaceAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            hasAnchor: function hasAnchor() {
              return !!_this3.anchorElement;
            },
            notifyClose: function notifyClose() {
              return _this3.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});
            },
            notifyOpen: function notifyOpen() {
              return _this3.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});
            },
            isElementInContainer: function isElementInContainer(el) {
              return _this3.root_ === el || _this3.root_.contains(el);
            },
            isRtl: function isRtl() {
              return getComputedStyle(_this3.root_).getPropertyValue('direction') === 'rtl';
            },
            setTransformOrigin: function setTransformOrigin(origin) {
              _this3.root_.style["".concat(getTransformPropertyName(window), "-origin")] = origin;
            }
          }, this.getFocusAdapterMethods_(), this.getDimensionAdapterMethods_()));
        }
        /**
         * @return {!{
         * isFocused: function(): boolean,
         * saveFocus: function(),
         * restoreFocus: function(),
         * isFirstElementFocused: function(): boolean,
         * isLastElementFocused: function(): boolean,
         * focusFirstElement: function(),
         * focusLastElement: function(),
         * }}
         * @private
         */

      }, {
        key: "getFocusAdapterMethods_",
        value: function getFocusAdapterMethods_() {
          var _this4 = this;

          return {
            isFocused: function isFocused() {
              return document.activeElement === _this4.root_;
            },
            saveFocus: function saveFocus() {
              _this4.previousFocus_ = document.activeElement;
            },
            restoreFocus: function restoreFocus() {
              if (_this4.root_.contains(document.activeElement)) {
                if (_this4.previousFocus_ && _this4.previousFocus_.focus) {
                  _this4.previousFocus_.focus();
                }
              }
            },
            isFirstElementFocused: function isFirstElementFocused() {
              return _this4.firstFocusableElement_ && _this4.firstFocusableElement_ === document.activeElement;
            },
            isLastElementFocused: function isLastElementFocused() {
              return _this4.lastFocusableElement_ && _this4.lastFocusableElement_ === document.activeElement;
            },
            focusFirstElement: function focusFirstElement() {
              return _this4.firstFocusableElement_ && _this4.firstFocusableElement_.focus && _this4.firstFocusableElement_.focus();
            },
            focusLastElement: function focusLastElement() {
              return _this4.lastFocusableElement_ && _this4.lastFocusableElement_.focus && _this4.lastFocusableElement_.focus();
            }
          };
        }
        /**
         * @return {!{
         * getInnerDimensions: function(),
         * getAnchorDimensions: function(): (HTMLElement | null | * | ClientRect),
         * getWindowDimensions: function(),
         * setPosition: function(*),
         * setMaxHeight: function(string)}}
         * @private
         */

      }, {
        key: "getDimensionAdapterMethods_",
        value: function getDimensionAdapterMethods_() {
          var _this5 = this;

          return {
            getInnerDimensions: function getInnerDimensions() {
              return {
                width: _this5.root_.offsetWidth,
                height: _this5.root_.offsetHeight
              };
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return _this5.anchorElement && _this5.anchorElement.getBoundingClientRect();
            },
            getWindowDimensions: function getWindowDimensions() {
              return {
                width: window.innerWidth,
                height: window.innerHeight
              };
            },
            getBodyDimensions: function getBodyDimensions() {
              return {
                width: document.body.clientWidth,
                height: document.body.clientHeight
              };
            },
            getWindowScroll: function getWindowScroll() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            },
            setPosition: function setPosition(position) {
              _this5.root_.style.left = 'left' in position ? position.left : null;
              _this5.root_.style.right = 'right' in position ? position.right : null;
              _this5.root_.style.top = 'top' in position ? position.top : null;
              _this5.root_.style.bottom = 'bottom' in position ? position.bottom : null;
            },
            setMaxHeight: function setMaxHeight(height) {
              _this5.root_.style.maxHeight = height;
            }
          };
        }
      }, {
        key: "open",
        get: function get() {
          return this.foundation_.isOpen();
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          if (value) {
            var focusableElements = this.root_.querySelectorAll(strings$9.FOCUSABLE_ELEMENTS);
            this.firstFocusableElement_ = focusableElements.length > 0 ? focusableElements[0] : null;
            this.lastFocusableElement_ = focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
            this.foundation_.open();
          } else {
            this.foundation_.close();
          }
        }
      }, {
        key: "quickOpen",
        set: function set(quickOpen) {
          this.foundation_.setQuickOpen(quickOpen);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCMenuSurface(root);
        }
      }]);

      return MDCMenuSurface;
    }(MDCComponent$b);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ANCHOR_CORNER_MAP = {
        bottomEnd: Corner.BOTTOM_END,
        bottomStart: Corner.BOTTOM_START,
        topEnd: Corner.TOP_END,
        topStart: Corner.TOP_START
    };
    /**
     * @abstract
     */
    var MdcMenuSurfaceBase = /** @class */ (function () {
        function MdcMenuSurfaceBase(changeDetectorRef, platform, _ngZone, elementRef) {
            this.changeDetectorRef = changeDetectorRef;
            this.platform = platform;
            this._ngZone = _ngZone;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._previousFocus = null;
            this._firstFocusableElement = null;
            this._lastFocusableElement = null;
            this._open = false;
            this._anchorElement = null;
            this._anchorCorner = 'topStart';
            this._quickOpen = false;
            this._fixed = false;
            this._coordinates = { x: 0, y: 0 };
            this._anchorMargin = {};
            this._hoistToBody = false;
            /**
             * Emits an event whenever the menu surface is opened.
             */
            this.opened = new core.EventEmitter();
            /**
             * Emits an event whenever the menu surface is closed.
             */
            this.closed = new core.EventEmitter();
            /**
             * Subscription to interaction events in menu-surface.
             */
            this._windowClickSubscription = null;
            this._foundation = new MDCMenuSurfaceFoundation(this._createSurfaceAdapter());
        }
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "open", {
            get: /**
             * @return {?}
             */
            function () { return this._open; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._open = toBoolean(value);
                this.setOpen();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "anchorElement", {
            get: /**
             * @return {?}
             */
            function () { return this._anchorElement; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                this._anchorElement = element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "anchorCorner", {
            get: /**
             * @return {?}
             */
            function () { return this._anchorCorner; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._anchorCorner = value || 'topStart';
                this._foundation.setAnchorCorner([ANCHOR_CORNER_MAP[this._anchorCorner]]);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "quickOpen", {
            get: /**
             * @return {?}
             */
            function () { return this._quickOpen; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._quickOpen = toBoolean(value);
                this._foundation.setQuickOpen(this._quickOpen);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "fixed", {
            get: /**
             * @return {?}
             */
            function () { return this._fixed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fixed = toBoolean(value);
                this._fixed ? this._getHostElement().classList.add('mdc-menu-surface--fixed') :
                    this._getHostElement().classList.remove('mdc-menu-surface--fixed');
                this._foundation.setFixedPosition(this._fixed);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "coordinates", {
            get: /**
             * @return {?}
             */
            function () { return this._coordinates; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._coordinates = value;
                this._foundation.setAbsolutePosition(value.x, value.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "anchorMargin", {
            get: /**
             * @return {?}
             */
            function () { return this._anchorMargin; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._anchorMargin = value;
                this._foundation.setAnchorMargin(this._anchorMargin);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenuSurfaceBase.prototype, "hoistToBody", {
            get: /**
             * @return {?}
             */
            function () { return this._hoistToBody; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._hoistToBody = toBoolean(value);
                if (this._hoistToBody) {
                    this.setHoistToBody();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype._createSurfaceAdapter = /**
         * @protected
         * @return {?}
         */
        function () {
            var _this = this;
            return Object.assign({
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                hasAnchor: (/**
                 * @return {?}
                 */
                function () { return !!_this.anchorElement; }),
                notifyClose: (/**
                 * @return {?}
                 */
                function () {
                    _this.closed.emit();
                    _this._deregisterWindowClickListener();
                }),
                notifyOpen: (/**
                 * @return {?}
                 */
                function () {
                    _this.opened.emit();
                    _this._registerWindowClickListener();
                }),
                isElementInContainer: (/**
                 * @param {?} el
                 * @return {?}
                 */
                function (el) { return _this._getHostElement() === el || _this._getHostElement().contains(el); }),
                isRtl: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return;
                    }
                    return window.getComputedStyle(_this._getHostElement()).getPropertyValue('direction') === 'rtl';
                }),
                setTransformOrigin: (/**
                 * @param {?} origin
                 * @return {?}
                 */
                function (origin) {
                    if (!_this.platform.isBrowser) {
                        return;
                    }
                    _this._getHostElement().style[(/** @type {?} */ (getTransformPropertyName(window) + "-origin"))] = origin;
                })
            }, this._getFocusAdaptermethods(), this._getDimensionAdapterMethods());
        };
        /**
         * @private
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype._getFocusAdaptermethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                isFocused: (/**
                 * @return {?}
                 */
                function () { return _this.platform.isBrowser ? (/** @type {?} */ (document.activeElement)) === _this._getHostElement() : false; }),
                saveFocus: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return;
                    }
                    _this._previousFocus = (/** @type {?} */ (document.activeElement));
                }),
                restoreFocus: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return;
                    }
                    if (_this._getHostElement().contains((/** @type {?} */ (document.activeElement)))) {
                        if (_this._previousFocus && ((/** @type {?} */ (_this._previousFocus))).focus) {
                            ((/** @type {?} */ (_this._previousFocus))).focus();
                        }
                    }
                }),
                isFirstElementFocused: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return false;
                    }
                    return _this._firstFocusableElement && _this._firstFocusableElement === (/** @type {?} */ (document.activeElement));
                }),
                isLastElementFocused: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return false;
                    }
                    return _this._lastFocusableElement && _this._lastFocusableElement === (/** @type {?} */ (document.activeElement));
                }),
                focusFirstElement: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return;
                    }
                    if (_this._firstFocusableElement) {
                        ((/** @type {?} */ (_this._firstFocusableElement))).focus();
                    }
                }),
                focusLastElement: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return;
                    }
                    if (_this._lastFocusableElement) {
                        ((/** @type {?} */ (_this._lastFocusableElement))).focus();
                    }
                })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype._getDimensionAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                getInnerDimensions: (/**
                 * @return {?}
                 */
                function () {
                    return { width: _this._getHostElement().offsetWidth, height: _this._getHostElement().offsetHeight };
                }),
                getAnchorDimensions: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this.platform.isBrowser) {
                        return;
                    }
                    return _this._anchorElement && _this._anchorElement.getBoundingClientRect();
                }),
                getWindowDimensions: (/**
                 * @return {?}
                 */
                function () {
                    return {
                        width: _this.platform.isBrowser ? window.innerWidth : 0,
                        height: _this.platform.isBrowser ? window.innerHeight : 0
                    };
                }),
                getBodyDimensions: (/**
                 * @return {?}
                 */
                function () {
                    return {
                        width: _this.platform.isBrowser ? (/** @type {?} */ (document.body)).clientWidth : 0,
                        height: _this.platform.isBrowser ? (/** @type {?} */ (document.body)).clientHeight : 0
                    };
                }),
                getWindowScroll: (/**
                 * @return {?}
                 */
                function () {
                    return {
                        x: _this.platform.isBrowser ? window.pageXOffset : 0,
                        y: _this.platform.isBrowser ? window.pageYOffset : 0
                    };
                }),
                setPosition: (/**
                 * @param {?} position
                 * @return {?}
                 */
                function (position) {
                    _this._getHostElement().style.left = 'left' in position ? position.left : null;
                    _this._getHostElement().style.right = 'right' in position ? position.right : null;
                    _this._getHostElement().style.top = 'top' in position ? position.top : null;
                    _this._getHostElement().style.bottom = 'bottom' in position ? position.bottom : null;
                }),
                setMaxHeight: (/**
                 * @param {?} height
                 * @return {?}
                 */
                function (height) { return _this._getHostElement().style.maxHeight = height; })
            };
        };
        /**
         * @protected
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype.initMenuSurface = /**
         * @protected
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._registerKeydownListener();
        };
        /**
         * @protected
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype.destroyMenuSurface = /**
         * @protected
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._deregisterWindowClickListener();
            // add platform check due to use of cancelAnimationFrame inside destroy()
            if (this.platform.isBrowser) {
                this._foundation.destroy();
            }
            if (this.hoistToBody) {
                (/** @type {?} */ (document.body)).removeChild(this._getHostElement());
            }
        };
        /**
         * @protected
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype.setOpen = /**
         * @protected
         * @return {?}
         */
        function () {
            if (this._open) {
                /** @type {?} */
                var focusableElements = this._getHostElement().querySelectorAll(strings$9.FOCUSABLE_ELEMENTS);
                this._firstFocusableElement = focusableElements.length > 0 ? focusableElements[0] : null;
                this._lastFocusableElement = focusableElements.length > 0 ?
                    focusableElements[focusableElements.length - 1] : null;
                this._foundation.open();
            }
            else {
                this._foundation.close();
            }
        };
        /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         */
        /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         * @protected
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype.setHoistToBody = /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         * @protected
         * @return {?}
         */
        function () {
            if (!this.platform.isBrowser) {
                return;
            }
            /** @type {?} */
            var parentEl = this._getHostElement().parentElement;
            if (parentEl) {
                (/** @type {?} */ (document.body)).appendChild(parentEl.removeChild(this._getHostElement()));
                this._foundation.setIsHoisted(true);
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype._registerKeydownListener = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._getHostElement(), 'keydown').pipe(operators.takeUntil(_this._destroy))
                    .subscribe((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this._foundation.handleKeydown(evt); })); }));
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype._registerWindowClickListener = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.platform.isBrowser) {
                return;
            }
            this._windowClickSubscription =
                this._ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    return rxjs.fromEvent(window, 'click')
                        .subscribe((/**
                     * @param {?} evt
                     * @return {?}
                     */
                    function (evt) { return _this._ngZone.run((/**
                     * @return {?}
                     */
                    function () {
                        _this._foundation.handleBodyClick(evt);
                        _this._open = _this._foundation.isOpen();
                    })); }));
                }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype._deregisterWindowClickListener = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._windowClickSubscription) {
                this._windowClickSubscription.unsubscribe();
            }
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @protected
         * @return {?}
         */
        MdcMenuSurfaceBase.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @protected
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /** @nocollapse */
        MdcMenuSurfaceBase.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: Platform },
            { type: core.NgZone, decorators: [{ type: core.Optional }] },
            { type: core.ElementRef }
        ]; };
        MdcMenuSurfaceBase.propDecorators = {
            open: [{ type: core.Input }],
            anchorElement: [{ type: core.Input }],
            anchorCorner: [{ type: core.Input }],
            quickOpen: [{ type: core.Input }],
            fixed: [{ type: core.Input }],
            coordinates: [{ type: core.Input }],
            anchorMargin: [{ type: core.Input }],
            hoistToBody: [{ type: core.Input }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }]
        };
        return MdcMenuSurfaceBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcMenuSurface = /** @class */ (function (_super) {
        __extends(MdcMenuSurface, _super);
        function MdcMenuSurface() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        MdcMenuSurface.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.initMenuSurface();
        };
        /**
         * @return {?}
         */
        MdcMenuSurface.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroyMenuSurface();
        };
        MdcMenuSurface.decorators = [
            { type: core.Component, args: [{selector: 'mdc-menu-surface',
                        exportAs: 'mdcMenuSurface',
                        host: { 'class': 'mdc-menu-surface' },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        return MdcMenuSurface;
    }(MdcMenuSurfaceBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcMenuSurfaceAnchor = /** @class */ (function () {
        function MdcMenuSurfaceAnchor(elementRef) {
            this.elementRef = elementRef;
        }
        MdcMenuSurfaceAnchor.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcMenuSurfaceAnchor], mdc-menu-surface-anchor',
                        host: { 'class': 'mdc-menu-surface--anchor' }
                    },] },
        ];
        /** @nocollapse */
        MdcMenuSurfaceAnchor.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcMenuSurfaceAnchor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MENU_SURFACE_DECLARATIONS = [
        MdcMenuSurface,
        MdcMenuSurfaceAnchor
    ];
    var MdcMenuSurfaceModule = /** @class */ (function () {
        function MdcMenuSurfaceModule() {
        }
        MdcMenuSurfaceModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MENU_SURFACE_DECLARATIONS],
                        declarations: [MENU_SURFACE_DECLARATIONS]
                    },] },
        ];
        return MdcMenuSurfaceModule;
    }());

    function _classCallCheck$c(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$c(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$c(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$c(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits$c(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$c(subClass, superClass);
    }

    function _getPrototypeOf$c(o) {
      _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$c(o);
    }

    function _setPrototypeOf$c(o, p) {
      _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$c(o, p);
    }

    function _assertThisInitialized$c(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$c(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$c(self);
    }

    function _superPropBase$5(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$c(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$5(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$5 = Reflect.get;
      } else {
        _get$5 = function _get(target, property, receiver) {
          var base = _superPropBase$5(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$5(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$c =
    /*#__PURE__*/
    function () {
      _createClass$c(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$c(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$c(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$c =
    /*#__PURE__*/
    function () {
      _createClass$c(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$c());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$c(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$c(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Menu. Provides an interface for managing
     * - selected element classes
     * - get focused elements
     * - toggling a checkbox inside a list item
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCMenuAdapter =
    /*#__PURE__*/
    function () {
      function MDCMenuAdapter() {
        _classCallCheck$c(this, MDCMenuAdapter);
      }

      _createClass$c(MDCMenuAdapter, [{
        key: "addClassToElementAtIndex",

        /**
         * Adds a class to the element at the index provided.
         * @param {number} index
         * @param {string} className
         */
        value: function addClassToElementAtIndex(index, className) {}
        /**
         * Removes a class from the element at the index provided
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "removeClassFromElementAtIndex",
        value: function removeClassFromElementAtIndex(index, className) {}
        /**
         * Adds an attribute, with value, to the element at the index provided.
         * @param {number} index
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "addAttributeToElementAtIndex",
        value: function addAttributeToElementAtIndex(index, attr, value) {}
        /**
         * Removes an attribute from an element at the index provided.
         * @param {number} index
         * @param {string} attr
         */

      }, {
        key: "removeAttributeFromElementAtIndex",
        value: function removeAttributeFromElementAtIndex(index, attr) {}
        /**
         * Returns true if the element contains the className.
         * @param {?HTMLElement} element
         * @param {string} className
         * @return {boolean} true if the element contains the className
         */

      }, {
        key: "elementContainsClass",
        value: function elementContainsClass(element, className) {}
        /**
         * Closes the menu-surface.
         */

      }, {
        key: "closeSurface",
        value: function closeSurface() {}
        /**
         * Returns the index for the element provided.
         * @param {?HTMLElement} element
         * @return {number} index of the element in the list or -1 if it is not in the list.
         */

      }, {
        key: "getElementIndex",
        value: function getElementIndex(element) {}
        /**
         * Returns the parentElement of the provided element.
         * @param {?HTMLElement} element
         * @return {?HTMLElement} parentElement of the element provided.
         */

      }, {
        key: "getParentElement",
        value: function getParentElement(element) {}
        /**
         * Returns the element within the selectionGroup containing the selected element class.
         * @param {!HTMLElement} selectionGroup
         * @return {number} element within the selectionGroup that contains the selected element class.
         */

      }, {
        key: "getSelectedElementIndex",
        value: function getSelectedElementIndex(selectionGroup) {}
        /**
         * Emits an event using the evtData.
         * @param {{
        *    index: number
        *   }} evtData
         */

      }, {
        key: "notifySelected",
        value: function notifySelected(evtData) {}
      }]);

      return MDCMenuAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$c = {
      ROOT: 'mdc-menu',
      MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
      MENU_SELECTION_GROUP: 'mdc-menu__selection-group'
    };
    /** @enum {string} */

    var strings$a = {
      SELECTED_EVENT: 'MDCMenu:selected',
      ARIA_SELECTED_ATTR: 'aria-selected',
      LIST_SELECTOR: '.mdc-list',
      CHECKBOX_SELECTOR: 'input[type="checkbox"]'
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDCMenuSurface. Provides an interface for managing
     * - classes
     * - dom
     * - focus
     * - position
     * - dimensions
     * - event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCMenuSurfaceAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCMenuSurfaceAdapter() {
        _classCallCheck$c(this, MDCMenuSurfaceAdapter);
      }

      _createClass$c(MDCMenuSurfaceAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /** @return {boolean} */

      }, {
        key: "hasAnchor",
        value: function hasAnchor() {}
        /** Emits an event when the menu surface is closed. */

      }, {
        key: "notifyClose",
        value: function notifyClose() {}
        /** Emits an event when the menu surface is opened. */

      }, {
        key: "notifyOpen",
        value: function notifyOpen() {}
        /**
         * @return {boolean}
         * @param {EventTarget} el
         */

      }, {
        key: "isElementInContainer",
        value: function isElementInContainer(el) {}
        /** @return {boolean} */

      }, {
        key: "isRtl",
        value: function isRtl() {}
        /** @param {string} origin */

      }, {
        key: "setTransformOrigin",
        value: function setTransformOrigin(origin) {}
        /** @return {boolean} */

      }, {
        key: "isFocused",
        value: function isFocused() {}
        /** Saves the element that was focused before the menu surface was opened. */

      }, {
        key: "saveFocus",
        value: function saveFocus() {}
        /** Restores focus to the element that was focused before the menu surface was opened. */

      }, {
        key: "restoreFocus",
        value: function restoreFocus() {}
        /** @return {boolean} */

      }, {
        key: "isFirstElementFocused",
        value: function isFirstElementFocused() {}
        /** @return {boolean} */

      }, {
        key: "isLastElementFocused",
        value: function isLastElementFocused() {}
        /** Focuses the first focusable element in the menu-surface. */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {}
        /** Focuses the first focusable element in the menu-surface. */

      }, {
        key: "focusLastElement",
        value: function focusLastElement() {}
        /** @return {!{width: number, height: number}} */

      }, {
        key: "getInnerDimensions",
        value: function getInnerDimensions() {}
        /** @return {!{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

      }, {
        key: "getAnchorDimensions",
        value: function getAnchorDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getWindowDimensions",
        value: function getWindowDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getBodyDimensions",
        value: function getBodyDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getWindowScroll",
        value: function getWindowScroll() {}
        /** @param {!{
        *   top: (string|undefined),
        *   right: (string|undefined),
        *   bottom: (string|undefined),
        *   left: (string|undefined)
        * }} position */

      }, {
        key: "setPosition",
        value: function setPosition(position) {}
        /** @param {string} height */

      }, {
        key: "setMaxHeight",
        value: function setMaxHeight(height) {}
      }]);

      return MDCMenuSurfaceAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1$6 = {
      ANCHOR: 'mdc-menu-surface--anchor',
      ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
      ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
      FIXED: 'mdc-menu-surface--fixed',
      OPEN: 'mdc-menu-surface--open',
      ROOT: 'mdc-menu-surface'
    };
    /** @enum {string} */

    var strings$1$6 = {
      CLOSED_EVENT: 'MDCMenuSurface:closed',
      OPENED_EVENT: 'MDCMenuSurface:opened',
      FOCUSABLE_ELEMENTS: 'button:not(:disabled), [href]:not([aria-disabled="true"]), input:not(:disabled), ' + 'select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
    };
    /** @enum {number} */

    var numbers$6 = {
      // Total duration of menu-surface open animation.
      TRANSITION_OPEN_DURATION: 120,
      // Total duration of menu-surface close animation.
      TRANSITION_CLOSE_DURATION: 75,
      // Margin left to the edge of the viewport when menu-surface is at maximum possible height.
      MARGIN_TO_EDGE: 32,
      // Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning.
      ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
    };
    /**
     * Enum for bits in the {@see Corner) bitmap.
     * @enum {number}
     */

    var CornerBit$1 = {
      BOTTOM: 1,
      CENTER: 2,
      RIGHT: 4,
      FLIP_RTL: 8
    };
    /**
     * Enum for representing an element corner for positioning the menu-surface.
     *
     * The START constants map to LEFT if element directionality is left
     * to right and RIGHT if the directionality is right to left.
     * Likewise END maps to RIGHT or LEFT depending on the directionality.
     *
     * @enum {number}
     */

    var Corner$1 = {
      TOP_LEFT: 0,
      TOP_RIGHT: CornerBit$1.RIGHT,
      BOTTOM_LEFT: CornerBit$1.BOTTOM,
      BOTTOM_RIGHT: CornerBit$1.BOTTOM | CornerBit$1.RIGHT,
      TOP_START: CornerBit$1.FLIP_RTL,
      TOP_END: CornerBit$1.FLIP_RTL | CornerBit$1.RIGHT,
      BOTTOM_START: CornerBit$1.BOTTOM | CornerBit$1.FLIP_RTL,
      BOTTOM_END: CornerBit$1.BOTTOM | CornerBit$1.RIGHT | CornerBit$1.FLIP_RTL
    };

    /**
     * @extends {MDCFoundation<!MDCMenuSurfaceAdapter>}
     */

    var MDCMenuSurfaceFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$c(MDCMenuSurfaceFoundation, _MDCFoundation);

      _createClass$c(MDCMenuSurfaceFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          return cssClasses$1$6;
        }
        /** @return enum{string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$6;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$6;
        }
        /** @return enum{number} */

      }, {
        key: "Corner",
        get: function get() {
          return Corner$1;
        }
        /**
         * {@see MDCMenuSurfaceAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCMenuSurfaceAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCMenuSurfaceAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {
                return false;
              },
              hasAnchor: function hasAnchor() {
                return false;
              },
              notifyClose: function notifyClose() {},
              notifyOpen: function notifyOpen() {},
              isElementInContainer: function isElementInContainer() {
                return false;
              },
              isRtl: function isRtl() {
                return false;
              },
              setTransformOrigin: function setTransformOrigin() {},
              isFocused: function isFocused() {
                return false;
              },
              saveFocus: function saveFocus() {},
              restoreFocus: function restoreFocus() {},
              isFirstElementFocused: function isFirstElementFocused() {},
              isLastElementFocused: function isLastElementFocused() {},
              focusFirstElement: function focusFirstElement() {},
              focusLastElement: function focusLastElement() {},
              getInnerDimensions: function getInnerDimensions() {
                return {};
              },
              getAnchorDimensions: function getAnchorDimensions() {
                return {};
              },
              getWindowDimensions: function getWindowDimensions() {
                return {};
              },
              getBodyDimensions: function getBodyDimensions() {
                return {};
              },
              getWindowScroll: function getWindowScroll() {
                return {};
              },
              setPosition: function setPosition() {},
              setMaxHeight: function setMaxHeight() {}
            }
          );
        }
        /** @param {!MDCMenuSurfaceAdapter} adapter */

      }]);

      function MDCMenuSurfaceFoundation(adapter) {
        var _this;

        _classCallCheck$c(this, MDCMenuSurfaceFoundation);

        _this = _possibleConstructorReturn$c(this, _getPrototypeOf$c(MDCMenuSurfaceFoundation).call(this, Object.assign(MDCMenuSurfaceFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.isOpen_ = false;
        /** @private {number} */

        _this.openAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.closeAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.animationRequestId_ = 0;
        /** @private {!{ width: number, height: number }} */

        _this.dimensions_;
        /** @private {!Corner} */

        _this.anchorCorner_ = Corner$1.TOP_START;
        /** @private {!AnchorMargin} */

        _this.anchorMargin_ = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        /** @private {?AutoLayoutMeasurements} */

        _this.measures_ = null;
        /** @private {boolean} */

        _this.quickOpen_ = false;
        /** @private {boolean} */

        _this.hoistedElement_ = false;
        /** @private {boolean} */

        _this.isFixedPosition_ = false;
        /** @private {!{x: number, y: number}} */

        _this.position_ = {
          x: 0,
          y: 0
        };
        return _this;
      }

      _createClass$c(MDCMenuSurfaceFoundation, [{
        key: "init",
        value: function init() {
          var _MDCMenuSurfaceFounda = MDCMenuSurfaceFoundation.cssClasses,
              ROOT = _MDCMenuSurfaceFounda.ROOT,
              OPEN = _MDCMenuSurfaceFounda.OPEN;

          if (!this.adapter_.hasClass(ROOT)) {
            throw new Error("".concat(ROOT, " class required in root element."));
          }

          if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          clearTimeout(this.openAnimationEndTimerId_);
          clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.

          cancelAnimationFrame(this.animationRequestId_);
        }
        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left menu surface corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.anchorCorner_ = corner;
        }
        /**
         * @param {!AnchorMargin} margin set of margin values from anchor.
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
          this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
          this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
          this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
        }
        /**
         * Used to indicate if the menu-surface is hoisted to the body.
         * @param {boolean} isHoisted
         */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.hoistedElement_ = isHoisted;
        }
        /**
         * Used to set the menu-surface calculations based on a fixed position menu.
         * @param {boolean} isFixedPosition
         */

      }, {
        key: "setFixedPosition",
        value: function setFixedPosition(isFixedPosition) {
          this.isFixedPosition_ = isFixedPosition;
        }
        /**
         * Sets the menu-surface position on the page.
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.position_.x = this.typeCheckisFinite_(x) ? x : 0;
          this.position_.y = this.typeCheckisFinite_(y) ? y : 0;
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "setQuickOpen",
        value: function setQuickOpen(quickOpen) {
          this.quickOpen_ = quickOpen;
        }
        /**
         * Handle clicks and close if not within menu-surface element.
         * @param {!Event} evt
         */

      }, {
        key: "handleBodyClick",
        value: function handleBodyClick(evt) {
          var el = evt.target;

          if (this.adapter_.isElementInContainer(el)) {
            return;
          }

          this.close();
        }
      }, {
        key: "handleKeydown",

        /**
         * Handle keys that close the surface.
         * @param {!Event} evt
         */
        value: function handleKeydown(evt) {
          var keyCode = evt.keyCode,
              key = evt.key,
              shiftKey = evt.shiftKey;
          var isEscape = key === 'Escape' || keyCode === 27;
          var isTab = key === 'Tab' || keyCode === 9;

          if (isEscape) {
            this.close();
          } else if (isTab) {
            if (this.adapter_.isLastElementFocused() && !shiftKey) {
              this.adapter_.focusFirstElement();
              evt.preventDefault();
            } else if (this.adapter_.isFirstElementFocused() && shiftKey) {
              this.adapter_.focusLastElement();
              evt.preventDefault();
            }
          }
        }
        /**
         * @return {!AutoLayoutMeasurements} Measurements used to position menu surface popup.
         */

      }, {
        key: "getAutoLayoutMeasurements_",
        value: function getAutoLayoutMeasurements_() {
          var anchorRect = this.adapter_.getAnchorDimensions();
          var viewport = this.adapter_.getWindowDimensions();
          var bodyDimensions = this.adapter_.getBodyDimensions();
          var windowScroll = this.adapter_.getWindowScroll();

          if (!anchorRect) {
            anchorRect =
            /** @type {ClientRect} */
            {
              x: this.position_.x,
              y: this.position_.y,
              top: this.position_.y,
              bottom: this.position_.y,
              left: this.position_.x,
              right: this.position_.x,
              height: 0,
              width: 0
            };
          }

          return {
            viewport: viewport,
            bodyDimensions: bodyDimensions,
            windowScroll: windowScroll,
            viewportDistance: {
              top: anchorRect.top,
              right: viewport.width - anchorRect.right,
              left: anchorRect.left,
              bottom: viewport.height - anchorRect.bottom
            },
            anchorHeight: anchorRect.height,
            anchorWidth: anchorRect.width,
            surfaceHeight: this.dimensions_.height,
            surfaceWidth: this.dimensions_.width
          };
        }
        /**
         * Computes the corner of the anchor from which to animate and position the menu surface.
         * @return {!Corner}
         * @private
         */

      }, {
        key: "getOriginCorner_",
        value: function getOriginCorner_() {
          // Defaults: open from the top left.
          var corner = Corner$1.TOP_LEFT;
          var _this$measures_ = this.measures_,
              viewportDistance = _this$measures_.viewportDistance,
              anchorHeight = _this$measures_.anchorHeight,
              anchorWidth = _this$measures_.anchorWidth,
              surfaceHeight = _this$measures_.surfaceHeight,
              surfaceWidth = _this$measures_.surfaceWidth;
          var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit$1.BOTTOM);
          var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
          var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;
          var topOverflow = surfaceHeight - availableTop;
          var bottomOverflow = surfaceHeight - availableBottom;

          if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
            corner |= CornerBit$1.BOTTOM;
          }

          var isRtl = this.adapter_.isRtl();
          var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit$1.FLIP_RTL);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit$1.RIGHT);
          var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
          var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
          var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;
          var leftOverflow = surfaceWidth - availableLeft;
          var rightOverflow = surfaceWidth - availableRight;

          if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
            corner |= CornerBit$1.RIGHT;
          }

          return (
            /** @type {Corner} */
            corner
          );
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Horizontal offset of menu surface origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getHorizontalOriginOffset_",
        value: function getHorizontalOriginOffset_(corner) {
          var anchorWidth = this.measures_.anchorWidth; // isRightAligned corresponds to using the 'right' property on the surface.

          var isRightAligned = Boolean(corner & CornerBit$1.RIGHT);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit$1.RIGHT);

          if (isRightAligned) {
            var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right; // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
            // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
            // the right property is correct.

            if (this.hoistedElement_ || this.isFixedPosition_) {
              return rightOffset - (this.measures_.viewport.width - this.measures_.bodyDimensions.width);
            }

            return rightOffset;
          }

          return avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Vertical offset of menu surface origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getVerticalOriginOffset_",
        value: function getVerticalOriginOffset_(corner) {
          var anchorHeight = this.measures_.anchorHeight;
          var isBottomAligned = Boolean(corner & CornerBit$1.BOTTOM);
          var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit$1.BOTTOM);
          var y = 0;

          if (isBottomAligned) {
            y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
          } else {
            y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
          }

          return y;
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Maximum height of the menu surface, based on available space. 0 indicates should not be set.
         * @private
         */

      }, {
        key: "getMenuSurfaceMaxHeight_",
        value: function getMenuSurfaceMaxHeight_(corner) {
          var maxHeight = 0;
          var viewportDistance = this.measures_.viewportDistance;
          var isBottomAligned = Boolean(corner & CornerBit$1.BOTTOM);
          var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE; // When maximum height is not specified, it is handled from css.

          if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;

            if (!(this.anchorCorner_ & CornerBit$1.BOTTOM)) {
              maxHeight += this.measures_.anchorHeight;
            }
          } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measures_.anchorHeight - MARGIN_TO_EDGE;

            if (this.anchorCorner_ & CornerBit$1.BOTTOM) {
              maxHeight -= this.measures_.anchorHeight;
            }
          }

          return maxHeight;
        }
        /** @private */

      }, {
        key: "autoPosition_",
        value: function autoPosition_() {
          var _position;

          // Compute measurements for autoposition methods reuse.
          this.measures_ = this.getAutoLayoutMeasurements_();
          var corner = this.getOriginCorner_();
          var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
          var verticalAlignment = corner & CornerBit$1.BOTTOM ? 'bottom' : 'top';
          var horizontalAlignment = corner & CornerBit$1.RIGHT ? 'right' : 'left';
          var horizontalOffset = this.getHorizontalOriginOffset_(corner);
          var verticalOffset = this.getVerticalOriginOffset_(corner);
          var position = (_position = {}, _defineProperty$1(_position, horizontalAlignment, horizontalOffset ? horizontalOffset : '0'), _defineProperty$1(_position, verticalAlignment, verticalOffset ? verticalOffset : '0'), _position);
          var _this$measures_2 = this.measures_,
              anchorWidth = _this$measures_2.anchorWidth,
              surfaceWidth = _this$measures_2.surfaceWidth; // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.

          if (anchorWidth / surfaceWidth > numbers$6.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
            horizontalAlignment = 'center';
          } // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element


          if (this.hoistedElement_ || this.isFixedPosition_) {
            position = this.adjustPositionForHoistedElement_(position);
          }

          for (var prop in position) {
            if (position.hasOwnProperty(prop) && position[prop] !== '0') {
              position[prop] = "".concat(parseInt(position[prop], 10), "px");
            }
          }

          this.adapter_.setTransformOrigin("".concat(horizontalAlignment, " ").concat(verticalAlignment));
          this.adapter_.setPosition(position);
          this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : ''); // Clear measures after positioning is complete.

          this.measures_ = null;
        }
        /**
         * Calculates the offsets for positioning the menu-surface when the menu-surface has been
         * hoisted to the body.
         * @param {!{
         *   top: (string|undefined),
         *   right: (string|undefined),
         *   bottom: (string|undefined),
         *   left: (string|undefined)
         * }} position
         * @return {!{
         *   top: (string|undefined),
         *   right: (string|undefined),
         *   bottom: (string|undefined),
         *   left: (string|undefined)
         * }} position
         * @private
         */

      }, {
        key: "adjustPositionForHoistedElement_",
        value: function adjustPositionForHoistedElement_(position) {
          var _this$measures_3 = this.measures_,
              windowScroll = _this$measures_3.windowScroll,
              viewportDistance = _this$measures_3.viewportDistance;

          for (var prop in position) {
            if (position.hasOwnProperty(prop)) {
              // Hoisted surfaces need to have the anchor elements location on the page added to the
              // position properties for proper alignment on the body.
              if (viewportDistance.hasOwnProperty(prop)) {
                position[prop] = parseInt(position[prop], 10) + viewportDistance[prop];
              } // Surfaces that are absolutely positioned need to have additional calculations for scroll
              // and bottom positioning.


              if (!this.isFixedPosition_) {
                if (prop === 'top') {
                  position[prop] = parseInt(position[prop], 10) + windowScroll.y;
                } else if (prop === 'bottom') {
                  position[prop] = parseInt(position[prop], 10) - windowScroll.y;
                } else if (prop === 'left') {
                  position[prop] = parseInt(position[prop], 10) + windowScroll.x;
                } else if (prop === 'right') {
                  position[prop] = parseInt(position[prop], 10) - windowScroll.x;
                }
              }
            }
          }

          return position;
        }
        /**
         * Open the menu surface.
         */

      }, {
        key: "open",
        value: function open() {
          var _this2 = this;

          this.adapter_.saveFocus();

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
          }

          this.animationRequestId_ = requestAnimationFrame(function () {
            _this2.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

            _this2.dimensions_ = _this2.adapter_.getInnerDimensions();

            _this2.autoPosition_();

            if (_this2.quickOpen_) {
              _this2.adapter_.notifyOpen();
            } else {
              _this2.openAnimationEndTimerId_ = setTimeout(function () {
                _this2.openAnimationEndTimerId_ = 0;

                _this2.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);

                _this2.adapter_.notifyOpen();
              }, numbers$6.TRANSITION_OPEN_DURATION);
            }
          });
          this.isOpen_ = true;
        }
        /**
         * Closes the menu surface.
         */

      }, {
        key: "close",
        value: function close() {
          var _this3 = this;

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
          }

          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

            if (_this3.quickOpen_) {
              _this3.adapter_.notifyClose();
            } else {
              _this3.closeAnimationEndTimerId_ = setTimeout(function () {
                _this3.closeAnimationEndTimerId_ = 0;

                _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);

                _this3.adapter_.notifyClose();
              }, numbers$6.TRANSITION_CLOSE_DURATION);
            }
          });
          this.isOpen_ = false;
          this.maybeRestoreFocus_();
        }
        /**
         * The last focused element when the menu surface was opened should regain focus, if the user is
         * focused on or within the menu surface when it is closed.
         * @private
         */

      }, {
        key: "maybeRestoreFocus_",
        value: function maybeRestoreFocus_() {
          if (this.adapter_.isFocused() || this.adapter_.isElementInContainer(document.activeElement)) {
            this.adapter_.restoreFocus();
          }
        }
        /** @return {boolean} */

      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
        /**
         * isFinite that doesn't force conversion to number type.
         * Equivalent to Number.isFinite in ES2015, but is not included in IE11.
         * @param {number} num
         * @return {boolean}
         * @private
         */

      }, {
        key: "typeCheckisFinite_",
        value: function typeCheckisFinite_(num) {
          return typeof num === 'number' && isFinite(num);
        }
      }]);

      return MDCMenuSurfaceFoundation;
    }(MDCFoundation$c);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC List. Provides an interface for managing focus.
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCListAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCListAdapter() {
        _classCallCheck$c(this, MDCListAdapter);
      }

      _createClass$c(MDCListAdapter, [{
        key: "getListItemCount",

        /** @return {number} */
        value: function getListItemCount() {}
        /**
         * @return {number} */

      }, {
        key: "getFocusedElementIndex",
        value: function getFocusedElementIndex() {}
        /**
         * @param {number} index
         * @param {string} attribute
         * @param {string} value
         */

      }, {
        key: "setAttributeForElementIndex",
        value: function setAttributeForElementIndex(index, attribute, value) {}
        /**
         * @param {number} index
         * @param {string} attribute
         */

      }, {
        key: "removeAttributeForElementIndex",
        value: function removeAttributeForElementIndex(index, attribute) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "addClassForElementIndex",
        value: function addClassForElementIndex(index, className) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "removeClassForElementIndex",
        value: function removeClassForElementIndex(index, className) {}
        /**
         * Focuses list item at the index specified.
         * @param {number} index
         */

      }, {
        key: "focusItemAtIndex",
        value: function focusItemAtIndex(index) {}
        /**
         * Sets the tabindex to the value specified for all button/a element children of
         * the list item at the index specified.
         * @param {number} listItemIndex
         * @param {number} tabIndexValue
         */

      }, {
        key: "setTabIndexForListItemChildren",
        value: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if radio button is present at given list item index.
         */

      }, {
        key: "hasRadioAtIndex",
        value: function hasRadioAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox is present at given list item index.
         */

      }, {
        key: "hasCheckboxAtIndex",
        value: function hasCheckboxAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox inside a list item is checked.
         */

      }, {
        key: "isCheckboxCheckedAtIndex",
        value: function isCheckboxCheckedAtIndex(index) {}
        /**
         * Sets the checked status of checkbox or radio at given list item index.
         * @param {number} index
         * @param {boolean} isChecked
         */

      }, {
        key: "setCheckedCheckboxOrRadioAtIndex",
        value: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {}
        /**
         * Notifies user action on list item.
         */

      }, {
        key: "notifyAction",
        value: function notifyAction(index) {}
        /**
         * @return {boolean} Returns true when the current focused element is inside list root.
         */

      }, {
        key: "isFocusInsideList",
        value: function isFocusInsideList() {}
      }]);

      return MDCListAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$2$2 = {
      ROOT: 'mdc-list',
      LIST_ITEM_CLASS: 'mdc-list-item',
      LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
      LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated'
    };
    /** @enum {string} */

    var strings$2$3 = {
      ARIA_ORIENTATION: 'aria-orientation',
      ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
      ARIA_SELECTED: 'aria-selected',
      ARIA_CHECKED: 'aria-checked',
      ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
      ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
      ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
      RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
      CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
      CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
      CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: ".".concat(cssClasses$2$2.LIST_ITEM_CLASS, " button:not(:disabled),\n  .").concat(cssClasses$2$2.LIST_ITEM_CLASS, " a"),
      FOCUSABLE_CHILD_ELEMENTS: ".".concat(cssClasses$2$2.LIST_ITEM_CLASS, " button:not(:disabled), .").concat(cssClasses$2$2.LIST_ITEM_CLASS, " a,\n  .").concat(cssClasses$2$2.LIST_ITEM_CLASS, " input[type=\"radio\"]:not(:disabled),\n  .").concat(cssClasses$2$2.LIST_ITEM_CLASS, " input[type=\"checkbox\"]:not(:disabled)"),
      ENABLED_ITEMS_SELECTOR: '.mdc-list-item:not(.mdc-list-item--disabled)',
      ACTION_EVENT: 'MDCList:action'
    };

    var ELEMENTS_KEY_ALLOWED_IN$2 = ['input', 'button', 'textarea', 'select'];

    var MDCListFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$c(MDCListFoundation, _MDCFoundation);

      _createClass$c(MDCListFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$2$3;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$2$2;
        }
        /**
         * {@see MDCListAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCListAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCListAdapter} */
            {
              getListItemCount: function getListItemCount() {},
              getFocusedElementIndex: function getFocusedElementIndex() {},
              setAttributeForElementIndex: function setAttributeForElementIndex() {},
              removeAttributeForElementIndex: function removeAttributeForElementIndex() {},
              addClassForElementIndex: function addClassForElementIndex() {},
              removeClassForElementIndex: function removeClassForElementIndex() {},
              focusItemAtIndex: function focusItemAtIndex() {},
              setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {},
              hasRadioAtIndex: function hasRadioAtIndex() {},
              hasCheckboxAtIndex: function hasCheckboxAtIndex() {},
              isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {},
              setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {},
              notifyAction: function notifyAction() {},
              isFocusInsideList: function isFocusInsideList() {}
            }
          );
        }
        /**
         * @param {!MDCListAdapter=} adapter
         */

      }]);

      function MDCListFoundation(adapter) {
        var _this;

        _classCallCheck$c(this, MDCListFoundation);

        _this = _possibleConstructorReturn$c(this, _getPrototypeOf$c(MDCListFoundation).call(this, Object.assign(MDCListFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.wrapFocus_ = false;
        /** @private {boolean} */

        _this.isVertical_ = true;
        /** @private {boolean} */

        _this.isSingleSelectionList_ = false;
        /** @private {!Index} */

        _this.selectedIndex_ = -1;
        /** @private {number} */

        _this.focusedItemIndex_ = -1;
        /** @private {boolean} */

        _this.useActivatedClass_ = false;
        /** @private {boolean} */

        _this.isCheckboxList_ = false;
        /** @private {boolean} */

        _this.isRadioList_ = false;
        return _this;
      }

      _createClass$c(MDCListFoundation, [{
        key: "layout",
        value: function layout() {
          if (this.adapter_.getListItemCount() === 0) return;

          if (this.adapter_.hasCheckboxAtIndex(0)) {
            this.isCheckboxList_ = true;
          } else if (this.adapter_.hasRadioAtIndex(0)) {
            this.isRadioList_ = true;
          }
        }
        /**
         * Sets the private wrapFocus_ variable.
         * @param {boolean} value
         */

      }, {
        key: "setWrapFocus",
        value: function setWrapFocus(value) {
          this.wrapFocus_ = value;
        }
        /**
         * Sets the isVertical_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setVerticalOrientation",
        value: function setVerticalOrientation(value) {
          this.isVertical_ = value;
        }
        /**
         * Sets the isSingleSelectionList_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setSingleSelection",
        value: function setSingleSelection(value) {
          this.isSingleSelectionList_ = value;
        }
        /**
         * Sets the useActivatedClass_ private variable.
         * @param {boolean} useActivated
         */

      }, {
        key: "setUseActivatedClass",
        value: function setUseActivatedClass(useActivated) {
          this.useActivatedClass_ = useActivated;
        }
        /** @return {!Index} */

      }, {
        key: "getSelectedIndex",
        value: function getSelectedIndex() {
          return this.selectedIndex_;
        }
        /** @param {!Index} index */

      }, {
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {
          if (!this.isIndexValid_(index)) return;

          if (this.isCheckboxList_) {
            this.setCheckboxAtIndex_(
            /** @type {!Array<number>} */
            index);
          } else if (this.isRadioList_) {
            this.setRadioAtIndex_(
            /** @type {number} */
            index);
          } else {
            this.setSingleSelectionAtIndex_(
            /** @type {number} */
            index);
          }
        }
        /**
         * Focus in handler for the list items.
         * @param evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusIn",
        value: function handleFocusIn(evt, listItemIndex) {
          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, 0);
          }
        }
        /**
         * Focus out handler for the list items.
         * @param {Event} evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusOut",
        value: function handleFocusOut(evt, listItemIndex) {
          var _this2 = this;

          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, -1);
          }
          /**
           * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
           * is moved to next element.
           */


          setTimeout(function () {
            if (!_this2.adapter_.isFocusInsideList()) {
              _this2.setTabindexToFirstSelectedItem_();
            }
          }, 0);
        }
        /**
         * Key handler for the list.
         * @param {Event} evt
         * @param {boolean} isRootListItem
         * @param {number} listItemIndex
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt, isRootListItem, listItemIndex) {
          var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
          var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
          var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
          var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
          var isHome = evt.key === 'Home' || evt.keyCode === 36;
          var isEnd = evt.key === 'End' || evt.keyCode === 35;
          var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
          var isSpace = evt.key === 'Space' || evt.keyCode === 32;
          var currentIndex = this.adapter_.getFocusedElementIndex();
          var nextIndex = -1;

          if (currentIndex === -1) {
            currentIndex = listItemIndex;

            if (currentIndex < 0) {
              // If this event doesn't have a mdc-list-item ancestor from the
              // current list (not from a sublist), return early.
              return;
            }
          }

          if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusNextElement(currentIndex);
          } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusPrevElement(currentIndex);
          } else if (isHome) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusFirstElement();
          } else if (isEnd) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusLastElement();
          } else if (isEnter || isSpace) {
            if (isRootListItem) {
              // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
              if (evt.target.tagName === 'A' && isEnter) return;
              this.preventDefaultEvent_(evt);

              if (this.isSelectableList_()) {
                this.setSelectedIndexOnAction_(currentIndex);
              }

              this.adapter_.notifyAction(currentIndex);
            }
          }

          this.focusedItemIndex_ = currentIndex;

          if (nextIndex >= 0) {
            this.setTabindexAtIndex_(nextIndex);
            this.focusedItemIndex_ = nextIndex;
          }
        }
        /**
         * Click handler for the list.
         * @param {number} index
         * @param {boolean} toggleCheckbox
         */

      }, {
        key: "handleClick",
        value: function handleClick(index, toggleCheckbox) {
          if (index === -1) return;

          if (this.isSelectableList_()) {
            this.setSelectedIndexOnAction_(index, toggleCheckbox);
          }

          this.adapter_.notifyAction(index);
          this.setTabindexAtIndex_(index);
          this.focusedItemIndex_ = index;
        }
        /**
         * Ensures that preventDefault is only called if the containing element doesn't
         * consume the event, and it will cause an unintended scroll.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "preventDefaultEvent_",
        value: function preventDefaultEvent_(evt) {
          var tagName = "".concat(evt.target.tagName).toLowerCase();

          if (ELEMENTS_KEY_ALLOWED_IN$2.indexOf(tagName) === -1) {
            evt.preventDefault();
          }
        }
        /**
         * Focuses the next element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusNextElement",
        value: function focusNextElement(index) {
          var count = this.adapter_.getListItemCount();
          var nextIndex = index + 1;

          if (nextIndex >= count) {
            if (this.wrapFocus_) {
              nextIndex = 0;
            } else {
              // Return early because last item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(nextIndex);
          return nextIndex;
        }
        /**
         * Focuses the previous element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusPrevElement",
        value: function focusPrevElement(index) {
          var prevIndex = index - 1;

          if (prevIndex < 0) {
            if (this.wrapFocus_) {
              prevIndex = this.adapter_.getListItemCount() - 1;
            } else {
              // Return early because first item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(prevIndex);
          return prevIndex;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {
          this.adapter_.focusItemAtIndex(0);
          return 0;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusLastElement",
        value: function focusLastElement() {
          var lastIndex = this.adapter_.getListItemCount() - 1;
          this.adapter_.focusItemAtIndex(lastIndex);
          return lastIndex;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setSingleSelectionAtIndex_",
        value: function setSingleSelectionAtIndex_(index) {
          var selectedClassName = cssClasses$2$2.LIST_ITEM_SELECTED_CLASS;

          if (this.useActivatedClass_) {
            selectedClassName = cssClasses$2$2.LIST_ITEM_ACTIVATED_CLASS;
          }

          if (this.selectedIndex_ >= 0 && this.selectedIndex_ !== index) {
            this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$2$3.ARIA_SELECTED, 'false');
          }

          this.adapter_.addClassForElementIndex(index, selectedClassName);
          this.adapter_.setAttributeForElementIndex(index, strings$2$3.ARIA_SELECTED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
         * @param {number} index
         * @private
         */

      }, {
        key: "setRadioAtIndex_",
        value: function setRadioAtIndex_(index) {
          this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);

          if (this.selectedIndex_ >= 0) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$2$3.ARIA_CHECKED, 'false');
          }

          this.adapter_.setAttributeForElementIndex(index, strings$2$3.ARIA_CHECKED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * @param {!Array<number>} index
         * @private
         */

      }, {
        key: "setCheckboxAtIndex_",
        value: function setCheckboxAtIndex_(index) {
          for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
            var isChecked = false;

            if (index.indexOf(i) >= 0) {
              isChecked = true;
            }

            this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
            this.adapter_.setAttributeForElementIndex(i, strings$2$3.ARIA_CHECKED, isChecked ? 'true' : 'false');
          }

          this.selectedIndex_ = index;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setTabindexAtIndex_",
        value: function setTabindexAtIndex_(index) {
          if (this.focusedItemIndex_ === -1 && index !== 0) {
            // If no list item was selected set first list item's tabindex to -1.
            // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
            this.adapter_.setAttributeForElementIndex(0, 'tabindex', -1);
          } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
            this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', -1);
          }

          this.adapter_.setAttributeForElementIndex(index, 'tabindex', 0);
        }
        /**
         * @return {boolean} Return true if it is single selectin list, checkbox list or radio list.
         * @private
         */

      }, {
        key: "isSelectableList_",
        value: function isSelectableList_() {
          return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
        }
        /** @private */

      }, {
        key: "setTabindexToFirstSelectedItem_",
        value: function setTabindexToFirstSelectedItem_() {
          var targetIndex = 0;

          if (this.isSelectableList_()) {
            if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== -1) {
              targetIndex = this.selectedIndex_;
            } else if (this.selectedIndex_ instanceof Array && this.selectedIndex_.length > 0) {
              targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
                return Math.min(currentIndex, minIndex);
              });
            }
          }

          this.setTabindexAtIndex_(targetIndex);
        }
        /**
         * @param {!Index} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexValid_",
        value: function isIndexValid_(index) {
          var _this3 = this;

          if (index instanceof Array) {
            if (!this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
            }

            if (index.length === 0) {
              return true;
            } else {
              return index.some(function (i) {
                return _this3.isIndexInRange_(i);
              });
            }
          } else if (typeof index === 'number') {
            if (this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
            }

            return this.isIndexInRange_(index);
          } else {
            return false;
          }
        }
        /**
         * @param {number} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexInRange_",
        value: function isIndexInRange_(index) {
          var listSize = this.adapter_.getListItemCount();
          return index >= 0 && index < listSize;
        }
        /**
         * @param {number} index
         * @param {boolean=} toggleCheckbox
         * @private
         */

      }, {
        key: "setSelectedIndexOnAction_",
        value: function setSelectedIndexOnAction_(index) {
          var toggleCheckbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (this.isCheckboxList_) {
            this.toggleCheckboxAtIndex_(index, toggleCheckbox);
          } else {
            this.setSelectedIndex(index);
          }
        }
        /**
         * @param {number} index
         * @param {boolean} toggleCheckbox
         * @private
         */

      }, {
        key: "toggleCheckboxAtIndex_",
        value: function toggleCheckboxAtIndex_(index, toggleCheckbox) {
          var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);

          if (toggleCheckbox) {
            isChecked = !isChecked;
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
          }

          this.adapter_.setAttributeForElementIndex(index, strings$2$3.ARIA_CHECKED, isChecked ? 'true' : 'false'); // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.

          if (this.selectedIndex_ === -1) {
            this.selectedIndex_ = [];
          }

          if (isChecked) {
            this.selectedIndex_.push(index);
          } else {
            this.selectedIndex_ = this.selectedIndex_.filter(function (i) {
              return i !== index;
            });
          }
        }
      }]);

      return MDCListFoundation;
    }(MDCFoundation$c);

    /**
     * @extends {MDCFoundation<!MDCMenuAdapter>}
     */

    var MDCMenuFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$c(MDCMenuFoundation, _MDCFoundation);

      _createClass$c(MDCMenuFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          return cssClasses$c;
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$a;
        }
        /**
         * {@see MDCMenuAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCMenuAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCMenuAdapter} */
            {
              addClassToElementAtIndex: function addClassToElementAtIndex() {},
              removeClassFromElementAtIndex: function removeClassFromElementAtIndex() {},
              addAttributeToElementAtIndex: function addAttributeToElementAtIndex() {},
              removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex() {},
              elementContainsClass: function elementContainsClass() {},
              closeSurface: function closeSurface() {},
              getElementIndex: function getElementIndex() {},
              getParentElement: function getParentElement() {},
              getSelectedElementIndex: function getSelectedElementIndex() {},
              notifySelected: function notifySelected() {}
            }
          );
        }
        /** @param {!MDCMenuAdapter} adapter */

      }]);

      function MDCMenuFoundation(adapter) {
        var _this;

        _classCallCheck$c(this, MDCMenuFoundation);

        _this = _possibleConstructorReturn$c(this, _getPrototypeOf$c(MDCMenuFoundation).call(this, Object.assign(MDCMenuFoundation.defaultAdapter, adapter)));
        /** @type {number} */

        _this.closeAnimationEndTimerId_ = 0;
        return _this;
      }

      _createClass$c(MDCMenuFoundation, [{
        key: "destroy",
        value: function destroy() {
          if (this.closeAnimationEndTimerId_) {
            clearTimeout(this.closeAnimationEndTimerId_);
          }

          this.adapter_.closeSurface();
        }
        /**
         * Handler function for the keydown events.
         * @param {!Event} evt
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt) {
          var key = evt.key,
              keyCode = evt.keyCode;
          var isTab = key === 'Tab' || keyCode === 9;

          if (isTab) {
            this.adapter_.closeSurface();
          }
        }
        /**
         * @param {!HTMLElement} listItem
         */

      }, {
        key: "handleItemAction",
        value: function handleItemAction(listItem) {
          var _this2 = this;

          var index = this.adapter_.getElementIndex(listItem);

          if (index < 0) {
            return;
          }

          this.adapter_.notifySelected({
            index: index
          });
          this.adapter_.closeSurface(); // Wait for the menu to close before adding/removing classes that affect styles.

          this.closeAnimationEndTimerId_ = setTimeout(function () {
            var selectionGroup = _this2.getSelectionGroup_(listItem);

            if (selectionGroup !== null) {
              _this2.handleSelectionGroup_(
              /** @type {!HTMLElement} */
              selectionGroup, index);
            }
          }, MDCMenuSurfaceFoundation$1.numbers.TRANSITION_CLOSE_DURATION);
        }
        /**
         * Handles toggling the selected classes in a selection group when a
         * selection is made.
         * @param {!HTMLElement} selectionGroup
         * @param {number} index The selected index value
         * @private
         */

      }, {
        key: "handleSelectionGroup_",
        value: function handleSelectionGroup_(selectionGroup, index) {
          // De-select the previous selection in this group.
          var selectedIndex = this.adapter_.getSelectedElementIndex(selectionGroup);

          if (selectedIndex >= 0) {
            this.adapter_.removeAttributeFromElementAtIndex(selectedIndex, strings$a.ARIA_SELECTED_ATTR);
            this.adapter_.removeClassFromElementAtIndex(selectedIndex, cssClasses$c.MENU_SELECTED_LIST_ITEM);
          } // Select the new list item in this group.


          this.adapter_.addClassToElementAtIndex(index, cssClasses$c.MENU_SELECTED_LIST_ITEM);
          this.adapter_.addAttributeToElementAtIndex(index, strings$a.ARIA_SELECTED_ATTR, 'true');
        }
        /**
         * Returns the parent selection group of an element if one exists.
         * @param listItem
         * @return {?HTMLElement} parent selection group element or null.
         * @private
         */

      }, {
        key: "getSelectionGroup_",
        value: function getSelectionGroup_(listItem) {
          var parent = this.adapter_.getParentElement(listItem);
          var isGroup = this.adapter_.elementContainsClass(parent, cssClasses$c.MENU_SELECTION_GROUP); // Iterate through ancestors until we find the group or get to the list.

          while (!isGroup && !this.adapter_.elementContainsClass(parent, MDCListFoundation$2.cssClasses.ROOT)) {
            parent = this.adapter_.getParentElement(parent);
            isGroup = this.adapter_.elementContainsClass(parent, cssClasses$c.MENU_SELECTION_GROUP);
          }

          if (isGroup) {
            return parent;
          } else {
            return null;
          }
        }
        /**
         * Find the first ancestor with the mdc-list-item class.
         * @param {?HTMLElement} target
         * @return {?HTMLElement}
         * @private
         */

      }, {
        key: "getListItem_",
        value: function getListItem_(target) {
          var isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation$2.cssClasses.LIST_ITEM_CLASS);

          while (!isListItem) {
            target = this.adapter_.getParentElement(target);

            if (target) {
              isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation$2.cssClasses.LIST_ITEM_CLASS);
            } else {
              // target has no parent element.
              return null;
            }
          }

          return target;
        }
      }]);

      return MDCMenuFoundation;
    }(MDCFoundation$c);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @type {string|undefined} */
    var storedTransformPropertyName_$1;
    /**
     * Returns the name of the correct transform property to use on the current browser.
     * @param {!Window} globalObj
     * @param {boolean=} forceRefresh
     * @return {string}
     */

    function getTransformPropertyName$1(globalObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
        var el = globalObj.document.createElement('div');
        var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
        storedTransformPropertyName_$1 = transformPropertyName;
      }

      return storedTransformPropertyName_$1;
    }

    /**
     * @extends MDCComponent<!MDCMenuSurfaceFoundation>
     */

    var MDCMenuSurface$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$c(MDCMenuSurface, _MDCComponent);

      /** @param {...?} args */
      function MDCMenuSurface() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$c(this, MDCMenuSurface);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$c(this, (_getPrototypeOf2 = _getPrototypeOf$c(MDCMenuSurface)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Element} */

        _this.previousFocus_;
        /** @private {!Element} */

        _this.anchorElement;
        /** @private {Element} */

        _this.firstFocusableElement_;
        /** @private {Element} */

        _this.lastFocusableElement_;
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleBodyClick_;
        /** @private {!Function} */

        _this.registerBodyClickListener_;
        /** @private {!Function} */

        _this.deregisterBodyClickListener_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCMenuSurface}
       */


      _createClass$c(MDCMenuSurface, [{
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          if (this.root_.parentElement && this.root_.parentElement.classList.contains(cssClasses$1$6.ANCHOR)) {
            this.anchorElement = this.root_.parentElement;
          }

          if (this.root_.classList.contains(cssClasses$1$6.FIXED)) {
            this.setFixedPosition(true);
          }

          this.handleKeydown_ = function (evt) {
            return _this2.foundation_.handleKeydown(evt);
          };

          this.handleBodyClick_ = function (evt) {
            return _this2.foundation_.handleBodyClick(evt);
          };

          this.registerBodyClickListener_ = function () {
            return document.body.addEventListener('click', _this2.handleBodyClick_);
          };

          this.deregisterBodyClickListener_ = function () {
            return document.body.removeEventListener('click', _this2.handleBodyClick_);
          };

          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener(strings$1$6.OPENED_EVENT, this.registerBodyClickListener_);
          this.root_.addEventListener(strings$1$6.CLOSED_EVENT, this.deregisterBodyClickListener_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener(strings$1$6.OPENED_EVENT, this.registerBodyClickListener_);
          this.root_.removeEventListener(strings$1$6.CLOSED_EVENT, this.deregisterBodyClickListener_);

          _get$5(_getPrototypeOf$c(MDCMenuSurface.prototype), "destroy", this).call(this);
        }
        /** @return {boolean} */

      }, {
        key: "hoistMenuToBody",

        /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         */
        value: function hoistMenuToBody() {
          document.body.appendChild(this.root_.parentElement.removeChild(this.root_));
          this.setIsHoisted(true);
        }
        /**
         * Sets the foundation to use page offsets for an positioning when the menu
         * is hoisted to the body.
         * @param {boolean} isHoisted
         */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.foundation_.setIsHoisted(isHoisted);
        }
        /**
         * Sets the element that the menu-surface is anchored to.
         * @param {!Element} element
         */

      }, {
        key: "setMenuSurfaceAnchorElement",
        value: function setMenuSurfaceAnchorElement(element) {
          this.anchorElement = element;
        }
        /**
         * Sets the menu-surface to position: fixed.
         * @param {boolean} isFixed
         */

      }, {
        key: "setFixedPosition",
        value: function setFixedPosition(isFixed) {
          if (isFixed) {
            this.root_.classList.add(cssClasses$1$6.FIXED);
          } else {
            this.root_.classList.remove(cssClasses$1$6.FIXED);
          }

          this.foundation_.setFixedPosition(isFixed);
        }
        /**
         * Sets the absolute x/y position to position based on. Requires the menu to be hoisted.
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.foundation_.setAbsolutePosition(x, y);
          this.setIsHoisted(true);
        }
        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left
         *     surface corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.foundation_.setAnchorCorner(corner);
        }
        /**
         * @param {!AnchorMargin} margin
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.foundation_.setAnchorMargin(margin);
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCMenuSurfaceFoundation} */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCMenuSurfaceFoundation$1(
          /** @type {!MDCMenuSurfaceAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            hasAnchor: function hasAnchor() {
              return !!_this3.anchorElement;
            },
            notifyClose: function notifyClose() {
              return _this3.emit(MDCMenuSurfaceFoundation$1.strings.CLOSED_EVENT, {});
            },
            notifyOpen: function notifyOpen() {
              return _this3.emit(MDCMenuSurfaceFoundation$1.strings.OPENED_EVENT, {});
            },
            isElementInContainer: function isElementInContainer(el) {
              return _this3.root_ === el || _this3.root_.contains(el);
            },
            isRtl: function isRtl() {
              return getComputedStyle(_this3.root_).getPropertyValue('direction') === 'rtl';
            },
            setTransformOrigin: function setTransformOrigin(origin) {
              _this3.root_.style["".concat(getTransformPropertyName$1(window), "-origin")] = origin;
            }
          }, this.getFocusAdapterMethods_(), this.getDimensionAdapterMethods_()));
        }
        /**
         * @return {!{
         * isFocused: function(): boolean,
         * saveFocus: function(),
         * restoreFocus: function(),
         * isFirstElementFocused: function(): boolean,
         * isLastElementFocused: function(): boolean,
         * focusFirstElement: function(),
         * focusLastElement: function(),
         * }}
         * @private
         */

      }, {
        key: "getFocusAdapterMethods_",
        value: function getFocusAdapterMethods_() {
          var _this4 = this;

          return {
            isFocused: function isFocused() {
              return document.activeElement === _this4.root_;
            },
            saveFocus: function saveFocus() {
              _this4.previousFocus_ = document.activeElement;
            },
            restoreFocus: function restoreFocus() {
              if (_this4.root_.contains(document.activeElement)) {
                if (_this4.previousFocus_ && _this4.previousFocus_.focus) {
                  _this4.previousFocus_.focus();
                }
              }
            },
            isFirstElementFocused: function isFirstElementFocused() {
              return _this4.firstFocusableElement_ && _this4.firstFocusableElement_ === document.activeElement;
            },
            isLastElementFocused: function isLastElementFocused() {
              return _this4.lastFocusableElement_ && _this4.lastFocusableElement_ === document.activeElement;
            },
            focusFirstElement: function focusFirstElement() {
              return _this4.firstFocusableElement_ && _this4.firstFocusableElement_.focus && _this4.firstFocusableElement_.focus();
            },
            focusLastElement: function focusLastElement() {
              return _this4.lastFocusableElement_ && _this4.lastFocusableElement_.focus && _this4.lastFocusableElement_.focus();
            }
          };
        }
        /**
         * @return {!{
         * getInnerDimensions: function(),
         * getAnchorDimensions: function(): (HTMLElement | null | * | ClientRect),
         * getWindowDimensions: function(),
         * setPosition: function(*),
         * setMaxHeight: function(string)}}
         * @private
         */

      }, {
        key: "getDimensionAdapterMethods_",
        value: function getDimensionAdapterMethods_() {
          var _this5 = this;

          return {
            getInnerDimensions: function getInnerDimensions() {
              return {
                width: _this5.root_.offsetWidth,
                height: _this5.root_.offsetHeight
              };
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return _this5.anchorElement && _this5.anchorElement.getBoundingClientRect();
            },
            getWindowDimensions: function getWindowDimensions() {
              return {
                width: window.innerWidth,
                height: window.innerHeight
              };
            },
            getBodyDimensions: function getBodyDimensions() {
              return {
                width: document.body.clientWidth,
                height: document.body.clientHeight
              };
            },
            getWindowScroll: function getWindowScroll() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            },
            setPosition: function setPosition(position) {
              _this5.root_.style.left = 'left' in position ? position.left : null;
              _this5.root_.style.right = 'right' in position ? position.right : null;
              _this5.root_.style.top = 'top' in position ? position.top : null;
              _this5.root_.style.bottom = 'bottom' in position ? position.bottom : null;
            },
            setMaxHeight: function setMaxHeight(height) {
              _this5.root_.style.maxHeight = height;
            }
          };
        }
      }, {
        key: "open",
        get: function get() {
          return this.foundation_.isOpen();
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          if (value) {
            var focusableElements = this.root_.querySelectorAll(strings$1$6.FOCUSABLE_ELEMENTS);
            this.firstFocusableElement_ = focusableElements.length > 0 ? focusableElements[0] : null;
            this.lastFocusableElement_ = focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
            this.foundation_.open();
          } else {
            this.foundation_.close();
          }
        }
      }, {
        key: "quickOpen",
        set: function set(quickOpen) {
          this.foundation_.setQuickOpen(quickOpen);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCMenuSurface(root);
        }
      }]);

      return MDCMenuSurface;
    }(MDCComponent$c);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {boolean}
     */


    function matches$4(element, selector) {
      var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      return nativeMatches.call(element, selector);
    }

    /**
     * @extends MDCComponent<!MDCListFoundation>
     */

    var MDCList$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$c(MDCList, _MDCComponent);

      /** @param {...?} args */
      function MDCList() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$c(this, MDCList);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$c(this, (_getPrototypeOf2 = _getPrototypeOf$c(MDCList)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleClick_;
        /** @private {!Function} */

        _this.focusInEventListener_;
        /** @private {!Function} */

        _this.focusOutEventListener_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCList}
       */


      _createClass$c(MDCList, [{
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener('click', this.handleClick_);
          this.root_.removeEventListener('focusin', this.focusInEventListener_);
          this.root_.removeEventListener('focusout', this.focusOutEventListener_);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.handleClick_ = this.handleClickEvent_.bind(this);
          this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
          this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
          this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener('focusin', this.focusInEventListener_);
          this.root_.addEventListener('focusout', this.focusOutEventListener_);
          this.root_.addEventListener('click', this.handleClick_);
          this.layout();
          this.initializeListType();
        }
      }, {
        key: "layout",
        value: function layout() {
          var direction = this.root_.getAttribute(strings$2$3.ARIA_ORIENTATION);
          this.vertical = direction !== strings$2$3.ARIA_ORIENTATION_HORIZONTAL; // List items need to have at least tabindex=-1 to be focusable.

          [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
            ele.setAttribute('tabindex', -1);
          }); // Child button/a elements are not tabbable until the list item is focused.

          [].slice.call(this.root_.querySelectorAll(strings$2$3.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
            return ele.setAttribute('tabindex', -1);
          });
          this.foundation_.layout();
        }
        /**
         * Used to figure out which list item this event is targetting. Or returns -1 if
         * there is no list item
         * @param {Event} evt
         * @private
         */

      }, {
        key: "getListItemIndex_",
        value: function getListItemIndex_(evt) {
          var eventTarget =
          /** @type {HTMLElement} */
          evt.target;
          var index = -1; // Find the first ancestor that is a list item or the list.

          while (!eventTarget.classList.contains(cssClasses$2$2.LIST_ITEM_CLASS) && !eventTarget.classList.contains(cssClasses$2$2.ROOT)) {
            eventTarget = eventTarget.parentElement;
          } // Get the index of the element if it is a list item.


          if (eventTarget.classList.contains(cssClasses$2$2.LIST_ITEM_CLASS)) {
            index = this.listElements.indexOf(eventTarget);
          }

          return index;
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusInEvent_",
        value: function handleFocusInEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusIn(evt, index);
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusOutEvent_",
        value: function handleFocusOutEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusOut(evt, index);
        }
        /**
         * Used to figure out which element was focused when keydown event occurred before sending the event to the
         * foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleKeydownEvent_",
        value: function handleKeydownEvent_(evt) {
          var index = this.getListItemIndex_(evt);

          if (index >= 0) {
            this.foundation_.handleKeydown(evt, evt.target.classList.contains(cssClasses$2$2.LIST_ITEM_CLASS), index);
          }
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleClickEvent_",
        value: function handleClickEvent_(evt) {
          var index = this.getListItemIndex_(evt); // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.

          var toggleCheckbox = !matches$4(
          /** @type {!Element} */
          evt.target, strings$2$3.CHECKBOX_RADIO_SELECTOR);
          this.foundation_.handleClick(index, toggleCheckbox);
        }
        /**
         * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
         */

      }, {
        key: "initializeListType",
        value: function initializeListType() {
          var _this2 = this;

          var checkboxListItems = this.root_.querySelectorAll(strings$2$3.ARIA_ROLE_CHECKBOX_SELECTOR);
          var singleSelectedListItem = this.root_.querySelector(".".concat(cssClasses$2$2.LIST_ITEM_ACTIVATED_CLASS, ",\n        .").concat(cssClasses$2$2.LIST_ITEM_SELECTED_CLASS));
          var radioSelectedListItem = this.root_.querySelector(strings$2$3.ARIA_CHECKED_RADIO_SELECTOR);

          if (checkboxListItems.length) {
            var preselectedItems = this.root_.querySelectorAll(strings$2$3.ARIA_CHECKED_CHECKBOX_SELECTOR);
            this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
              return _this2.listElements.indexOf(listItem);
            });
          } else if (singleSelectedListItem) {
            if (singleSelectedListItem.classList.contains(cssClasses$2$2.LIST_ITEM_ACTIVATED_CLASS)) {
              this.foundation_.setUseActivatedClass(true);
            }

            this.singleSelection = true;
            this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
          } else if (radioSelectedListItem) {
            this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
          }
        }
        /** @param {boolean} value */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCListFoundation} */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCListFoundation$2(
          /** @type {!MDCListAdapter} */
          Object.assign({
            getListItemCount: function getListItemCount() {
              return _this3.listElements.length;
            },
            getFocusedElementIndex: function getFocusedElementIndex() {
              return _this3.listElements.indexOf(document.activeElement);
            },
            setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
              var element = _this3.listElements[index];

              if (element) {
                element.setAttribute(attr, value);
              }
            },
            removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
              var element = _this3.listElements[index];

              if (element) {
                element.removeAttribute(attr);
              }
            },
            addClassForElementIndex: function addClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.add(className);
              }
            },
            removeClassForElementIndex: function removeClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.remove(className);
              }
            },
            focusItemAtIndex: function focusItemAtIndex(index) {
              var element = _this3.listElements[index];

              if (element) {
                element.focus();
              }
            },
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
              var element = _this3.listElements[listItemIndex];
              var listItemChildren = [].slice.call(element.querySelectorAll(strings$2$3.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
              listItemChildren.forEach(function (ele) {
                return ele.setAttribute('tabindex', tabIndexValue);
              });
            },
            hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$2$3.CHECKBOX_SELECTOR);
            },
            hasRadioAtIndex: function hasRadioAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$2$3.RADIO_SELECTOR);
            },
            isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$2$3.CHECKBOX_SELECTOR);
              return toggleEl.checked;
            },
            setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$2$3.CHECKBOX_RADIO_SELECTOR);
              toggleEl.checked = isChecked;
              var event = document.createEvent('Event');
              event.initEvent('change', true, true);
              toggleEl.dispatchEvent(event);
            },
            notifyAction: function notifyAction(index) {
              _this3.emit(strings$2$3.ACTION_EVENT, index,
              /** shouldBubble */
              true);
            },
            isFocusInsideList: function isFocusInsideList() {
              return _this3.root_.contains(document.activeElement);
            }
          }));
        }
      }, {
        key: "vertical",
        set: function set(value) {
          this.foundation_.setVerticalOrientation(value);
        }
        /** @return Array<!Element>*/

      }, {
        key: "listElements",
        get: function get() {
          return [].slice.call(this.root_.querySelectorAll(strings$2$3.ENABLED_ITEMS_SELECTOR));
        }
        /** @param {boolean} value */

      }, {
        key: "wrapFocus",
        set: function set(value) {
          this.foundation_.setWrapFocus(value);
        }
        /** @param {boolean} isSingleSelectionList */

      }, {
        key: "singleSelection",
        set: function set(isSingleSelectionList) {
          this.foundation_.setSingleSelection(isSingleSelectionList);
        }
        /** @return {!Index} */

      }, {
        key: "selectedIndex",
        get: function get() {
          return this.foundation_.getSelectedIndex();
        }
        /** @param {!Index} index */
        ,
        set: function set(index) {
          this.foundation_.setSelectedIndex(index);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCList(root);
        }
      }]);

      return MDCList;
    }(MDCComponent$c);

    /**
     * @extends MDCComponent<!MDCMenuFoundation>
     */

    var MDCMenu =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$c(MDCMenu, _MDCComponent);

      /** @param {...?} args */
      function MDCMenu() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$c(this, MDCMenu);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$c(this, (_getPrototypeOf2 = _getPrototypeOf$c(MDCMenu)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCMenuSurface} */

        _this.menuSurface_;
        /** @private {!MDCList} */

        _this.list_;
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleItemAction_;
        /** @private {!Function} */

        _this.afterOpenedCallback_;
        return _this;
      }
      /**
       * @param {!HTMLElement} root
       * @return {!MDCMenu}
       */


      _createClass$c(MDCMenu, [{
        key: "initialize",
        value: function initialize() {
          var menuSurfaceFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCMenuSurface$1(el);
          };
          var listFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCList$2(el);
          };
          this.menuSurface_ = menuSurfaceFactory(this.root_);
          var list = this.root_.querySelector(strings$a.LIST_SELECTOR);

          if (list) {
            this.list_ = listFactory(list);
            this.list_.wrapFocus = true;
          }
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.afterOpenedCallback_ = function () {
            return _this2.handleAfterOpened_();
          };

          this.handleKeydown_ = function (evt) {
            return _this2.foundation_.handleKeydown(evt);
          };

          this.handleItemAction_ = function (evt) {
            return _this2.foundation_.handleItemAction(_this2.items[evt.detail]);
          };

          this.menuSurface_.listen(MDCMenuSurfaceFoundation$1.strings.OPENED_EVENT, this.afterOpenedCallback_);
          this.listen('keydown', this.handleKeydown_);
          this.listen(MDCListFoundation$2.strings.ACTION_EVENT, this.handleItemAction_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.list_) {
            this.list_.destroy();
          }

          this.menuSurface_.destroy();
          this.menuSurface_.unlisten(MDCMenuSurfaceFoundation$1.strings.OPENED_EVENT, this.afterOpenedCallback_);
          this.unlisten('keydown', this.handleKeydown_);
          this.unlisten(MDCListFoundation$2.strings.ACTION_EVENT, this.handleItemAction_);

          _get$5(_getPrototypeOf$c(MDCMenu.prototype), "destroy", this).call(this);
        }
        /** @return {boolean} */

      }, {
        key: "setAnchorCorner",

        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left
         *     menu corner.
         */
        value: function setAnchorCorner(corner) {
          this.menuSurface_.setAnchorCorner(corner);
        }
        /**
         * @param {!AnchorMargin} margin
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.menuSurface_.setAnchorMargin(margin);
        }
        /**
         * Return the items within the menu. Note that this only contains the set of elements within
         * the items container that are proper list items, and not supplemental / presentational DOM
         * elements.
         * @return {!Array<!HTMLElement>}
         */

      }, {
        key: "getOptionByIndex",

        /**
         * Return the item within the menu at the index specified.
         * @param {number} index
         * @return {?HTMLElement}
         */
        value: function getOptionByIndex(index) {
          var items = this.items;

          if (index < items.length) {
            return this.items[index];
          } else {
            return null;
          }
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "setFixedPosition",

        /** @param {boolean} isFixed */
        value: function setFixedPosition(isFixed) {
          this.menuSurface_.setFixedPosition(isFixed);
        }
      }, {
        key: "hoistMenuToBody",
        value: function hoistMenuToBody() {
          this.menuSurface_.hoistMenuToBody();
        }
        /** @param {boolean} isHoisted */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.menuSurface_.setIsHoisted(isHoisted);
        }
        /**
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.menuSurface_.setAbsolutePosition(x, y);
        }
        /**
         * Sets the element that the menu-surface is anchored to.
         * @param {!HTMLElement} element
         */

      }, {
        key: "setAnchorElement",
        value: function setAnchorElement(element) {
          this.menuSurface_.anchorElement = element;
        }
      }, {
        key: "handleAfterOpened_",
        value: function handleAfterOpened_() {
          var list = this.items;

          if (list.length > 0) {
            list[0].focus();
          }
        }
        /** @return {!MDCMenuFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCMenuFoundation({
            addClassToElementAtIndex: function addClassToElementAtIndex(index, className) {
              var list = _this3.items;
              list[index].classList.add(className);
            },
            removeClassFromElementAtIndex: function removeClassFromElementAtIndex(index, className) {
              var list = _this3.items;
              list[index].classList.remove(className);
            },
            addAttributeToElementAtIndex: function addAttributeToElementAtIndex(index, attr, value) {
              var list = _this3.items;
              list[index].setAttribute(attr, value);
            },
            removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex(index, attr) {
              var list = _this3.items;
              list[index].removeAttribute(attr);
            },
            elementContainsClass: function elementContainsClass(element, className) {
              return element.classList.contains(className);
            },
            closeSurface: function closeSurface() {
              return _this3.open = false;
            },
            getElementIndex: function getElementIndex(element) {
              return _this3.items.indexOf(element);
            },
            getParentElement: function getParentElement(element) {
              return element.parentElement;
            },
            getSelectedElementIndex: function getSelectedElementIndex(selectionGroup) {
              return _this3.items.indexOf(selectionGroup.querySelector(".".concat(cssClasses$c.MENU_SELECTED_LIST_ITEM)));
            },
            notifySelected: function notifySelected(evtData) {
              return _this3.emit(strings$a.SELECTED_EVENT, {
                index: evtData.index,
                item: _this3.items[evtData.index]
              });
            }
          });
        }
      }, {
        key: "open",
        get: function get() {
          return this.menuSurface_.open;
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          this.menuSurface_.open = value;
        }
        /** @return {boolean} */

      }, {
        key: "wrapFocus",
        get: function get() {
          return this.list_.wrapFocus;
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          this.list_.wrapFocus = value;
        }
      }, {
        key: "items",
        get: function get() {
          return this.list_.listElements;
        }
      }, {
        key: "quickOpen",
        set: function set(quickOpen) {
          this.menuSurface_.quickOpen = quickOpen;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCMenu(root);
        }
      }]);

      return MDCMenu;
    }(MDCComponent$c);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcMenuSelectedEvent = /** @class */ (function () {
        function MdcMenuSelectedEvent(index, source) {
            this.index = index;
            this.source = source;
        }
        return MdcMenuSelectedEvent;
    }());
    /** @type {?} */
    var nextUniqueId$4 = 0;
    var MdcMenuSelectionGroup = /** @class */ (function () {
        function MdcMenuSelectionGroup(elementRef) {
            this.elementRef = elementRef;
        }
        MdcMenuSelectionGroup.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcMenuSelectionGroup], mdc-menu-selection-group',
                        host: { 'class': 'mdc-menu__selection-group' },
                        exportAs: 'mdcMenuSelectionGroup'
                    },] },
        ];
        /** @nocollapse */
        MdcMenuSelectionGroup.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcMenuSelectionGroup;
    }());
    var MdcMenuSelectionGroupIcon = /** @class */ (function () {
        function MdcMenuSelectionGroupIcon(elementRef) {
            this.elementRef = elementRef;
        }
        MdcMenuSelectionGroupIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcMenuSelectionGroupIcon], mdc-menu-selection-group-icon',
                        host: { 'class': 'mdc-menu__selection-group-icon' },
                        exportAs: 'mdcMenuSelectionGroupIcon'
                    },] },
        ];
        /** @nocollapse */
        MdcMenuSelectionGroupIcon.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcMenuSelectionGroupIcon;
    }());
    var MdcMenu = /** @class */ (function (_super) {
        __extends(MdcMenu, _super);
        function MdcMenu() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Emits whenever the component is destroyed.
             */
            _this._destroyed = new rxjs.Subject();
            _this._uniqueId = "mdc-menu-" + ++nextUniqueId$4;
            _this.id = _this._uniqueId;
            _this._wrapFocus = false;
            _this.selected = new core.EventEmitter();
            _this._menuFoundation = new MDCMenuFoundation(_this._createAdapter());
            return _this;
        }
        Object.defineProperty(MdcMenu.prototype, "wrapFocus", {
            get: /**
             * @return {?}
             */
            function () { return this._wrapFocus; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._wrapFocus) {
                    this._wrapFocus = newValue;
                    this._list.wrapFocus = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcMenu.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return Object.assign({
                addClassToElementAtIndex: (/**
                 * @param {?} index
                 * @param {?} className
                 * @return {?}
                 */
                function (index, className) {
                    return _this._list.items.toArray()[index].getListItemElement().classList.add(className);
                }),
                removeClassFromElementAtIndex: (/**
                 * @param {?} index
                 * @param {?} className
                 * @return {?}
                 */
                function (index, className) {
                    return _this._list.items.toArray()[index].getListItemElement().classList.remove(className);
                }),
                addAttributeToElementAtIndex: (/**
                 * @param {?} index
                 * @param {?} attr
                 * @param {?} value
                 * @return {?}
                 */
                function (index, attr, value) {
                    return _this._list.items.toArray()[index].getListItemElement().setAttribute(attr, value);
                }),
                removeAttributeFromElementAtIndex: (/**
                 * @param {?} index
                 * @param {?} attr
                 * @return {?}
                 */
                function (index, attr) {
                    return _this._list.items.toArray()[index].getListItemElement().removeAttribute(attr);
                }),
                elementContainsClass: (/**
                 * @param {?} element
                 * @param {?} className
                 * @return {?}
                 */
                function (element, className) { return element.classList.contains(className); }),
                closeSurface: (/**
                 * @return {?}
                 */
                function () {
                    _this.open = false;
                    _this.setOpen();
                }),
                getElementIndex: (/**
                 * @param {?} element
                 * @return {?}
                 */
                function (element) {
                    return _this._list.items.toArray().findIndex((/**
                     * @param {?} _
                     * @return {?}
                     */
                    function (_) { return _.getListItemElement() === element; }));
                }),
                getParentElement: (/**
                 * @param {?} element
                 * @return {?}
                 */
                function (element) { return element.parentElement; }),
                getSelectedElementIndex: (/**
                 * @param {?} selectionGroup
                 * @return {?}
                 */
                function (selectionGroup) {
                    /** @type {?} */
                    var selectedItem = selectionGroup.querySelector(".mdc-menu-item--selected");
                    return selectedItem ? _this._list.items.toArray().findIndex((/**
                     * @param {?} _
                     * @return {?}
                     */
                    function (_) { return _.id === selectedItem.id; })) : -1;
                }),
                notifySelected: (/**
                 * @param {?} evtData
                 * @return {?}
                 */
                function (evtData) {
                    return _this.selected.emit(new MdcMenuSelectedEvent(evtData.index, _this._list.items.toArray()[evtData.index]));
                })
            });
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.initMenuSurface();
            this._initList();
            this._listenForListItemActions();
            this.opened.pipe(operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                if (_this._list) {
                    _this._list.focusFirstElement();
                }
            }));
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
            this.destroyMenuSurface();
            this._menuFoundation.destroy();
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.focus = /**
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcMenu.prototype._handleKeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._menuFoundation.handleKeydown(evt);
        };
        /**
         * @private
         * @return {?}
         */
        MdcMenu.prototype._initList = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this._list) {
                return;
            }
            this._list.setRole('menu');
            this._list.wrapFocus = this._wrapFocus;
            // When the list items change, re-subscribe
            this._list.items.changes.pipe(operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this._list.items.forEach((/**
             * @param {?} item
             * @return {?}
             */
            function (item) { return item.setRole('menuitem'); })); }));
        };
        /** Listens to action events on each list item. */
        /**
         * Listens to action events on each list item.
         * @private
         * @return {?}
         */
        MdcMenu.prototype._listenForListItemActions = /**
         * Listens to action events on each list item.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._list.actionEvent.pipe(operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                return _this._menuFoundation.handleItemAction(_this._list.items.toArray()[event.index].getListItemElement());
            }));
        };
        MdcMenu.decorators = [
            { type: core.Component, args: [{selector: 'mdc-menu',
                        exportAs: 'mdcMenu',
                        host: {
                            '[id]': 'id',
                            'tabindex': '-1',
                            'class': 'mdc-menu mdc-menu-surface',
                            '(keydown)': '_handleKeydown($event)',
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        MdcMenu.propDecorators = {
            id: [{ type: core.Input }],
            wrapFocus: [{ type: core.Input }],
            selected: [{ type: core.Output }],
            _list: [{ type: core.ContentChild, args: [MdcList,] }]
        };
        return MdcMenu;
    }(MdcMenuSurfaceBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MENU_DECLARATIONS = [
        MdcMenu,
        MdcMenuSelectionGroup,
        MdcMenuSelectionGroupIcon
    ];
    var MdcMenuModule = /** @class */ (function () {
        function MdcMenuModule() {
        }
        MdcMenuModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [MdcMenuSurfaceModule],
                        exports: MENU_DECLARATIONS.concat([
                            MdcMenuSurfaceModule
                        ]),
                        declarations: [MENU_DECLARATIONS]
                    },] },
        ];
        return MdcMenuModule;
    }());

    function _classCallCheck$d(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$d(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$d(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$d(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$d(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$d(subClass, superClass);
    }

    function _getPrototypeOf$d(o) {
      _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$d(o);
    }

    function _setPrototypeOf$d(o, p) {
      _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$d(o, p);
    }

    function _assertThisInitialized$d(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$d(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$d(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$d =
    /*#__PURE__*/
    function () {
      _createClass$d(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$d(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$d(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$d =
    /*#__PURE__*/
    function () {
      _createClass$d(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$d());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$d(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$d(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Notched Outline.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Notched Outline into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCNotchedOutlineAdapter =
    /*#__PURE__*/
    function () {
      function MDCNotchedOutlineAdapter() {
        _classCallCheck$d(this, MDCNotchedOutlineAdapter);
      }

      _createClass$d(MDCNotchedOutlineAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets the width style property of the notch element.
         * @param {number} width
         */

      }, {
        key: "setNotchWidthProperty",
        value: function setNotchWidthProperty(width) {}
        /**
         * Removes the width style property from the notch element.
         */

      }, {
        key: "removeNotchWidthProperty",
        value: function removeNotchWidthProperty() {}
      }]);

      return MDCNotchedOutlineAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$b = {
      NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch'
    };
    /** @enum {number} */

    var numbers$7 = {
      // This should stay in sync with $mdc-notched-outline-padding * 2.
      NOTCH_ELEMENT_PADDING: 8
    };
    /** @enum {string} */

    var cssClasses$d = {
      OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
      OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
      NO_LABEL: 'mdc-notched-outline--no-label'
    };

    /**
     * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
     * @final
     */

    var MDCNotchedOutlineFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$d(MDCNotchedOutlineFoundation, _MDCFoundation);

      _createClass$d(MDCNotchedOutlineFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$b;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$d;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$7;
        }
        /**
         * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCNotchedOutlineAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCNotchedOutlineAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              setNotchWidthProperty: function setNotchWidthProperty() {},
              removeNotchWidthProperty: function removeNotchWidthProperty() {}
            }
          );
        }
        /**
         * @param {!MDCNotchedOutlineAdapter} adapter
         */

      }]);

      function MDCNotchedOutlineFoundation(adapter) {
        _classCallCheck$d(this, MDCNotchedOutlineFoundation);

        return _possibleConstructorReturn$d(this, _getPrototypeOf$d(MDCNotchedOutlineFoundation).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
      }
      /**
       * Adds the outline notched selector and updates the notch width
       * calculated based off of notchWidth.
       * @param {number} notchWidth
       */


      _createClass$d(MDCNotchedOutlineFoundation, [{
        key: "notch",
        value: function notch(notchWidth) {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

          if (notchWidth > 0) {
            notchWidth += numbers$7.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
          }

          this.adapter_.setNotchWidthProperty(notchWidth);
          this.adapter_.addClass(OUTLINE_NOTCHED);
        }
        /**
         * Removes notched outline selector to close the notch in the outline.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.removeClass(OUTLINE_NOTCHED);
          this.adapter_.removeNotchWidthProperty();
        }
      }]);

      return MDCNotchedOutlineFoundation;
    }(MDCFoundation$d);

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCFloatingLabelAdapter() {
        _classCallCheck$d(this, MDCFloatingLabelAdapter);
      }

      _createClass$d(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);

      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1$7 = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake',
      ROOT: 'mdc-floating-label'
    };

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$d(MDCFloatingLabelFoundation, _MDCFoundation);

      _createClass$d(MDCFloatingLabelFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$1$7;
        }
        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCFloatingLabelAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }
        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        var _this;

        _classCallCheck$d(this, MDCFloatingLabelFoundation);

        _this = _possibleConstructorReturn$d(this, _getPrototypeOf$d(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };

        return _this;
      }

      _createClass$d(MDCFloatingLabelFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.adapter_.getWidth();
        }
        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: "shake",
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: "handleShakeAnimationEnd_",
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);

      return MDCFloatingLabelFoundation;
    }(MDCFoundation$d);

    /**
     * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
     * @final
     */

    var MDCFloatingLabel$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$d(MDCFloatingLabel, _MDCComponent);

      function MDCFloatingLabel() {
        _classCallCheck$d(this, MDCFloatingLabel);

        return _possibleConstructorReturn$d(this, _getPrototypeOf$d(MDCFloatingLabel).apply(this, arguments));
      }

      _createClass$d(MDCFloatingLabel, [{
        key: "shake",

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake styles the label to shake by adding shake class
         * if true, otherwise will stop shaking by removing shake class.
         */
        value: function shake(shouldShake) {
          this.foundation_.shake(shouldShake);
        }
        /**
         * Styles label to float/dock.
         * @param {boolean} shouldFloat styles the label to float by adding float class
         * if true, otherwise docks the label by removing the float class.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          this.foundation_.float(shouldFloat);
        }
        /**
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.foundation_.getWidth();
        }
        /**
         * @return {!MDCFloatingLabelFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCFloatingLabelFoundation$1({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
              return _this.root_.scrollWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCFloatingLabel}
         */
        value: function attachTo(root) {
          return new MDCFloatingLabel(root);
        }
      }]);

      return MDCFloatingLabel;
    }(MDCComponent$d);

    /**
     * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
     * @final
     */

    var MDCNotchedOutline =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$d(MDCNotchedOutline, _MDCComponent);

      _createClass$d(MDCNotchedOutline, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCNotchedOutline}
         */
        value: function attachTo(root) {
          return new MDCNotchedOutline(root);
        }
        /** @param {...?} args */

      }]);

      function MDCNotchedOutline() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$d(this, MDCNotchedOutline);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$d(this, (_getPrototypeOf2 = _getPrototypeOf$d(MDCNotchedOutline)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {Element} */

        _this.notchElement_;
        return _this;
      }

      _createClass$d(MDCNotchedOutline, [{
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var label = this.root_.querySelector('.' + MDCFloatingLabelFoundation$1.cssClasses.ROOT);
          this.notchElement_ = this.root_.querySelector(strings$b.NOTCH_ELEMENT_SELECTOR);

          if (label) {
            label.style.transitionDuration = '0s';
            this.root_.classList.add(cssClasses$d.OUTLINE_UPGRADED);
            requestAnimationFrame(function () {
              label.style.transitionDuration = '';
            });
          } else {
            this.root_.classList.add(cssClasses$d.NO_LABEL);
          }
        }
        /**
          * Updates classes and styles to open the notch to the specified width.
          * @param {number} notchWidth The notch width in the outline.
          */

      }, {
        key: "notch",
        value: function notch(notchWidth) {
          this.foundation_.notch(notchWidth);
        }
        /**
         * Updates classes and styles to close the notch.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          this.foundation_.closeNotch();
        }
        /**
         * @return {!MDCNotchedOutlineFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCNotchedOutlineFoundation(
          /** @type {!MDCNotchedOutlineAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            setNotchWidthProperty: function setNotchWidthProperty(width) {
              return _this2.notchElement_.style.setProperty('width', width + 'px');
            },
            removeNotchWidthProperty: function removeNotchWidthProperty() {
              return _this2.notchElement_.style.removeProperty('width');
            }
          }));
        }
      }]);

      return MDCNotchedOutline;
    }(MDCComponent$d);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcNotchedOutline = /** @class */ (function () {
        function MdcNotchedOutline(elementRef) {
            this.elementRef = elementRef;
            this._foundation = new MDCNotchedOutlineFoundation(this._createAdapter());
        }
        /**
         * @private
         * @return {?}
         */
        MdcNotchedOutline.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this.elementRef.nativeElement.classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) {
                    return _this.elementRef.nativeElement.classList.remove(className);
                }),
                setNotchWidthProperty: (/**
                 * @param {?} width
                 * @return {?}
                 */
                function (width) {
                    return _this._notchElement.nativeElement.style.setProperty('width', width + "px");
                }),
                removeNotchWidthProperty: (/**
                 * @return {?}
                 */
                function () { return _this._notchElement.nativeElement.style.removeProperty('width'); })
            };
        };
        /** Updates classes and styles to open the notch to the specified width. */
        /**
         * Updates classes and styles to open the notch to the specified width.
         * @param {?} notchWidth
         * @return {?}
         */
        MdcNotchedOutline.prototype.notch = /**
         * Updates classes and styles to open the notch to the specified width.
         * @param {?} notchWidth
         * @return {?}
         */
        function (notchWidth) {
            this._foundation.notch(notchWidth);
        };
        /** Updates classes and styles to close the notch. */
        /**
         * Updates classes and styles to close the notch.
         * @return {?}
         */
        MdcNotchedOutline.prototype.closeNotch = /**
         * Updates classes and styles to close the notch.
         * @return {?}
         */
        function () {
            this._foundation.closeNotch();
        };
        MdcNotchedOutline.decorators = [
            { type: core.Component, args: [{selector: '[mdcNotchedOutline], mdc-notched-outline',
                        exportAs: 'mdcNotchedOutline',
                        host: {
                            'class': 'mdc-notched-outline',
                            '[class.mdc-notched-outline--upgraded]': 'label',
                            '[class.mdc-notched-outline--no-label]': '!label'
                        },
                        template: "\n  <div class=\"mdc-notched-outline__leading\"></div>\n  <div #notch class=\"mdc-notched-outline__notch\">\n    <label mdcFloatingLabel [for]=\"for\">{{label}}</label>\n  </div>\n  <div class=\"mdc-notched-outline__trailing\"></div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcNotchedOutline.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcNotchedOutline.propDecorators = {
            label: [{ type: core.Input }],
            for: [{ type: core.Input }],
            _notchElement: [{ type: core.ViewChild, args: ['notch',] }],
            floatingLabel: [{ type: core.ViewChild, args: [MdcFloatingLabel,] }]
        };
        return MdcNotchedOutline;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcNotchedOutlineModule = /** @class */ (function () {
        function MdcNotchedOutlineModule() {
        }
        MdcNotchedOutlineModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [MdcFloatingLabelModule],
                        exports: [MdcNotchedOutline],
                        declarations: [MdcNotchedOutline]
                    },] },
        ];
        return MdcNotchedOutlineModule;
    }());

    function _classCallCheck$e(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$e(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$e(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$e(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$e(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$e(subClass, superClass);
    }

    function _getPrototypeOf$e(o) {
      _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$e(o);
    }

    function _setPrototypeOf$e(o, p) {
      _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$e(o, p);
    }

    function _assertThisInitialized$e(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$e(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$e(self);
    }

    function _superPropBase$6(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$e(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$6(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$6 = Reflect.get;
      } else {
        _get$6 = function _get(target, property, receiver) {
          var base = _superPropBase$6(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$6(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$e =
    /*#__PURE__*/
    function () {
      _createClass$e(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$e(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$e(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$e =
    /*#__PURE__*/
    function () {
      _createClass$e(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$e());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$e(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$e(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$5 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$e(this, MDCRippleAdapter);
      }

      _createClass$e(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$e = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$c = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$8 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$5;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$5;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$5(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$5(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$5;

      if (typeof supportsCssVariables_$5 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$5(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$5 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$5() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$5 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$5 = isSupported;
      }

      return supportsPassive_$5 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$5(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$5(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$6 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$6 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$5 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$5 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$e(MDCRippleFoundation, _MDCFoundation);

      _createClass$e(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$e;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$c;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$8;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$e(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$e(this, _getPrototypeOf$e(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$e(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$6.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$6.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$6.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$6.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$5.length > 0 && activatedTargets$5.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$5.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$5 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$5(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$8.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$e);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$5 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$e(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$e(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$e(this, (_getPrototypeOf2 = _getPrototypeOf$e(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$e(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$5(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$5(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$5(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$5());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$5());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$5());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$5());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$e);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$5 = function RippleCapableSurface() {
      _classCallCheck$e(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$5.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$5.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$5.prototype.disabled;

    /**
     * @record
     */

    var MDCSelectionControl$1 =
    /*#__PURE__*/
    function () {
      function MDCSelectionControl() {
        _classCallCheck$e(this, MDCSelectionControl);
      }

      _createClass$e(MDCSelectionControl, [{
        key: "ripple",

        /** @return {?MDCRipple} */
        get: function get() {}
      }]);

      return MDCSelectionControl;
    }();

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Radio. Provides an interface for managing
     * - classes
     * - dom
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */

    var MDCRadioAdapter =
    /*#__PURE__*/
    function () {
      function MDCRadioAdapter() {
        _classCallCheck$e(this, MDCRadioAdapter);
      }

      _createClass$e(MDCRadioAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {boolean} disabled */

      }, {
        key: "setNativeControlDisabled",
        value: function setNativeControlDisabled(disabled) {}
      }]);

      return MDCRadioAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$1$7 = {
      NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
    };
    /** @enum {string} */

    var cssClasses$1$8 = {
      ROOT: 'mdc-radio',
      DISABLED: 'mdc-radio--disabled'
    };

    /**
     * @extends {MDCFoundation<!MDCRadioAdapter>}
     */

    var MDCRadioFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$e(MDCRadioFoundation, _MDCFoundation);

      function MDCRadioFoundation() {
        _classCallCheck$e(this, MDCRadioFoundation);

        return _possibleConstructorReturn$e(this, _getPrototypeOf$e(MDCRadioFoundation).apply(this, arguments));
      }

      _createClass$e(MDCRadioFoundation, [{
        key: "setDisabled",

        /** @param {boolean} disabled */
        value: function setDisabled(disabled) {
          var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
          this.adapter_.setNativeControlDisabled(disabled);

          if (disabled) {
            this.adapter_.addClass(DISABLED);
          } else {
            this.adapter_.removeClass(DISABLED);
          }
        }
      }], [{
        key: "cssClasses",

        /** @return enum {cssClasses} */
        get: function get() {
          return cssClasses$1$8;
        }
        /** @return enum {strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$7;
        }
        /** @return {!MDCRadioAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCRadioAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              setNativeControlDisabled: function setNativeControlDisabled()
              /* disabled: boolean */
              {}
            }
          );
        }
      }]);

      return MDCRadioFoundation;
    }(MDCFoundation$e);

    /**
     * @extends MDCComponent<!MDCRadioFoundation>
     * @implements {MDCSelectionControl}
     */

    var MDCRadio =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$e(MDCRadio, _MDCComponent);

      _createClass$e(MDCRadio, [{
        key: "checked",

        /** @return {boolean} */
        get: function get() {
          return this.nativeControl_.checked;
        }
        /** @param {boolean} checked */
        ,
        set: function set(checked) {
          this.nativeControl_.checked = checked;
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get() {
          return this.nativeControl_.disabled;
        }
        /** @param {boolean} disabled */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
        /** @return {?string} */

      }, {
        key: "value",
        get: function get() {
          return this.nativeControl_.value;
        }
        /** @param {?string} value */
        ,
        set: function set(value) {
          this.nativeControl_.value = value;
        }
        /** @return {!MDCRipple} */

      }, {
        key: "ripple",
        get: function get() {
          return this.ripple_;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCRadio(root);
        }
      }]);

      function MDCRadio() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$e(this, MDCRadio);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$e(this, (_getPrototypeOf2 = _getPrototypeOf$e(MDCRadio)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        return _this;
      }
      /**
       * @return {!MDCRipple}
       * @private
       */


      _createClass$e(MDCRadio, [{
        key: "initRipple_",
        value: function initRipple_() {
          var _this2 = this;

          var adapter = Object.assign(MDCRipple$5.createAdapter(this), {
            isUnbounded: function isUnbounded() {
              return true;
            },
            // Radio buttons technically go "active" whenever there is *any* keyboard interaction. This is not the
            // UI we desire.
            isSurfaceActive: function isSurfaceActive() {
              return false;
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.nativeControl_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.nativeControl_.removeEventListener(type, handler);
            }
          });
          var foundation = new MDCRippleFoundation$5(adapter);
          return new MDCRipple$5(this.root_, foundation);
        }
        /**
         * Returns the state of the native control element, or null if the native control element is not present.
         * @return {?MDCSelectionControlState}
         * @private
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();

          _get$6(_getPrototypeOf$e(MDCRadio.prototype), "destroy", this).call(this);
        }
        /** @return {!MDCRadioFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCRadioFoundation({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            setNativeControlDisabled: function setNativeControlDisabled(disabled) {
              return _this3.nativeControl_.disabled = disabled;
            }
          });
        }
      }, {
        key: "nativeControl_",
        get: function get() {
          var NATIVE_CONTROL_SELECTOR = MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
          var el =
          /** @type {?MDCSelectionControlState} */
          this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
          return el;
        }
      }]);

      return MDCRadio;
    }(MDCComponent$e);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token used to provide the parent MdcRadioGroup component to MdcRadio.
     * @type {?}
     */
    var MDC_RADIO_GROUP_PARENT_COMPONENT = new core.InjectionToken('MDC_RADIO_GROUP_PARENT_COMPONENT');
    /** @type {?} */
    var nextUniqueId$5 = 0;
    /**
     * Change event object emitted by MdcRadio.
     */
    var   /**
     * Change event object emitted by MdcRadio.
     */
    MdcRadioChange = /** @class */ (function () {
        function MdcRadioChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return MdcRadioChange;
    }());
    var MdcRadio = /** @class */ (function () {
        function MdcRadio(_changeDetectorRef, elementRef, ripple, _radioDispatcher, radioGroup, _parentFormField) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this.ripple = ripple;
            this._radioDispatcher = _radioDispatcher;
            this.radioGroup = radioGroup;
            this._parentFormField = _parentFormField;
            this._uniqueId = "mdc-radio-" + ++nextUniqueId$5;
            /**
             * The unique ID for the radio button.
             */
            this.id = this._uniqueId;
            this.tabIndex = 0;
            this._checked = false;
            this._disabled = false;
            this._required = false;
            this.change = new core.EventEmitter();
            /**
             * Unregister function for _radioDispatcher
             */
            this._removeUniqueSelectionListener = (/**
             * @return {?}
             */
            function () { });
            this._foundation = new MDCRadioFoundation(this._createAdapter());
            if (this._parentFormField) {
                _parentFormField.elementRef.nativeElement.classList.add('mdc-form-field');
            }
            this._removeUniqueSelectionListener =
                _radioDispatcher.listen((/**
                 * @param {?} id
                 * @param {?} name
                 * @return {?}
                 */
                function (id, name) {
                    if (id !== _this.id && name === _this.name) {
                        _this.checked = false;
                    }
                }));
        }
        Object.defineProperty(MdcRadio.prototype, "inputId", {
            get: /**
             * @return {?}
             */
            function () { return (this.id || this._uniqueId) + "-input"; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadio.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this.setValue(newValue);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadio.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () { return this._checked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadio.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled); },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newDisabledState = toBoolean(value);
                if (this._disabled !== newDisabledState) {
                    this._disabled = newDisabledState;
                    this._foundation.setDisabled(this._disabled);
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadio.prototype, "required", {
            get: /**
             * @return {?}
             */
            function () { return this._required || (this.radioGroup && this.radioGroup.required); },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcRadio.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                setNativeControlDisabled: (/**
                 * @param {?} disabled
                 * @return {?}
                 */
                function (disabled) { return _this.disabled = disabled; })
            };
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            this._initRipple();
            if (this.radioGroup) {
                Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    // If the radio is inside a radio group, determine if it should be checked
                    _this.checked = _this.radioGroup.value === _this._value;
                    // Copy name from parent radio group
                    _this.name = _this.radioGroup.name;
                    _this._changeDetectorRef.markForCheck();
                }));
            }
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._removeUniqueSelectionListener();
            this.ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcRadio.prototype.onInputClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // Preventing bubbling for the second event will solve that issue.
            event.stopPropagation();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcRadio.prototype.onInputChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            /** @type {?} */
            var groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;
            this.checked = true;
            this._emitChangeEvent();
            if (this.radioGroup) {
                this.radioGroup._controlValueAccessorChangeFn(this.value);
                this.radioGroup._touch();
                if (groupValueChanged) {
                    this.radioGroup.emitChangeEvent();
                }
            }
        };
        /**
         * @param {?} checked
         * @return {?}
         */
        MdcRadio.prototype.setChecked = /**
         * @param {?} checked
         * @return {?}
         */
        function (checked) {
            /** @type {?} */
            var newCheckedState = toBoolean(checked);
            if (this._checked !== newCheckedState) {
                this._checked = newCheckedState;
                this._getInputElement().checked = newCheckedState;
                if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {
                    this.radioGroup.selected = this;
                }
                else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {
                    // When unchecking the selected radio button, update the selected radio
                    // property on the group.
                    this.radioGroup.selected = null;
                }
                if (newCheckedState) {
                    // Notify all radio buttons with the same name to un-check.
                    this._radioDispatcher.notify(this.id, this.name);
                }
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcRadio.prototype.setValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._value !== value) {
                this._value = value;
                this._getInputElement().value = this._value;
                if (this.radioGroup !== null) {
                    if (!this.checked) {
                        // Update checked when the value changed to match the radio group's value
                        this.checked = this.radioGroup.value === value;
                    }
                    if (this.checked) {
                        this.radioGroup.selected = this;
                    }
                }
            }
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.focus = /**
         * @return {?}
         */
        function () {
            this._getInputElement().focus();
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.markForCheck = /**
         * @return {?}
         */
        function () {
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        MdcRadio.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.ripple.init({
                surface: this._getHostElement(),
                activator: this._getInputElement()
            }, Object.assign(this.ripple.createAdapter(), {
                isUnbounded: (/**
                 * @return {?}
                 */
                function () { return true; }),
                isSurfaceActive: (/**
                 * @return {?}
                 */
                function () { return false; }),
                isSurfaceDisabled: (/**
                 * @return {?}
                 */
                function () { return _this._disabled; })
            }));
        };
        /** Dispatch change event with current value. */
        /**
         * Dispatch change event with current value.
         * @private
         * @return {?}
         */
        MdcRadio.prototype._emitChangeEvent = /**
         * Dispatch change event with current value.
         * @private
         * @return {?}
         */
        function () {
            this.change.emit(new MdcRadioChange(this, this._value));
        };
        /** Retrieves the DOM element of the component input. */
        /**
         * Retrieves the DOM element of the component input.
         * @private
         * @return {?}
         */
        MdcRadio.prototype._getInputElement = /**
         * Retrieves the DOM element of the component input.
         * @private
         * @return {?}
         */
        function () {
            return this.input.nativeElement;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcRadio.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcRadio.decorators = [
            { type: core.Component, args: [{selector: 'mdc-radio',
                        exportAs: 'mdcRadio',
                        host: {
                            '[id]': 'id',
                            'class': 'mdc-radio',
                            '(focus)': 'input.nativeElement.focus()',
                            '[attr.tabindex]': 'null'
                        },
                        template: "\n  <input type=\"radio\"\n    #input\n    class=\"mdc-radio__native-control\"\n    [id]=\"inputId\"\n    [attr.name]=\"name\"\n    [tabIndex]=\"tabIndex\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [attr.aria-describedby]=\"ariaDescribedby\"\n    [disabled]=\"disabled\"\n    [required]=\"required\"\n    [checked]=\"checked\"\n    (click)=\"onInputClick($event)\"\n    (change)=\"onInputChange($event)\" />\n    <div class=\"mdc-radio__background\">\n      <div class=\"mdc-radio__outer-circle\"></div>\n      <div class=\"mdc-radio__inner-circle\"></div>\n    </div>\n  ",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            MdcRipple,
                            { provide: MdcFormFieldControl, useExisting: MdcRadio }
                        ]
                    },] },
        ];
        /** @nocollapse */
        MdcRadio.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: MdcRipple },
            { type: UniqueSelectionDispatcher },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_RADIO_GROUP_PARENT_COMPONENT,] }] },
            { type: MdcFormField, decorators: [{ type: core.Optional }] }
        ]; };
        MdcRadio.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            ariaDescribedby: [{ type: core.Input, args: ['aria-describedby',] }],
            value: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            required: [{ type: core.Input }],
            change: [{ type: core.Output }],
            input: [{ type: core.ViewChild, args: ['input',] }]
        };
        return MdcRadio;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Provider Expression that allows mdc-radio-group to register as a ControlValueAccessor. This
     * allows it to support [(ngModel)] and ngControl.
     * @type {?}
     */
    var MDC_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return MdcRadioGroup; })),
        multi: true
    };
    /** @type {?} */
    var nextUniqueId$1$1 = 0;
    var MdcRadioGroup = /** @class */ (function () {
        function MdcRadioGroup(_changeDetectorRef, elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._name = "mdc-radio-group-" + nextUniqueId$1$1++;
            /**
             * Selected value for the radio group.
             */
            this._value = null;
            /**
             * Whether the `value` has been set to its initial value.
             */
            this._isInitialized = false;
            this._selected = null;
            this._required = false;
            this._disabled = false;
            /**
             * The method to be called in order to update ngModel
             */
            this._controlValueAccessorChangeFn = (/**
             * @return {?}
             */
            function () { });
            /**
             * onTouch function registered via registerOnTouch (ControlValueAccessor).
             */
            this.onTouched = (/**
             * @return {?}
             */
            function () { });
            this.change = new core.EventEmitter();
        }
        Object.defineProperty(MdcRadioGroup.prototype, "name", {
            /** Name of the radio button group. All radio buttons inside this group will use this name. */
            get: /**
             * Name of the radio button group. All radio buttons inside this group will use this name.
             * @return {?}
             */
            function () { return this._name; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this._updateRadioButtonNames();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadioGroup.prototype, "value", {
            /**
             * Value for the radio-group. Should equal the value of the selected radio button if there is
             * a corresponding radio button with a matching value. If there is not such a corresponding
             * radio button, this value persists to be applied in case a new radio button is added with a
             * matching value.
             */
            get: /**
             * Value for the radio-group. Should equal the value of the selected radio button if there is
             * a corresponding radio button with a matching value. If there is not such a corresponding
             * radio button, this value persists to be applied in case a new radio button is added with a
             * matching value.
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (this._value !== newValue) {
                    // Set this before proceeding to ensure no circular loop occurs with selection.
                    this._value = newValue;
                    this._updateSelectedRadioFromValue();
                    this._checkSelectedRadioButton();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadioGroup.prototype, "selected", {
            /**
             * The currently selected radio button. If set to a new radio button, the radio group value
             * will be updated to match the new selected button.
             */
            get: /**
             * The currently selected radio button. If set to a new radio button, the radio group value
             * will be updated to match the new selected button.
             * @return {?}
             */
            function () { return this._selected; },
            set: /**
             * @param {?} selected
             * @return {?}
             */
            function (selected) {
                this._selected = selected;
                this.value = selected ? selected.value : null;
                this._checkSelectedRadioButton();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadioGroup.prototype, "required", {
            get: /**
             * @return {?}
             */
            function () { return this._required; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = toBoolean(value);
                this._markRadiosForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadioGroup.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = toBoolean(value);
                this._updateDisableRadioState(this._disabled);
                this._markRadiosForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcRadioGroup.prototype._checkSelectedRadioButton = /**
         * @return {?}
         */
        function () {
            if (this._selected && !this._selected.checked) {
                this._selected.checked = true;
            }
        };
        /**
         * @return {?}
         */
        MdcRadioGroup.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._isInitialized = true;
        };
        /**
         * @return {?}
         */
        MdcRadioGroup.prototype._touch = /**
         * @return {?}
         */
        function () {
            if (this.onTouched) {
                this.onTouched();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcRadioGroup.prototype._updateRadioButtonNames = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._radios) {
                this._radios.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                function (radio) {
                    radio.name = _this.name;
                }));
                this._markRadiosForCheck();
            }
        };
        /** Updates the `selected` radio button from the internal _value state. */
        /**
         * Updates the `selected` radio button from the internal _value state.
         * @private
         * @return {?}
         */
        MdcRadioGroup.prototype._updateSelectedRadioFromValue = /**
         * Updates the `selected` radio button from the internal _value state.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // If the value already matches the selected radio, do nothing.
            /** @type {?} */
            var isAlreadySelected = this._selected !== null && this._selected.value === this._value;
            if (this._radios && !isAlreadySelected) {
                this._selected = null;
                this._radios.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                function (radio) {
                    radio.checked = _this.value === radio.value;
                    if (radio.checked) {
                        _this._selected = radio;
                    }
                }));
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcRadioGroup.prototype._markRadiosForCheck = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._radios) {
                this._radios.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                function (radio) { return radio.markForCheck(); }));
            }
        };
        /**
         * @private
         * @param {?} disabled
         * @return {?}
         */
        MdcRadioGroup.prototype._updateDisableRadioState = /**
         * @private
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            if (this._radios) {
                this._radios.forEach((/**
                 * @param {?} radio
                 * @return {?}
                 */
                function (radio) { return radio.disabled = disabled; }));
            }
        };
        /** Sets the model value. Implemented as part of ControlValueAccessor. */
        /**
         * Sets the model value. Implemented as part of ControlValueAccessor.
         * @param {?} value
         * @return {?}
         */
        MdcRadioGroup.prototype.writeValue = /**
         * Sets the model value. Implemented as part of ControlValueAccessor.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Registers a callback to be triggered when the model value changes.
         * Implemented as part of ControlValueAccessor.
         * @param fn Callback to be registered.
         */
        /**
         * Registers a callback to be triggered when the model value changes.
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn Callback to be registered.
         * @return {?}
         */
        MdcRadioGroup.prototype.registerOnChange = /**
         * Registers a callback to be triggered when the model value changes.
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn Callback to be registered.
         * @return {?}
         */
        function (fn) {
            this._controlValueAccessorChangeFn = fn;
        };
        /**
         * Registers a callback to be triggered when the control is touched.
         * Implemented as part of ControlValueAccessor.
         * @param fn Callback to be registered.
         */
        /**
         * Registers a callback to be triggered when the control is touched.
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn Callback to be registered.
         * @return {?}
         */
        MdcRadioGroup.prototype.registerOnTouched = /**
         * Registers a callback to be triggered when the control is touched.
         * Implemented as part of ControlValueAccessor.
         * @param {?} fn Callback to be registered.
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
         * @param isDisabled Whether the control should be disabled.
         */
        /**
         * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
         * @param {?} isDisabled Whether the control should be disabled.
         * @return {?}
         */
        MdcRadioGroup.prototype.setDisabledState = /**
         * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
         * @param {?} isDisabled Whether the control should be disabled.
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = toBoolean(isDisabled);
            this._changeDetectorRef.markForCheck();
        };
        /** Dispatch change event with current selection and group value. */
        /**
         * Dispatch change event with current selection and group value.
         * @return {?}
         */
        MdcRadioGroup.prototype.emitChangeEvent = /**
         * Dispatch change event with current selection and group value.
         * @return {?}
         */
        function () {
            if (this._isInitialized) {
                this.change.emit(new MdcRadioChange((/** @type {?} */ (this._selected)), this._value));
            }
        };
        MdcRadioGroup.decorators = [
            { type: core.Component, args: [{
                        selector: 'mdc-radio-group, [mdcRadioGroup]',
                        exportAs: 'mdcRadioGroup',
                        host: {
                            'role': 'radiogroup'
                        },
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [
                            MDC_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,
                            { provide: MDC_RADIO_GROUP_PARENT_COMPONENT, useExisting: MdcRadioGroup }
                        ]
                    },] },
        ];
        /** @nocollapse */
        MdcRadioGroup.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcRadioGroup.propDecorators = {
            _radios: [{ type: core.ContentChildren, args: [core.forwardRef((/**
                         * @return {?}
                         */
                        function () { return MdcRadio; })), { descendants: true },] }],
            name: [{ type: core.Input }],
            value: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            required: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            change: [{ type: core.Output }]
        };
        return MdcRadioGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcRadioModule = /** @class */ (function () {
        function MdcRadioModule() {
        }
        MdcRadioModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [MdcFormFieldModule],
                        exports: [
                            MdcRadio,
                            MdcRadioGroup
                        ],
                        declarations: [
                            MdcRadio,
                            MdcRadioGroup
                        ]
                    },] },
        ];
        return MdcRadioModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcSelectIcon = /** @class */ (function (_super) {
        __extends(MdcSelectIcon, _super);
        function MdcSelectIcon() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MdcSelectIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcSelectIcon]',
                        exportAs: 'mdcSelectIcon',
                        host: { 'class': 'mdc-select__icon' }
                    },] },
        ];
        return MdcSelectIcon;
    }(MdcIcon));

    function _classCallCheck$f(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$f(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$f(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$f(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty$2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits$f(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$f(subClass, superClass);
    }

    function _getPrototypeOf$f(o) {
      _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$f(o);
    }

    function _setPrototypeOf$f(o, p) {
      _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$f(o, p);
    }

    function _assertThisInitialized$f(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$f(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$f(self);
    }

    function _superPropBase$7(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$f(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$7(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$7 = Reflect.get;
      } else {
        _get$7 = function _get(target, property, receiver) {
          var base = _superPropBase$7(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$7(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$f =
    /*#__PURE__*/
    function () {
      _createClass$f(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$f(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$f(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$f =
    /*#__PURE__*/
    function () {
      _createClass$f(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$f());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$f(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$f(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Select Helper Text.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Select helper text into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCSelectHelperTextAdapter =
    /*#__PURE__*/
    function () {
      function MDCSelectHelperTextAdapter() {
        _classCallCheck$f(this, MDCSelectHelperTextAdapter);
      }

      _createClass$f(MDCSelectHelperTextAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the helper text element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the helper text element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns whether or not the helper text element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets an attribute with a given value on the helper text element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Removes an attribute from the helper text element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}
        /**
         * Sets the text content for the helper text element.
         * @param {string} content
         */

      }, {
        key: "setContent",
        value: function setContent(content) {}
      }]);

      return MDCSelectHelperTextAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$d = {
      ARIA_HIDDEN: 'aria-hidden',
      ROLE: 'role'
    };
    /** @enum {string} */

    var cssClasses$f = {
      HELPER_TEXT_PERSISTENT: 'mdc-select-helper-text--persistent',
      HELPER_TEXT_VALIDATION_MSG: 'mdc-select-helper-text--validation-msg'
    };

    /**
     * @extends {MDCFoundation<!MDCSelectHelperTextAdapter>}
     * @final
     */

    var MDCSelectHelperTextFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCSelectHelperTextFoundation, _MDCFoundation);

      _createClass$f(MDCSelectHelperTextFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$f;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$d;
        }
        /**
         * {@see MDCSelectHelperTextAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCSelectHelperTextAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCSelectHelperTextAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              setContent: function setContent() {}
            }
          );
        }
        /**
         * @param {!MDCSelectHelperTextAdapter} adapter
         */

      }]);

      function MDCSelectHelperTextFoundation(adapter) {
        _classCallCheck$f(this, MDCSelectHelperTextFoundation);

        return _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCSelectHelperTextFoundation).call(this, Object.assign(MDCSelectHelperTextFoundation.defaultAdapter, adapter)));
      }
      /**
       * Sets the content of the helper text field.
       * @param {string} content
       */


      _createClass$f(MDCSelectHelperTextFoundation, [{
        key: "setContent",
        value: function setContent(content) {
          this.adapter_.setContent(content);
        }
        /** @param {boolean} isPersistent Sets the persistency of the helper text. */

      }, {
        key: "setPersistent",
        value: function setPersistent(isPersistent) {
          if (isPersistent) {
            this.adapter_.addClass(cssClasses$f.HELPER_TEXT_PERSISTENT);
          } else {
            this.adapter_.removeClass(cssClasses$f.HELPER_TEXT_PERSISTENT);
          }
        }
        /**
         * @param {boolean} isValidation True to make the helper text act as an
         *   error validation message.
         */

      }, {
        key: "setValidation",
        value: function setValidation(isValidation) {
          if (isValidation) {
            this.adapter_.addClass(cssClasses$f.HELPER_TEXT_VALIDATION_MSG);
          } else {
            this.adapter_.removeClass(cssClasses$f.HELPER_TEXT_VALIDATION_MSG);
          }
        }
        /** Makes the helper text visible to the screen reader. */

      }, {
        key: "showToScreenReader",
        value: function showToScreenReader() {
          this.adapter_.removeAttr(strings$d.ARIA_HIDDEN);
        }
        /**
         * Sets the validity of the helper text based on the select validity.
         * @param {boolean} selectIsValid
         */

      }, {
        key: "setValidity",
        value: function setValidity(selectIsValid) {
          var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$f.HELPER_TEXT_PERSISTENT);
          var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$f.HELPER_TEXT_VALIDATION_MSG);
          var validationMsgNeedsDisplay = helperTextIsValidationMsg && !selectIsValid;

          if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(strings$d.ROLE, 'alert');
          } else {
            this.adapter_.removeAttr(strings$d.ROLE);
          }

          if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
          }
        }
        /**
         * Hides the help text from screen readers.
         * @private
         */

      }, {
        key: "hide_",
        value: function hide_() {
          this.adapter_.setAttr(strings$d.ARIA_HIDDEN, 'true');
        }
      }]);

      return MDCSelectHelperTextFoundation;
    }(MDCFoundation$f);

    /**
     * @extends {MDCComponent<!MDCSelectHelperTextFoundation>}
     * @final
     */

    var MDCSelectHelperText =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCSelectHelperText, _MDCComponent);

      function MDCSelectHelperText() {
        _classCallCheck$f(this, MDCSelectHelperText);

        return _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCSelectHelperText).apply(this, arguments));
      }

      _createClass$f(MDCSelectHelperText, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCSelectHelperTextFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCSelectHelperTextFoundation(
          /** @type {!MDCSelectHelperTextAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setAttr: function setAttr(attr, value) {
              return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
              return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCSelectHelperTextFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCSelectHelperText}
         */
        value: function attachTo(root) {
          return new MDCSelectHelperText(root);
        }
      }]);

      return MDCSelectHelperText;
    }(MDCComponent$f);

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1$9 = {
      DISABLED: 'mdc-select--disabled',
      ROOT: 'mdc-select',
      OUTLINED: 'mdc-select--outlined',
      FOCUSED: 'mdc-select--focused',
      SELECTED_ITEM_CLASS: 'mdc-list-item--selected',
      WITH_LEADING_ICON: 'mdc-select--with-leading-icon',
      INVALID: 'mdc-select--invalid',
      REQUIRED: 'mdc-select--required'
    };
    /** @enum {string} */

    var strings$1$8 = {
      ARIA_CONTROLS: 'aria-controls',
      CHANGE_EVENT: 'MDCSelect:change',
      SELECTED_ITEM_SELECTOR: ".".concat(cssClasses$1$9.SELECTED_ITEM_CLASS),
      LEADING_ICON_SELECTOR: '.mdc-select__icon',
      SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text',
      HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
      MENU_SELECTOR: '.mdc-select__menu',
      LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
      LABEL_SELECTOR: '.mdc-floating-label',
      NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
      OUTLINE_SELECTOR: '.mdc-notched-outline',
      ENHANCED_VALUE_ATTR: 'data-value',
      ARIA_SELECTED_ATTR: 'aria-selected'
    };
    /** @enum {number} */

    var numbers$9 = {
      LABEL_SCALE: 0.75
    };

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCFloatingLabelAdapter() {
        _classCallCheck$f(this, MDCFloatingLabelAdapter);
      }

      _createClass$f(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);

      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$2$3 = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake',
      ROOT: 'mdc-floating-label'
    };

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCFloatingLabelFoundation, _MDCFoundation);

      _createClass$f(MDCFloatingLabelFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$2$3;
        }
        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCFloatingLabelAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }
        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCFloatingLabelFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };

        return _this;
      }

      _createClass$f(MDCFloatingLabelFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.adapter_.getWidth();
        }
        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: "shake",
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: "handleShakeAnimationEnd_",
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);

      return MDCFloatingLabelFoundation;
    }(MDCFoundation$f);

    /**
     * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
     * @final
     */

    var MDCFloatingLabel$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCFloatingLabel, _MDCComponent);

      function MDCFloatingLabel() {
        _classCallCheck$f(this, MDCFloatingLabel);

        return _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCFloatingLabel).apply(this, arguments));
      }

      _createClass$f(MDCFloatingLabel, [{
        key: "shake",

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake styles the label to shake by adding shake class
         * if true, otherwise will stop shaking by removing shake class.
         */
        value: function shake(shouldShake) {
          this.foundation_.shake(shouldShake);
        }
        /**
         * Styles label to float/dock.
         * @param {boolean} shouldFloat styles the label to float by adding float class
         * if true, otherwise docks the label by removing the float class.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          this.foundation_.float(shouldFloat);
        }
        /**
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.foundation_.getWidth();
        }
        /**
         * @return {!MDCFloatingLabelFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCFloatingLabelFoundation$2({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
              return _this.root_.scrollWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCFloatingLabel}
         */
        value: function attachTo(root) {
          return new MDCFloatingLabel(root);
        }
      }]);

      return MDCFloatingLabel;
    }(MDCComponent$f);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC TextField Line Ripple.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the line ripple into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCLineRippleAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCLineRippleAdapter() {
        _classCallCheck$f(this, MDCLineRippleAdapter);
      }

      _createClass$f(MDCLineRippleAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the line ripple element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the line ripple element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the style property with propertyName to value on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(propertyName, value) {}
        /**
         * Registers an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
      }]);

      return MDCLineRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$3$1 = {
      LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
      LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
    };

    /**
     * @extends {MDCFoundation<!MDCLineRippleAdapter>}
     * @final
     */

    var MDCLineRippleFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCLineRippleFoundation, _MDCFoundation);

      _createClass$f(MDCLineRippleFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$3$1;
        }
        /**
         * {@see MDCLineRippleAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCLineRippleAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCLineRippleAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setStyle: function setStyle() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {}
            }
          );
        }
        /**
         * @param {!MDCLineRippleAdapter=} adapter
         */

      }]);

      function MDCLineRippleFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCLineRippleFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCLineRippleFoundation).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };

        return _this;
      }

      _createClass$f(MDCLineRippleFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        }
        /**
         * Activates the line ripple
         */

      }, {
        key: "activate",
        value: function activate() {
          this.adapter_.removeClass(cssClasses$3$1.LINE_RIPPLE_DEACTIVATING);
          this.adapter_.addClass(cssClasses$3$1.LINE_RIPPLE_ACTIVE);
        }
        /**
         * Sets the center of the ripple animation to the given X coordinate.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.addClass(cssClasses$3$1.LINE_RIPPLE_DEACTIVATING);
        }
        /**
         * Handles a transition end event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Wait for the line ripple to be either transparent or opaque
          // before emitting the animation end event
          var isDeactivating = this.adapter_.hasClass(cssClasses$3$1.LINE_RIPPLE_DEACTIVATING);

          if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
              this.adapter_.removeClass(cssClasses$3$1.LINE_RIPPLE_ACTIVE);
              this.adapter_.removeClass(cssClasses$3$1.LINE_RIPPLE_DEACTIVATING);
            }
          }
        }
      }]);

      return MDCLineRippleFoundation;
    }(MDCFoundation$f);

    /**
     * @extends {MDCComponent<!MDCLineRippleFoundation>}
     * @final
     */

    var MDCLineRipple$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCLineRipple, _MDCComponent);

      function MDCLineRipple() {
        _classCallCheck$f(this, MDCLineRipple);

        return _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCLineRipple).apply(this, arguments));
      }

      _createClass$f(MDCLineRipple, [{
        key: "activate",

        /**
         * Activates the line ripple
         */
        value: function activate() {
          this.foundation_.activate();
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Sets the transform origin given a user's click location. The `rippleCenter` is the
         * x-coordinate of the middle of the ripple.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.foundation_.setRippleCenter(xCoordinate);
        }
        /**
         * @return {!MDCLineRippleFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLineRippleFoundation$1(
          /** @type {!MDCLineRippleAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setStyle: function setStyle(propertyName, value) {
              return _this.root_.style[propertyName] = value;
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          }));
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCLineRipple}
         */
        value: function attachTo(root) {
          return new MDCLineRipple(root);
        }
      }]);

      return MDCLineRipple;
    }(MDCComponent$f);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Menu. Provides an interface for managing
     * - selected element classes
     * - get focused elements
     * - toggling a checkbox inside a list item
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCMenuAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCMenuAdapter() {
        _classCallCheck$f(this, MDCMenuAdapter);
      }

      _createClass$f(MDCMenuAdapter, [{
        key: "addClassToElementAtIndex",

        /**
         * Adds a class to the element at the index provided.
         * @param {number} index
         * @param {string} className
         */
        value: function addClassToElementAtIndex(index, className) {}
        /**
         * Removes a class from the element at the index provided
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "removeClassFromElementAtIndex",
        value: function removeClassFromElementAtIndex(index, className) {}
        /**
         * Adds an attribute, with value, to the element at the index provided.
         * @param {number} index
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "addAttributeToElementAtIndex",
        value: function addAttributeToElementAtIndex(index, attr, value) {}
        /**
         * Removes an attribute from an element at the index provided.
         * @param {number} index
         * @param {string} attr
         */

      }, {
        key: "removeAttributeFromElementAtIndex",
        value: function removeAttributeFromElementAtIndex(index, attr) {}
        /**
         * Returns true if the element contains the className.
         * @param {?HTMLElement} element
         * @param {string} className
         * @return {boolean} true if the element contains the className
         */

      }, {
        key: "elementContainsClass",
        value: function elementContainsClass(element, className) {}
        /**
         * Closes the menu-surface.
         */

      }, {
        key: "closeSurface",
        value: function closeSurface() {}
        /**
         * Returns the index for the element provided.
         * @param {?HTMLElement} element
         * @return {number} index of the element in the list or -1 if it is not in the list.
         */

      }, {
        key: "getElementIndex",
        value: function getElementIndex(element) {}
        /**
         * Returns the parentElement of the provided element.
         * @param {?HTMLElement} element
         * @return {?HTMLElement} parentElement of the element provided.
         */

      }, {
        key: "getParentElement",
        value: function getParentElement(element) {}
        /**
         * Returns the element within the selectionGroup containing the selected element class.
         * @param {!HTMLElement} selectionGroup
         * @return {number} element within the selectionGroup that contains the selected element class.
         */

      }, {
        key: "getSelectedElementIndex",
        value: function getSelectedElementIndex(selectionGroup) {}
        /**
         * Emits an event using the evtData.
         * @param {{
        *    index: number
        *   }} evtData
         */

      }, {
        key: "notifySelected",
        value: function notifySelected(evtData) {}
      }]);

      return MDCMenuAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$4$1 = {
      ROOT: 'mdc-menu',
      MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
      MENU_SELECTION_GROUP: 'mdc-menu__selection-group'
    };
    /** @enum {string} */

    var strings$2$4 = {
      SELECTED_EVENT: 'MDCMenu:selected',
      ARIA_SELECTED_ATTR: 'aria-selected',
      LIST_SELECTOR: '.mdc-list',
      CHECKBOX_SELECTOR: 'input[type="checkbox"]'
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDCMenuSurface. Provides an interface for managing
     * - classes
     * - dom
     * - focus
     * - position
     * - dimensions
     * - event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCMenuSurfaceAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCMenuSurfaceAdapter() {
        _classCallCheck$f(this, MDCMenuSurfaceAdapter);
      }

      _createClass$f(MDCMenuSurfaceAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /** @return {boolean} */

      }, {
        key: "hasAnchor",
        value: function hasAnchor() {}
        /** Emits an event when the menu surface is closed. */

      }, {
        key: "notifyClose",
        value: function notifyClose() {}
        /** Emits an event when the menu surface is opened. */

      }, {
        key: "notifyOpen",
        value: function notifyOpen() {}
        /**
         * @return {boolean}
         * @param {EventTarget} el
         */

      }, {
        key: "isElementInContainer",
        value: function isElementInContainer(el) {}
        /** @return {boolean} */

      }, {
        key: "isRtl",
        value: function isRtl() {}
        /** @param {string} origin */

      }, {
        key: "setTransformOrigin",
        value: function setTransformOrigin(origin) {}
        /** @return {boolean} */

      }, {
        key: "isFocused",
        value: function isFocused() {}
        /** Saves the element that was focused before the menu surface was opened. */

      }, {
        key: "saveFocus",
        value: function saveFocus() {}
        /** Restores focus to the element that was focused before the menu surface was opened. */

      }, {
        key: "restoreFocus",
        value: function restoreFocus() {}
        /** @return {boolean} */

      }, {
        key: "isFirstElementFocused",
        value: function isFirstElementFocused() {}
        /** @return {boolean} */

      }, {
        key: "isLastElementFocused",
        value: function isLastElementFocused() {}
        /** Focuses the first focusable element in the menu-surface. */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {}
        /** Focuses the first focusable element in the menu-surface. */

      }, {
        key: "focusLastElement",
        value: function focusLastElement() {}
        /** @return {!{width: number, height: number}} */

      }, {
        key: "getInnerDimensions",
        value: function getInnerDimensions() {}
        /** @return {!{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

      }, {
        key: "getAnchorDimensions",
        value: function getAnchorDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getWindowDimensions",
        value: function getWindowDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getBodyDimensions",
        value: function getBodyDimensions() {}
        /** @return {!{ width: number, height: number }} */

      }, {
        key: "getWindowScroll",
        value: function getWindowScroll() {}
        /** @param {!{
        *   top: (string|undefined),
        *   right: (string|undefined),
        *   bottom: (string|undefined),
        *   left: (string|undefined)
        * }} position */

      }, {
        key: "setPosition",
        value: function setPosition(position) {}
        /** @param {string} height */

      }, {
        key: "setMaxHeight",
        value: function setMaxHeight(height) {}
      }]);

      return MDCMenuSurfaceAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$5$1 = {
      ANCHOR: 'mdc-menu-surface--anchor',
      ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
      ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
      FIXED: 'mdc-menu-surface--fixed',
      OPEN: 'mdc-menu-surface--open',
      ROOT: 'mdc-menu-surface'
    };
    /** @enum {string} */

    var strings$3$1 = {
      CLOSED_EVENT: 'MDCMenuSurface:closed',
      OPENED_EVENT: 'MDCMenuSurface:opened',
      FOCUSABLE_ELEMENTS: 'button:not(:disabled), [href]:not([aria-disabled="true"]), input:not(:disabled), ' + 'select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
    };
    /** @enum {number} */

    var numbers$1$3 = {
      // Total duration of menu-surface open animation.
      TRANSITION_OPEN_DURATION: 120,
      // Total duration of menu-surface close animation.
      TRANSITION_CLOSE_DURATION: 75,
      // Margin left to the edge of the viewport when menu-surface is at maximum possible height.
      MARGIN_TO_EDGE: 32,
      // Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning.
      ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
    };
    /**
     * Enum for bits in the {@see Corner) bitmap.
     * @enum {number}
     */

    var CornerBit$2 = {
      BOTTOM: 1,
      CENTER: 2,
      RIGHT: 4,
      FLIP_RTL: 8
    };
    /**
     * Enum for representing an element corner for positioning the menu-surface.
     *
     * The START constants map to LEFT if element directionality is left
     * to right and RIGHT if the directionality is right to left.
     * Likewise END maps to RIGHT or LEFT depending on the directionality.
     *
     * @enum {number}
     */

    var Corner$2 = {
      TOP_LEFT: 0,
      TOP_RIGHT: CornerBit$2.RIGHT,
      BOTTOM_LEFT: CornerBit$2.BOTTOM,
      BOTTOM_RIGHT: CornerBit$2.BOTTOM | CornerBit$2.RIGHT,
      TOP_START: CornerBit$2.FLIP_RTL,
      TOP_END: CornerBit$2.FLIP_RTL | CornerBit$2.RIGHT,
      BOTTOM_START: CornerBit$2.BOTTOM | CornerBit$2.FLIP_RTL,
      BOTTOM_END: CornerBit$2.BOTTOM | CornerBit$2.RIGHT | CornerBit$2.FLIP_RTL
    };

    /**
     * @extends {MDCFoundation<!MDCMenuSurfaceAdapter>}
     */

    var MDCMenuSurfaceFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCMenuSurfaceFoundation, _MDCFoundation);

      _createClass$f(MDCMenuSurfaceFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          return cssClasses$5$1;
        }
        /** @return enum{string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$3$1;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$3;
        }
        /** @return enum{number} */

      }, {
        key: "Corner",
        get: function get() {
          return Corner$2;
        }
        /**
         * {@see MDCMenuSurfaceAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCMenuSurfaceAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCMenuSurfaceAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {
                return false;
              },
              hasAnchor: function hasAnchor() {
                return false;
              },
              notifyClose: function notifyClose() {},
              notifyOpen: function notifyOpen() {},
              isElementInContainer: function isElementInContainer() {
                return false;
              },
              isRtl: function isRtl() {
                return false;
              },
              setTransformOrigin: function setTransformOrigin() {},
              isFocused: function isFocused() {
                return false;
              },
              saveFocus: function saveFocus() {},
              restoreFocus: function restoreFocus() {},
              isFirstElementFocused: function isFirstElementFocused() {},
              isLastElementFocused: function isLastElementFocused() {},
              focusFirstElement: function focusFirstElement() {},
              focusLastElement: function focusLastElement() {},
              getInnerDimensions: function getInnerDimensions() {
                return {};
              },
              getAnchorDimensions: function getAnchorDimensions() {
                return {};
              },
              getWindowDimensions: function getWindowDimensions() {
                return {};
              },
              getBodyDimensions: function getBodyDimensions() {
                return {};
              },
              getWindowScroll: function getWindowScroll() {
                return {};
              },
              setPosition: function setPosition() {},
              setMaxHeight: function setMaxHeight() {}
            }
          );
        }
        /** @param {!MDCMenuSurfaceAdapter} adapter */

      }]);

      function MDCMenuSurfaceFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCMenuSurfaceFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCMenuSurfaceFoundation).call(this, Object.assign(MDCMenuSurfaceFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.isOpen_ = false;
        /** @private {number} */

        _this.openAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.closeAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.animationRequestId_ = 0;
        /** @private {!{ width: number, height: number }} */

        _this.dimensions_;
        /** @private {!Corner} */

        _this.anchorCorner_ = Corner$2.TOP_START;
        /** @private {!AnchorMargin} */

        _this.anchorMargin_ = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        /** @private {?AutoLayoutMeasurements} */

        _this.measures_ = null;
        /** @private {boolean} */

        _this.quickOpen_ = false;
        /** @private {boolean} */

        _this.hoistedElement_ = false;
        /** @private {boolean} */

        _this.isFixedPosition_ = false;
        /** @private {!{x: number, y: number}} */

        _this.position_ = {
          x: 0,
          y: 0
        };
        return _this;
      }

      _createClass$f(MDCMenuSurfaceFoundation, [{
        key: "init",
        value: function init() {
          var _MDCMenuSurfaceFounda = MDCMenuSurfaceFoundation.cssClasses,
              ROOT = _MDCMenuSurfaceFounda.ROOT,
              OPEN = _MDCMenuSurfaceFounda.OPEN;

          if (!this.adapter_.hasClass(ROOT)) {
            throw new Error("".concat(ROOT, " class required in root element."));
          }

          if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          clearTimeout(this.openAnimationEndTimerId_);
          clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.

          cancelAnimationFrame(this.animationRequestId_);
        }
        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left menu surface corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.anchorCorner_ = corner;
        }
        /**
         * @param {!AnchorMargin} margin set of margin values from anchor.
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
          this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
          this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
          this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
        }
        /**
         * Used to indicate if the menu-surface is hoisted to the body.
         * @param {boolean} isHoisted
         */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.hoistedElement_ = isHoisted;
        }
        /**
         * Used to set the menu-surface calculations based on a fixed position menu.
         * @param {boolean} isFixedPosition
         */

      }, {
        key: "setFixedPosition",
        value: function setFixedPosition(isFixedPosition) {
          this.isFixedPosition_ = isFixedPosition;
        }
        /**
         * Sets the menu-surface position on the page.
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.position_.x = this.typeCheckisFinite_(x) ? x : 0;
          this.position_.y = this.typeCheckisFinite_(y) ? y : 0;
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "setQuickOpen",
        value: function setQuickOpen(quickOpen) {
          this.quickOpen_ = quickOpen;
        }
        /**
         * Handle clicks and close if not within menu-surface element.
         * @param {!Event} evt
         */

      }, {
        key: "handleBodyClick",
        value: function handleBodyClick(evt) {
          var el = evt.target;

          if (this.adapter_.isElementInContainer(el)) {
            return;
          }

          this.close();
        }
      }, {
        key: "handleKeydown",

        /**
         * Handle keys that close the surface.
         * @param {!Event} evt
         */
        value: function handleKeydown(evt) {
          var keyCode = evt.keyCode,
              key = evt.key,
              shiftKey = evt.shiftKey;
          var isEscape = key === 'Escape' || keyCode === 27;
          var isTab = key === 'Tab' || keyCode === 9;

          if (isEscape) {
            this.close();
          } else if (isTab) {
            if (this.adapter_.isLastElementFocused() && !shiftKey) {
              this.adapter_.focusFirstElement();
              evt.preventDefault();
            } else if (this.adapter_.isFirstElementFocused() && shiftKey) {
              this.adapter_.focusLastElement();
              evt.preventDefault();
            }
          }
        }
        /**
         * @return {!AutoLayoutMeasurements} Measurements used to position menu surface popup.
         */

      }, {
        key: "getAutoLayoutMeasurements_",
        value: function getAutoLayoutMeasurements_() {
          var anchorRect = this.adapter_.getAnchorDimensions();
          var viewport = this.adapter_.getWindowDimensions();
          var bodyDimensions = this.adapter_.getBodyDimensions();
          var windowScroll = this.adapter_.getWindowScroll();

          if (!anchorRect) {
            anchorRect =
            /** @type {ClientRect} */
            {
              x: this.position_.x,
              y: this.position_.y,
              top: this.position_.y,
              bottom: this.position_.y,
              left: this.position_.x,
              right: this.position_.x,
              height: 0,
              width: 0
            };
          }

          return {
            viewport: viewport,
            bodyDimensions: bodyDimensions,
            windowScroll: windowScroll,
            viewportDistance: {
              top: anchorRect.top,
              right: viewport.width - anchorRect.right,
              left: anchorRect.left,
              bottom: viewport.height - anchorRect.bottom
            },
            anchorHeight: anchorRect.height,
            anchorWidth: anchorRect.width,
            surfaceHeight: this.dimensions_.height,
            surfaceWidth: this.dimensions_.width
          };
        }
        /**
         * Computes the corner of the anchor from which to animate and position the menu surface.
         * @return {!Corner}
         * @private
         */

      }, {
        key: "getOriginCorner_",
        value: function getOriginCorner_() {
          // Defaults: open from the top left.
          var corner = Corner$2.TOP_LEFT;
          var _this$measures_ = this.measures_,
              viewportDistance = _this$measures_.viewportDistance,
              anchorHeight = _this$measures_.anchorHeight,
              anchorWidth = _this$measures_.anchorWidth,
              surfaceHeight = _this$measures_.surfaceHeight,
              surfaceWidth = _this$measures_.surfaceWidth;
          var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit$2.BOTTOM);
          var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
          var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;
          var topOverflow = surfaceHeight - availableTop;
          var bottomOverflow = surfaceHeight - availableBottom;

          if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
            corner |= CornerBit$2.BOTTOM;
          }

          var isRtl = this.adapter_.isRtl();
          var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit$2.FLIP_RTL);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit$2.RIGHT);
          var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
          var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
          var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;
          var leftOverflow = surfaceWidth - availableLeft;
          var rightOverflow = surfaceWidth - availableRight;

          if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
            corner |= CornerBit$2.RIGHT;
          }

          return (
            /** @type {Corner} */
            corner
          );
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Horizontal offset of menu surface origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getHorizontalOriginOffset_",
        value: function getHorizontalOriginOffset_(corner) {
          var anchorWidth = this.measures_.anchorWidth; // isRightAligned corresponds to using the 'right' property on the surface.

          var isRightAligned = Boolean(corner & CornerBit$2.RIGHT);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit$2.RIGHT);

          if (isRightAligned) {
            var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right; // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
            // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
            // the right property is correct.

            if (this.hoistedElement_ || this.isFixedPosition_) {
              return rightOffset - (this.measures_.viewport.width - this.measures_.bodyDimensions.width);
            }

            return rightOffset;
          }

          return avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Vertical offset of menu surface origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getVerticalOriginOffset_",
        value: function getVerticalOriginOffset_(corner) {
          var anchorHeight = this.measures_.anchorHeight;
          var isBottomAligned = Boolean(corner & CornerBit$2.BOTTOM);
          var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit$2.BOTTOM);
          var y = 0;

          if (isBottomAligned) {
            y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
          } else {
            y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
          }

          return y;
        }
        /**
         * @param {!Corner} corner Origin corner of the menu surface.
         * @return {number} Maximum height of the menu surface, based on available space. 0 indicates should not be set.
         * @private
         */

      }, {
        key: "getMenuSurfaceMaxHeight_",
        value: function getMenuSurfaceMaxHeight_(corner) {
          var maxHeight = 0;
          var viewportDistance = this.measures_.viewportDistance;
          var isBottomAligned = Boolean(corner & CornerBit$2.BOTTOM);
          var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE; // When maximum height is not specified, it is handled from css.

          if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;

            if (!(this.anchorCorner_ & CornerBit$2.BOTTOM)) {
              maxHeight += this.measures_.anchorHeight;
            }
          } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measures_.anchorHeight - MARGIN_TO_EDGE;

            if (this.anchorCorner_ & CornerBit$2.BOTTOM) {
              maxHeight -= this.measures_.anchorHeight;
            }
          }

          return maxHeight;
        }
        /** @private */

      }, {
        key: "autoPosition_",
        value: function autoPosition_() {
          var _position;

          // Compute measurements for autoposition methods reuse.
          this.measures_ = this.getAutoLayoutMeasurements_();
          var corner = this.getOriginCorner_();
          var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
          var verticalAlignment = corner & CornerBit$2.BOTTOM ? 'bottom' : 'top';
          var horizontalAlignment = corner & CornerBit$2.RIGHT ? 'right' : 'left';
          var horizontalOffset = this.getHorizontalOriginOffset_(corner);
          var verticalOffset = this.getVerticalOriginOffset_(corner);
          var position = (_position = {}, _defineProperty$2(_position, horizontalAlignment, horizontalOffset ? horizontalOffset : '0'), _defineProperty$2(_position, verticalAlignment, verticalOffset ? verticalOffset : '0'), _position);
          var _this$measures_2 = this.measures_,
              anchorWidth = _this$measures_2.anchorWidth,
              surfaceWidth = _this$measures_2.surfaceWidth; // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.

          if (anchorWidth / surfaceWidth > numbers$1$3.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
            horizontalAlignment = 'center';
          } // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element


          if (this.hoistedElement_ || this.isFixedPosition_) {
            position = this.adjustPositionForHoistedElement_(position);
          }

          for (var prop in position) {
            if (position.hasOwnProperty(prop) && position[prop] !== '0') {
              position[prop] = "".concat(parseInt(position[prop], 10), "px");
            }
          }

          this.adapter_.setTransformOrigin("".concat(horizontalAlignment, " ").concat(verticalAlignment));
          this.adapter_.setPosition(position);
          this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : ''); // Clear measures after positioning is complete.

          this.measures_ = null;
        }
        /**
         * Calculates the offsets for positioning the menu-surface when the menu-surface has been
         * hoisted to the body.
         * @param {!{
         *   top: (string|undefined),
         *   right: (string|undefined),
         *   bottom: (string|undefined),
         *   left: (string|undefined)
         * }} position
         * @return {!{
         *   top: (string|undefined),
         *   right: (string|undefined),
         *   bottom: (string|undefined),
         *   left: (string|undefined)
         * }} position
         * @private
         */

      }, {
        key: "adjustPositionForHoistedElement_",
        value: function adjustPositionForHoistedElement_(position) {
          var _this$measures_3 = this.measures_,
              windowScroll = _this$measures_3.windowScroll,
              viewportDistance = _this$measures_3.viewportDistance;

          for (var prop in position) {
            if (position.hasOwnProperty(prop)) {
              // Hoisted surfaces need to have the anchor elements location on the page added to the
              // position properties for proper alignment on the body.
              if (viewportDistance.hasOwnProperty(prop)) {
                position[prop] = parseInt(position[prop], 10) + viewportDistance[prop];
              } // Surfaces that are absolutely positioned need to have additional calculations for scroll
              // and bottom positioning.


              if (!this.isFixedPosition_) {
                if (prop === 'top') {
                  position[prop] = parseInt(position[prop], 10) + windowScroll.y;
                } else if (prop === 'bottom') {
                  position[prop] = parseInt(position[prop], 10) - windowScroll.y;
                } else if (prop === 'left') {
                  position[prop] = parseInt(position[prop], 10) + windowScroll.x;
                } else if (prop === 'right') {
                  position[prop] = parseInt(position[prop], 10) - windowScroll.x;
                }
              }
            }
          }

          return position;
        }
        /**
         * Open the menu surface.
         */

      }, {
        key: "open",
        value: function open() {
          var _this2 = this;

          this.adapter_.saveFocus();

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
          }

          this.animationRequestId_ = requestAnimationFrame(function () {
            _this2.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

            _this2.dimensions_ = _this2.adapter_.getInnerDimensions();

            _this2.autoPosition_();

            if (_this2.quickOpen_) {
              _this2.adapter_.notifyOpen();
            } else {
              _this2.openAnimationEndTimerId_ = setTimeout(function () {
                _this2.openAnimationEndTimerId_ = 0;

                _this2.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);

                _this2.adapter_.notifyOpen();
              }, numbers$1$3.TRANSITION_OPEN_DURATION);
            }
          });
          this.isOpen_ = true;
        }
        /**
         * Closes the menu surface.
         */

      }, {
        key: "close",
        value: function close() {
          var _this3 = this;

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
          }

          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

            if (_this3.quickOpen_) {
              _this3.adapter_.notifyClose();
            } else {
              _this3.closeAnimationEndTimerId_ = setTimeout(function () {
                _this3.closeAnimationEndTimerId_ = 0;

                _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);

                _this3.adapter_.notifyClose();
              }, numbers$1$3.TRANSITION_CLOSE_DURATION);
            }
          });
          this.isOpen_ = false;
          this.maybeRestoreFocus_();
        }
        /**
         * The last focused element when the menu surface was opened should regain focus, if the user is
         * focused on or within the menu surface when it is closed.
         * @private
         */

      }, {
        key: "maybeRestoreFocus_",
        value: function maybeRestoreFocus_() {
          if (this.adapter_.isFocused() || this.adapter_.isElementInContainer(document.activeElement)) {
            this.adapter_.restoreFocus();
          }
        }
        /** @return {boolean} */

      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
        /**
         * isFinite that doesn't force conversion to number type.
         * Equivalent to Number.isFinite in ES2015, but is not included in IE11.
         * @param {number} num
         * @return {boolean}
         * @private
         */

      }, {
        key: "typeCheckisFinite_",
        value: function typeCheckisFinite_(num) {
          return typeof num === 'number' && isFinite(num);
        }
      }]);

      return MDCMenuSurfaceFoundation;
    }(MDCFoundation$f);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC List. Provides an interface for managing focus.
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCListAdapter$3 =
    /*#__PURE__*/
    function () {
      function MDCListAdapter() {
        _classCallCheck$f(this, MDCListAdapter);
      }

      _createClass$f(MDCListAdapter, [{
        key: "getListItemCount",

        /** @return {number} */
        value: function getListItemCount() {}
        /**
         * @return {number} */

      }, {
        key: "getFocusedElementIndex",
        value: function getFocusedElementIndex() {}
        /**
         * @param {number} index
         * @param {string} attribute
         * @param {string} value
         */

      }, {
        key: "setAttributeForElementIndex",
        value: function setAttributeForElementIndex(index, attribute, value) {}
        /**
         * @param {number} index
         * @param {string} attribute
         */

      }, {
        key: "removeAttributeForElementIndex",
        value: function removeAttributeForElementIndex(index, attribute) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "addClassForElementIndex",
        value: function addClassForElementIndex(index, className) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "removeClassForElementIndex",
        value: function removeClassForElementIndex(index, className) {}
        /**
         * Focuses list item at the index specified.
         * @param {number} index
         */

      }, {
        key: "focusItemAtIndex",
        value: function focusItemAtIndex(index) {}
        /**
         * Sets the tabindex to the value specified for all button/a element children of
         * the list item at the index specified.
         * @param {number} listItemIndex
         * @param {number} tabIndexValue
         */

      }, {
        key: "setTabIndexForListItemChildren",
        value: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if radio button is present at given list item index.
         */

      }, {
        key: "hasRadioAtIndex",
        value: function hasRadioAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox is present at given list item index.
         */

      }, {
        key: "hasCheckboxAtIndex",
        value: function hasCheckboxAtIndex(index) {}
        /**
         * @param {number} index
         * @return {boolean} Returns true if checkbox inside a list item is checked.
         */

      }, {
        key: "isCheckboxCheckedAtIndex",
        value: function isCheckboxCheckedAtIndex(index) {}
        /**
         * Sets the checked status of checkbox or radio at given list item index.
         * @param {number} index
         * @param {boolean} isChecked
         */

      }, {
        key: "setCheckedCheckboxOrRadioAtIndex",
        value: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {}
        /**
         * Notifies user action on list item.
         */

      }, {
        key: "notifyAction",
        value: function notifyAction(index) {}
        /**
         * @return {boolean} Returns true when the current focused element is inside list root.
         */

      }, {
        key: "isFocusInsideList",
        value: function isFocusInsideList() {}
      }]);

      return MDCListAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$6$1 = {
      ROOT: 'mdc-list',
      LIST_ITEM_CLASS: 'mdc-list-item',
      LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
      LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated'
    };
    /** @enum {string} */

    var strings$4$1 = {
      ARIA_ORIENTATION: 'aria-orientation',
      ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
      ARIA_SELECTED: 'aria-selected',
      ARIA_CHECKED: 'aria-checked',
      ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
      ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
      ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
      RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
      CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
      CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
      CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: ".".concat(cssClasses$6$1.LIST_ITEM_CLASS, " button:not(:disabled),\n  .").concat(cssClasses$6$1.LIST_ITEM_CLASS, " a"),
      FOCUSABLE_CHILD_ELEMENTS: ".".concat(cssClasses$6$1.LIST_ITEM_CLASS, " button:not(:disabled), .").concat(cssClasses$6$1.LIST_ITEM_CLASS, " a,\n  .").concat(cssClasses$6$1.LIST_ITEM_CLASS, " input[type=\"radio\"]:not(:disabled),\n  .").concat(cssClasses$6$1.LIST_ITEM_CLASS, " input[type=\"checkbox\"]:not(:disabled)"),
      ENABLED_ITEMS_SELECTOR: '.mdc-list-item:not(.mdc-list-item--disabled)',
      ACTION_EVENT: 'MDCList:action'
    };

    var ELEMENTS_KEY_ALLOWED_IN$3 = ['input', 'button', 'textarea', 'select'];

    var MDCListFoundation$3 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCListFoundation, _MDCFoundation);

      _createClass$f(MDCListFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$4$1;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$6$1;
        }
        /**
         * {@see MDCListAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCListAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCListAdapter} */
            {
              getListItemCount: function getListItemCount() {},
              getFocusedElementIndex: function getFocusedElementIndex() {},
              setAttributeForElementIndex: function setAttributeForElementIndex() {},
              removeAttributeForElementIndex: function removeAttributeForElementIndex() {},
              addClassForElementIndex: function addClassForElementIndex() {},
              removeClassForElementIndex: function removeClassForElementIndex() {},
              focusItemAtIndex: function focusItemAtIndex() {},
              setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {},
              hasRadioAtIndex: function hasRadioAtIndex() {},
              hasCheckboxAtIndex: function hasCheckboxAtIndex() {},
              isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {},
              setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {},
              notifyAction: function notifyAction() {},
              isFocusInsideList: function isFocusInsideList() {}
            }
          );
        }
        /**
         * @param {!MDCListAdapter=} adapter
         */

      }]);

      function MDCListFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCListFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCListFoundation).call(this, Object.assign(MDCListFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.wrapFocus_ = false;
        /** @private {boolean} */

        _this.isVertical_ = true;
        /** @private {boolean} */

        _this.isSingleSelectionList_ = false;
        /** @private {!Index} */

        _this.selectedIndex_ = -1;
        /** @private {number} */

        _this.focusedItemIndex_ = -1;
        /** @private {boolean} */

        _this.useActivatedClass_ = false;
        /** @private {boolean} */

        _this.isCheckboxList_ = false;
        /** @private {boolean} */

        _this.isRadioList_ = false;
        return _this;
      }

      _createClass$f(MDCListFoundation, [{
        key: "layout",
        value: function layout() {
          if (this.adapter_.getListItemCount() === 0) return;

          if (this.adapter_.hasCheckboxAtIndex(0)) {
            this.isCheckboxList_ = true;
          } else if (this.adapter_.hasRadioAtIndex(0)) {
            this.isRadioList_ = true;
          }
        }
        /**
         * Sets the private wrapFocus_ variable.
         * @param {boolean} value
         */

      }, {
        key: "setWrapFocus",
        value: function setWrapFocus(value) {
          this.wrapFocus_ = value;
        }
        /**
         * Sets the isVertical_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setVerticalOrientation",
        value: function setVerticalOrientation(value) {
          this.isVertical_ = value;
        }
        /**
         * Sets the isSingleSelectionList_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setSingleSelection",
        value: function setSingleSelection(value) {
          this.isSingleSelectionList_ = value;
        }
        /**
         * Sets the useActivatedClass_ private variable.
         * @param {boolean} useActivated
         */

      }, {
        key: "setUseActivatedClass",
        value: function setUseActivatedClass(useActivated) {
          this.useActivatedClass_ = useActivated;
        }
        /** @return {!Index} */

      }, {
        key: "getSelectedIndex",
        value: function getSelectedIndex() {
          return this.selectedIndex_;
        }
        /** @param {!Index} index */

      }, {
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {
          if (!this.isIndexValid_(index)) return;

          if (this.isCheckboxList_) {
            this.setCheckboxAtIndex_(
            /** @type {!Array<number>} */
            index);
          } else if (this.isRadioList_) {
            this.setRadioAtIndex_(
            /** @type {number} */
            index);
          } else {
            this.setSingleSelectionAtIndex_(
            /** @type {number} */
            index);
          }
        }
        /**
         * Focus in handler for the list items.
         * @param evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusIn",
        value: function handleFocusIn(evt, listItemIndex) {
          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, 0);
          }
        }
        /**
         * Focus out handler for the list items.
         * @param {Event} evt
         * @param {number} listItemIndex
         */

      }, {
        key: "handleFocusOut",
        value: function handleFocusOut(evt, listItemIndex) {
          var _this2 = this;

          if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, -1);
          }
          /**
           * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
           * is moved to next element.
           */


          setTimeout(function () {
            if (!_this2.adapter_.isFocusInsideList()) {
              _this2.setTabindexToFirstSelectedItem_();
            }
          }, 0);
        }
        /**
         * Key handler for the list.
         * @param {Event} evt
         * @param {boolean} isRootListItem
         * @param {number} listItemIndex
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt, isRootListItem, listItemIndex) {
          var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
          var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
          var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
          var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
          var isHome = evt.key === 'Home' || evt.keyCode === 36;
          var isEnd = evt.key === 'End' || evt.keyCode === 35;
          var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
          var isSpace = evt.key === 'Space' || evt.keyCode === 32;
          var currentIndex = this.adapter_.getFocusedElementIndex();
          var nextIndex = -1;

          if (currentIndex === -1) {
            currentIndex = listItemIndex;

            if (currentIndex < 0) {
              // If this event doesn't have a mdc-list-item ancestor from the
              // current list (not from a sublist), return early.
              return;
            }
          }

          if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusNextElement(currentIndex);
          } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusPrevElement(currentIndex);
          } else if (isHome) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusFirstElement();
          } else if (isEnd) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusLastElement();
          } else if (isEnter || isSpace) {
            if (isRootListItem) {
              // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
              if (evt.target.tagName === 'A' && isEnter) return;
              this.preventDefaultEvent_(evt);

              if (this.isSelectableList_()) {
                this.setSelectedIndexOnAction_(currentIndex);
              }

              this.adapter_.notifyAction(currentIndex);
            }
          }

          this.focusedItemIndex_ = currentIndex;

          if (nextIndex >= 0) {
            this.setTabindexAtIndex_(nextIndex);
            this.focusedItemIndex_ = nextIndex;
          }
        }
        /**
         * Click handler for the list.
         * @param {number} index
         * @param {boolean} toggleCheckbox
         */

      }, {
        key: "handleClick",
        value: function handleClick(index, toggleCheckbox) {
          if (index === -1) return;

          if (this.isSelectableList_()) {
            this.setSelectedIndexOnAction_(index, toggleCheckbox);
          }

          this.adapter_.notifyAction(index);
          this.setTabindexAtIndex_(index);
          this.focusedItemIndex_ = index;
        }
        /**
         * Ensures that preventDefault is only called if the containing element doesn't
         * consume the event, and it will cause an unintended scroll.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "preventDefaultEvent_",
        value: function preventDefaultEvent_(evt) {
          var tagName = "".concat(evt.target.tagName).toLowerCase();

          if (ELEMENTS_KEY_ALLOWED_IN$3.indexOf(tagName) === -1) {
            evt.preventDefault();
          }
        }
        /**
         * Focuses the next element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusNextElement",
        value: function focusNextElement(index) {
          var count = this.adapter_.getListItemCount();
          var nextIndex = index + 1;

          if (nextIndex >= count) {
            if (this.wrapFocus_) {
              nextIndex = 0;
            } else {
              // Return early because last item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(nextIndex);
          return nextIndex;
        }
        /**
         * Focuses the previous element on the list.
         * @param {number} index
         * @return {number}
         */

      }, {
        key: "focusPrevElement",
        value: function focusPrevElement(index) {
          var prevIndex = index - 1;

          if (prevIndex < 0) {
            if (this.wrapFocus_) {
              prevIndex = this.adapter_.getListItemCount() - 1;
            } else {
              // Return early because first item is already focused.
              return index;
            }
          }

          this.adapter_.focusItemAtIndex(prevIndex);
          return prevIndex;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {
          this.adapter_.focusItemAtIndex(0);
          return 0;
        }
        /**
         * @return {number}
         */

      }, {
        key: "focusLastElement",
        value: function focusLastElement() {
          var lastIndex = this.adapter_.getListItemCount() - 1;
          this.adapter_.focusItemAtIndex(lastIndex);
          return lastIndex;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setSingleSelectionAtIndex_",
        value: function setSingleSelectionAtIndex_(index) {
          var selectedClassName = cssClasses$6$1.LIST_ITEM_SELECTED_CLASS;

          if (this.useActivatedClass_) {
            selectedClassName = cssClasses$6$1.LIST_ITEM_ACTIVATED_CLASS;
          }

          if (this.selectedIndex_ >= 0 && this.selectedIndex_ !== index) {
            this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$4$1.ARIA_SELECTED, 'false');
          }

          this.adapter_.addClassForElementIndex(index, selectedClassName);
          this.adapter_.setAttributeForElementIndex(index, strings$4$1.ARIA_SELECTED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
         * @param {number} index
         * @private
         */

      }, {
        key: "setRadioAtIndex_",
        value: function setRadioAtIndex_(index) {
          this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);

          if (this.selectedIndex_ >= 0) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$4$1.ARIA_CHECKED, 'false');
          }

          this.adapter_.setAttributeForElementIndex(index, strings$4$1.ARIA_CHECKED, 'true');
          this.selectedIndex_ = index;
        }
        /**
         * @param {!Array<number>} index
         * @private
         */

      }, {
        key: "setCheckboxAtIndex_",
        value: function setCheckboxAtIndex_(index) {
          for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
            var isChecked = false;

            if (index.indexOf(i) >= 0) {
              isChecked = true;
            }

            this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
            this.adapter_.setAttributeForElementIndex(i, strings$4$1.ARIA_CHECKED, isChecked ? 'true' : 'false');
          }

          this.selectedIndex_ = index;
        }
        /**
         * @param {number} index
         * @private
         */

      }, {
        key: "setTabindexAtIndex_",
        value: function setTabindexAtIndex_(index) {
          if (this.focusedItemIndex_ === -1 && index !== 0) {
            // If no list item was selected set first list item's tabindex to -1.
            // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
            this.adapter_.setAttributeForElementIndex(0, 'tabindex', -1);
          } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
            this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', -1);
          }

          this.adapter_.setAttributeForElementIndex(index, 'tabindex', 0);
        }
        /**
         * @return {boolean} Return true if it is single selectin list, checkbox list or radio list.
         * @private
         */

      }, {
        key: "isSelectableList_",
        value: function isSelectableList_() {
          return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
        }
        /** @private */

      }, {
        key: "setTabindexToFirstSelectedItem_",
        value: function setTabindexToFirstSelectedItem_() {
          var targetIndex = 0;

          if (this.isSelectableList_()) {
            if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== -1) {
              targetIndex = this.selectedIndex_;
            } else if (this.selectedIndex_ instanceof Array && this.selectedIndex_.length > 0) {
              targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
                return Math.min(currentIndex, minIndex);
              });
            }
          }

          this.setTabindexAtIndex_(targetIndex);
        }
        /**
         * @param {!Index} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexValid_",
        value: function isIndexValid_(index) {
          var _this3 = this;

          if (index instanceof Array) {
            if (!this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
            }

            if (index.length === 0) {
              return true;
            } else {
              return index.some(function (i) {
                return _this3.isIndexInRange_(i);
              });
            }
          } else if (typeof index === 'number') {
            if (this.isCheckboxList_) {
              throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
            }

            return this.isIndexInRange_(index);
          } else {
            return false;
          }
        }
        /**
         * @param {number} index
         * @return {boolean}
         * @private
         */

      }, {
        key: "isIndexInRange_",
        value: function isIndexInRange_(index) {
          var listSize = this.adapter_.getListItemCount();
          return index >= 0 && index < listSize;
        }
        /**
         * @param {number} index
         * @param {boolean=} toggleCheckbox
         * @private
         */

      }, {
        key: "setSelectedIndexOnAction_",
        value: function setSelectedIndexOnAction_(index) {
          var toggleCheckbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (this.isCheckboxList_) {
            this.toggleCheckboxAtIndex_(index, toggleCheckbox);
          } else {
            this.setSelectedIndex(index);
          }
        }
        /**
         * @param {number} index
         * @param {boolean} toggleCheckbox
         * @private
         */

      }, {
        key: "toggleCheckboxAtIndex_",
        value: function toggleCheckboxAtIndex_(index, toggleCheckbox) {
          var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);

          if (toggleCheckbox) {
            isChecked = !isChecked;
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
          }

          this.adapter_.setAttributeForElementIndex(index, strings$4$1.ARIA_CHECKED, isChecked ? 'true' : 'false'); // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.

          if (this.selectedIndex_ === -1) {
            this.selectedIndex_ = [];
          }

          if (isChecked) {
            this.selectedIndex_.push(index);
          } else {
            this.selectedIndex_ = this.selectedIndex_.filter(function (i) {
              return i !== index;
            });
          }
        }
      }]);

      return MDCListFoundation;
    }(MDCFoundation$f);

    /**
     * @extends {MDCFoundation<!MDCMenuAdapter>}
     */

    var MDCMenuFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCMenuFoundation, _MDCFoundation);

      _createClass$f(MDCMenuFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          return cssClasses$4$1;
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$2$4;
        }
        /**
         * {@see MDCMenuAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCMenuAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCMenuAdapter} */
            {
              addClassToElementAtIndex: function addClassToElementAtIndex() {},
              removeClassFromElementAtIndex: function removeClassFromElementAtIndex() {},
              addAttributeToElementAtIndex: function addAttributeToElementAtIndex() {},
              removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex() {},
              elementContainsClass: function elementContainsClass() {},
              closeSurface: function closeSurface() {},
              getElementIndex: function getElementIndex() {},
              getParentElement: function getParentElement() {},
              getSelectedElementIndex: function getSelectedElementIndex() {},
              notifySelected: function notifySelected() {}
            }
          );
        }
        /** @param {!MDCMenuAdapter} adapter */

      }]);

      function MDCMenuFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCMenuFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCMenuFoundation).call(this, Object.assign(MDCMenuFoundation.defaultAdapter, adapter)));
        /** @type {number} */

        _this.closeAnimationEndTimerId_ = 0;
        return _this;
      }

      _createClass$f(MDCMenuFoundation, [{
        key: "destroy",
        value: function destroy() {
          if (this.closeAnimationEndTimerId_) {
            clearTimeout(this.closeAnimationEndTimerId_);
          }

          this.adapter_.closeSurface();
        }
        /**
         * Handler function for the keydown events.
         * @param {!Event} evt
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt) {
          var key = evt.key,
              keyCode = evt.keyCode;
          var isTab = key === 'Tab' || keyCode === 9;

          if (isTab) {
            this.adapter_.closeSurface();
          }
        }
        /**
         * @param {!HTMLElement} listItem
         */

      }, {
        key: "handleItemAction",
        value: function handleItemAction(listItem) {
          var _this2 = this;

          var index = this.adapter_.getElementIndex(listItem);

          if (index < 0) {
            return;
          }

          this.adapter_.notifySelected({
            index: index
          });
          this.adapter_.closeSurface(); // Wait for the menu to close before adding/removing classes that affect styles.

          this.closeAnimationEndTimerId_ = setTimeout(function () {
            var selectionGroup = _this2.getSelectionGroup_(listItem);

            if (selectionGroup !== null) {
              _this2.handleSelectionGroup_(
              /** @type {!HTMLElement} */
              selectionGroup, index);
            }
          }, MDCMenuSurfaceFoundation$2.numbers.TRANSITION_CLOSE_DURATION);
        }
        /**
         * Handles toggling the selected classes in a selection group when a
         * selection is made.
         * @param {!HTMLElement} selectionGroup
         * @param {number} index The selected index value
         * @private
         */

      }, {
        key: "handleSelectionGroup_",
        value: function handleSelectionGroup_(selectionGroup, index) {
          // De-select the previous selection in this group.
          var selectedIndex = this.adapter_.getSelectedElementIndex(selectionGroup);

          if (selectedIndex >= 0) {
            this.adapter_.removeAttributeFromElementAtIndex(selectedIndex, strings$2$4.ARIA_SELECTED_ATTR);
            this.adapter_.removeClassFromElementAtIndex(selectedIndex, cssClasses$4$1.MENU_SELECTED_LIST_ITEM);
          } // Select the new list item in this group.


          this.adapter_.addClassToElementAtIndex(index, cssClasses$4$1.MENU_SELECTED_LIST_ITEM);
          this.adapter_.addAttributeToElementAtIndex(index, strings$2$4.ARIA_SELECTED_ATTR, 'true');
        }
        /**
         * Returns the parent selection group of an element if one exists.
         * @param listItem
         * @return {?HTMLElement} parent selection group element or null.
         * @private
         */

      }, {
        key: "getSelectionGroup_",
        value: function getSelectionGroup_(listItem) {
          var parent = this.adapter_.getParentElement(listItem);
          var isGroup = this.adapter_.elementContainsClass(parent, cssClasses$4$1.MENU_SELECTION_GROUP); // Iterate through ancestors until we find the group or get to the list.

          while (!isGroup && !this.adapter_.elementContainsClass(parent, MDCListFoundation$3.cssClasses.ROOT)) {
            parent = this.adapter_.getParentElement(parent);
            isGroup = this.adapter_.elementContainsClass(parent, cssClasses$4$1.MENU_SELECTION_GROUP);
          }

          if (isGroup) {
            return parent;
          } else {
            return null;
          }
        }
        /**
         * Find the first ancestor with the mdc-list-item class.
         * @param {?HTMLElement} target
         * @return {?HTMLElement}
         * @private
         */

      }, {
        key: "getListItem_",
        value: function getListItem_(target) {
          var isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation$3.cssClasses.LIST_ITEM_CLASS);

          while (!isListItem) {
            target = this.adapter_.getParentElement(target);

            if (target) {
              isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation$3.cssClasses.LIST_ITEM_CLASS);
            } else {
              // target has no parent element.
              return null;
            }
          }

          return target;
        }
      }]);

      return MDCMenuFoundation;
    }(MDCFoundation$f);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @type {string|undefined} */
    var storedTransformPropertyName_$2;
    /**
     * Returns the name of the correct transform property to use on the current browser.
     * @param {!Window} globalObj
     * @param {boolean=} forceRefresh
     * @return {string}
     */

    function getTransformPropertyName$2(globalObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (storedTransformPropertyName_$2 === undefined || forceRefresh) {
        var el = globalObj.document.createElement('div');
        var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
        storedTransformPropertyName_$2 = transformPropertyName;
      }

      return storedTransformPropertyName_$2;
    }

    /**
     * @extends MDCComponent<!MDCMenuSurfaceFoundation>
     */

    var MDCMenuSurface$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCMenuSurface, _MDCComponent);

      /** @param {...?} args */
      function MDCMenuSurface() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$f(this, MDCMenuSurface);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$f(this, (_getPrototypeOf2 = _getPrototypeOf$f(MDCMenuSurface)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Element} */

        _this.previousFocus_;
        /** @private {!Element} */

        _this.anchorElement;
        /** @private {Element} */

        _this.firstFocusableElement_;
        /** @private {Element} */

        _this.lastFocusableElement_;
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleBodyClick_;
        /** @private {!Function} */

        _this.registerBodyClickListener_;
        /** @private {!Function} */

        _this.deregisterBodyClickListener_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCMenuSurface}
       */


      _createClass$f(MDCMenuSurface, [{
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          if (this.root_.parentElement && this.root_.parentElement.classList.contains(cssClasses$5$1.ANCHOR)) {
            this.anchorElement = this.root_.parentElement;
          }

          if (this.root_.classList.contains(cssClasses$5$1.FIXED)) {
            this.setFixedPosition(true);
          }

          this.handleKeydown_ = function (evt) {
            return _this2.foundation_.handleKeydown(evt);
          };

          this.handleBodyClick_ = function (evt) {
            return _this2.foundation_.handleBodyClick(evt);
          };

          this.registerBodyClickListener_ = function () {
            return document.body.addEventListener('click', _this2.handleBodyClick_);
          };

          this.deregisterBodyClickListener_ = function () {
            return document.body.removeEventListener('click', _this2.handleBodyClick_);
          };

          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener(strings$3$1.OPENED_EVENT, this.registerBodyClickListener_);
          this.root_.addEventListener(strings$3$1.CLOSED_EVENT, this.deregisterBodyClickListener_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener(strings$3$1.OPENED_EVENT, this.registerBodyClickListener_);
          this.root_.removeEventListener(strings$3$1.CLOSED_EVENT, this.deregisterBodyClickListener_);

          _get$7(_getPrototypeOf$f(MDCMenuSurface.prototype), "destroy", this).call(this);
        }
        /** @return {boolean} */

      }, {
        key: "hoistMenuToBody",

        /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         */
        value: function hoistMenuToBody() {
          document.body.appendChild(this.root_.parentElement.removeChild(this.root_));
          this.setIsHoisted(true);
        }
        /**
         * Sets the foundation to use page offsets for an positioning when the menu
         * is hoisted to the body.
         * @param {boolean} isHoisted
         */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.foundation_.setIsHoisted(isHoisted);
        }
        /**
         * Sets the element that the menu-surface is anchored to.
         * @param {!Element} element
         */

      }, {
        key: "setMenuSurfaceAnchorElement",
        value: function setMenuSurfaceAnchorElement(element) {
          this.anchorElement = element;
        }
        /**
         * Sets the menu-surface to position: fixed.
         * @param {boolean} isFixed
         */

      }, {
        key: "setFixedPosition",
        value: function setFixedPosition(isFixed) {
          if (isFixed) {
            this.root_.classList.add(cssClasses$5$1.FIXED);
          } else {
            this.root_.classList.remove(cssClasses$5$1.FIXED);
          }

          this.foundation_.setFixedPosition(isFixed);
        }
        /**
         * Sets the absolute x/y position to position based on. Requires the menu to be hoisted.
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.foundation_.setAbsolutePosition(x, y);
          this.setIsHoisted(true);
        }
        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left
         *     surface corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.foundation_.setAnchorCorner(corner);
        }
        /**
         * @param {!AnchorMargin} margin
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.foundation_.setAnchorMargin(margin);
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCMenuSurfaceFoundation} */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCMenuSurfaceFoundation$2(
          /** @type {!MDCMenuSurfaceAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            hasAnchor: function hasAnchor() {
              return !!_this3.anchorElement;
            },
            notifyClose: function notifyClose() {
              return _this3.emit(MDCMenuSurfaceFoundation$2.strings.CLOSED_EVENT, {});
            },
            notifyOpen: function notifyOpen() {
              return _this3.emit(MDCMenuSurfaceFoundation$2.strings.OPENED_EVENT, {});
            },
            isElementInContainer: function isElementInContainer(el) {
              return _this3.root_ === el || _this3.root_.contains(el);
            },
            isRtl: function isRtl() {
              return getComputedStyle(_this3.root_).getPropertyValue('direction') === 'rtl';
            },
            setTransformOrigin: function setTransformOrigin(origin) {
              _this3.root_.style["".concat(getTransformPropertyName$2(window), "-origin")] = origin;
            }
          }, this.getFocusAdapterMethods_(), this.getDimensionAdapterMethods_()));
        }
        /**
         * @return {!{
         * isFocused: function(): boolean,
         * saveFocus: function(),
         * restoreFocus: function(),
         * isFirstElementFocused: function(): boolean,
         * isLastElementFocused: function(): boolean,
         * focusFirstElement: function(),
         * focusLastElement: function(),
         * }}
         * @private
         */

      }, {
        key: "getFocusAdapterMethods_",
        value: function getFocusAdapterMethods_() {
          var _this4 = this;

          return {
            isFocused: function isFocused() {
              return document.activeElement === _this4.root_;
            },
            saveFocus: function saveFocus() {
              _this4.previousFocus_ = document.activeElement;
            },
            restoreFocus: function restoreFocus() {
              if (_this4.root_.contains(document.activeElement)) {
                if (_this4.previousFocus_ && _this4.previousFocus_.focus) {
                  _this4.previousFocus_.focus();
                }
              }
            },
            isFirstElementFocused: function isFirstElementFocused() {
              return _this4.firstFocusableElement_ && _this4.firstFocusableElement_ === document.activeElement;
            },
            isLastElementFocused: function isLastElementFocused() {
              return _this4.lastFocusableElement_ && _this4.lastFocusableElement_ === document.activeElement;
            },
            focusFirstElement: function focusFirstElement() {
              return _this4.firstFocusableElement_ && _this4.firstFocusableElement_.focus && _this4.firstFocusableElement_.focus();
            },
            focusLastElement: function focusLastElement() {
              return _this4.lastFocusableElement_ && _this4.lastFocusableElement_.focus && _this4.lastFocusableElement_.focus();
            }
          };
        }
        /**
         * @return {!{
         * getInnerDimensions: function(),
         * getAnchorDimensions: function(): (HTMLElement | null | * | ClientRect),
         * getWindowDimensions: function(),
         * setPosition: function(*),
         * setMaxHeight: function(string)}}
         * @private
         */

      }, {
        key: "getDimensionAdapterMethods_",
        value: function getDimensionAdapterMethods_() {
          var _this5 = this;

          return {
            getInnerDimensions: function getInnerDimensions() {
              return {
                width: _this5.root_.offsetWidth,
                height: _this5.root_.offsetHeight
              };
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return _this5.anchorElement && _this5.anchorElement.getBoundingClientRect();
            },
            getWindowDimensions: function getWindowDimensions() {
              return {
                width: window.innerWidth,
                height: window.innerHeight
              };
            },
            getBodyDimensions: function getBodyDimensions() {
              return {
                width: document.body.clientWidth,
                height: document.body.clientHeight
              };
            },
            getWindowScroll: function getWindowScroll() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            },
            setPosition: function setPosition(position) {
              _this5.root_.style.left = 'left' in position ? position.left : null;
              _this5.root_.style.right = 'right' in position ? position.right : null;
              _this5.root_.style.top = 'top' in position ? position.top : null;
              _this5.root_.style.bottom = 'bottom' in position ? position.bottom : null;
            },
            setMaxHeight: function setMaxHeight(height) {
              _this5.root_.style.maxHeight = height;
            }
          };
        }
      }, {
        key: "open",
        get: function get() {
          return this.foundation_.isOpen();
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          if (value) {
            var focusableElements = this.root_.querySelectorAll(strings$3$1.FOCUSABLE_ELEMENTS);
            this.firstFocusableElement_ = focusableElements.length > 0 ? focusableElements[0] : null;
            this.lastFocusableElement_ = focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
            this.foundation_.open();
          } else {
            this.foundation_.close();
          }
        }
      }, {
        key: "quickOpen",
        set: function set(quickOpen) {
          this.foundation_.setQuickOpen(quickOpen);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCMenuSurface(root);
        }
      }]);

      return MDCMenuSurface;
    }(MDCComponent$f);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {boolean}
     */


    function matches$5(element, selector) {
      var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      return nativeMatches.call(element, selector);
    }

    /**
     * @extends MDCComponent<!MDCListFoundation>
     */

    var MDCList$3 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCList, _MDCComponent);

      /** @param {...?} args */
      function MDCList() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$f(this, MDCList);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$f(this, (_getPrototypeOf2 = _getPrototypeOf$f(MDCList)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleClick_;
        /** @private {!Function} */

        _this.focusInEventListener_;
        /** @private {!Function} */

        _this.focusOutEventListener_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCList}
       */


      _createClass$f(MDCList, [{
        key: "destroy",
        value: function destroy() {
          this.root_.removeEventListener('keydown', this.handleKeydown_);
          this.root_.removeEventListener('click', this.handleClick_);
          this.root_.removeEventListener('focusin', this.focusInEventListener_);
          this.root_.removeEventListener('focusout', this.focusOutEventListener_);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.handleClick_ = this.handleClickEvent_.bind(this);
          this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
          this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
          this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
          this.root_.addEventListener('keydown', this.handleKeydown_);
          this.root_.addEventListener('focusin', this.focusInEventListener_);
          this.root_.addEventListener('focusout', this.focusOutEventListener_);
          this.root_.addEventListener('click', this.handleClick_);
          this.layout();
          this.initializeListType();
        }
      }, {
        key: "layout",
        value: function layout() {
          var direction = this.root_.getAttribute(strings$4$1.ARIA_ORIENTATION);
          this.vertical = direction !== strings$4$1.ARIA_ORIENTATION_HORIZONTAL; // List items need to have at least tabindex=-1 to be focusable.

          [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
            ele.setAttribute('tabindex', -1);
          }); // Child button/a elements are not tabbable until the list item is focused.

          [].slice.call(this.root_.querySelectorAll(strings$4$1.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
            return ele.setAttribute('tabindex', -1);
          });
          this.foundation_.layout();
        }
        /**
         * Used to figure out which list item this event is targetting. Or returns -1 if
         * there is no list item
         * @param {Event} evt
         * @private
         */

      }, {
        key: "getListItemIndex_",
        value: function getListItemIndex_(evt) {
          var eventTarget =
          /** @type {HTMLElement} */
          evt.target;
          var index = -1; // Find the first ancestor that is a list item or the list.

          while (!eventTarget.classList.contains(cssClasses$6$1.LIST_ITEM_CLASS) && !eventTarget.classList.contains(cssClasses$6$1.ROOT)) {
            eventTarget = eventTarget.parentElement;
          } // Get the index of the element if it is a list item.


          if (eventTarget.classList.contains(cssClasses$6$1.LIST_ITEM_CLASS)) {
            index = this.listElements.indexOf(eventTarget);
          }

          return index;
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusInEvent_",
        value: function handleFocusInEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusIn(evt, index);
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleFocusOutEvent_",
        value: function handleFocusOutEvent_(evt) {
          var index = this.getListItemIndex_(evt);
          this.foundation_.handleFocusOut(evt, index);
        }
        /**
         * Used to figure out which element was focused when keydown event occurred before sending the event to the
         * foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleKeydownEvent_",
        value: function handleKeydownEvent_(evt) {
          var index = this.getListItemIndex_(evt);

          if (index >= 0) {
            this.foundation_.handleKeydown(evt, evt.target.classList.contains(cssClasses$6$1.LIST_ITEM_CLASS), index);
          }
        }
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "handleClickEvent_",
        value: function handleClickEvent_(evt) {
          var index = this.getListItemIndex_(evt); // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.

          var toggleCheckbox = !matches$5(
          /** @type {!Element} */
          evt.target, strings$4$1.CHECKBOX_RADIO_SELECTOR);
          this.foundation_.handleClick(index, toggleCheckbox);
        }
        /**
         * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
         */

      }, {
        key: "initializeListType",
        value: function initializeListType() {
          var _this2 = this;

          var checkboxListItems = this.root_.querySelectorAll(strings$4$1.ARIA_ROLE_CHECKBOX_SELECTOR);
          var singleSelectedListItem = this.root_.querySelector(".".concat(cssClasses$6$1.LIST_ITEM_ACTIVATED_CLASS, ",\n        .").concat(cssClasses$6$1.LIST_ITEM_SELECTED_CLASS));
          var radioSelectedListItem = this.root_.querySelector(strings$4$1.ARIA_CHECKED_RADIO_SELECTOR);

          if (checkboxListItems.length) {
            var preselectedItems = this.root_.querySelectorAll(strings$4$1.ARIA_CHECKED_CHECKBOX_SELECTOR);
            this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
              return _this2.listElements.indexOf(listItem);
            });
          } else if (singleSelectedListItem) {
            if (singleSelectedListItem.classList.contains(cssClasses$6$1.LIST_ITEM_ACTIVATED_CLASS)) {
              this.foundation_.setUseActivatedClass(true);
            }

            this.singleSelection = true;
            this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
          } else if (radioSelectedListItem) {
            this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
          }
        }
        /** @param {boolean} value */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCListFoundation} */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCListFoundation$3(
          /** @type {!MDCListAdapter} */
          Object.assign({
            getListItemCount: function getListItemCount() {
              return _this3.listElements.length;
            },
            getFocusedElementIndex: function getFocusedElementIndex() {
              return _this3.listElements.indexOf(document.activeElement);
            },
            setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
              var element = _this3.listElements[index];

              if (element) {
                element.setAttribute(attr, value);
              }
            },
            removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
              var element = _this3.listElements[index];

              if (element) {
                element.removeAttribute(attr);
              }
            },
            addClassForElementIndex: function addClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.add(className);
              }
            },
            removeClassForElementIndex: function removeClassForElementIndex(index, className) {
              var element = _this3.listElements[index];

              if (element) {
                element.classList.remove(className);
              }
            },
            focusItemAtIndex: function focusItemAtIndex(index) {
              var element = _this3.listElements[index];

              if (element) {
                element.focus();
              }
            },
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
              var element = _this3.listElements[listItemIndex];
              var listItemChildren = [].slice.call(element.querySelectorAll(strings$4$1.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
              listItemChildren.forEach(function (ele) {
                return ele.setAttribute('tabindex', tabIndexValue);
              });
            },
            hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$4$1.CHECKBOX_SELECTOR);
            },
            hasRadioAtIndex: function hasRadioAtIndex(index) {
              var listItem = _this3.listElements[index];
              return !!listItem.querySelector(strings$4$1.RADIO_SELECTOR);
            },
            isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$4$1.CHECKBOX_SELECTOR);
              return toggleEl.checked;
            },
            setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
              var listItem = _this3.listElements[index];
              var toggleEl = listItem.querySelector(strings$4$1.CHECKBOX_RADIO_SELECTOR);
              toggleEl.checked = isChecked;
              var event = document.createEvent('Event');
              event.initEvent('change', true, true);
              toggleEl.dispatchEvent(event);
            },
            notifyAction: function notifyAction(index) {
              _this3.emit(strings$4$1.ACTION_EVENT, index,
              /** shouldBubble */
              true);
            },
            isFocusInsideList: function isFocusInsideList() {
              return _this3.root_.contains(document.activeElement);
            }
          }));
        }
      }, {
        key: "vertical",
        set: function set(value) {
          this.foundation_.setVerticalOrientation(value);
        }
        /** @return Array<!Element>*/

      }, {
        key: "listElements",
        get: function get() {
          return [].slice.call(this.root_.querySelectorAll(strings$4$1.ENABLED_ITEMS_SELECTOR));
        }
        /** @param {boolean} value */

      }, {
        key: "wrapFocus",
        set: function set(value) {
          this.foundation_.setWrapFocus(value);
        }
        /** @param {boolean} isSingleSelectionList */

      }, {
        key: "singleSelection",
        set: function set(isSingleSelectionList) {
          this.foundation_.setSingleSelection(isSingleSelectionList);
        }
        /** @return {!Index} */

      }, {
        key: "selectedIndex",
        get: function get() {
          return this.foundation_.getSelectedIndex();
        }
        /** @param {!Index} index */
        ,
        set: function set(index) {
          this.foundation_.setSelectedIndex(index);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCList(root);
        }
      }]);

      return MDCList;
    }(MDCComponent$f);

    /**
     * @extends MDCComponent<!MDCMenuFoundation>
     */

    var MDCMenu$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCMenu, _MDCComponent);

      /** @param {...?} args */
      function MDCMenu() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$f(this, MDCMenu);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$f(this, (_getPrototypeOf2 = _getPrototypeOf$f(MDCMenu)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCMenuSurface} */

        _this.menuSurface_;
        /** @private {!MDCList} */

        _this.list_;
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleItemAction_;
        /** @private {!Function} */

        _this.afterOpenedCallback_;
        return _this;
      }
      /**
       * @param {!HTMLElement} root
       * @return {!MDCMenu}
       */


      _createClass$f(MDCMenu, [{
        key: "initialize",
        value: function initialize() {
          var menuSurfaceFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCMenuSurface$2(el);
          };
          var listFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCList$3(el);
          };
          this.menuSurface_ = menuSurfaceFactory(this.root_);
          var list = this.root_.querySelector(strings$2$4.LIST_SELECTOR);

          if (list) {
            this.list_ = listFactory(list);
            this.list_.wrapFocus = true;
          }
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.afterOpenedCallback_ = function () {
            return _this2.handleAfterOpened_();
          };

          this.handleKeydown_ = function (evt) {
            return _this2.foundation_.handleKeydown(evt);
          };

          this.handleItemAction_ = function (evt) {
            return _this2.foundation_.handleItemAction(_this2.items[evt.detail]);
          };

          this.menuSurface_.listen(MDCMenuSurfaceFoundation$2.strings.OPENED_EVENT, this.afterOpenedCallback_);
          this.listen('keydown', this.handleKeydown_);
          this.listen(MDCListFoundation$3.strings.ACTION_EVENT, this.handleItemAction_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.list_) {
            this.list_.destroy();
          }

          this.menuSurface_.destroy();
          this.menuSurface_.unlisten(MDCMenuSurfaceFoundation$2.strings.OPENED_EVENT, this.afterOpenedCallback_);
          this.unlisten('keydown', this.handleKeydown_);
          this.unlisten(MDCListFoundation$3.strings.ACTION_EVENT, this.handleItemAction_);

          _get$7(_getPrototypeOf$f(MDCMenu.prototype), "destroy", this).call(this);
        }
        /** @return {boolean} */

      }, {
        key: "setAnchorCorner",

        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left
         *     menu corner.
         */
        value: function setAnchorCorner(corner) {
          this.menuSurface_.setAnchorCorner(corner);
        }
        /**
         * @param {!AnchorMargin} margin
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.menuSurface_.setAnchorMargin(margin);
        }
        /**
         * Return the items within the menu. Note that this only contains the set of elements within
         * the items container that are proper list items, and not supplemental / presentational DOM
         * elements.
         * @return {!Array<!HTMLElement>}
         */

      }, {
        key: "getOptionByIndex",

        /**
         * Return the item within the menu at the index specified.
         * @param {number} index
         * @return {?HTMLElement}
         */
        value: function getOptionByIndex(index) {
          var items = this.items;

          if (index < items.length) {
            return this.items[index];
          } else {
            return null;
          }
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "setFixedPosition",

        /** @param {boolean} isFixed */
        value: function setFixedPosition(isFixed) {
          this.menuSurface_.setFixedPosition(isFixed);
        }
      }, {
        key: "hoistMenuToBody",
        value: function hoistMenuToBody() {
          this.menuSurface_.hoistMenuToBody();
        }
        /** @param {boolean} isHoisted */

      }, {
        key: "setIsHoisted",
        value: function setIsHoisted(isHoisted) {
          this.menuSurface_.setIsHoisted(isHoisted);
        }
        /**
         * @param {number} x
         * @param {number} y
         */

      }, {
        key: "setAbsolutePosition",
        value: function setAbsolutePosition(x, y) {
          this.menuSurface_.setAbsolutePosition(x, y);
        }
        /**
         * Sets the element that the menu-surface is anchored to.
         * @param {!HTMLElement} element
         */

      }, {
        key: "setAnchorElement",
        value: function setAnchorElement(element) {
          this.menuSurface_.anchorElement = element;
        }
      }, {
        key: "handleAfterOpened_",
        value: function handleAfterOpened_() {
          var list = this.items;

          if (list.length > 0) {
            list[0].focus();
          }
        }
        /** @return {!MDCMenuFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCMenuFoundation$1({
            addClassToElementAtIndex: function addClassToElementAtIndex(index, className) {
              var list = _this3.items;
              list[index].classList.add(className);
            },
            removeClassFromElementAtIndex: function removeClassFromElementAtIndex(index, className) {
              var list = _this3.items;
              list[index].classList.remove(className);
            },
            addAttributeToElementAtIndex: function addAttributeToElementAtIndex(index, attr, value) {
              var list = _this3.items;
              list[index].setAttribute(attr, value);
            },
            removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex(index, attr) {
              var list = _this3.items;
              list[index].removeAttribute(attr);
            },
            elementContainsClass: function elementContainsClass(element, className) {
              return element.classList.contains(className);
            },
            closeSurface: function closeSurface() {
              return _this3.open = false;
            },
            getElementIndex: function getElementIndex(element) {
              return _this3.items.indexOf(element);
            },
            getParentElement: function getParentElement(element) {
              return element.parentElement;
            },
            getSelectedElementIndex: function getSelectedElementIndex(selectionGroup) {
              return _this3.items.indexOf(selectionGroup.querySelector(".".concat(cssClasses$4$1.MENU_SELECTED_LIST_ITEM)));
            },
            notifySelected: function notifySelected(evtData) {
              return _this3.emit(strings$2$4.SELECTED_EVENT, {
                index: evtData.index,
                item: _this3.items[evtData.index]
              });
            }
          });
        }
      }, {
        key: "open",
        get: function get() {
          return this.menuSurface_.open;
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          this.menuSurface_.open = value;
        }
        /** @return {boolean} */

      }, {
        key: "wrapFocus",
        get: function get() {
          return this.list_.wrapFocus;
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          this.list_.wrapFocus = value;
        }
      }, {
        key: "items",
        get: function get() {
          return this.list_.listElements;
        }
      }, {
        key: "quickOpen",
        set: function set(quickOpen) {
          this.menuSurface_.quickOpen = quickOpen;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCMenu(root);
        }
      }]);

      return MDCMenu;
    }(MDCComponent$f);

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$6 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$f(this, MDCRippleAdapter);
      }

      _createClass$f(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$7$1 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$5$1 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$2$1 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$6;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$6;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$6(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$6(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$6;

      if (typeof supportsCssVariables_$6 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$6(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$6 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$6() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$6 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$6 = isSupported;
      }

      return supportsPassive_$6 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$6(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$6(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$7 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$7 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$6 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$6 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCRippleFoundation, _MDCFoundation);

      _createClass$f(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$7$1;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$5$1;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$2$1;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$f(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$7.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$7.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$7.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$7.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$6.length > 0 && activatedTargets$6.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$6.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$6 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$6(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$2$1.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$f);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$6 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$f(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$f(this, (_getPrototypeOf2 = _getPrototypeOf$f(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$f(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$6(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$6(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$6(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$6());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$6());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$6());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$6());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$f);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$6 = function RippleCapableSurface() {
      _classCallCheck$f(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$6.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$6.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$6.prototype.disabled;

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Notched Outline.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Notched Outline into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCNotchedOutlineAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCNotchedOutlineAdapter() {
        _classCallCheck$f(this, MDCNotchedOutlineAdapter);
      }

      _createClass$f(MDCNotchedOutlineAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets the width style property of the notch element.
         * @param {number} width
         */

      }, {
        key: "setNotchWidthProperty",
        value: function setNotchWidthProperty(width) {}
        /**
         * Removes the width style property from the notch element.
         */

      }, {
        key: "removeNotchWidthProperty",
        value: function removeNotchWidthProperty() {}
      }]);

      return MDCNotchedOutlineAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$6$1 = {
      NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch'
    };
    /** @enum {number} */

    var numbers$3$1 = {
      // This should stay in sync with $mdc-notched-outline-padding * 2.
      NOTCH_ELEMENT_PADDING: 8
    };
    /** @enum {string} */

    var cssClasses$8$1 = {
      OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
      OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
      NO_LABEL: 'mdc-notched-outline--no-label'
    };

    /**
     * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
     * @final
     */

    var MDCNotchedOutlineFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCNotchedOutlineFoundation, _MDCFoundation);

      _createClass$f(MDCNotchedOutlineFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$6$1;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$8$1;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$3$1;
        }
        /**
         * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCNotchedOutlineAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCNotchedOutlineAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              setNotchWidthProperty: function setNotchWidthProperty() {},
              removeNotchWidthProperty: function removeNotchWidthProperty() {}
            }
          );
        }
        /**
         * @param {!MDCNotchedOutlineAdapter} adapter
         */

      }]);

      function MDCNotchedOutlineFoundation(adapter) {
        _classCallCheck$f(this, MDCNotchedOutlineFoundation);

        return _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCNotchedOutlineFoundation).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
      }
      /**
       * Adds the outline notched selector and updates the notch width
       * calculated based off of notchWidth.
       * @param {number} notchWidth
       */


      _createClass$f(MDCNotchedOutlineFoundation, [{
        key: "notch",
        value: function notch(notchWidth) {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

          if (notchWidth > 0) {
            notchWidth += numbers$3$1.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
          }

          this.adapter_.setNotchWidthProperty(notchWidth);
          this.adapter_.addClass(OUTLINE_NOTCHED);
        }
        /**
         * Removes notched outline selector to close the notch in the outline.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.removeClass(OUTLINE_NOTCHED);
          this.adapter_.removeNotchWidthProperty();
        }
      }]);

      return MDCNotchedOutlineFoundation;
    }(MDCFoundation$f);

    /**
     * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
     * @final
     */

    var MDCNotchedOutline$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCNotchedOutline, _MDCComponent);

      _createClass$f(MDCNotchedOutline, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCNotchedOutline}
         */
        value: function attachTo(root) {
          return new MDCNotchedOutline(root);
        }
        /** @param {...?} args */

      }]);

      function MDCNotchedOutline() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$f(this, MDCNotchedOutline);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$f(this, (_getPrototypeOf2 = _getPrototypeOf$f(MDCNotchedOutline)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {Element} */

        _this.notchElement_;
        return _this;
      }

      _createClass$f(MDCNotchedOutline, [{
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var label = this.root_.querySelector('.' + MDCFloatingLabelFoundation$2.cssClasses.ROOT);
          this.notchElement_ = this.root_.querySelector(strings$6$1.NOTCH_ELEMENT_SELECTOR);

          if (label) {
            label.style.transitionDuration = '0s';
            this.root_.classList.add(cssClasses$8$1.OUTLINE_UPGRADED);
            requestAnimationFrame(function () {
              label.style.transitionDuration = '';
            });
          } else {
            this.root_.classList.add(cssClasses$8$1.NO_LABEL);
          }
        }
        /**
          * Updates classes and styles to open the notch to the specified width.
          * @param {number} notchWidth The notch width in the outline.
          */

      }, {
        key: "notch",
        value: function notch(notchWidth) {
          this.foundation_.notch(notchWidth);
        }
        /**
         * Updates classes and styles to close the notch.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          this.foundation_.closeNotch();
        }
        /**
         * @return {!MDCNotchedOutlineFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCNotchedOutlineFoundation$1(
          /** @type {!MDCNotchedOutlineAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            setNotchWidthProperty: function setNotchWidthProperty(width) {
              return _this2.notchElement_.style.setProperty('width', width + 'px');
            },
            removeNotchWidthProperty: function removeNotchWidthProperty() {
              return _this2.notchElement_.style.removeProperty('width');
            }
          }));
        }
      }]);

      return MDCNotchedOutline;
    }(MDCComponent$f);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Select Icon.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the select icon into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCSelectIconAdapter =
    /*#__PURE__*/
    function () {
      function MDCSelectIconAdapter() {
        _classCallCheck$f(this, MDCSelectIconAdapter);
      }

      _createClass$f(MDCSelectIconAdapter, [{
        key: "getAttr",

        /**
         * Gets the value of an attribute on the icon element.
         * @param {string} attr
         * @return {string}
         */
        value: function getAttr(attr) {}
        /**
         * Sets an attribute on the icon element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Removes an attribute from the icon element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}
        /**
         * Sets the text content of the icon element.
         * @param {string} content
         */

      }, {
        key: "setContent",
        value: function setContent(content) {}
        /**
         * Registers an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * Emits a custom event "MDCSelect:icon" denoting a user has clicked the icon.
         */

      }, {
        key: "notifyIconAction",
        value: function notifyIconAction() {}
      }]);

      return MDCSelectIconAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$7$1 = {
      ICON_EVENT: 'MDCSelect:icon',
      ICON_ROLE: 'button'
    };

    /**
     * @extends {MDCFoundation<!MDCSelectIconAdapter>}
     * @final
     */

    var MDCSelectIconFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCSelectIconFoundation, _MDCFoundation);

      _createClass$f(MDCSelectIconFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$7$1;
        }
        /**
         * {@see MDCSelectIconAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCSelectIconAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCSelectIconAdapter} */
            {
              getAttr: function getAttr() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              setContent: function setContent() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {},
              notifyIconAction: function notifyIconAction() {}
            }
          );
        }
        /**
         * @param {!MDCSelectIconAdapter} adapter
         */

      }]);

      function MDCSelectIconFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCSelectIconFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCSelectIconFoundation).call(this, Object.assign(MDCSelectIconFoundation.defaultAdapter, adapter)));
        /** @private {string?} */

        _this.savedTabIndex_ = null;
        /** @private {function(!Event): undefined} */

        _this.interactionHandler_ = function (evt) {
          return _this.handleInteraction(evt);
        };

        return _this;
      }

      _createClass$f(MDCSelectIconFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
          });
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          if (!this.savedTabIndex_) {
            return;
          }

          if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
          } else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', strings$7$1.ICON_ROLE);
          }
        }
        /** @param {string} label */

      }, {
        key: "setAriaLabel",
        value: function setAriaLabel(label) {
          this.adapter_.setAttr('aria-label', label);
        }
        /** @param {string} content */

      }, {
        key: "setContent",
        value: function setContent(content) {
          this.adapter_.setContent(content);
        }
        /**
         * Handles an interaction event
         * @param {!Event} evt
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction(evt) {
          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyIconAction();
          }
        }
      }]);

      return MDCSelectIconFoundation;
    }(MDCFoundation$f);

    /**
     * @extends {MDCComponent<!MDCSelectIconFoundation>}
     * @final
     */

    var MDCSelectIcon =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCSelectIcon, _MDCComponent);

      function MDCSelectIcon() {
        _classCallCheck$f(this, MDCSelectIcon);

        return _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCSelectIcon).apply(this, arguments));
      }

      _createClass$f(MDCSelectIcon, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCSelectIconFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCSelectIconFoundation(
          /** @type {!MDCSelectIconAdapter} */
          Object.assign({
            getAttr: function getAttr(attr) {
              return _this.root_.getAttribute(attr);
            },
            setAttr: function setAttr(attr, value) {
              return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
              return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            },
            notifyIconAction: function notifyIconAction() {
              return _this.emit(MDCSelectIconFoundation.strings.ICON_EVENT, {}
              /* evtData */
              , true
              /* shouldBubble */
              );
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCSelectIconFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCSelectIcon}
         */
        value: function attachTo(root) {
          return new MDCSelectIcon(root);
        }
      }]);

      return MDCSelectIcon;
    }(MDCComponent$f);

    /**
     * Adapter for MDC Select. Provides an interface for managing
     * - classes
     * - dom
     * - event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */

    var MDCSelectAdapter =
    /*#__PURE__*/
    function () {
      function MDCSelectAdapter() {
        _classCallCheck$f(this, MDCSelectAdapter);
      }

      _createClass$f(MDCSelectAdapter, [{
        key: "addClass",

        /**
         * Adds class to root element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root element contains the given class name.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Activates the bottom line, showing a focused state.
         */

      }, {
        key: "activateBottomLine",
        value: function activateBottomLine() {}
        /**
         * Deactivates the bottom line.
         */

      }, {
        key: "deactivateBottomLine",
        value: function deactivateBottomLine() {}
        /**
         * Sets the value of the select.
         * @param {string} value
         */

      }, {
        key: "setValue",
        value: function setValue(value) {}
        /**
         * Returns the selected value of the select element.
         * @return {string}
         */

      }, {
        key: "getValue",
        value: function getValue() {}
        /**
         * Floats label determined based off of the shouldFloat argument.
         * @param {boolean} shouldFloat
         */

      }, {
        key: "floatLabel",
        value: function floatLabel(shouldFloat) {}
        /**
         * Returns width of label in pixels, if the label exists.
         * @return {number}
         */

      }, {
        key: "getLabelWidth",
        value: function getLabelWidth() {}
        /**
         * Returns true if outline element exists, false if it doesn't.
         * @return {boolean}
         */

      }, {
        key: "hasOutline",
        value: function hasOutline() {}
        /**
         * Only implement if outline element exists.
         * @param {number} labelWidth
         */

      }, {
        key: "notchOutline",
        value: function notchOutline(labelWidth) {}
        /**
         * Closes notch in outline element, if the outline exists.
         */

      }, {
        key: "closeOutline",
        value: function closeOutline() {}
        /**
         * Opens the menu.
         */

      }, {
        key: "openMenu",
        value: function openMenu() {}
        /**
         * Closes the menu.
         */

      }, {
        key: "closeMenu",
        value: function closeMenu() {}
        /**
         * Returns true if the menu is currently open.
         * @return {boolean}
         */

      }, {
        key: "isMenuOpen",
        value: function isMenuOpen() {}
        /**
         * Sets the selected index of the select to the index provided.
         * @param {number} index
         */

      }, {
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {}
        /**
         * Sets the select to disabled.
         * @param {boolean} isDisabled
         */

      }, {
        key: "setDisabled",
        value: function setDisabled(isDisabled) {}
        /**
         * Sets the line ripple transform origin center.
         * @param {number} normalizedX
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(normalizedX) {}
        /**
         * Emits a change event when an element is selected.
         * @param {string} value
         */

      }, {
        key: "notifyChange",
        value: function notifyChange(value) {}
        /**
         * Checks if the select is currently valid.
         * @return {boolean} isValid
         */

      }, {
        key: "checkValidity",
        value: function checkValidity() {}
        /**
         * Adds/Removes the invalid class.
         * @param {boolean} isValid
         */

      }, {
        key: "setValid",
        value: function setValid(isValid) {}
      }]);

      return MDCSelectAdapter;
    }();

    /**
     * @extends {MDCFoundation<!MDCSelectAdapter>}
     * @final
     */

    var MDCSelectFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCSelectFoundation, _MDCFoundation);

      _createClass$f(MDCSelectFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$1$9;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$9;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$8;
        }
        /**
         * {@see MDCSelectAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCSelectAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCSelectAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              hasClass: function hasClass() {
                return (
                  /* className: string */
                  false
                );
              },
              activateBottomLine: function activateBottomLine() {},
              deactivateBottomLine: function deactivateBottomLine() {},
              setValue: function setValue() {},
              getValue: function getValue() {},
              floatLabel: function floatLabel()
              /* value: boolean */
              {},
              getLabelWidth: function getLabelWidth() {},
              hasOutline: function hasOutline() {
                return false;
              },
              notchOutline: function notchOutline()
              /* labelWidth: number, */
              {},
              closeOutline: function closeOutline() {},
              openMenu: function openMenu() {},
              closeMenu: function closeMenu() {},
              isMenuOpen: function isMenuOpen() {},
              setSelectedIndex: function setSelectedIndex() {},
              setDisabled: function setDisabled() {},
              setRippleCenter: function setRippleCenter() {},
              notifyChange: function notifyChange() {},
              checkValidity: function checkValidity() {},
              setValid: function setValid() {}
            }
          );
        }
        /**
         * @param {!MDCSelectAdapter} adapter
         * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
         */

      }]);

      function MDCSelectFoundation(adapter) {
        var _this;

        var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :
        /** @type {!FoundationMapType} */
        {};

        _classCallCheck$f(this, MDCSelectFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCSelectFoundation).call(this, Object.assign(MDCSelectFoundation.defaultAdapter, adapter)));
        /** @type {!MDCSelectIconFoundation|undefined} */

        _this.leadingIcon_ = foundationMap.leadingIcon;
        /** @type {!MDCSelectHelperTextFoundation|undefined} */

        _this.helperText_ = foundationMap.helperText;
        return _this;
      }

      _createClass$f(MDCSelectFoundation, [{
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {
          this.adapter_.setSelectedIndex(index);
          this.adapter_.closeMenu();
          var didChange = true;
          this.handleChange(didChange);
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.adapter_.setValue(value);
          var didChange = true;
          this.handleChange(didChange);
        }
      }, {
        key: "getValue",
        value: function getValue() {
          return this.adapter_.getValue();
        }
      }, {
        key: "setDisabled",
        value: function setDisabled(isDisabled) {
          isDisabled ? this.adapter_.addClass(cssClasses$1$9.DISABLED) : this.adapter_.removeClass(cssClasses$1$9.DISABLED);
          this.adapter_.setDisabled(isDisabled);
          this.adapter_.closeMenu();

          if (this.leadingIcon_) {
            this.leadingIcon_.setDisabled(isDisabled);
          }
        }
        /**
         * @param {string} content Sets the content of the helper text.
         */

      }, {
        key: "setHelperTextContent",
        value: function setHelperTextContent(content) {
          if (this.helperText_) {
            this.helperText_.setContent(content);
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var openNotch = this.getValue().length > 0;
          this.notchOutline(openNotch);
        }
        /**
         * Handles value changes, via change event or programmatic updates.
         */

      }, {
        key: "handleChange",
        value: function handleChange() {
          var didChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var value = this.getValue();
          var optionHasValue = value.length > 0;
          var isRequired = this.adapter_.hasClass(cssClasses$1$9.REQUIRED);
          this.notchOutline(optionHasValue);

          if (!this.adapter_.hasClass(cssClasses$1$9.FOCUSED)) {
            this.adapter_.floatLabel(optionHasValue);
          }

          if (didChange) {
            this.adapter_.notifyChange(value);

            if (isRequired) {
              this.setValid(this.isValid());

              if (this.helperText_) {
                this.helperText_.setValidity(this.isValid());
              }
            }
          }
        }
        /**
         * Handles focus events from select element.
         */

      }, {
        key: "handleFocus",
        value: function handleFocus() {
          this.adapter_.addClass(cssClasses$1$9.FOCUSED);
          this.adapter_.floatLabel(true);
          this.notchOutline(true);
          this.adapter_.activateBottomLine();

          if (this.helperText_) {
            this.helperText_.showToScreenReader();
          }
        }
        /**
         * Handles blur events from select element.
         */

      }, {
        key: "handleBlur",
        value: function handleBlur() {
          if (this.adapter_.isMenuOpen()) return;
          this.adapter_.removeClass(cssClasses$1$9.FOCUSED);
          this.handleChange(false);
          this.adapter_.deactivateBottomLine();
          var isRequired = this.adapter_.hasClass(cssClasses$1$9.REQUIRED);

          if (isRequired) {
            this.setValid(this.isValid());

            if (this.helperText_) {
              this.helperText_.setValidity(this.isValid());
            }
          }
        }
      }, {
        key: "handleClick",
        value: function handleClick(normalizedX) {
          if (this.adapter_.isMenuOpen()) return;
          this.adapter_.setRippleCenter(normalizedX);
          this.adapter_.openMenu();
        }
      }, {
        key: "handleKeydown",
        value: function handleKeydown(event) {
          if (this.adapter_.isMenuOpen()) return;
          var isEnter = event.key === 'Enter' || event.keyCode === 13;
          var isSpace = event.key === 'Space' || event.keyCode === 32;
          var arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
          var arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;

          if (this.adapter_.hasClass(cssClasses$1$9.FOCUSED) && (isEnter || isSpace || arrowUp || arrowDown)) {
            this.adapter_.openMenu();
            event.preventDefault();
          }
        }
        /**
         * Opens/closes the notched outline.
         * @param {boolean} openNotch
         */

      }, {
        key: "notchOutline",
        value: function notchOutline(openNotch) {
          if (!this.adapter_.hasOutline()) {
            return;
          }

          var isFocused = this.adapter_.hasClass(cssClasses$1$9.FOCUSED);

          if (openNotch) {
            var labelScale = numbers$9.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            this.adapter_.notchOutline(labelWidth);
          } else if (!isFocused) {
            this.adapter_.closeOutline();
          }
        }
        /**
         * Sets the aria label of the leading icon.
         * @param {string} label
         */

      }, {
        key: "setLeadingIconAriaLabel",
        value: function setLeadingIconAriaLabel(label) {
          if (this.leadingIcon_) {
            this.leadingIcon_.setAriaLabel(label);
          }
        }
        /**
         * Sets the text content of the leading icon.
         * @param {string} content
         */

      }, {
        key: "setLeadingIconContent",
        value: function setLeadingIconContent(content) {
          if (this.leadingIcon_) {
            this.leadingIcon_.setContent(content);
          }
        }
      }, {
        key: "setValid",
        value: function setValid(isValid) {
          this.adapter_.setValid(isValid);
        }
      }, {
        key: "isValid",
        value: function isValid() {
          return this.adapter_.checkValidity();
        }
      }]);

      return MDCSelectFoundation;
    }(MDCFoundation$f);

    var VALIDATION_ATTR_WHITELIST = ['required', 'aria-required'];
    /**
     * @extends MDCComponent<!MDCSelectFoundation>
     */

    var MDCSelect =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCSelect, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCSelect() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$f(this, MDCSelect);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$f(this, (_getPrototypeOf2 = _getPrototypeOf$f(MDCSelect)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.nativeControl_;
        /** @private {?Element} */

        _this.selectedText_;
        /** @private {?Element} */

        _this.hiddenInput_;
        /** @private {?MDCSelectIcon} */

        _this.leadingIcon_;
        /** @private {?MDCSelectHelperText} */

        _this.helperText_;
        /** @private {?Element} */

        _this.menuElement_;
        /** @type {?MDCMenu} */

        _this.menu_;
        /** @type {?MDCRipple} */

        _this.ripple;
        /** @private {?MDCLineRipple} */

        _this.lineRipple_;
        /** @private {?MDCFloatingLabel} */

        _this.label_;
        /** @private {?MDCNotchedOutline} */

        _this.outline_;
        /** @private {!Function} */

        _this.handleChange_;
        /** @private {!Function} */

        _this.handleFocus_;
        /** @private {!Function} */

        _this.handleBlur_;
        /** @private {!Function} */

        _this.handleClick_;
        /** @private {!Function} */

        _this.handleKeydown_;
        /** @private {!Function} */

        _this.handleMenuOpened_;
        /** @private {!Function} */

        _this.handleMenuClosed_;
        /** @private {!Function} */

        _this.handleMenuSelected_;
        /** @private {boolean} */

        _this.menuOpened_ = false;
        /** @private {!MutationObserver} */

        _this.validationObserver_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCSelect}
       */


      _createClass$f(MDCSelect, [{
        key: "layout",

        /**
         * Recomputes the outline SVG path for the outline element.
         */
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @param {(function(!Element): !MDCLineRipple)=} lineRippleFactory A function which creates a new MDCLineRipple.
         * @param {(function(!Element): !MDCFloatingLabel)=} labelFactory A function which creates a new MDCFloatingLabel.
         * @param {(function(!Element): !MDCNotchedOutline)=} outlineFactory A function which creates a new MDCNotchedOutline.
         * @param {(function(!Element): !MDCMenu)=} menuFactory A function which creates a new MDCMenu.
         * @param {(function(!Element): !MDCSelectIcon)=} iconFactory A function which creates a new MDCSelectIcon.
         * @param {(function(!Element): !MDCSelectHelperText)=} helperTextFactory A function which creates a new
         * MDCSelectHelperText.
         */

      }, {
        key: "initialize",
        value: function initialize() {
          var labelFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCFloatingLabel$2(el);
          };
          var lineRippleFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCLineRipple$1(el);
          };
          var outlineFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el) {
            return new MDCNotchedOutline$1(el);
          };
          var menuFactory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (el) {
            return new MDCMenu$1(el);
          };
          var iconFactory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (el) {
            return new MDCSelectIcon(el);
          };
          var helperTextFactory = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (el) {
            return new MDCSelectHelperText(el);
          };
          this.nativeControl_ =
          /** @type {HTMLElement} */
          this.root_.querySelector(strings$1$8.NATIVE_CONTROL_SELECTOR);
          this.selectedText_ =
          /** @type {HTMLElement} */
          this.root_.querySelector(strings$1$8.SELECTED_TEXT_SELECTOR);

          if (this.selectedText_) {
            this.enhancedSelectSetup_(menuFactory);
          }

          var labelElement = this.root_.querySelector(strings$1$8.LABEL_SELECTOR);

          if (labelElement) {
            this.label_ = labelFactory(labelElement);
          }

          var lineRippleElement = this.root_.querySelector(strings$1$8.LINE_RIPPLE_SELECTOR);

          if (lineRippleElement) {
            this.lineRipple_ = lineRippleFactory(lineRippleElement);
          }

          var outlineElement = this.root_.querySelector(strings$1$8.OUTLINE_SELECTOR);

          if (outlineElement) {
            this.outline_ = outlineFactory(outlineElement);
          }

          var leadingIcon = this.root_.querySelector(strings$1$8.LEADING_ICON_SELECTOR);

          if (leadingIcon) {
            this.root_.classList.add(cssClasses$1$9.WITH_LEADING_ICON);
            this.leadingIcon_ = iconFactory(leadingIcon);

            if (this.menuElement_) {
              this.menuElement_.classList.add(cssClasses$1$9.WITH_LEADING_ICON);
            }
          }

          var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;

          if (element.hasAttribute(strings$1$8.ARIA_CONTROLS)) {
            var helperTextElement = document.getElementById(element.getAttribute(strings$1$8.ARIA_CONTROLS));

            if (helperTextElement) {
              this.helperText_ = helperTextFactory(helperTextElement);
            }
          }

          if (!this.root_.classList.contains(cssClasses$1$9.OUTLINED)) {
            this.ripple = this.initRipple_();
          } // The required state needs to be sync'd before the mutation observer is added.


          this.initialSyncRequiredState_();
          this.addMutationObserverForRequired_();
        }
        /**
         * Handles setup for the enhanced menu.
         * @private
         */

      }, {
        key: "enhancedSelectSetup_",
        value: function enhancedSelectSetup_(menuFactory) {
          var isDisabled = this.root_.classList.contains(cssClasses$1$9.DISABLED);
          this.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');
          this.hiddenInput_ = this.root_.querySelector(strings$1$8.HIDDEN_INPUT_SELECTOR);
          this.menuElement_ =
          /** @type {HTMLElement} */
          this.root_.querySelector(strings$1$8.MENU_SELECTOR);
          this.menu_ = menuFactory(this.menuElement_);
          this.menu_.hoistMenuToBody();
          this.menu_.setAnchorElement(
          /** @type {!HTMLElement} */
          this.root_);
          this.menu_.setAnchorCorner(Corner$2.BOTTOM_START);
          this.menu_.wrapFocus = false;
        }
        /**
         * @private
         * @return {!MDCRipple}
         */

      }, {
        key: "initRipple_",
        value: function initRipple_() {
          var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
          var adapter = Object.assign(MDCRipple$6.createAdapter(this), {
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return element.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return element.removeEventListener(type, handler);
            }
          });
          var foundation = new MDCRippleFoundation$6(adapter);
          return new MDCRipple$6(this.root_, foundation);
        }
        /**
         * Initializes the select's event listeners and internal state based
         * on the environment's state.
         */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.handleChange_ = function () {
            return _this2.foundation_.handleChange(
            /* didChange */
            true);
          };

          this.handleFocus_ = function () {
            return _this2.foundation_.handleFocus();
          };

          this.handleBlur_ = function () {
            return _this2.foundation_.handleBlur();
          };

          this.handleClick_ = function (evt) {
            if (_this2.selectedText_) _this2.selectedText_.focus();

            _this2.foundation_.handleClick(_this2.getNormalizedXCoordinate_(evt));
          };

          this.handleKeydown_ = function (evt) {
            return _this2.foundation_.handleKeydown(evt);
          };

          this.handleMenuSelected_ = function (evtData) {
            return _this2.selectedIndex = evtData.detail.index;
          };

          this.handleMenuOpened_ = function () {
            // Menu should open to the last selected element.
            if (_this2.selectedIndex >= 0) {
              _this2.menu_.items[_this2.selectedIndex].focus();
            }
          };

          this.handleMenuClosed_ = function () {
            // menuOpened_ is used to track the state of the menu opening or closing since the menu.open function
            // will return false if the menu is still closing and this method listens to the closed event which
            // occurs after the menu is already closed.
            _this2.menuOpened_ = false;

            _this2.selectedText_.removeAttribute('aria-expanded');

            if (document.activeElement !== _this2.selectedText_) {
              _this2.foundation_.handleBlur();
            }
          };

          var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
          element.addEventListener('change', this.handleChange_);
          element.addEventListener('focus', this.handleFocus_);
          element.addEventListener('blur', this.handleBlur_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            element.addEventListener(evtType, _this2.handleClick_);
          });

          if (this.menuElement_) {
            this.selectedText_.addEventListener('keydown', this.handleKeydown_);
            this.menu_.listen(strings$3$1.CLOSED_EVENT, this.handleMenuClosed_);
            this.menu_.listen(strings$3$1.OPENED_EVENT, this.handleMenuOpened_);
            this.menu_.listen(strings$2$4.SELECTED_EVENT, this.handleMenuSelected_);

            if (this.hiddenInput_ && this.hiddenInput_.value) {
              // If the hidden input already has a value, use it to restore the select's value.
              // This can happen e.g. if the user goes back or (in some browsers) refreshes the page.
              var enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();
              enhancedAdapterMethods.setValue(this.hiddenInput_.value);
            } else if (this.menuElement_.querySelector(strings$1$8.SELECTED_ITEM_SELECTOR)) {
              // If an element is selected, the select should set the initial selected text.
              var _enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();

              _enhancedAdapterMethods.setValue(_enhancedAdapterMethods.getValue());
            }
          } // Initially sync floating label


          this.foundation_.handleChange(
          /* didChange */
          false);

          if (this.root_.classList.contains(cssClasses$1$9.DISABLED) || this.nativeControl_ && this.nativeControl_.disabled) {
            this.disabled = true;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
          element.removeEventListener('change', this.handleChange_);
          element.removeEventListener('focus', this.handleFocus_);
          element.removeEventListener('blur', this.handleBlur_);
          element.removeEventListener('keydown', this.handleKeydown_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            element.removeEventListener(evtType, _this3.handleClick_);
          });

          if (this.menu_) {
            this.menu_.unlisten(strings$3$1.CLOSED_EVENT, this.handleMenuClosed_);
            this.menu_.unlisten(strings$3$1.OPENED_EVENT, this.handleMenuOpened_);
            this.menu_.unlisten(strings$2$4.SELECTED_EVENT, this.handleMenuSelected_);
            this.menu_.destroy();
          }

          if (this.ripple) {
            this.ripple.destroy();
          }

          if (this.outline_) {
            this.outline_.destroy();
          }

          if (this.leadingIcon_) {
            this.leadingIcon_.destroy();
          }

          if (this.helperText_) {
            this.helperText_.destroy();
          }

          if (this.validationObserver_) {
            this.validationObserver_.disconnect();
          }

          _get$7(_getPrototypeOf$f(MDCSelect.prototype), "destroy", this).call(this);
        }
        /**
         * @return {!MDCSelectFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCSelectFoundation(
          /** @type {!MDCSelectAdapter} */
          Object.assign(this.nativeControl_ ? this.getNativeSelectAdapterMethods_() : this.getEnhancedSelectAdapterMethods_(), this.getCommonAdapterMethods_(), this.getOutlineAdapterMethods_(), this.getLabelAdapterMethods_()), this.getFoundationMap_());
        }
        /**
         * @return {!{
         *   getValue: function(): string,
         *   setValue: function(string): string,
         *   openMenu: function(): void,
         *   closeMenu: function(): void,
         *   isMenuOpen: function(): boolean,
         *   setSelectedIndex: function(number): void,
         *   setDisabled: function(boolean): void
         * }}
         * @private
         */

      }, {
        key: "getNativeSelectAdapterMethods_",
        value: function getNativeSelectAdapterMethods_() {
          var _this4 = this;

          return {
            getValue: function getValue() {
              return _this4.nativeControl_.value;
            },
            setValue: function setValue(value) {
              return _this4.nativeControl_.value = value;
            },
            openMenu: function openMenu() {},
            closeMenu: function closeMenu() {},
            isMenuOpen: function isMenuOpen() {
              return false;
            },
            setSelectedIndex: function setSelectedIndex(index) {
              _this4.nativeControl_.selectedIndex = index;
            },
            setDisabled: function setDisabled(isDisabled) {
              return _this4.nativeControl_.disabled = isDisabled;
            },
            setValid: function setValid(isValid) {
              isValid ? _this4.root_.classList.remove(cssClasses$1$9.INVALID) : _this4.root_.classList.add(cssClasses$1$9.INVALID);
            },
            checkValidity: function checkValidity() {
              return _this4.nativeControl_.checkValidity();
            }
          };
        }
        /**
         * @return {!{
         *   getValue: function(): string,
         *   setValue: function(string): string,
         *   openMenu: function(): void,
         *   closeMenu: function(): void,
         *   isMenuOpen: function(): boolean,
         *   setSelectedIndex: function(number): void,
         *   setDisabled: function(boolean): void
         * }}
         * @private
         */

      }, {
        key: "getEnhancedSelectAdapterMethods_",
        value: function getEnhancedSelectAdapterMethods_() {
          var _this5 = this;

          return {
            getValue: function getValue() {
              var listItem = _this5.menuElement_.querySelector(strings$1$8.SELECTED_ITEM_SELECTOR);

              if (listItem && listItem.hasAttribute(strings$1$8.ENHANCED_VALUE_ATTR)) {
                return listItem.getAttribute(strings$1$8.ENHANCED_VALUE_ATTR);
              }

              return '';
            },
            setValue: function setValue(value) {
              var element =
              /** @type {HTMLElement} */
              _this5.menuElement_.querySelector("[".concat(strings$1$8.ENHANCED_VALUE_ATTR, "=\"").concat(value, "\"]"));

              _this5.setEnhancedSelectedIndex_(element ? _this5.menu_.items.indexOf(element) : -1);
            },
            openMenu: function openMenu() {
              if (_this5.menu_ && !_this5.menu_.open) {
                _this5.menu_.open = true;
                _this5.menuOpened_ = true;

                _this5.selectedText_.setAttribute('aria-expanded', 'true');
              }
            },
            closeMenu: function closeMenu() {
              if (_this5.menu_ && _this5.menu_.open) {
                _this5.menu_.open = false;
              }
            },
            isMenuOpen: function isMenuOpen() {
              return _this5.menu_ && _this5.menuOpened_;
            },
            setSelectedIndex: function setSelectedIndex(index) {
              _this5.setEnhancedSelectedIndex_(index);
            },
            setDisabled: function setDisabled(isDisabled) {
              _this5.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');

              _this5.selectedText_.setAttribute('aria-disabled', isDisabled.toString());

              if (_this5.hiddenInput_) {
                _this5.hiddenInput_.disabled = isDisabled;
              }
            },
            checkValidity: function checkValidity() {
              var classList = _this5.root_.classList;

              if (classList.contains(cssClasses$1$9.REQUIRED) && !classList.contains(cssClasses$1$9.DISABLED)) {
                // See notes for required attribute under https://www.w3.org/TR/html52/sec-forms.html#the-select-element
                // TL;DR: Invalid if no index is selected, or if the first index is selected and has an empty value.
                return _this5.selectedIndex !== -1 && (_this5.selectedIndex !== 0 || _this5.value);
              } else {
                return true;
              }
            },
            setValid: function setValid(isValid) {
              _this5.selectedText_.setAttribute('aria-invalid', (!isValid).toString());

              isValid ? _this5.root_.classList.remove(cssClasses$1$9.INVALID) : _this5.root_.classList.add(cssClasses$1$9.INVALID);
            }
          };
        }
        /**
         * @return {!{
         *   addClass: function(string): void,
         *   removeClass: function(string): void,
         *   hasClass: function(string): void,
         *   setRippleCenter: function(number): void,
         *   activateBottomLine: function(): void,
         *   deactivateBottomLine: function(): void,
         *   notifyChange: function(string): void
         * }}
         * @private
         */

      }, {
        key: "getCommonAdapterMethods_",
        value: function getCommonAdapterMethods_() {
          var _this6 = this;

          return {
            addClass: function addClass(className) {
              return _this6.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this6.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this6.root_.classList.contains(className);
            },
            setRippleCenter: function setRippleCenter(normalizedX) {
              return _this6.lineRipple_ && _this6.lineRipple_.setRippleCenter(normalizedX);
            },
            activateBottomLine: function activateBottomLine() {
              return _this6.lineRipple_ && _this6.lineRipple_.activate();
            },
            deactivateBottomLine: function deactivateBottomLine() {
              return _this6.lineRipple_ && _this6.lineRipple_.deactivate();
            },
            notifyChange: function notifyChange(value) {
              var index = _this6.selectedIndex;

              _this6.emit(strings$1$8.CHANGE_EVENT, {
                value: value,
                index: index
              }, true
              /* shouldBubble  */
              );
            }
          };
        }
        /**
         * @return {!{
         *   hasOutline: function(): boolean,
         *   notchOutline: function(number, boolean): undefined,
         *   closeOutline: function(): undefined,
         * }}
         */

      }, {
        key: "getOutlineAdapterMethods_",
        value: function getOutlineAdapterMethods_() {
          var _this7 = this;

          return {
            hasOutline: function hasOutline() {
              return !!_this7.outline_;
            },
            notchOutline: function notchOutline(labelWidth) {
              if (_this7.outline_) {
                _this7.outline_.notch(labelWidth);
              }
            },
            closeOutline: function closeOutline() {
              if (_this7.outline_) {
                _this7.outline_.closeNotch();
              }
            }
          };
        }
        /**
         * @return {!{
         *   floatLabel: function(boolean): undefined,
         *   getLabelWidth: function(): number,
         * }}
         */

      }, {
        key: "getLabelAdapterMethods_",
        value: function getLabelAdapterMethods_() {
          var _this8 = this;

          return {
            floatLabel: function floatLabel(shouldFloat) {
              if (_this8.label_) {
                _this8.label_.float(shouldFloat);
              }
            },
            getLabelWidth: function getLabelWidth() {
              return _this8.label_ ? _this8.label_.getWidth() : 0;
            }
          };
        }
        /**
         * Calculates where the line ripple should start based on the x coordinate within the component.
         * @param {!(MouseEvent|TouchEvent)} evt
         * @return {number} normalizedX
         */

      }, {
        key: "getNormalizedXCoordinate_",
        value: function getNormalizedXCoordinate_(evt) {
          var targetClientRect = evt.target.getBoundingClientRect();
          var xCoordinate = evt.clientX;
          return xCoordinate - targetClientRect.left;
        }
        /**
         * Returns a map of all subcomponents to subfoundations.
         * @return {!FoundationMapType}
         */

      }, {
        key: "getFoundationMap_",
        value: function getFoundationMap_() {
          return {
            leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
            helperText: this.helperText_ ? this.helperText_.foundation : undefined
          };
        }
        /**
         * Sets the selected index of the enhanced menu.
         * @param {number} index
         * @private
         */

      }, {
        key: "setEnhancedSelectedIndex_",
        value: function setEnhancedSelectedIndex_(index) {
          var selectedItem = this.menu_.items[index];
          this.selectedText_.textContent = selectedItem ? selectedItem.textContent.trim() : '';
          var previouslySelected = this.menuElement_.querySelector(strings$1$8.SELECTED_ITEM_SELECTOR);

          if (previouslySelected) {
            previouslySelected.classList.remove(cssClasses$1$9.SELECTED_ITEM_CLASS);
            previouslySelected.removeAttribute(strings$1$8.ARIA_SELECTED_ATTR);
          }

          if (selectedItem) {
            selectedItem.classList.add(cssClasses$1$9.SELECTED_ITEM_CLASS);
            selectedItem.setAttribute(strings$1$8.ARIA_SELECTED_ATTR, 'true');
          } // Synchronize hidden input's value with data-value attribute of selected item.
          // This code path is also followed when setting value directly, so this covers all cases.


          if (this.hiddenInput_) {
            this.hiddenInput_.value = selectedItem ? selectedItem.getAttribute(strings$1$8.ENHANCED_VALUE_ATTR) || '' : '';
          }

          this.layout();
        }
      }, {
        key: "initialSyncRequiredState_",
        value: function initialSyncRequiredState_() {
          var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
          var isRequired = element.required || element.getAttribute('aria-required') === 'true' || this.root_.classList.contains(cssClasses$1$9.REQUIRED);

          if (isRequired) {
            if (this.nativeControl_) {
              this.nativeControl_.required = true;
            } else {
              this.selectedText_.setAttribute('aria-required', 'true');
            }

            this.root_.classList.add(cssClasses$1$9.REQUIRED);
          }
        }
      }, {
        key: "addMutationObserverForRequired_",
        value: function addMutationObserverForRequired_() {
          var _this9 = this;

          var observerHandler = function observerHandler(attributesList) {
            attributesList.some(function (attributeName) {
              if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
                if (_this9.selectedText_) {
                  if (_this9.selectedText_.getAttribute('aria-required') === 'true') {
                    _this9.root_.classList.add(cssClasses$1$9.REQUIRED);
                  } else {
                    _this9.root_.classList.remove(cssClasses$1$9.REQUIRED);
                  }
                } else {
                  if (_this9.nativeControl_.required) {
                    _this9.root_.classList.add(cssClasses$1$9.REQUIRED);
                  } else {
                    _this9.root_.classList.remove(cssClasses$1$9.REQUIRED);
                  }
                }

                return true;
              }
            });
          };

          var getAttributesList = function getAttributesList(mutationsList) {
            return mutationsList.map(function (mutation) {
              return mutation.attributeName;
            });
          };

          var observer = new MutationObserver(function (mutationsList) {
            return observerHandler(getAttributesList(mutationsList));
          });
          var element = this.nativeControl_ ? this.nativeControl_ : this.selectedText_;
          observer.observe(element, {
            attributes: true
          });
          this.validationObserver_ = observer;
        }
      }, {
        key: "value",

        /**
         * @return {string} The value of the select.
         */
        get: function get() {
          return this.foundation_.getValue();
        }
        /**
         * @param {string} value The value to set on the select.
         */
        ,
        set: function set(value) {
          this.foundation_.setValue(value);
        }
        /**
         * @return {number} The selected index of the select.
         */

      }, {
        key: "selectedIndex",
        get: function get() {
          var selectedIndex;

          if (this.menuElement_) {
            var selectedEl =
            /** @type {!HTMLElement} */
            this.menuElement_.querySelector(strings$1$8.SELECTED_ITEM_SELECTOR);
            selectedIndex = this.menu_.items.indexOf(selectedEl);
          } else {
            selectedIndex = this.nativeControl_.selectedIndex;
          }

          return selectedIndex;
        }
        /**
         * @param {number} selectedIndex The index of the option to be set on the select.
         */
        ,
        set: function set(selectedIndex) {
          this.foundation_.setSelectedIndex(selectedIndex);
        }
        /**
         * @return {boolean} True if the select is disabled.
         */

      }, {
        key: "disabled",
        get: function get() {
          return this.root_.classList.contains(cssClasses$1$9.DISABLED) || (this.nativeControl_ ? this.nativeControl_.disabled : false);
        }
        /**
         * @param {boolean} disabled Sets the select disabled or enabled.
         */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
        /**
         * Sets the aria label of the leading icon.
         * @param {string} label
         */

      }, {
        key: "leadingIconAriaLabel",
        set: function set(label) {
          this.foundation_.setLeadingIconAriaLabel(label);
        }
        /**
         * Sets the text content of the leading icon.
         * @param {string} content
         */

      }, {
        key: "leadingIconContent",
        set: function set(content) {
          this.foundation_.setLeadingIconContent(content);
        }
        /**
         * Sets the text content of the helper text.
         * @param {string} content
         */

      }, {
        key: "helperTextContent",
        set: function set(content) {
          this.foundation_.setHelperTextContent(content);
        }
        /**
         * Sets the current invalid state of the select.
         * @param {boolean} isValid
         */

      }, {
        key: "valid",
        set: function set(isValid) {
          this.foundation_.setValid(isValid);
        }
        /**
         * Checks if the select is in a valid state.
         * @return {boolean}
         */
        ,
        get: function get() {
          return this.foundation_.isValid();
        }
        /**
         * Sets the control to the required state.
         * @param {boolean} isRequired
         */

      }, {
        key: "required",
        set: function set(isRequired) {
          if (this.nativeControl_) {
            this.nativeControl_.required = isRequired;
          } else {
            if (isRequired) {
              this.selectedText_.setAttribute('aria-required', isRequired.toString());
            } else {
              this.selectedText_.removeAttribute('aria-required');
            }
          }
        }
        /**
         * Returns whether the select is required.
         * @return {boolean}
         */
        ,
        get: function get() {
          if (this.nativeControl_) {
            return this.nativeControl_.required;
          } else {
            return this.selectedText_.getAttribute('aria-required') === 'true';
          }
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCSelect(root);
        }
      }]);

      return MDCSelect;
    }(MDCComponent$f);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to configure the default options for all
     * mdc-select usage within an app.
     * @type {?}
     */
    var MDC_SELECT_DEFAULT_OPTIONS = new core.InjectionToken('MDC_SELECT_DEFAULT_OPTIONS');
    var MdcSelectBase = /** @class */ (function () {
        function MdcSelectBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
            this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this.ngControl = ngControl;
        }
        return MdcSelectBase;
    }());
    /** @type {?} */
    var _MdcSelectMixinBase = mixinErrorState(MdcSelectBase);
    var MdcSelectChange = /** @class */ (function () {
        function MdcSelectChange(source, index, value) {
            this.source = source;
            this.index = index;
            this.value = value;
        }
        return MdcSelectChange;
    }());
    var MdcSelectOption = /** @class */ (function () {
        function MdcSelectOption() {
        }
        MdcSelectOption.decorators = [
            { type: core.Directive, args: [{
                        selector: 'option',
                        exportAs: 'mdcSelectOption',
                    },] },
        ];
        return MdcSelectOption;
    }());
    /** @type {?} */
    var nextUniqueId$6 = 0;
    var MdcSelect = /** @class */ (function (_super) {
        __extends(MdcSelect, _super);
        function MdcSelect(_platform, _changeDetectorRef, elementRef, _defaultErrorStateMatcher, _parentFormField, _ripple, ngControl, _parentForm, _parentFormGroup, _defaults) {
            var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
            _this._platform = _platform;
            _this._changeDetectorRef = _changeDetectorRef;
            _this.elementRef = elementRef;
            _this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
            _this._parentFormField = _parentFormField;
            _this._ripple = _ripple;
            _this.ngControl = ngControl;
            _this._defaults = _defaults;
            /**
             * Emits whenever the component is destroyed.
             */
            _this._destroyed = new rxjs.Subject();
            _this._uniqueId = "mdc-select-" + ++nextUniqueId$6;
            _this.controlType = 'mdc-select';
            _this._enhancedSelectedText = '';
            _this.id = _this._uniqueId;
            _this.name = null;
            _this._placeholder = '';
            _this._disabled = false;
            _this._floatLabel = true;
            _this._outlined = false;
            _this._required = false;
            _this._autosize = false;
            _this._compareWith = (/**
             * @param {?} o1
             * @param {?} o2
             * @return {?}
             */
            function (o1, o2) { return o1 === o2; });
            _this._helperText = null;
            /**
             * Event emitted when the selected value has been changed by the user.
             */
            _this.selectionChange = new core.EventEmitter();
            /**
             * Event that emits whenever the raw value of the select changes. This is here primarily
             * to facilitate the two-way binding for the `value` input.
             */
            _this.valueChange = new core.EventEmitter();
            /**
             * View to model callback called when value changes
             */
            _this._onChange = (/**
             * @return {?}
             */
            function () { });
            /**
             * View to model callback called when select has been touched
             */
            _this._onTouched = (/**
             * @return {?}
             */
            function () { });
            if (_this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                _this.ngControl.valueAccessor = _this;
            }
            if (_this._parentFormField) {
                _parentFormField.elementRef.nativeElement.classList.add('ngx-form-field-select');
            }
            // Force setter to be called in case id was not specified.
            _this.id = _this.id;
            return _this;
        }
        Object.defineProperty(MdcSelect.prototype, "placeholder", {
            /** Placeholder to be shown if no value has been selected. */
            get: /**
             * Placeholder to be shown if no value has been selected.
             * @return {?}
             */
            function () { return this._placeholder; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._placeholder = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabledState(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "floatLabel", {
            get: /**
             * @return {?}
             */
            function () { return this._floatLabel; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._floatLabel) {
                    this._floatLabel = newValue;
                    this.layout();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "outlined", {
            get: /**
             * @return {?}
             */
            function () { return this._outlined; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._outlined) {
                    this._outlined = newValue || (this._defaults && this._defaults.outlined) || false;
                    this.layout();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "required", {
            get: /**
             * @return {?}
             */
            function () { return this._required; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._required) {
                    this._required = newValue;
                    if (this._foundation) {
                        if (!this._required) {
                            this.valid = true;
                            this._changeDetectorRef.markForCheck();
                        }
                        if (this.ngControl) {
                            this._required ? this._getInputElement().setAttribute('required', '') :
                                this._getInputElement().removeAttribute('required');
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "valid", {
            get: /**
             * @return {?}
             */
            function () { return this._valid; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._valid) {
                    this._valid = newValue;
                    if (this._foundation && this._valid !== undefined) {
                        this._foundation.setValid(this._valid);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "autosize", {
            get: /**
             * @return {?}
             */
            function () { return this._autosize; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._autosize) {
                    this._autosize = newValue;
                    this._setWidth();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "compareWith", {
            get: /**
             * @return {?}
             */
            function () { return this._compareWith; },
            set: /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._compareWith = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "value", {
            /** Value of the select control. */
            get: /**
             * Value of the select control.
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this.setSelectionByValue(newValue);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "helperText", {
            get: /**
             * @return {?}
             */
            function () { return this._helperText; },
            set: /**
             * @param {?} helperText
             * @return {?}
             */
            function (helperText) {
                if (this._helperText !== helperText) {
                    this._helperText = helperText;
                    this._initHelperText();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "placeholderText", {
            get: /**
             * @return {?}
             */
            function () {
                return !this._hasFloatingLabel() && this.getValue() ? '' : this.placeholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            return Object.assign(this._isEnhancedVariant() ? this._getEnhancedSelectAdapterMethods() : this._getNativeSelectAdapterMethods(), this._getCommonAdapterMethods(), this._getOutlineAdapterMethods(), this._getLabelAdapterMethods());
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getCommonAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                setRippleCenter: (/**
                 * @param {?} normalizedX
                 * @return {?}
                 */
                function (normalizedX) { return _this._lineRipple && _this._lineRipple.setRippleCenter(normalizedX); }),
                activateBottomLine: (/**
                 * @return {?}
                 */
                function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.activate();
                    }
                }),
                deactivateBottomLine: (/**
                 * @return {?}
                 */
                function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.deactivate();
                    }
                }),
                notifyChange: (/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    return _this.selectionChange.emit(new MdcSelectChange(_this, _this.getSelectedIndex(), value));
                })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getNativeSelectAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                getValue: (/**
                 * @return {?}
                 */
                function () { return _this._platform.isBrowser ? _this._getInputElement().value : ''; }),
                setValue: (/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) { return _this._getInputElement().value = value; }),
                isMenuOpen: (/**
                 * @return {?}
                 */
                function () { return false; }),
                setSelectedIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) { return _this._getInputElement().selectedIndex = index; }),
                setDisabled: (/**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                function (isDisabled) { return _this._getInputElement().disabled = isDisabled; }),
                setValid: (/**
                 * @param {?} isValid
                 * @return {?}
                 */
                function (isValid) {
                    if (_this.ngControl) {
                        return;
                    }
                    isValid ? _this._getHostElement().classList.remove(cssClasses$1$9.INVALID) :
                        _this._getHostElement().classList.add(cssClasses$1$9.INVALID);
                }),
                checkValidity: (/**
                 * @return {?}
                 */
                function () { return _this._getInputElement().checkValidity(); })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getEnhancedSelectAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                getValue: (/**
                 * @return {?}
                 */
                function () { return _this.getValue() || ''; }),
                openMenu: (/**
                 * @return {?}
                 */
                function () {
                    if (_this._menu && !_this._menu.open) {
                        _this._menu.open = true;
                        (/** @type {?} */ (_this._selectedText)).nativeElement.setAttribute('aria-expanded', 'true');
                    }
                }),
                closeMenu: (/**
                 * @return {?}
                 */
                function () {
                    if (_this._menu && _this._menu.open) {
                        _this._menu.open = false;
                    }
                }),
                isMenuOpen: (/**
                 * @return {?}
                 */
                function () { return _this._menu && _this._menu.open; }),
                setDisabled: (/**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                function (isDisabled) {
                    _this._selectedText.nativeElement.setAttribute('aria-disabled', isDisabled.toString());
                }),
                checkValidity: (/**
                 * @return {?}
                 */
                function () { return _this._isValid(); }),
                setValid: (/**
                 * @param {?} isValid
                 * @return {?}
                 */
                function (isValid) {
                    _this._selectedText.nativeElement.setAttribute('aria-invalid', (!isValid).toString());
                    _this._valid = isValid;
                    isValid ? _this._getHostElement().classList.remove(cssClasses$1$9.INVALID) :
                        _this._getHostElement().classList.add(cssClasses$1$9.INVALID);
                })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getOutlineAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                hasOutline: (/**
                 * @return {?}
                 */
                function () { return !!_this._notchedOutline; }),
                notchOutline: (/**
                 * @param {?} labelWidth
                 * @return {?}
                 */
                function (labelWidth) { return (/** @type {?} */ (_this._notchedOutline)).notch(labelWidth); }),
                closeOutline: (/**
                 * @return {?}
                 */
                function () { return (/** @type {?} */ (_this._notchedOutline)).closeNotch(); })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getLabelAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                floatLabel: (/**
                 * @param {?} shouldFloat
                 * @return {?}
                 */
                function (shouldFloat) { return _this._getFloatingLabel().float(shouldFloat); }),
                getLabelWidth: (/**
                 * @return {?}
                 */
                function () { return _this._hasFloatingLabel() ? (/** @type {?} */ (_this._getFloatingLabel())).getWidth() : 0; })
            };
        };
        /** Returns a map of all subcomponents to subfoundations.*/
        /**
         * Returns a map of all subcomponents to subfoundations.
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getFoundationMap = /**
         * Returns a map of all subcomponents to subfoundations.
         * @private
         * @return {?}
         */
        function () {
            return {
                helperText: this._helperText || undefined
            };
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._setDefaultOptions();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.init();
            if (!this._isEnhancedVariant()) {
                this._options.changes.pipe(operators.takeUntil(this._destroyed))
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this._getFloatingLabel().float(!!_this.getValue());
                    if (_this.outlined) {
                        _this.getValue() ?
                            (/** @type {?} */ (_this._notchedOutline)).notch(_this._getFloatingLabel().getWidth()) : (/** @type {?} */ (_this._notchedOutline)).closeNotch();
                    }
                }));
            }
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.init = /**
         * @return {?}
         */
        function () {
            this._foundation = new MDCSelectFoundation(this._createAdapter(), this._getFoundationMap());
            this._changeDetectorRef.detectChanges();
            // initialize after running a detectChanges()
            this._initRipple();
            this._initializeSelection();
            this._setWidth();
            this._enhancedSelectSetup();
            this._foundation.handleChange(false);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSelect.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setSelectionByValue(value, false);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSelect.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSelect.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcSelect.prototype.onChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.setSelectionByValue(((/** @type {?} */ (event.target))).value);
            event.stopPropagation();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._foundation.handleBlur();
                this._onTouched();
            }
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.onFocus = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._foundation.handleFocus();
                this._onTouched();
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSelect.prototype.onInteraction = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (this._selectedText) {
                this._selectedText.nativeElement.focus();
            }
            this._foundation.handleClick(this._getNormalizedXCoordinate(evt));
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSelect.prototype.onKeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleKeydown(evt);
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.getValue = /**
         * @return {?}
         */
        function () {
            return this._value;
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.getSelectedIndex = /**
         * @return {?}
         */
        function () {
            if (this._isEnhancedVariant()) {
                return this._list ? this._list.getSelectedIndex() : -1;
            }
            return ((/** @type {?} */ (this._getInputElement()))).selectedIndex || -1;
        };
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         */
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcSelect.prototype.setSelectionByValue = /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        function (value, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            if (!this._foundation) {
                return;
            }
            /** @type {?} */
            var newValue = value;
            this._setEnhancedSelection(newValue); // if enhanced select, perform selection
            if (this._value === newValue) {
                if (newValue === null) {
                    this._valid = true;
                }
                return;
            }
            this._value = newValue;
            this._foundation.setValue(this._value);
            this.valueChange.emit({ index: this.getSelectedIndex(), value: this._value });
            if (isUserInput) {
                this._onChange(this._value);
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcSelect.prototype.setSelectedIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this._foundation.setSelectedIndex(index);
            if (this._isEnhancedVariant()) {
                this._list.setSelectedIndex(index);
            }
            /** @type {?} */
            var value = this._isEnhancedVariant() ? this._list.getSelectedValue() : this._getInputElement().value;
            this.setSelectionByValue(value);
        };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSelect.prototype.setDisabledState = 
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = toBoolean(disabled);
            if (this._foundation) {
                this._foundation.setDisabled(this._disabled);
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.focus = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._isEnhancedVariant() ? this._selectedText.nativeElement.focus() : this._getInputElement().focus();
            }
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.reset = /**
         * @return {?}
         */
        function () {
            if (this._isEnhancedVariant()) {
                this._enhancedSelectedText = '';
                this._list.reset();
            }
            this._value = null;
            this.valid = true;
            this.layout();
        };
        /** Initialize Select internal state based on the environment state */
        /**
         * Initialize Select internal state based on the environment state
         * @private
         * @return {?}
         */
        MdcSelect.prototype.layout = /**
         * Initialize Select internal state based on the environment state
         * @private
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._destroy();
            }
            this.init();
            this._changeDetectorRef.markForCheck();
            if (this._outlined) {
                this._foundation.layout();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._initializeSelection = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var value = _this.ngControl ? _this.ngControl.value : _this._value;
                if (value) {
                    _this.setSelectionByValue(value, false);
                    _this._foundation.layout();
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._initHelperText = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var helper = this.helperText;
            if (helper) {
                helper.addHelperTextClass(this.controlType);
                helper.init(MDCSelectHelperTextFoundation);
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this.outlined) {
                this._ripple.init({
                    surface: this.elementRef.nativeElement,
                    activator: this._nativeSelect ? this._nativeSelect.nativeElement : this._selectedText.nativeElement
                });
            }
        };
        /** Set the default options. */
        /**
         * Set the default options.
         * @private
         * @return {?}
         */
        MdcSelect.prototype._setDefaultOptions = /**
         * Set the default options.
         * @private
         * @return {?}
         */
        function () {
            if (this._defaults && this._defaults.outlined) {
                this._outlined = this._defaults.outlined;
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._destroy = /**
         * @private
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
            if (this._lineRipple) {
                this._lineRipple.destroy();
            }
            if (this._ripple) {
                this._ripple.destroy();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._isEnhancedVariant = /**
         * @private
         * @return {?}
         */
        function () {
            return !!this._list;
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        MdcSelect.prototype._setEnhancedSelection = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._isEnhancedVariant()) {
                this._list.setSelectedValue(value);
                this._enhancedSelectedText = this._list.getSelectedText();
                this._menu.open = false;
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._enhancedSelectSetup = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._isEnhancedVariant()) {
                this._menu.elementRef.nativeElement.classList.add('mdc-select__menu');
                this._menu.hoistToBody = true;
                this._menu.anchorElement = this._getHostElement();
                this._menu.wrapFocus = false;
                this._list.useSelectedClass = true;
                this._list.singleSelection = true;
                // Subscribe to menu opened event
                this._menu.opened.pipe(operators.takeUntil(this._destroyed))
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var selectedIndex = _this._list.getSelectedIndex();
                    if (selectedIndex > -1) {
                        _this._list.items.toArray()[selectedIndex].focus();
                    }
                }));
                // Subscribe to menu closed event
                this._menu.closed.pipe(operators.takeUntil(this._destroyed))
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this._selectedText.nativeElement.removeAttribute('aria-expanded');
                    if (_this._platform.isBrowser) {
                        if (document.activeElement !== _this._selectedText.nativeElement) {
                            _this._foundation.handleBlur();
                        }
                    }
                }));
                // Subscribe to menu selected event
                this._list.selectionChange.pipe(operators.takeUntil(this._destroyed))
                    .subscribe((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) {
                    _this.setSelectionByValue(evt.option.value, true);
                }));
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._isValid = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                return !this.errorState;
            }
            if (this.required && !this.disabled) {
                return this.getSelectedIndex() !== -1 && (this.getSelectedIndex() !== 0 || this._value);
            }
            return true;
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._hasFloatingLabel = /**
         * @private
         * @return {?}
         */
        function () {
            return (this.placeholder && this.floatLabel) || this._required
                && (this._floatingLabel || this._notchedOutline) ? true : false;
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getFloatingLabel = /**
         * @private
         * @return {?}
         */
        function () {
            return this._floatingLabel || (/** @type {?} */ (this._notchedOutline)).floatingLabel;
        };
        /**
         * Calculates where the line ripple should start based on the x coordinate within the component.
         */
        /**
         * Calculates where the line ripple should start based on the x coordinate within the component.
         * @private
         * @param {?} evt
         * @return {?}
         */
        MdcSelect.prototype._getNormalizedXCoordinate = /**
         * Calculates where the line ripple should start based on the x coordinate within the component.
         * @private
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var targetClientRect = ((/** @type {?} */ (evt.target))).getBoundingClientRect();
            if (evt instanceof MouseEvent) {
                return evt.clientX - targetClientRect.left;
            }
            /** @type {?} */
            var clientX = evt.touches[0] && evt.touches[0].clientX;
            return clientX - targetClientRect.left;
        };
        /**
         * @private
         * @return {?}
         */
        MdcSelect.prototype._setWidth = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.placeholder && this.autosize) {
                /** @type {?} */
                var labelLength = this.placeholder.length;
                this._getHostElement().style.setProperty('width', labelLength + "rem");
            }
            else {
                this._getHostElement().style.removeProperty('width');
            }
        };
        /** Retrieves the select input element. */
        /**
         * Retrieves the select input element.
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getInputElement = /**
         * Retrieves the select input element.
         * @private
         * @return {?}
         */
        function () {
            return this._nativeSelect.nativeElement;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcSelect.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcSelect.decorators = [
            { type: core.Component, args: [{selector: 'mdc-select',
                        exportAs: 'mdcSelect',
                        host: {
                            '[id]': 'id',
                            'class': 'mdc-select',
                            '[class.mdc-select--disabled]': 'disabled',
                            '[class.mdc-select--outlined]': 'outlined',
                            '[class.mdc-select--required]': 'required',
                            '[class.mdc-select--with-leading-icon]': 'leadingIcon',
                            '[class.mdc-select--invalid]': 'errorState'
                        },
                        template: "\n  <ng-content select=\"mdc-icon\"></ng-content>\n  <ng-container *ngIf=\"_list\">\n    <div #selectedText class=\"mdc-select__selected-text\"\n      [tabindex]=\"disabled ? '-1' : '0'\"\n      (blur)=\"onBlur()\"\n      (change)=\"onChange($event)\"\n      (focus)=\"onFocus()\"\n      (keydown)=\"onKeydown($event)\"\n      (mousedown)=\"onInteraction($event)\">{{_enhancedSelectedText}}</div>\n    <ng-content select=\"mdc-menu\"></ng-content>\n  </ng-container>\n  <i class=\"mdc-select__dropdown-icon\"></i>\n  <select #nativeSelect *ngIf=\"!_list\"\n   class=\"mdc-select__native-control\"\n   [attr.aria-describedby]=\"_ariaDescribedby || null\"\n   [required]=\"required\"\n   [value]=\"value\"\n   (mousedown)=\"onInteraction($event)\"\n   (touchstart)=\"onInteraction($event)\"\n   (blur)=\"onBlur()\"\n   (change)=\"onChange($event)\"\n   (focus)=\"onFocus()\">\n    <ng-content></ng-content>\n  </select>\n  <label mdcFloatingLabel *ngIf=\"!outlined\" [for]=\"id\">{{placeholderText}}</label>\n  <mdc-line-ripple *ngIf=\"!outlined\"></mdc-line-ripple>\n  <mdc-notched-outline *ngIf=\"outlined\" [label]=\"placeholderText\" [for]=\"id\"></mdc-notched-outline>\n  ",
                        providers: [
                            MdcRipple,
                            { provide: MdcFormFieldControl, useExisting: MdcSelect }
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcSelect.ctorParameters = function () { return [
            { type: Platform },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: ErrorStateMatcher },
            { type: MdcFormField, decorators: [{ type: core.Optional }] },
            { type: MdcRipple, decorators: [{ type: core.Optional }] },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_SELECT_DEFAULT_OPTIONS,] }] }
        ]; };
        MdcSelect.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            floatLabel: [{ type: core.Input }],
            outlined: [{ type: core.Input }],
            required: [{ type: core.Input }],
            valid: [{ type: core.Input }],
            autosize: [{ type: core.Input }],
            compareWith: [{ type: core.Input }],
            value: [{ type: core.Input }],
            helperText: [{ type: core.Input }],
            errorStateMatcher: [{ type: core.Input }],
            selectionChange: [{ type: core.Output }],
            valueChange: [{ type: core.Output }],
            _floatingLabel: [{ type: core.ViewChild, args: [MdcFloatingLabel,] }],
            _lineRipple: [{ type: core.ViewChild, args: [MdcLineRipple,] }],
            _notchedOutline: [{ type: core.ViewChild, args: [MdcNotchedOutline,] }],
            _nativeSelect: [{ type: core.ViewChild, args: ['nativeSelect',] }],
            _selectedText: [{ type: core.ViewChild, args: ['selectedText',] }],
            _menu: [{ type: core.ContentChild, args: [MdcMenu,] }],
            leadingIcon: [{ type: core.ContentChild, args: [MdcSelectIcon,] }],
            _list: [{ type: core.ContentChild, args: [MdcList,] }],
            _options: [{ type: core.ContentChildren, args: [MdcSelectOption,] }]
        };
        return MdcSelect;
    }(_MdcSelectMixinBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SELECT_DECLARATIONS = [
        MdcSelect,
        MdcSelectIcon,
        MdcSelectOption
    ];
    var MdcSelectModule = /** @class */ (function () {
        function MdcSelectModule() {
        }
        MdcSelectModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            MdcMenuModule,
                            MdcFormFieldModule,
                            MdcFloatingLabelModule,
                            MdcNotchedOutlineModule,
                            MdcLineRippleModule
                        ],
                        exports: [
                            MdcMenuModule,
                            MdcFormFieldModule,
                            SELECT_DECLARATIONS
                        ],
                        declarations: SELECT_DECLARATIONS
                    },] },
        ];
        return MdcSelectModule;
    }());

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$g = {
      ACTIVE: 'mdc-slider--active',
      DISABLED: 'mdc-slider--disabled',
      DISCRETE: 'mdc-slider--discrete',
      FOCUS: 'mdc-slider--focus',
      IN_TRANSIT: 'mdc-slider--in-transit',
      IS_DISCRETE: 'mdc-slider--discrete',
      HAS_TRACK_MARKER: 'mdc-slider--display-markers'
    };
    /** @enum {string} */

    var strings$e = {
      TRACK_SELECTOR: '.mdc-slider__track',
      TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
      LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
      THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
      PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
      ARIA_VALUEMIN: 'aria-valuemin',
      ARIA_VALUEMAX: 'aria-valuemax',
      ARIA_VALUENOW: 'aria-valuenow',
      ARIA_DISABLED: 'aria-disabled',
      STEP_DATA_ATTR: 'data-step',
      CHANGE_EVENT: 'MDCSlider:change',
      INPUT_EVENT: 'MDCSlider:input'
    };
    /** @enum {number} */

    var numbers$a = {
      PAGE_FACTOR: 4
    };

    function _classCallCheck$g(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$g(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$g(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$g(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$g(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$g(subClass, superClass);
    }

    function _getPrototypeOf$g(o) {
      _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$g(o);
    }

    function _setPrototypeOf$g(o, p) {
      _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$g(o, p);
    }

    function _assertThisInitialized$g(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$g(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$g(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$g =
    /*#__PURE__*/
    function () {
      _createClass$g(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$g(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$g(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$g =
    /*#__PURE__*/
    function () {
      _createClass$g(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$g());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$g(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$g(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint-disable no-unused-vars */

    /**
     * Adapter for MDC Slider.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Slider into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCSliderAdapter =
    /*#__PURE__*/
    function () {
      function MDCSliderAdapter() {
        _classCallCheck$g(this, MDCSliderAdapter);
      }

      _createClass$g(MDCSliderAdapter, [{
        key: "hasClass",

        /**
         * Returns true if className exists for the slider Element
         * @param {string} className
         * @return {boolean}
         */
        value: function hasClass(className) {}
        /**
         * Adds a class to the slider Element
         * @param {string} className
         */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /**
         * Removes a class from the slider Element
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns a string if attribute name exists on the slider Element,
         * otherwise returns null
         * @param {string} name
         * @return {?string}
         */

      }, {
        key: "getAttribute",
        value: function getAttribute(name) {}
        /**
         * Sets attribute name on slider Element to value
         * @param {string} name
         * @param {string} value
         */

      }, {
        key: "setAttribute",
        value: function setAttribute(name, value) {}
        /**
         * Removes attribute name from slider Element
         * @param {string} name
         */

      }, {
        key: "removeAttribute",
        value: function removeAttribute(name) {}
        /**
         * Returns the bounding client rect for the slider Element
         * @return {?ClientRect}
         */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /**
         * Returns the tab index of the slider Element
         * @return {number}
         */

      }, {
        key: "getTabIndex",
        value: function getTabIndex() {}
        /**
         * Registers an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(type, handler) {}
        /**
         * Registers an event handler on the thumb container element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerThumbContainerInteractionHandler",
        value: function registerThumbContainerInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the thumb container element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterThumbContainerInteractionHandler",
        value: function deregisterThumbContainerInteractionHandler(type, handler) {}
        /**
         * Registers an event handler on the body for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerBodyInteractionHandler",
        value: function registerBodyInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the body for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterBodyInteractionHandler",
        value: function deregisterBodyInteractionHandler(type, handler) {}
        /**
         * Registers an event handler for the window resize event
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * Deregisters an event handler for the window resize event
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * Emits a custom event MDCSlider:input from the root
         */

      }, {
        key: "notifyInput",
        value: function notifyInput() {}
        /**
         * Emits a custom event MDCSlider:change from the root
         */

      }, {
        key: "notifyChange",
        value: function notifyChange() {}
        /**
         * Sets a style property of the thumb container element to the passed value
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setThumbContainerStyleProperty",
        value: function setThumbContainerStyleProperty(propertyName, value) {}
        /**
         * Sets a style property of the track element to the passed value
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setTrackStyleProperty",
        value: function setTrackStyleProperty(propertyName, value) {}
        /**
         * Sets the inner text of the pin marker to the passed value
         * @param {number} value
         */

      }, {
        key: "setMarkerValue",
        value: function setMarkerValue(value) {}
        /**
         * Appends the passed number of track markers to the track mark container element
         * @param {number} numMarkers
         */

      }, {
        key: "appendTrackMarkers",
        value: function appendTrackMarkers(numMarkers) {}
        /**
         * Removes all track markers fromt he track mark container element
         */

      }, {
        key: "removeTrackMarkers",
        value: function removeTrackMarkers() {}
        /**
         * Sets a style property of the last track marker to the passed value
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setLastTrackMarkersStyleProperty",
        value: function setLastTrackMarkersStyleProperty(propertyName, value) {}
        /**
         * Returns true if the root element is RTL, otherwise false
         * @return {boolean}
         */

      }, {
        key: "isRTL",
        value: function isRTL() {}
      }]);

      return MDCSliderAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /** @const {Object<string, !VendorPropertyMapType>} */

    var eventTypeMap$1 = {
      'animationstart': {
        noPrefix: 'animationstart',
        webkitPrefix: 'webkitAnimationStart',
        styleProperty: 'animation'
      },
      'animationend': {
        noPrefix: 'animationend',
        webkitPrefix: 'webkitAnimationEnd',
        styleProperty: 'animation'
      },
      'animationiteration': {
        noPrefix: 'animationiteration',
        webkitPrefix: 'webkitAnimationIteration',
        styleProperty: 'animation'
      },
      'transitionend': {
        noPrefix: 'transitionend',
        webkitPrefix: 'webkitTransitionEnd',
        styleProperty: 'transition'
      }
    };
    /** @const {Object<string, !VendorPropertyMapType>} */

    var cssPropertyMap$1 = {
      'animation': {
        noPrefix: 'animation',
        webkitPrefix: '-webkit-animation'
      },
      'transform': {
        noPrefix: 'transform',
        webkitPrefix: '-webkit-transform'
      },
      'transition': {
        noPrefix: 'transition',
        webkitPrefix: '-webkit-transition'
      }
    };
    /**
     * @param {!Object} windowObj
     * @return {boolean}
     */

    function hasProperShape$1(windowObj) {
      return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
    }
    /**
     * @param {string} eventType
     * @return {boolean}
     */


    function eventFoundInMaps$1(eventType) {
      return eventType in eventTypeMap$1 || eventType in cssPropertyMap$1;
    }
    /**
     * @param {string} eventType
     * @param {!Object<string, !VendorPropertyMapType>} map
     * @param {!Element} el
     * @return {string}
     */


    function getJavaScriptEventName$1(eventType, map, el) {
      return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }
    /**
     * Helper function to determine browser prefix for CSS3 animation events
     * and property names.
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getAnimationName$1(windowObj, eventType) {
      if (!hasProperShape$1(windowObj) || !eventFoundInMaps$1(eventType)) {
        return eventType;
      }

      var map =
      /** @type {!Object<string, !VendorPropertyMapType>} */
      eventType in eventTypeMap$1 ? eventTypeMap$1 : cssPropertyMap$1;
      var el = windowObj['document']['createElement']('div');
      var eventName = '';

      if (map === eventTypeMap$1) {
        eventName = getJavaScriptEventName$1(eventType, map, el);
      } else {
        eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
      }

      return eventName;
    } // Public functions to access getAnimationName() for JavaScript events or CSS
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */

    function getCorrectEventName$1(windowObj, eventType) {
      return getAnimationName$1(windowObj, eventType);
    }
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getCorrectPropertyName(windowObj, eventType) {
      return getAnimationName$1(windowObj, eventType);
    }

    /** @enum {string} */

    var KEY_IDS = {
      ARROW_LEFT: 'ArrowLeft',
      ARROW_RIGHT: 'ArrowRight',
      ARROW_UP: 'ArrowUp',
      ARROW_DOWN: 'ArrowDown',
      HOME: 'Home',
      END: 'End',
      PAGE_UP: 'PageUp',
      PAGE_DOWN: 'PageDown'
    };
    /** @enum {string} */

    var MOVE_EVENT_MAP = {
      'mousedown': 'mousemove',
      'touchstart': 'touchmove',
      'pointerdown': 'pointermove'
    };
    var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
    var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];
    /**
     * @extends {MDCFoundation<!MDCSliderAdapter>}
     */

    var MDCSliderFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$g(MDCSliderFoundation, _MDCFoundation);

      _createClass$g(MDCSliderFoundation, null, [{
        key: "cssClasses",

        /** @return enum {cssClasses} */
        get: function get() {
          return cssClasses$g;
        }
        /** @return enum {strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$e;
        }
        /** @return enum {numbers} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$a;
        }
        /** @return {!MDCSliderAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCSliderAdapter} */
            {
              hasClass: function hasClass() {
                return (
                  /* className: string */

                  /* boolean */
                  false
                );
              },
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              getAttribute: function getAttribute() {
                return (
                  /* name: string */

                  /* string|null */
                  null
                );
              },
              setAttribute: function setAttribute()
              /* name: string, value: string */
              {},
              removeAttribute: function removeAttribute()
              /* name: string */
              {},
              computeBoundingRect: function computeBoundingRect() {
                return (
                  /* ClientRect */
                  {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    width: 0,
                    height: 0
                  }
                );
              },
              getTabIndex: function getTabIndex() {
                return (
                  /* number */
                  0
                );
              },
              registerInteractionHandler: function registerInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterInteractionHandler: function deregisterInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              registerBodyInteractionHandler: function registerBodyInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              registerResizeHandler: function registerResizeHandler()
              /* handler: EventListener */
              {},
              deregisterResizeHandler: function deregisterResizeHandler()
              /* handler: EventListener */
              {},
              notifyInput: function notifyInput() {},
              notifyChange: function notifyChange() {},
              setThumbContainerStyleProperty: function setThumbContainerStyleProperty()
              /* propertyName: string, value: string */
              {},
              setTrackStyleProperty: function setTrackStyleProperty()
              /* propertyName: string, value: string */
              {},
              setMarkerValue: function setMarkerValue()
              /* value: number */
              {},
              appendTrackMarkers: function appendTrackMarkers()
              /* numMarkers: number */
              {},
              removeTrackMarkers: function removeTrackMarkers() {},
              setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty()
              /* propertyName: string, value: string */
              {},
              isRTL: function isRTL() {
                return (
                  /* boolean */
                  false
                );
              }
            }
          );
        }
        /**
         * Creates a new instance of MDCSliderFoundation
         * @param {?MDCSliderAdapter} adapter
         */

      }]);

      function MDCSliderFoundation(adapter) {
        var _this;

        _classCallCheck$g(this, MDCSliderFoundation);

        _this = _possibleConstructorReturn$g(this, _getPrototypeOf$g(MDCSliderFoundation).call(this, Object.assign(MDCSliderFoundation.defaultAdapter, adapter)));
        /** @private {?ClientRect} */

        _this.rect_ = null; // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
        // because those could be valid tabindices set by the client code.

        _this.savedTabIndex_ = NaN;
        _this.active_ = false;
        _this.inTransit_ = false;
        _this.isDiscrete_ = false;
        _this.hasTrackMarker_ = false;
        _this.handlingThumbTargetEvt_ = false;
        _this.min_ = 0;
        _this.max_ = 100;
        _this.step_ = 0;
        _this.value_ = 0;
        _this.disabled_ = false;
        _this.preventFocusState_ = false;
        _this.updateUIFrame_ = 0;

        _this.thumbContainerPointerHandler_ = function () {
          _this.handlingThumbTargetEvt_ = true;
        };

        _this.interactionStartHandler_ = function (evt) {
          return _this.handleDown_(evt);
        };

        _this.keydownHandler_ = function (evt) {
          return _this.handleKeydown_(evt);
        };

        _this.focusHandler_ = function () {
          return _this.handleFocus_();
        };

        _this.blurHandler_ = function () {
          return _this.handleBlur_();
        };

        _this.resizeHandler_ = function () {
          return _this.layout();
        };

        return _this;
      }

      _createClass$g(MDCSliderFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          this.isDiscrete_ = this.adapter_.hasClass(cssClasses$g.IS_DISCRETE);
          this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$g.HAS_TRACK_MARKER);
          DOWN_EVENTS.forEach(function (evtName) {
            return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
          });
          this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
          DOWN_EVENTS.forEach(function (evtName) {
            _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
          });
          this.adapter_.registerResizeHandler(this.resizeHandler_);
          this.layout(); // At last step, provide a reasonable default value to discrete slider

          if (this.isDiscrete_ && this.getStep() == 0) {
            this.step_ = 1;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          DOWN_EVENTS.forEach(function (evtName) {
            _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
          });
          this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
          DOWN_EVENTS.forEach(function (evtName) {
            _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
          });
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }, {
        key: "setupTrackMarker",
        value: function setupTrackMarker() {
          if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
            var min = this.getMin();
            var max = this.getMax();
            var step = this.getStep();
            var numMarkers = (max - min) / step; // In case distance between max & min is indivisible to step,
            // we place the secondary to last marker proportionally at where thumb
            // could reach and place the last marker at max value

            var indivisible = Math.ceil(numMarkers) !== numMarkers;

            if (indivisible) {
              numMarkers = Math.ceil(numMarkers);
            }

            this.adapter_.removeTrackMarkers();
            this.adapter_.appendTrackMarkers(numMarkers);

            if (indivisible) {
              var lastStepRatio = (max - numMarkers * step) / step + 1;
              var flex = getCorrectPropertyName(window, 'flex');
              this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
            }
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          this.rect_ = this.adapter_.computeBoundingRect();
          this.updateUIForCurrentValue_();
        }
        /** @return {number} */

      }, {
        key: "getValue",
        value: function getValue() {
          return this.value_;
        }
        /** @param {number} value */

      }, {
        key: "setValue",
        value: function setValue(value) {
          this.setValue_(value, false);
        }
        /** @return {number} */

      }, {
        key: "getMax",
        value: function getMax() {
          return this.max_;
        }
        /** @param {number} max */

      }, {
        key: "setMax",
        value: function setMax(max) {
          if (max < this.min_) {
            throw new Error('Cannot set max to be less than the slider\'s minimum value');
          }

          this.max_ = max;
          this.setValue_(this.value_, false, true);
          this.adapter_.setAttribute(strings$e.ARIA_VALUEMAX, String(this.max_));
          this.setupTrackMarker();
        }
        /** @return {number} */

      }, {
        key: "getMin",
        value: function getMin() {
          return this.min_;
        }
        /** @param {number} min */

      }, {
        key: "setMin",
        value: function setMin(min) {
          if (min > this.max_) {
            throw new Error('Cannot set min to be greater than the slider\'s maximum value');
          }

          this.min_ = min;
          this.setValue_(this.value_, false, true);
          this.adapter_.setAttribute(strings$e.ARIA_VALUEMIN, String(this.min_));
          this.setupTrackMarker();
        }
        /** @return {number} */

      }, {
        key: "getStep",
        value: function getStep() {
          return this.step_;
        }
        /** @param {number} step */

      }, {
        key: "setStep",
        value: function setStep(step) {
          if (step < 0) {
            throw new Error('Step cannot be set to a negative number');
          }

          if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
            step = 1;
          }

          this.step_ = step;
          this.setValue_(this.value_, false, true);
          this.setupTrackMarker();
        }
        /** @return {boolean} */

      }, {
        key: "isDisabled",
        value: function isDisabled() {
          return this.disabled_;
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          this.disabled_ = disabled;
          this.toggleClass_(cssClasses$g.DISABLED, this.disabled_);

          if (this.disabled_) {
            this.savedTabIndex_ = this.adapter_.getTabIndex();
            this.adapter_.setAttribute(strings$e.ARIA_DISABLED, 'true');
            this.adapter_.removeAttribute('tabindex');
          } else {
            this.adapter_.removeAttribute(strings$e.ARIA_DISABLED);

            if (!isNaN(this.savedTabIndex_)) {
              this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
            }
          }
        }
        /**
         * Called when the user starts interacting with the slider
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "handleDown_",
        value: function handleDown_(evt) {
          var _this4 = this;

          if (this.disabled_) {
            return;
          }

          this.preventFocusState_ = true;
          this.setInTransit_(!this.handlingThumbTargetEvt_);
          this.handlingThumbTargetEvt_ = false;
          this.setActive_(true);

          var moveHandler = function moveHandler(evt) {
            _this4.handleMove_(evt);
          }; // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
          // do not always fire these consistently in pairs.
          // (See https://github.com/material-components/material-components-web/issues/1192)


          var upHandler = function upHandler() {
            _this4.handleUp_();

            _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);

            UP_EVENTS.forEach(function (evtName) {
              return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
            });
          };

          this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
          });
          this.setValueFromEvt_(evt);
        }
        /**
         * Called when the user moves the slider
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "handleMove_",
        value: function handleMove_(evt) {
          evt.preventDefault();
          this.setValueFromEvt_(evt);
        }
        /**
         * Called when the user's interaction with the slider ends
         * @private
         */

      }, {
        key: "handleUp_",
        value: function handleUp_() {
          this.setActive_(false);
          this.adapter_.notifyChange();
        }
        /**
         * Returns the pageX of the event
         * @param {!Event} evt
         * @return {number}
         * @private
         */

      }, {
        key: "getPageX_",
        value: function getPageX_(evt) {
          if (evt.targetTouches && evt.targetTouches.length > 0) {
            return evt.targetTouches[0].pageX;
          }

          return evt.pageX;
        }
        /**
         * Sets the slider value from an event
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "setValueFromEvt_",
        value: function setValueFromEvt_(evt) {
          var pageX = this.getPageX_(evt);
          var value = this.computeValueFromPageX_(pageX);
          this.setValue_(value, true);
        }
        /**
         * Computes the new value from the pageX position
         * @param {number} pageX
         * @return {number}
         */

      }, {
        key: "computeValueFromPageX_",
        value: function computeValueFromPageX_(pageX) {
          var max = this.max_,
              min = this.min_;
          var xPos = pageX - this.rect_.left;
          var pctComplete = xPos / this.rect_.width;

          if (this.adapter_.isRTL()) {
            pctComplete = 1 - pctComplete;
          } // Fit the percentage complete between the range [min,max]
          // by remapping from [0, 1] to [min, min+(max-min)].


          return min + pctComplete * (max - min);
        }
        /**
         * Handles keydown events
         * @param {!Event} evt
         */

      }, {
        key: "handleKeydown_",
        value: function handleKeydown_(evt) {
          var keyId = this.getKeyId_(evt);
          var value = this.getValueForKeyId_(keyId);

          if (isNaN(value)) {
            return;
          } // Prevent page from scrolling due to key presses that would normally scroll the page


          evt.preventDefault();
          this.adapter_.addClass(cssClasses$g.FOCUS);
          this.setValue_(value, true);
          this.adapter_.notifyChange();
        }
        /**
         * Returns the computed name of the event
         * @param {!Event} kbdEvt
         * @return {string}
         */

      }, {
        key: "getKeyId_",
        value: function getKeyId_(kbdEvt) {
          if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
            return KEY_IDS.ARROW_LEFT;
          }

          if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
            return KEY_IDS.ARROW_RIGHT;
          }

          if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
            return KEY_IDS.ARROW_UP;
          }

          if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
            return KEY_IDS.ARROW_DOWN;
          }

          if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
            return KEY_IDS.HOME;
          }

          if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
            return KEY_IDS.END;
          }

          if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
            return KEY_IDS.PAGE_UP;
          }

          if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
            return KEY_IDS.PAGE_DOWN;
          }

          return '';
        }
        /**
         * Computes the value given a keyboard key ID
         * @param {string} keyId
         * @return {number}
         */

      }, {
        key: "getValueForKeyId_",
        value: function getValueForKeyId_(keyId) {
          var max = this.max_,
              min = this.min_,
              step = this.step_;
          var delta = step || (max - min) / 100;
          var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);

          if (valueNeedsToBeFlipped) {
            delta = -delta;
          }

          switch (keyId) {
            case KEY_IDS.ARROW_LEFT:
            case KEY_IDS.ARROW_DOWN:
              return this.value_ - delta;

            case KEY_IDS.ARROW_RIGHT:
            case KEY_IDS.ARROW_UP:
              return this.value_ + delta;

            case KEY_IDS.HOME:
              return this.min_;

            case KEY_IDS.END:
              return this.max_;

            case KEY_IDS.PAGE_UP:
              return this.value_ + delta * numbers$a.PAGE_FACTOR;

            case KEY_IDS.PAGE_DOWN:
              return this.value_ - delta * numbers$a.PAGE_FACTOR;

            default:
              return NaN;
          }
        }
      }, {
        key: "handleFocus_",
        value: function handleFocus_() {
          if (this.preventFocusState_) {
            return;
          }

          this.adapter_.addClass(cssClasses$g.FOCUS);
        }
      }, {
        key: "handleBlur_",
        value: function handleBlur_() {
          this.preventFocusState_ = false;
          this.adapter_.removeClass(cssClasses$g.FOCUS);
        }
        /**
         * Sets the value of the slider
         * @param {number} value
         * @param {boolean} shouldFireInput
         * @param {boolean=} force
         */

      }, {
        key: "setValue_",
        value: function setValue_(value, shouldFireInput) {
          var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (value === this.value_ && !force) {
            return;
          }

          var min = this.min_,
              max = this.max_;
          var valueSetToBoundary = value === min || value === max;

          if (this.step_ && !valueSetToBoundary) {
            value = this.quantize_(value);
          }

          if (value < min) {
            value = min;
          } else if (value > max) {
            value = max;
          }

          this.value_ = value;
          this.adapter_.setAttribute(strings$e.ARIA_VALUENOW, String(this.value_));
          this.updateUIForCurrentValue_();

          if (shouldFireInput) {
            this.adapter_.notifyInput();

            if (this.isDiscrete_) {
              this.adapter_.setMarkerValue(value);
            }
          }
        }
        /**
         * Calculates the quantized value
         * @param {number} value
         * @return {number}
         */

      }, {
        key: "quantize_",
        value: function quantize_(value) {
          var numSteps = Math.round(value / this.step_);
          var quantizedVal = numSteps * this.step_;
          return quantizedVal;
        }
      }, {
        key: "updateUIForCurrentValue_",
        value: function updateUIForCurrentValue_() {
          var _this5 = this;

          var max = this.max_,
              min = this.min_,
              value = this.value_;
          var pctComplete = (value - min) / (max - min);
          var translatePx = pctComplete * this.rect_.width;

          if (this.adapter_.isRTL()) {
            translatePx = this.rect_.width - translatePx;
          }

          var transformProp = getCorrectPropertyName(window, 'transform');
          var transitionendEvtName = getCorrectEventName$1(window, 'transitionend');

          if (this.inTransit_) {
            var onTransitionEnd = function onTransitionEnd() {
              _this5.setInTransit_(false);

              _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
            };

            this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          }

          this.updateUIFrame_ = requestAnimationFrame(function () {
            // NOTE(traviskaufman): It would be nice to use calc() here,
            // but IE cannot handle calcs in transforms correctly.
            // See: https://goo.gl/NC2itk
            // Also note that the -50% offset is used to center the slider thumb.
            _this5.adapter_.setThumbContainerStyleProperty(transformProp, "translateX(".concat(translatePx, "px) translateX(-50%)"));

            _this5.adapter_.setTrackStyleProperty(transformProp, "scaleX(".concat(pctComplete, ")"));
          });
        }
        /**
         * Toggles the active state of the slider
         * @param {boolean} active
         */

      }, {
        key: "setActive_",
        value: function setActive_(active) {
          this.active_ = active;
          this.toggleClass_(cssClasses$g.ACTIVE, this.active_);
        }
        /**
         * Toggles the inTransit state of the slider
         * @param {boolean} inTransit
         */

      }, {
        key: "setInTransit_",
        value: function setInTransit_(inTransit) {
          this.inTransit_ = inTransit;
          this.toggleClass_(cssClasses$g.IN_TRANSIT, this.inTransit_);
        }
        /**
         * Conditionally adds or removes a class based on shouldBePresent
         * @param {string} className
         * @param {boolean} shouldBePresent
         */

      }, {
        key: "toggleClass_",
        value: function toggleClass_(className, shouldBePresent) {
          if (shouldBePresent) {
            this.adapter_.addClass(className);
          } else {
            this.adapter_.removeClass(className);
          }
        }
      }]);

      return MDCSliderFoundation;
    }(MDCFoundation$g);

    /**
     * @extends MDCComponent<!MDCSliderFoundation>
     */

    var MDCSlider =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$g(MDCSlider, _MDCComponent);

      _createClass$g(MDCSlider, null, [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCSlider(root);
        }
      }]);

      function MDCSlider() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$g(this, MDCSlider);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$g(this, (_getPrototypeOf2 = _getPrototypeOf$g(MDCSlider)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {?Element} */

        _this.thumbContainer_;
        /** @type {?Element} */

        _this.track_;
        /** @type {?Element} */

        _this.pinValueMarker_;
        /** @type {?Element} */

        _this.trackMarkerContainer_;
        return _this;
      }
      /** @return {number} */


      _createClass$g(MDCSlider, [{
        key: "initialize",
        value: function initialize() {
          this.thumbContainer_ = this.root_.querySelector(strings$e.THUMB_CONTAINER_SELECTOR);
          this.track_ = this.root_.querySelector(strings$e.TRACK_SELECTOR);
          this.pinValueMarker_ = this.root_.querySelector(strings$e.PIN_VALUE_MARKER_SELECTOR);
          this.trackMarkerContainer_ = this.root_.querySelector(strings$e.TRACK_MARKER_CONTAINER_SELECTOR);
        }
        /**
         * @return {!MDCSliderFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCSliderFoundation(
          /** @type {!MDCSliderAdapter} */
          {
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            getAttribute: function getAttribute(name) {
              return _this2.root_.getAttribute(name);
            },
            setAttribute: function setAttribute(name, value) {
              return _this2.root_.setAttribute(name, value);
            },
            removeAttribute: function removeAttribute(name) {
              return _this2.root_.removeAttribute(name);
            },
            computeBoundingRect: function computeBoundingRect() {
              return _this2.root_.getBoundingClientRect();
            },
            getTabIndex: function getTabIndex() {
              return _this2.root_.tabIndex;
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              _this2.root_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              _this2.root_.removeEventListener(type, handler);
            },
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
              _this2.thumbContainer_.addEventListener(type, handler);
            },
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
              _this2.thumbContainer_.removeEventListener(type, handler);
            },
            registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
              document.body.addEventListener(type, handler);
            },
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
              document.body.removeEventListener(type, handler);
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              window.removeEventListener('resize', handler);
            },
            notifyInput: function notifyInput() {
              _this2.emit(strings$e.INPUT_EVENT, _this2);
            },
            notifyChange: function notifyChange() {
              _this2.emit(strings$e.CHANGE_EVENT, _this2);
            },
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
              _this2.thumbContainer_.style.setProperty(propertyName, value);
            },
            setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
              _this2.track_.style.setProperty(propertyName, value);
            },
            setMarkerValue: function setMarkerValue(value) {
              _this2.pinValueMarker_.innerText = value;
            },
            appendTrackMarkers: function appendTrackMarkers(numMarkers) {
              var frag = document.createDocumentFragment();

              for (var i = 0; i < numMarkers; i++) {
                var marker = document.createElement('div');
                marker.classList.add('mdc-slider__track-marker');
                frag.appendChild(marker);
              }

              _this2.trackMarkerContainer_.appendChild(frag);
            },
            removeTrackMarkers: function removeTrackMarkers() {
              while (_this2.trackMarkerContainer_.firstChild) {
                _this2.trackMarkerContainer_.removeChild(_this2.trackMarkerContainer_.firstChild);
              }
            },
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
              // We remove and append new nodes, thus, the last track marker must be dynamically found.
              var lastTrackMarker = _this2.root_.querySelector(strings$e.LAST_TRACK_MARKER_SELECTOR);

              lastTrackMarker.style.setProperty(propertyName, value);
            },
            isRTL: function isRTL() {
              return getComputedStyle(_this2.root_).direction === 'rtl';
            }
          });
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var origValueNow = parseFloat(this.root_.getAttribute(strings$e.ARIA_VALUENOW));
          var min = parseFloat(this.root_.getAttribute(strings$e.ARIA_VALUEMIN)) || this.min;
          var max = parseFloat(this.root_.getAttribute(strings$e.ARIA_VALUEMAX)) || this.max; // min and max need to be set in the right order to avoid throwing an error
          // when the new min is greater than the default max.

          if (min >= this.max) {
            this.max = max;
            this.min = min;
          } else {
            this.min = min;
            this.max = max;
          }

          this.step = parseFloat(this.root_.getAttribute(strings$e.STEP_DATA_ATTR)) || this.step;
          this.value = origValueNow || this.value;
          this.disabled = this.root_.hasAttribute(strings$e.ARIA_DISABLED) && this.root_.getAttribute(strings$e.ARIA_DISABLED) !== 'false';
          this.foundation_.setupTrackMarker();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /** @param {number=} amount */

      }, {
        key: "stepUp",
        value: function stepUp() {
          var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.step || 1;
          this.value += amount;
        }
        /** @param {number=} amount */

      }, {
        key: "stepDown",
        value: function stepDown() {
          var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.step || 1;
          this.value -= amount;
        }
      }, {
        key: "value",
        get: function get() {
          return this.foundation_.getValue();
        }
        /** @param {number} value */
        ,
        set: function set(value) {
          this.foundation_.setValue(value);
        }
        /** @return {number} */

      }, {
        key: "min",
        get: function get() {
          return this.foundation_.getMin();
        }
        /** @param {number} min */
        ,
        set: function set(min) {
          this.foundation_.setMin(min);
        }
        /** @return {number} */

      }, {
        key: "max",
        get: function get() {
          return this.foundation_.getMax();
        }
        /** @param {number} max */
        ,
        set: function set(max) {
          this.foundation_.setMax(max);
        }
        /** @return {number} */

      }, {
        key: "step",
        get: function get() {
          return this.foundation_.getStep();
        }
        /** @param {number} step */
        ,
        set: function set(step) {
          this.foundation_.setStep(step);
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get() {
          return this.foundation_.isDisabled();
        }
        /** @param {boolean} disabled */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
      }]);

      return MDCSlider;
    }(MDCComponent$g);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MDC_SLIDER_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return MdcSlider; })),
        multi: true
    };
    var MdcSliderChange = /** @class */ (function () {
        function MdcSliderChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return MdcSliderChange;
    }());
    var MdcSlider = /** @class */ (function () {
        function MdcSlider(_platform, _changeDetectorRef, elementRef) {
            this._platform = _platform;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._discrete = false;
            this._markers = false;
            this._min = 0;
            this._max = 100;
            this._step = 0;
            this._value = 0;
            this._disabled = false;
            this.change = new core.EventEmitter();
            this.input = new core.EventEmitter();
            /**
             * View to model callback called when value changes
             */
            this._onChanged = (/**
             * @return {?}
             */
            function () { });
            /**
             * onTouch function registered via registerOnTouch (ControlValueAccessor).
             */
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
        }
        Object.defineProperty(MdcSlider.prototype, "discrete", {
            get: /**
             * @return {?}
             */
            function () { return this._discrete; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._discrete = toBoolean(value);
                if (this._foundation) {
                    if (this._discrete && this.markers) {
                        this._foundation.setupTrackMarker();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "markers", {
            get: /**
             * @return {?}
             */
            function () { return this._markers; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._markers = toBoolean(value);
                if (this._foundation) {
                    if (this._markers && this.discrete) {
                        this._foundation.setupTrackMarker();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "min", {
            get: /**
             * @return {?}
             */
            function () { return this._min; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var min = toNumber(value, this._min);
                if (min > this._max) {
                    return;
                }
                if (min !== this._min) {
                    this._min = min;
                    if (this._foundation) {
                        this._foundation.setMin(this._min);
                    }
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "max", {
            get: /**
             * @return {?}
             */
            function () { return this._max; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var max = toNumber(value, this._max);
                if (max < this._min) {
                    return;
                }
                if (max !== this._max) {
                    this._max = max;
                    if (this._foundation) {
                        this._foundation.setMax(this._max);
                    }
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "step", {
            get: /**
             * @return {?}
             */
            function () { return this._step; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var step = toNumber(value, this._step);
                if (step !== this._step) {
                    this._step = step;
                    if (this._foundation) {
                        this._foundation.setStep(this._step);
                    }
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this.setValue(newValue, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabledState(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcSlider.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                getAttribute: (/**
                 * @param {?} name
                 * @return {?}
                 */
                function (name) { return _this._getHostElement().getAttribute(name); }),
                setAttribute: (/**
                 * @param {?} name
                 * @param {?} value
                 * @return {?}
                 */
                function (name, value) { return _this._getHostElement().setAttribute(name, value); }),
                removeAttribute: (/**
                 * @param {?} name
                 * @return {?}
                 */
                function (name) { return _this._getHostElement().removeAttribute(name); }),
                computeBoundingRect: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().getBoundingClientRect(); }),
                getTabIndex: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().tabIndex; }),
                registerInteractionHandler: (/**
                 * @param {?} type
                 * @param {?} handler
                 * @return {?}
                 */
                function (type, handler) {
                    return _this._getHostElement().addEventListener(type, handler);
                }),
                deregisterInteractionHandler: (/**
                 * @param {?} type
                 * @param {?} handler
                 * @return {?}
                 */
                function (type, handler) {
                    return _this._getHostElement().removeEventListener(type, handler);
                }),
                registerThumbContainerInteractionHandler: (/**
                 * @param {?} type
                 * @param {?} handler
                 * @return {?}
                 */
                function (type, handler) {
                    return _this.thumbContainer.nativeElement.addEventListener(type, handler);
                }),
                deregisterThumbContainerInteractionHandler: (/**
                 * @param {?} type
                 * @param {?} handler
                 * @return {?}
                 */
                function (type, handler) {
                    return _this.thumbContainer.nativeElement.removeEventListener(type, handler);
                }),
                registerBodyInteractionHandler: (/**
                 * @param {?} type
                 * @param {?} handler
                 * @return {?}
                 */
                function (type, handler) {
                    return document.body.addEventListener(type, handler);
                }),
                deregisterBodyInteractionHandler: (/**
                 * @param {?} type
                 * @param {?} handler
                 * @return {?}
                 */
                function (type, handler) {
                    return document.body.removeEventListener(type, handler);
                }),
                registerResizeHandler: (/**
                 * @param {?} handler
                 * @return {?}
                 */
                function (handler) { return window.addEventListener('resize', handler); }),
                deregisterResizeHandler: (/**
                 * @param {?} handler
                 * @return {?}
                 */
                function (handler) { return window.removeEventListener('resize', handler); }),
                notifyInput: (/**
                 * @return {?}
                 */
                function () { return _this._onInput(); }),
                notifyChange: (/**
                 * @return {?}
                 */
                function () { return _this._onChange(); }),
                setThumbContainerStyleProperty: (/**
                 * @param {?} propertyName
                 * @param {?} value
                 * @return {?}
                 */
                function (propertyName, value) {
                    return _this.thumbContainer.nativeElement.style.setProperty(propertyName, value);
                }),
                setTrackStyleProperty: (/**
                 * @param {?} propertyName
                 * @param {?} value
                 * @return {?}
                 */
                function (propertyName, value) {
                    return _this.track.nativeElement.style.setProperty(propertyName, value);
                }),
                setMarkerValue: (/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    return (/** @type {?} */ (_this.pinValueMarker)).nativeElement.innerText = value !== null ? value.toString() : null;
                }),
                appendTrackMarkers: (/**
                 * @param {?} numMarkers
                 * @return {?}
                 */
                function (numMarkers) {
                    /** @type {?} */
                    var docFrag = document.createDocumentFragment();
                    for (var i = 0; i < numMarkers; i++) {
                        /** @type {?} */
                        var marker = document.createElement('div');
                        marker.classList.add('mdc-slider__track-marker');
                        docFrag.appendChild(marker);
                    }
                    (/** @type {?} */ (_this.trackMarkerContainer)).nativeElement.appendChild(docFrag);
                }),
                removeTrackMarkers: (/**
                 * @return {?}
                 */
                function () {
                    while ((/** @type {?} */ (_this.trackMarkerContainer)).nativeElement.firstChild) {
                        (/** @type {?} */ (_this.trackMarkerContainer)).nativeElement.removeChild((/** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ (_this.trackMarkerContainer)).nativeElement)).firstChild)));
                    }
                }),
                setLastTrackMarkersStyleProperty: (/**
                 * @param {?} propertyName
                 * @param {?} value
                 * @return {?}
                 */
                function (propertyName, value) {
                    /** @type {?} */
                    var lastTrackMarker = _this._getHostElement().querySelector(strings$e.LAST_TRACK_MARKER_SELECTOR);
                    lastTrackMarker.style.setProperty(propertyName, value);
                }),
                isRTL: (/**
                 * @return {?}
                 */
                function () { return getComputedStyle(_this._getHostElement()).direction === 'rtl'; })
            };
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this._platform.isBrowser) {
                this._foundation = new MDCSliderFoundation(this._createAdapter());
                this._foundation.init();
                this._initializeSelection();
                this._foundation.setupTrackMarker();
            }
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSlider.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setValue(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSlider.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChanged = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSlider.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcSlider.prototype.setValue = /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        function (value, isUserInput) {
            if (this.disabled) {
                return;
            }
            /** @type {?} */
            var newValue = toNumber(value, this.min);
            this._value = Math.round(newValue);
            if (this._foundation) {
                this._foundation.setValue(this._value);
            }
            if (isUserInput) {
                this._onChanged(this._value);
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSlider.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = toBoolean(disabled);
            if (!this._foundation) {
                return;
            }
            this._foundation.setDisabled(this._disabled);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        MdcSlider.prototype._onInput = /**
         * @private
         * @return {?}
         */
        function () {
            this.setValue(this._foundation.getValue(), true);
            this.input.emit(new MdcSliderChange(this, this._value));
        };
        /**
         * @private
         * @return {?}
         */
        MdcSlider.prototype._onChange = /**
         * @private
         * @return {?}
         */
        function () {
            this.setValue(this._foundation.getValue(), true);
            this.change.emit(new MdcSliderChange(this, this._value));
        };
        /**
         * @private
         * @return {?}
         */
        MdcSlider.prototype._initializeSelection = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                _this._foundation.setMin(_this._min);
                _this._foundation.setMax(_this._max);
                _this._foundation.setStep(_this._step);
                _this._foundation.setValue(_this._value);
            }));
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcSlider.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcSlider.decorators = [
            { type: core.Component, args: [{selector: 'mdc-slider',
                        exportAs: 'mdcSlider',
                        host: {
                            'role': 'slider',
                            'tabindex': '0',
                            'class': 'mdc-slider',
                            '[class.mdc-slider--discrete]': 'discrete',
                            '[class.mdc-slider--display-markers]': 'markers && discrete'
                        },
                        template: "\n  <div class=\"mdc-slider__track-container\">\n    <div #track class=\"mdc-slider__track\"></div>\n    <div #markercontainer *ngIf=\"markers\" class=\"mdc-slider__track-marker-container\"></div>\n  </div>\n  <div #thumbcontainer class=\"mdc-slider__thumb-container\">\n    <div *ngIf=\"discrete\" class=\"mdc-slider__pin\">\n      <span #pin class=\"mdc-slider__pin-value-marker\"></span>\n    </div>\n    <svg #sliderThumb\n      class=\"mdc-slider__thumb\"\n      width=\"21\" height=\"21\"\n      focusable=\"false\">\n      <circle cx=\"10.5\" cy=\"10.5\" r=\"7.875\"></circle>\n    </svg>\n    <div class=\"mdc-slider__focus-ring\"></div>\n  </div>",
                        providers: [MDC_SLIDER_CONTROL_VALUE_ACCESSOR],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcSlider.ctorParameters = function () { return [
            { type: Platform },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcSlider.propDecorators = {
            discrete: [{ type: core.Input }],
            markers: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            step: [{ type: core.Input }],
            value: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            change: [{ type: core.Output }],
            input: [{ type: core.Output }],
            thumbContainer: [{ type: core.ViewChild, args: ['thumbcontainer',] }],
            _sliderThumb: [{ type: core.ViewChild, args: ['sliderThumb',] }],
            track: [{ type: core.ViewChild, args: ['track',] }],
            pinValueMarker: [{ type: core.ViewChild, args: ['pin',] }],
            trackMarkerContainer: [{ type: core.ViewChild, args: ['markercontainer',] }]
        };
        return MdcSlider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcSliderModule = /** @class */ (function () {
        function MdcSliderModule() {
        }
        MdcSliderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [MdcSlider],
                        declarations: [MdcSlider]
                    },] },
        ];
        return MdcSliderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Reference to a snackbar dispatched from the snackbar service.
     * @template T
     */
    var   /**
     * Reference to a snackbar dispatched from the snackbar service.
     * @template T
     */
    MdcSnackbarRef = /** @class */ (function () {
        function MdcSnackbarRef(containerInstance, _overlayRef) {
            this.containerInstance = containerInstance;
            this._overlayRef = _overlayRef;
            /**
             * Subject for notifying the user that the snackbar has been dismissed.
             */
            this._afterDismiss = new rxjs.Subject();
            this.componentInstance = containerInstance;
        }
        /** Gets an observable that is notified when the snackbar is finished closing. */
        /**
         * Gets an observable that is notified when the snackbar is finished closing.
         * @return {?}
         */
        MdcSnackbarRef.prototype.afterDismiss = /**
         * Gets an observable that is notified when the snackbar is finished closing.
         * @return {?}
         */
        function () {
            return this._afterDismiss.asObservable();
        };
        /**
         * @param {?=} reason
         * @return {?}
         */
        MdcSnackbarRef.prototype.dismiss = /**
         * @param {?=} reason
         * @return {?}
         */
        function (reason) {
            if (!this._afterDismiss.closed) {
                this._dismissedReason = reason;
                this._finishDismiss();
            }
        };
        /** Cleans up the DOM after closing. */
        /**
         * Cleans up the DOM after closing.
         * @private
         * @return {?}
         */
        MdcSnackbarRef.prototype._finishDismiss = /**
         * Cleans up the DOM after closing.
         * @private
         * @return {?}
         */
        function () {
            this._overlayRef.dispose();
            this._afterDismiss.next(this._dismissedReason);
            this._afterDismiss.complete();
        };
        return MdcSnackbarRef;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to access the data that was passed in to a snackbar.
     * @type {?}
     */
    var MDC_SNACKBAR_DATA = new core.InjectionToken('MdcSnackbarData');
    /**
     * @template D
     */
    var   /**
     * @template D
     */
    MdcSnackbarConfig = /** @class */ (function () {
        function MdcSnackbarConfig() {
            /**
             * Data being injected into the child component.
             */
            this.data = null;
            /**
             * Positions the action button/icon below the label instead of alongside it.
             */
            this.stacked = false;
            /**
             * Positions the snackbar on the leading edge of the screen
             */
            this.leading = false;
            /**
             * Positions the snackbar on the trailing edge of the screen
             */
            this.trailing = false;
            /**
             * The layout direction of the snackbar content
             */
            this.direction = 'ltr';
            /**
             * Show dismiss ("X") icon
             */
            this.dismiss = false;
            /**
             * Whether the snackbar closes when it is focused and the user presses the ESC key
             */
            this.closeOnEscape = true;
        }
        return MdcSnackbarConfig;
    }());

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$h = {
      OPENING: 'mdc-snackbar--opening',
      OPEN: 'mdc-snackbar--open',
      CLOSING: 'mdc-snackbar--closing'
    };
    var strings$f = {
      SURFACE_SELECTOR: '.mdc-snackbar__surface',
      LABEL_SELECTOR: '.mdc-snackbar__label',
      ACTION_SELECTOR: '.mdc-snackbar__action',
      DISMISS_SELECTOR: '.mdc-snackbar__dismiss',
      OPENING_EVENT: 'MDCSnackbar:opening',
      OPENED_EVENT: 'MDCSnackbar:opened',
      CLOSING_EVENT: 'MDCSnackbar:closing',
      CLOSED_EVENT: 'MDCSnackbar:closed',
      REASON_ACTION: 'action',
      REASON_DISMISS: 'dismiss',
      ARIA_LIVE_LABEL_TEXT_ATTR: 'data-mdc-snackbar-label-text'
    };
    var numbers$b = {
      MIN_AUTO_DISMISS_TIMEOUT_MS: 4000,
      MAX_AUTO_DISMISS_TIMEOUT_MS: 10000,
      DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,
      // These variables need to be kept in sync with the values in _variables.scss.
      SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
      SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,

      /**
       * Number of milliseconds to wait between temporarily clearing the label text
       * in the DOM and subsequently restoring it. This is necessary to force IE 11
       * to pick up the `aria-live` content change and announce it to the user.
       */
      ARIA_LIVE_DELAY_MS: 1000
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var ARIA_LIVE_DELAY_MS = numbers$b.ARIA_LIVE_DELAY_MS;
    var ARIA_LIVE_LABEL_TEXT_ATTR = strings$f.ARIA_LIVE_LABEL_TEXT_ATTR;
    /**
     * @param {!HTMLElement} ariaEl
     * @param {!HTMLElement=} labelEl
     */

    function announce(ariaEl) {
      var labelEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ariaEl;
      var priority = ariaEl.getAttribute('aria-live');
      var labelText = labelEl.textContent.trim(); // Ignore `&nbsp;` (see below)

      if (!labelText) {
        return;
      } // Temporarily disable `aria-live` to prevent JAWS+Firefox from announcing the message twice.


      ariaEl.setAttribute('aria-live', 'off'); // Temporarily clear `textContent` to force a DOM mutation event that will be detected by screen readers.
      // `aria-live` elements are only announced when the element's `textContent` *changes*, so snackbars
      // sent to the browser in the initial HTML response won't be read unless we clear the element's `textContent` first.
      // Similarly, displaying the same snackbar message twice in a row doesn't trigger a DOM mutation event,
      // so screen readers won't announce the second message unless we first clear `textContent`.
      //
      // We have to clear the label text two different ways to make it work in all browsers and screen readers:
      //
      //   1. `textContent = ''` is required for IE11 + JAWS
      //   2. `innerHTML = '&nbsp;'` is required for Chrome + JAWS and NVDA
      //
      // All other browser/screen reader combinations support both methods.
      //
      // The wrapper `<span>` visually hides the space character so that it doesn't cause jank when added/removed.
      // N.B.: Setting `position: absolute`, `opacity: 0`, or `height: 0` prevents Chrome from detecting the DOM change.
      //
      // This technique has been tested in:
      //
      //   * JAWS 2019:
      //       - Chrome 70
      //       - Firefox 60 (ESR)
      //       - IE 11
      //   * NVDA 2018:
      //       - Chrome 70
      //       - Firefox 60 (ESR)
      //       - IE 11
      //   * ChromeVox 53

      labelEl.textContent = '';
      labelEl.innerHTML = '<span style="display: inline-block; width: 0; height: 1px;">&nbsp;</span>'; // Prevent visual jank by temporarily displaying the label text in the ::before pseudo-element.
      // CSS generated content is normally announced by screen readers
      // (except in IE 11; see https://tink.uk/accessibility-support-for-css-generated-content/);
      // however, `aria-live` is turned off, so this DOM update will be ignored by screen readers.

      labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);
      setTimeout(function () {
        // Allow screen readers to announce changes to the DOM again.
        ariaEl.setAttribute('aria-live', priority); // Remove the message from the ::before pseudo-element.

        labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR); // Restore the original label text, which will be announced by screen readers.

        labelEl.textContent = labelText;
      }, ARIA_LIVE_DELAY_MS);
    }

    function _classCallCheck$h(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$h(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$h(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$h(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$h(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$h(subClass, superClass);
    }

    function _getPrototypeOf$h(o) {
      _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$h(o);
    }

    function _setPrototypeOf$h(o, p) {
      _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$h(o, p);
    }

    function _assertThisInitialized$h(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$h(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$h(self);
    }

    function _superPropBase$8(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$h(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$8(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$8 = Reflect.get;
      } else {
        _get$8 = function _get(target, property, receiver) {
          var base = _superPropBase$8(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$8(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$h =
    /*#__PURE__*/
    function () {
      _createClass$h(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$h(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$h(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$h =
    /*#__PURE__*/
    function () {
      _createClass$h(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$h());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$h(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$h(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Snackbar. Provides an interface for managing:
     * - CSS classes
     * - Event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCSnackbarAdapter =
    /*#__PURE__*/
    function () {
      function MDCSnackbarAdapter() {
        _classCallCheck$h(this, MDCSnackbarAdapter);
      }

      _createClass$h(MDCSnackbarAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
      }, {
        key: "announce",
        value: function announce() {}
      }, {
        key: "notifyOpening",
        value: function notifyOpening() {}
      }, {
        key: "notifyOpened",
        value: function notifyOpened() {}
        /**
         * @param {string} reason
         */

      }, {
        key: "notifyClosing",
        value: function notifyClosing(reason) {}
        /**
         * @param {string} reason
         */

      }, {
        key: "notifyClosed",
        value: function notifyClosed(reason) {}
      }]);

      return MDCSnackbarAdapter;
    }();

    var OPENING = cssClasses$h.OPENING,
        OPEN = cssClasses$h.OPEN,
        CLOSING = cssClasses$h.CLOSING;
    var REASON_ACTION = strings$f.REASON_ACTION,
        REASON_DISMISS = strings$f.REASON_DISMISS;

    var MDCSnackbarFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$h(MDCSnackbarFoundation, _MDCFoundation);

      _createClass$h(MDCSnackbarFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$h;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$f;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$b;
        }
        /**
         * @return {!MDCSnackbarAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCSnackbarAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              announce: function announce() {},
              notifyOpening: function notifyOpening() {},
              notifyOpened: function notifyOpened() {},
              notifyClosing: function notifyClosing()
              /* reason: string */
              {},
              notifyClosed: function notifyClosed()
              /* reason: string */
              {}
            }
          );
        }
        /**
         * @param {!MDCSnackbarAdapter=} adapter
         */

      }]);

      function MDCSnackbarFoundation(adapter) {
        var _this;

        _classCallCheck$h(this, MDCSnackbarFoundation);

        _this = _possibleConstructorReturn$h(this, _getPrototypeOf$h(MDCSnackbarFoundation).call(this, Object.assign(MDCSnackbarFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.isOpen_ = false;
        /** @private {number} */

        _this.animationFrame_ = 0;
        /** @private {number} */

        _this.animationTimer_ = 0;
        /** @private {number} */

        _this.autoDismissTimer_ = 0;
        /** @private {number} */

        _this.autoDismissTimeoutMs_ = numbers$b.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
        /** @private {boolean} */

        _this.closeOnEscape_ = true;
        return _this;
      }

      _createClass$h(MDCSnackbarFoundation, [{
        key: "destroy",
        value: function destroy() {
          this.clearAutoDismissTimer_();
          cancelAnimationFrame(this.animationFrame_);
          this.animationFrame_ = 0;
          clearTimeout(this.animationTimer_);
          this.animationTimer_ = 0;
          this.adapter_.removeClass(OPENING);
          this.adapter_.removeClass(OPEN);
          this.adapter_.removeClass(CLOSING);
        }
      }, {
        key: "open",
        value: function open() {
          var _this2 = this;

          this.clearAutoDismissTimer_();
          this.isOpen_ = true;
          this.adapter_.notifyOpening();
          this.adapter_.removeClass(CLOSING);
          this.adapter_.addClass(OPENING);
          this.adapter_.announce(); // Wait a frame once display is no longer "none", to establish basis for animation

          this.runNextAnimationFrame_(function () {
            _this2.adapter_.addClass(OPEN);

            _this2.animationTimer_ = setTimeout(function () {
              _this2.handleAnimationTimerEnd_();

              _this2.adapter_.notifyOpened();

              _this2.autoDismissTimer_ = setTimeout(function () {
                _this2.close(REASON_DISMISS);
              }, _this2.getTimeoutMs());
            }, numbers$b.SNACKBAR_ANIMATION_OPEN_TIME_MS);
          });
        }
        /**
         * @param {string=} reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
         *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
         *     client-specific values may also be used if desired.
         */

      }, {
        key: "close",
        value: function close() {
          var _this3 = this;

          var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          if (!this.isOpen_) {
            // Avoid redundant close calls (and events), e.g. repeated interactions as the snackbar is animating closed
            return;
          }

          cancelAnimationFrame(this.animationFrame_);
          this.animationFrame_ = 0;
          this.clearAutoDismissTimer_();
          this.isOpen_ = false;
          this.adapter_.notifyClosing(reason);
          this.adapter_.addClass(cssClasses$h.CLOSING);
          this.adapter_.removeClass(cssClasses$h.OPEN);
          this.adapter_.removeClass(cssClasses$h.OPENING);
          clearTimeout(this.animationTimer_);
          this.animationTimer_ = setTimeout(function () {
            _this3.handleAnimationTimerEnd_();

            _this3.adapter_.notifyClosed(reason);
          }, numbers$b.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
        }
        /**
         * @return {boolean}
         */

      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
        /**
         * @return {number}
         */

      }, {
        key: "getTimeoutMs",
        value: function getTimeoutMs() {
          return this.autoDismissTimeoutMs_;
        }
        /**
         * @param {number} timeoutMs
         */

      }, {
        key: "setTimeoutMs",
        value: function setTimeoutMs(timeoutMs) {
          // Use shorter variable names to make the code more readable
          var minValue = numbers$b.MIN_AUTO_DISMISS_TIMEOUT_MS;
          var maxValue = numbers$b.MAX_AUTO_DISMISS_TIMEOUT_MS;

          if (timeoutMs <= maxValue && timeoutMs >= minValue) {
            this.autoDismissTimeoutMs_ = timeoutMs;
          } else {
            throw new Error("timeoutMs must be an integer in the range ".concat(minValue, "\u2013").concat(maxValue, ", but got '").concat(timeoutMs, "'"));
          }
        }
        /**
         * @return {boolean}
         */

      }, {
        key: "getCloseOnEscape",
        value: function getCloseOnEscape() {
          return this.closeOnEscape_;
        }
        /**
         * @param {boolean} closeOnEscape
         */

      }, {
        key: "setCloseOnEscape",
        value: function setCloseOnEscape(closeOnEscape) {
          this.closeOnEscape_ = closeOnEscape;
        }
        /**
         * @param {!KeyboardEvent} evt
         */

      }, {
        key: "handleKeyDown",
        value: function handleKeyDown(evt) {
          if (this.getCloseOnEscape() && (evt.key === 'Escape' || evt.keyCode === 27)) {
            this.close(REASON_DISMISS);
          }
        }
        /**
         * @param {!MouseEvent} evt
         */

      }, {
        key: "handleActionButtonClick",
        value: function handleActionButtonClick(evt) {
          this.close(REASON_ACTION);
        }
        /**
         * @param {!MouseEvent} evt
         */

      }, {
        key: "handleActionIconClick",
        value: function handleActionIconClick(evt) {
          this.close(REASON_DISMISS);
        }
        /** @private */

      }, {
        key: "clearAutoDismissTimer_",
        value: function clearAutoDismissTimer_() {
          clearTimeout(this.autoDismissTimer_);
          this.autoDismissTimer_ = 0;
        }
        /** @private */

      }, {
        key: "handleAnimationTimerEnd_",
        value: function handleAnimationTimerEnd_() {
          this.animationTimer_ = 0;
          this.adapter_.removeClass(cssClasses$h.OPENING);
          this.adapter_.removeClass(cssClasses$h.CLOSING);
        }
        /**
         * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
         * @param {Function} callback
         * @private
         */

      }, {
        key: "runNextAnimationFrame_",
        value: function runNextAnimationFrame_(callback) {
          var _this4 = this;

          cancelAnimationFrame(this.animationFrame_);
          this.animationFrame_ = requestAnimationFrame(function () {
            _this4.animationFrame_ = 0;
            clearTimeout(_this4.animationTimer_);
            _this4.animationTimer_ = setTimeout(callback, 0);
          });
        }
      }]);

      return MDCSnackbarFoundation;
    }(MDCFoundation$h);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
     * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
     */

    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {?Element}
     */
    function closest$1(element, selector) {
      if (element.closest) {
        return element.closest(selector);
      }

      var el = element;

      while (el) {
        if (matches$6(el, selector)) {
          return el;
        }

        el = el.parentElement;
      }

      return null;
    }
    /**
     * @param {!Element} element
     * @param {string} selector
     * @return {boolean}
     */


    function matches$6(element, selector) {
      var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      return nativeMatches.call(element, selector);
    }

    var SURFACE_SELECTOR = strings$f.SURFACE_SELECTOR,
        LABEL_SELECTOR = strings$f.LABEL_SELECTOR,
        ACTION_SELECTOR = strings$f.ACTION_SELECTOR,
        DISMISS_SELECTOR = strings$f.DISMISS_SELECTOR,
        OPENING_EVENT = strings$f.OPENING_EVENT,
        OPENED_EVENT = strings$f.OPENED_EVENT,
        CLOSING_EVENT = strings$f.CLOSING_EVENT,
        CLOSED_EVENT = strings$f.CLOSED_EVENT;

    var MDCSnackbar =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$h(MDCSnackbar, _MDCComponent);

      _createClass$h(MDCSnackbar, null, [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCSnackbar(root);
        }
      }]);

      function MDCSnackbar() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$h(this, MDCSnackbar);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$h(this, (_getPrototypeOf2 = _getPrototypeOf$h(MDCSnackbar)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {!HTMLElement} */

        _this.surfaceEl_;
        /** @type {!HTMLElement} */

        _this.labelEl_;
        /** @type {!HTMLElement} */

        _this.actionEl_;
        /** @type {function(!HTMLElement, !HTMLElement=): void} */

        _this.announce_;
        /** @private {!Function} */

        _this.handleKeyDown_;
        /** @private {!Function} */

        _this.handleSurfaceClick_;
        return _this;
      }
      /**
       * @param {function(): function(!HTMLElement, !HTMLElement=):void} announceFactory
       */


      _createClass$h(MDCSnackbar, [{
        key: "initialize",
        value: function initialize() {
          var announceFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {
            return announce;
          };
          this.announce_ = announceFactory();
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.surfaceEl_ =
          /** @type {!HTMLElement} */
          this.root_.querySelector(SURFACE_SELECTOR);
          this.labelEl_ =
          /** @type {!HTMLElement} */
          this.root_.querySelector(LABEL_SELECTOR);
          this.actionEl_ =
          /** @type {!HTMLElement} */
          this.root_.querySelector(ACTION_SELECTOR);

          this.handleKeyDown_ = function (evt) {
            return _this2.foundation_.handleKeyDown(evt);
          };

          this.handleSurfaceClick_ = function (evt) {
            if (_this2.isActionButton_(evt.target)) {
              _this2.foundation_.handleActionButtonClick(evt);
            } else if (_this2.isActionIcon_(evt.target)) {
              _this2.foundation_.handleActionIconClick(evt);
            }
          };

          this.registerKeyDownHandler_(this.handleKeyDown_);
          this.registerSurfaceClickHandler_(this.handleSurfaceClick_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$8(_getPrototypeOf$h(MDCSnackbar.prototype), "destroy", this).call(this);

          this.deregisterKeyDownHandler_(this.handleKeyDown_);
          this.deregisterSurfaceClickHandler_(this.handleSurfaceClick_);
        }
      }, {
        key: "open",
        value: function open() {
          this.foundation_.open();
        }
        /**
         * @param {string=} reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
         *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
         *     client-specific values may also be used if desired.
         */

      }, {
        key: "close",
        value: function close() {
          var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          this.foundation_.close(reason);
        }
        /**
         * @return {!MDCSnackbarFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          /* eslint brace-style: "off" */
          return new MDCSnackbarFoundation({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            announce: function announce() {
              return _this3.announce_(_this3.labelEl_);
            },
            notifyOpening: function notifyOpening() {
              return _this3.emit(OPENING_EVENT, {});
            },
            notifyOpened: function notifyOpened() {
              return _this3.emit(OPENED_EVENT, {});
            },
            notifyClosing: function notifyClosing(reason) {
              return _this3.emit(CLOSING_EVENT, reason ? {
                reason: reason
              } : {});
            },
            notifyClosed: function notifyClosed(reason) {
              return _this3.emit(CLOSED_EVENT, reason ? {
                reason: reason
              } : {});
            }
          });
        }
        /**
         * @return {number}
         */

      }, {
        key: "registerKeyDownHandler_",

        /**
         * @param {!Function} handler
         * @private
         */
        value: function registerKeyDownHandler_(handler) {
          this.listen('keydown', handler);
        }
        /**
         * @param {!Function} handler
         * @private
         */

      }, {
        key: "deregisterKeyDownHandler_",
        value: function deregisterKeyDownHandler_(handler) {
          this.unlisten('keydown', handler);
        }
        /**
         * @param {!Function} handler
         * @private
         */

      }, {
        key: "registerSurfaceClickHandler_",
        value: function registerSurfaceClickHandler_(handler) {
          this.surfaceEl_.addEventListener('click', handler);
        }
        /**
         * @param {!Function} handler
         * @private
         */

      }, {
        key: "deregisterSurfaceClickHandler_",
        value: function deregisterSurfaceClickHandler_(handler) {
          this.surfaceEl_.removeEventListener('click', handler);
        }
        /**
         * @param {!Element} target
         * @return {boolean}
         * @private
         */

      }, {
        key: "isActionButton_",
        value: function isActionButton_(target) {
          return Boolean(closest$1(target, ACTION_SELECTOR));
        }
        /**
         * @param {!Element} target
         * @return {boolean}
         * @private
         */

      }, {
        key: "isActionIcon_",
        value: function isActionIcon_(target) {
          return Boolean(closest$1(target, DISMISS_SELECTOR));
        }
      }, {
        key: "timeoutMs",
        get: function get() {
          return this.foundation_.getTimeoutMs();
        }
        /**
         * @param {number} timeoutMs
         */
        ,
        set: function set(timeoutMs) {
          this.foundation_.setTimeoutMs(timeoutMs);
        }
        /**
         * @return {boolean}
         */

      }, {
        key: "closeOnEscape",
        get: function get() {
          return this.foundation_.getCloseOnEscape();
        }
        /**
         * @param {boolean} closeOnEscape
         */
        ,
        set: function set(closeOnEscape) {
          this.foundation_.setCloseOnEscape(closeOnEscape);
        }
        /**
         * @return {boolean}
         */

      }, {
        key: "isOpen",
        get: function get() {
          return this.foundation_.isOpen();
        }
        /**
         * @return {string}
         */

      }, {
        key: "labelText",
        get: function get() {
          return this.labelEl_.textContent;
        }
        /**
         * @param {string} labelText
         */
        ,
        set: function set(labelText) {
          this.labelEl_.textContent = labelText;
        }
        /**
         * @return {string}
         */

      }, {
        key: "actionButtonText",
        get: function get() {
          return this.actionEl_.textContent;
        }
        /**
         * @param {string} actionButtonText
         */
        ,
        set: function set(actionButtonText) {
          this.actionEl_.textContent = actionButtonText;
        }
      }]);

      return MDCSnackbar;
    }(MDCComponent$h);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcSnackbarComponent = /** @class */ (function () {
        function MdcSnackbarComponent(_changeDetectorRef, elementRef, snackbarRef, data) {
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this.snackbarRef = snackbarRef;
            this.data = data;
            this._foundation = new MDCSnackbarFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcSnackbarComponent.prototype, "config", {
            get: /**
             * @return {?}
             */
            function () { return this.snackbarRef.componentInstance.snackbarConfig; },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcSnackbarComponent.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                announce: (/**
                 * @return {?}
                 */
                function () { return announce(_this.label.nativeElement); }),
                notifyClosed: (/**
                 * @param {?} reason
                 * @return {?}
                 */
                function (reason) { return _this.snackbarRef.dismiss(reason); })
            };
        };
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._changeDetectorRef.detectChanges();
            this._applyClasses();
            this._applyConfig();
        };
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSnackbarComponent.prototype._onKeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleKeyDown(evt);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSnackbarComponent.prototype._onActionClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleActionButtonClick(evt);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSnackbarComponent.prototype._onActionIconClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleActionIconClick(evt);
        };
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype.open = /**
         * @return {?}
         */
        function () {
            this._foundation.open();
        };
        /**
         * @param {?=} reason
         * @return {?}
         */
        MdcSnackbarComponent.prototype.close = /**
         * @param {?=} reason
         * @return {?}
         */
        function (reason) {
            this._foundation.close(reason);
        };
        /**
         * @private
         * @return {?}
         */
        MdcSnackbarComponent.prototype._applyClasses = /**
         * @private
         * @return {?}
         */
        function () {
            var _a, _b, _c;
            /** @type {?} */
            var classes = this.config.classes;
            if (classes) {
                if (classes instanceof Array) {
                    (_a = this._getHostElement().classList).add.apply(_a, (/** @type {?} */ (this.config.classes)));
                }
                else {
                    this._getHostElement().classList.toggle(classes);
                }
            }
            /** @type {?} */
            var actionClasses = this.config.actionClasses;
            if (actionClasses && this.action) {
                if (actionClasses instanceof Array) {
                    (_b = this.action.nativeElement.classList).add.apply(_b, (/** @type {?} */ (this.config.actionClasses)));
                }
                else {
                    this.action.nativeElement.classList.toggle(actionClasses);
                }
            }
            if (this.dismiss) {
                /** @type {?} */
                var dismissClasses = this.config.dismissClasses;
                if (dismissClasses) {
                    if (dismissClasses instanceof Array) {
                        (_c = this.dismiss.nativeElement.classList).add.apply(_c, (/** @type {?} */ (this.config.dismissClasses)));
                    }
                    else {
                        this.dismiss.nativeElement.classList.toggle(dismissClasses);
                    }
                }
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcSnackbarComponent.prototype._applyConfig = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.config.timeoutMs) {
                this._foundation.setTimeoutMs(this.config.timeoutMs);
            }
            if (this.config.dismiss) {
                this._foundation.setCloseOnEscape(this.config.closeOnEscape ? true : false);
            }
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcSnackbarComponent.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcSnackbarComponent.decorators = [
            { type: core.Component, args: [{selector: 'mdc-snackbar',
                        host: {
                            'class': 'mdc-snackbar',
                            '[dir]': 'this.config.direction',
                            '[class.mdc-snackbar--stacked]': 'config.stacked',
                            '[class.mdc-snackbar--leading]': 'config.leading',
                            '[class.ngx-mdc-snackbar--trailing]': 'config.trailing',
                            '(keydown)': '_onKeydown($event)'
                        },
                        template: "\n  <div #surface class=\"mdc-snackbar__surface\">\n    <div #label class=\"mdc-snackbar__label\"\n      role=\"status\"\n      aria-live=\"polite\">{{data.message}}</div>\n    <div class=\"mdc-snackbar__actions\" *ngIf=\"data.action\">\n      <button #action type=\"button\" class=\"mdc-button mdc-snackbar__action\"\n        (click)=\"_onActionClick($event)\">{{data.action}}</button>\n      <button #dismiss *ngIf=\"config.dismiss\"\n        class=\"mdc-icon-button mdc-snackbar__dismiss material-icons\"\n        title=\"Dismiss\" (click)=\"_onActionIconClick($event)\">close</button>\n    </div>\n  </div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcSnackbarComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: MdcSnackbarRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [MDC_SNACKBAR_DATA,] }] }
        ]; };
        MdcSnackbarComponent.propDecorators = {
            label: [{ type: core.ViewChild, args: ['label',] }],
            action: [{ type: core.ViewChild, args: ['action',] }],
            dismiss: [{ type: core.ViewChild, args: ['dismiss',] }]
        };
        return MdcSnackbarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcSnackbarContainer = /** @class */ (function (_super) {
        __extends(MdcSnackbarContainer, _super);
        function MdcSnackbarContainer(_ngZone, snackbarConfig) {
            var _this = _super.call(this) || this;
            _this._ngZone = _ngZone;
            _this.snackbarConfig = snackbarConfig;
            /**
             * Subject for notifying that the snackbar has exited from view.
             */
            _this._onExit = new rxjs.Subject();
            return _this;
        }
        /** Attach a component portal as content to this snackbar container. */
        /**
         * Attach a component portal as content to this snackbar container.
         * @template T
         * @param {?} portal
         * @return {?}
         */
        MdcSnackbarContainer.prototype.attachComponentPortal = /**
         * Attach a component portal as content to this snackbar container.
         * @template T
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /** Attach a template portal as content to this snackbar container. */
        /**
         * Attach a template portal as content to this snackbar container.
         * @template C
         * @param {?} portal
         * @return {?}
         */
        MdcSnackbarContainer.prototype.attachTemplatePortal = /**
         * Attach a template portal as content to this snackbar container.
         * @template C
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        /**
         * @return {?}
         */
        MdcSnackbarContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._completeExit();
        };
        /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         */
        /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         * @private
         * @return {?}
         */
        MdcSnackbarContainer.prototype._completeExit = /**
         * Waits for the zone to settle before removing the element. Helps prevent
         * errors where we end up removing an element which is in the middle of an animation.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._onExit.next();
                _this._onExit.complete();
            }));
        };
        MdcSnackbarContainer.decorators = [
            { type: core.Component, args: [{selector: 'mdc-snackbar-container',
                        template: '<ng-template cdkPortalOutlet></ng-template>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcSnackbarContainer.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: MdcSnackbarConfig }
        ]; };
        MdcSnackbarContainer.propDecorators = {
            _portalOutlet: [{ type: core.ViewChild, args: [CdkPortalOutlet,] }]
        };
        return MdcSnackbarContainer;
    }(BasePortalOutlet));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcSnackbarModule = /** @class */ (function () {
        function MdcSnackbarModule() {
        }
        MdcSnackbarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            OverlayModule,
                            PortalModule,
                            MdcButtonModule
                        ],
                        exports: [MdcSnackbarContainer],
                        declarations: [MdcSnackbarContainer, MdcSnackbarComponent],
                        entryComponents: [MdcSnackbarContainer, MdcSnackbarComponent]
                    },] },
        ];
        return MdcSnackbarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to specify default snackbar.
     * @type {?}
     */
    var MDC_SNACKBAR_DEFAULT_OPTIONS = new core.InjectionToken('mdc-snackbar-default-options', {
        providedIn: 'root',
        factory: MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY,
    });
    /**
     * \@docs-private
     * @return {?}
     */
    function MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY() {
        return new MdcSnackbarConfig();
    }
    var MdcSnackbar = /** @class */ (function () {
        function MdcSnackbar(_overlay, _injector, _parentSnackBar, _defaultConfig) {
            this._overlay = _overlay;
            this._injector = _injector;
            this._parentSnackBar = _parentSnackBar;
            this._defaultConfig = _defaultConfig;
            /**
             * Reference to the current snackbar in the view *at this level* (in the Angular injector tree).
             * If there is a parent snack-bar service, all operations should delegate to that parent
             * via `_openedSnackBarRef`.
             */
            this._snackBarRefAtThisLevel = null;
        }
        Object.defineProperty(MdcSnackbar.prototype, "_openedSnackbarRef", {
            /** Reference to the currently opened snackbar at *any* level. */
            get: /**
             * Reference to the currently opened snackbar at *any* level.
             * @return {?}
             */
            function () {
                /** @type {?} */
                var parent = this._parentSnackBar;
                return parent ? parent._openedSnackbarRef : this._snackBarRefAtThisLevel;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._parentSnackBar) {
                    this._parentSnackBar._openedSnackbarRef = value;
                }
                else {
                    this._snackBarRefAtThisLevel = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and dispatches a snackbar with a custom component for the content, removing any
         * currently opened snackbars.
         *
         * @param component Component to be instantiated.
         * @param config Extra configuration for the snackbar.
         */
        /**
         * Creates and dispatches a snackbar with a custom component for the content, removing any
         * currently opened snackbars.
         *
         * @template T
         * @param {?} component Component to be instantiated.
         * @param {?=} config Extra configuration for the snackbar.
         * @return {?}
         */
        MdcSnackbar.prototype.openFromComponent = /**
         * Creates and dispatches a snackbar with a custom component for the content, removing any
         * currently opened snackbars.
         *
         * @template T
         * @param {?} component Component to be instantiated.
         * @param {?=} config Extra configuration for the snackbar.
         * @return {?}
         */
        function (component, config) {
            return (/** @type {?} */ (this._attach(component, config)));
        };
        /**
         * Opens a snackbar with a message and an optional action.
         * @param message Message text.
         * @param action The label for the snackbar action.
         * @param config Additional configuration options for the snackbar.
         */
        /**
         * Opens a snackbar with a message and an optional action.
         * @param {?} message Message text.
         * @param {?=} action The label for the snackbar action.
         * @param {?=} config Additional configuration options for the snackbar.
         * @return {?}
         */
        MdcSnackbar.prototype.open = /**
         * Opens a snackbar with a message and an optional action.
         * @param {?} message Message text.
         * @param {?=} action The label for the snackbar action.
         * @param {?=} config Additional configuration options for the snackbar.
         * @return {?}
         */
        function (message, action, config) {
            if (action === void 0) { action = ''; }
            /** @type {?} */
            var _config = _assign({}, this._defaultConfig, config);
            // Since the user doesn't have access to the component, we can
            // override the data to pass in our own message and action.
            _config.data = { message: message, action: action };
            return this.openFromComponent(MdcSnackbarComponent, _config);
        };
        /**
         * Dismisses the currently-visible snackbar.
         */
        /**
         * Dismisses the currently-visible snackbar.
         * @return {?}
         */
        MdcSnackbar.prototype.dismiss = /**
         * Dismisses the currently-visible snackbar.
         * @return {?}
         */
        function () {
            if (this._openedSnackbarRef) {
                if (this._openedSnackbarRef.instance instanceof MdcSnackbarComponent) {
                    ((/** @type {?} */ (this._openedSnackbarRef.instance))).close();
                }
                this._openedSnackbarRef.dismiss();
            }
        };
        /**
         * @return {?}
         */
        MdcSnackbar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            // Only dismiss the snackbar at the current level on destroy.
            if (this._snackBarRefAtThisLevel) {
                this._snackBarRefAtThisLevel.dismiss();
            }
        };
        /**
         * Attaches the snackbar container component to the overlay.
         */
        /**
         * Attaches the snackbar container component to the overlay.
         * @private
         * @param {?} overlayRef
         * @param {?} config
         * @return {?}
         */
        MdcSnackbar.prototype._attachSnackbarContainer = /**
         * Attaches the snackbar container component to the overlay.
         * @private
         * @param {?} overlayRef
         * @param {?} config
         * @return {?}
         */
        function (overlayRef, config) {
            /** @type {?} */
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            /** @type {?} */
            var injector = new PortalInjector(userInjector || this._injector, new WeakMap([
                [MdcSnackbarConfig, config]
            ]));
            /** @type {?} */
            var containerPortal = new ComponentPortal(MdcSnackbarContainer, config.viewContainerRef, injector);
            /** @type {?} */
            var containerRef = overlayRef.attach(containerPortal);
            containerRef.instance.snackbarConfig = config;
            return containerRef.instance;
        };
        /**
         * Places a new component or a template as the content of the snackbar container.
         */
        /**
         * Places a new component or a template as the content of the snackbar container.
         * @private
         * @template T
         * @param {?} content
         * @param {?=} userConfig
         * @return {?}
         */
        MdcSnackbar.prototype._attach = /**
         * Places a new component or a template as the content of the snackbar container.
         * @private
         * @template T
         * @param {?} content
         * @param {?=} userConfig
         * @return {?}
         */
        function (content, userConfig) {
            /** @type {?} */
            var config = _assign({}, new MdcSnackbarConfig(), this._defaultConfig, userConfig);
            /** @type {?} */
            var overlayRef = this._createOverlay();
            /** @type {?} */
            var container = this._attachSnackbarContainer(overlayRef, config);
            /** @type {?} */
            var snackbarRef = new MdcSnackbarRef(container, overlayRef);
            /** @type {?} */
            var injector = this._createInjector(config, snackbarRef);
            /** @type {?} */
            var portal = new ComponentPortal(content, undefined, injector);
            /** @type {?} */
            var contentRef = container.attachComponentPortal(portal);
            // We can't pass this via the injector, because the injector is created earlier.
            snackbarRef.instance = contentRef.instance;
            this._loadListeners(snackbarRef);
            this._openedSnackbarRef = snackbarRef;
            if (snackbarRef.instance instanceof MdcSnackbarComponent) {
                ((/** @type {?} */ (snackbarRef.instance))).open();
            }
            return this._openedSnackbarRef;
        };
        /**
         * @private
         * @param {?} snackbarRef
         * @return {?}
         */
        MdcSnackbar.prototype._loadListeners = /**
         * @private
         * @param {?} snackbarRef
         * @return {?}
         */
        function (snackbarRef) {
            var _this = this;
            // When the snackbar is dismissed, clear the reference to it.
            snackbarRef.afterDismiss().subscribe((/**
             * @return {?}
             */
            function () {
                // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
                if (_this._openedSnackbarRef === snackbarRef) {
                    _this._openedSnackbarRef = null;
                }
            }));
            if (this._openedSnackbarRef) {
                this._openedSnackbarRef.dismiss();
            }
        };
        /**
         * Creates a new overlay and places it in the correct location.
         * @param config The user-specified snackbar config.
         */
        /**
         * Creates a new overlay and places it in the correct location.
         * @private
         * @return {?}
         */
        MdcSnackbar.prototype._createOverlay = /**
         * Creates a new overlay and places it in the correct location.
         * @private
         * @return {?}
         */
        function () {
            return this._overlay.create();
        };
        /**
         * Creates an injector to be used inside of a snackbar component.
         * @param config Config that was used to create the snackbar.
         * @param snackbarRef Reference to the snackbar.
         */
        /**
         * Creates an injector to be used inside of a snackbar component.
         * @private
         * @template T
         * @param {?} config Config that was used to create the snackbar.
         * @param {?} snackbarRef Reference to the snackbar.
         * @return {?}
         */
        MdcSnackbar.prototype._createInjector = /**
         * Creates an injector to be used inside of a snackbar component.
         * @private
         * @template T
         * @param {?} config Config that was used to create the snackbar.
         * @param {?} snackbarRef Reference to the snackbar.
         * @return {?}
         */
        function (config, snackbarRef) {
            /** @type {?} */
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            return new PortalInjector(userInjector || this._injector, new WeakMap([
                [MdcSnackbarRef, snackbarRef],
                [MDC_SNACKBAR_DATA, config.data]
            ]));
        };
        MdcSnackbar.decorators = [
            { type: core.Injectable, args: [{ providedIn: MdcSnackbarModule },] },
        ];
        /** @nocollapse */
        MdcSnackbar.ctorParameters = function () { return [
            { type: Overlay },
            { type: core.Injector },
            { type: MdcSnackbar, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: MdcSnackbarConfig, decorators: [{ type: core.Inject, args: [MDC_SNACKBAR_DEFAULT_OPTIONS,] }] }
        ]; };
        /** @nocollapse */ MdcSnackbar.ngInjectableDef = core.defineInjectable({ factory: function MdcSnackbar_Factory() { return new MdcSnackbar(core.inject(Overlay), core.inject(core.INJECTOR), core.inject(MdcSnackbar, 12), core.inject(MDC_SNACKBAR_DEFAULT_OPTIONS)); }, token: MdcSnackbar, providedIn: MdcSnackbarModule });
        return MdcSnackbar;
    }());

    function _classCallCheck$i(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$i(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$i(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$i(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$i(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$i(subClass, superClass);
    }

    function _getPrototypeOf$i(o) {
      _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$i(o);
    }

    function _setPrototypeOf$i(o, p) {
      _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$i(o, p);
    }

    function _assertThisInitialized$i(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$i(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$i(self);
    }

    function _superPropBase$9(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$i(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$9(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$9 = Reflect.get;
      } else {
        _get$9 = function _get(target, property, receiver) {
          var base = _superPropBase$9(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$9(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$i =
    /*#__PURE__*/
    function () {
      _createClass$i(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$i(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$i(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$i =
    /*#__PURE__*/
    function () {
      _createClass$i(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$i());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$i(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$i(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$7 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$i(this, MDCRippleAdapter);
      }

      _createClass$i(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$i = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$g = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$c = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$7;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$7;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$7(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$7(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$7;

      if (typeof supportsCssVariables_$7 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$7(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$7 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$7() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$7 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$7 = isSupported;
      }

      return supportsPassive_$7 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$7(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$7(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$8 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$8 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$7 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$7 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$i(MDCRippleFoundation, _MDCFoundation);

      _createClass$i(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$i;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$g;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$c;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$i(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$i(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$8.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$8.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$8.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$8.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$7.length > 0 && activatedTargets$7.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$7.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$7 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$7(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$c.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$i);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$7 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$i(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$i(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$i(this, (_getPrototypeOf2 = _getPrototypeOf$i(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$i(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$7(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$7(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$7(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$7());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$7());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$7());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$7());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$i);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$7 = function RippleCapableSurface() {
      _classCallCheck$i(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$7.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$7.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$7.prototype.disabled;

    /**
     * @record
     */

    var MDCSelectionControl$2 =
    /*#__PURE__*/
    function () {
      function MDCSelectionControl() {
        _classCallCheck$i(this, MDCSelectionControl);
      }

      _createClass$i(MDCSelectionControl, [{
        key: "ripple",

        /** @return {?MDCRipple} */
        get: function get() {}
      }]);

      return MDCSelectionControl;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Switch. Provides an interface for managing
     * - classes
     * - dom
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCSwitchAdapter =
    /*#__PURE__*/
    function () {
      function MDCSwitchAdapter() {
        _classCallCheck$i(this, MDCSwitchAdapter);
      }

      _createClass$i(MDCSwitchAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {boolean} checked */

      }, {
        key: "setNativeControlChecked",
        value: function setNativeControlChecked(checked) {}
        /** @param {boolean} disabled */

      }, {
        key: "setNativeControlDisabled",
        value: function setNativeControlDisabled(disabled) {}
      }]);

      return MDCSwitchAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1$a = {
      CHECKED: 'mdc-switch--checked',
      DISABLED: 'mdc-switch--disabled'
    };
    /** @enum {string} */

    var strings$1$9 = {
      NATIVE_CONTROL_SELECTOR: '.mdc-switch__native-control',
      RIPPLE_SURFACE_SELECTOR: '.mdc-switch__thumb-underlay'
    };

    /**
     * @extends {MDCFoundation<!MDCSwitchAdapter>}
     */

    var MDCSwitchFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$i(MDCSwitchFoundation, _MDCFoundation);

      _createClass$i(MDCSwitchFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$1$9;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$a;
        }
        /** @return {!MDCSwitchAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCSwitchAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              setNativeControlChecked: function setNativeControlChecked()
              /* checked: boolean */
              {},
              setNativeControlDisabled: function setNativeControlDisabled()
              /* disabled: boolean */
              {}
            }
          );
        }
      }]);

      function MDCSwitchFoundation(adapter) {
        _classCallCheck$i(this, MDCSwitchFoundation);

        return _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCSwitchFoundation).call(this, Object.assign(MDCSwitchFoundation.defaultAdapter, adapter)));
      }
      /** @param {boolean} checked */


      _createClass$i(MDCSwitchFoundation, [{
        key: "setChecked",
        value: function setChecked(checked) {
          this.adapter_.setNativeControlChecked(checked);
          this.updateCheckedStyling_(checked);
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          this.adapter_.setNativeControlDisabled(disabled);

          if (disabled) {
            this.adapter_.addClass(cssClasses$1$a.DISABLED);
          } else {
            this.adapter_.removeClass(cssClasses$1$a.DISABLED);
          }
        }
        /**
         * Handles the change event for the switch native control.
         * @param {!Event} evt
         */

      }, {
        key: "handleChange",
        value: function handleChange(evt) {
          this.updateCheckedStyling_(evt.target.checked);
        }
        /**
         * Updates the styling of the switch based on its checked state.
         * @param {boolean} checked
         * @private
         */

      }, {
        key: "updateCheckedStyling_",
        value: function updateCheckedStyling_(checked) {
          if (checked) {
            this.adapter_.addClass(cssClasses$1$a.CHECKED);
          } else {
            this.adapter_.removeClass(cssClasses$1$a.CHECKED);
          }
        }
      }]);

      return MDCSwitchFoundation;
    }(MDCFoundation$i);

    /**
     * @extends MDCComponent<!MDCSwitchFoundation>
     * @implements {MDCSelectionControl}
     */

    var MDCSwitch =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$i(MDCSwitch, _MDCComponent);

      _createClass$i(MDCSwitch, null, [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCSwitch(root);
        }
      }]);

      function MDCSwitch() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$i(this, MDCSwitch);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$i(this, (_getPrototypeOf2 = _getPrototypeOf$i(MDCSwitch)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        /** @private {!Function} */

        _this.changeHandler_;
        return _this;
      }

      _createClass$i(MDCSwitch, [{
        key: "destroy",
        value: function destroy() {
          _get$9(_getPrototypeOf$i(MDCSwitch.prototype), "destroy", this).call(this);

          this.ripple_.destroy();
          this.nativeControl_.removeEventListener('change', this.changeHandler_);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.changeHandler_ = this.foundation_.handleChange.bind(this.foundation_);
          this.nativeControl_.addEventListener('change', this.changeHandler_); // Sometimes the checked state of the input element is saved in the history.
          // The switch styling should match the checked state of the input element.
          // Do an initial sync between the native control and the foundation.

          this.checked = this.checked;
        }
        /**
         * Returns the state of the native control element, or null if the native control element is not present.
         * @return {?MDCSelectionControlState}
         * @private
         */

      }, {
        key: "initRipple_",

        /**
         * @return {!MDCRipple}
         * @private
         */
        value: function initRipple_() {
          var _this2 = this;

          var RIPPLE_SURFACE_SELECTOR = MDCSwitchFoundation.strings.RIPPLE_SURFACE_SELECTOR;
          var rippleSurface =
          /** @type {!Element} */
          this.root_.querySelector(RIPPLE_SURFACE_SELECTOR);
          var MATCHES = getMatchesProperty$7(HTMLElement.prototype);
          var adapter = Object.assign(MDCRipple$7.createAdapter(this), {
            isUnbounded: function isUnbounded() {
              return true;
            },
            isSurfaceActive: function isSurfaceActive() {
              return _this2.nativeControl_[MATCHES](':active');
            },
            addClass: function addClass(className) {
              return rippleSurface.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return rippleSurface.classList.remove(className);
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.nativeControl_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.nativeControl_.removeEventListener(type, handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return rippleSurface.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return rippleSurface.getBoundingClientRect();
            }
          });
          var foundation = new MDCRippleFoundation$7(adapter);
          return new MDCRipple$7(this.root_, foundation);
        }
        /** @return {!MDCSwitchFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCSwitchFoundation({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            setNativeControlChecked: function setNativeControlChecked(checked) {
              return _this3.nativeControl_.checked = checked;
            },
            setNativeControlDisabled: function setNativeControlDisabled(disabled) {
              return _this3.nativeControl_.disabled = disabled;
            }
          });
        }
        /** @return {!MDCRipple} */

      }, {
        key: "nativeControl_",
        get: function get() {
          var NATIVE_CONTROL_SELECTOR = MDCSwitchFoundation.strings.NATIVE_CONTROL_SELECTOR;
          var el =
          /** @type {?MDCSelectionControlState} */
          this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
          return el;
        }
      }, {
        key: "ripple",
        get: function get() {
          return this.ripple_;
        }
        /** @return {boolean} */

      }, {
        key: "checked",
        get: function get() {
          return this.nativeControl_.checked;
        }
        /** @param {boolean} checked */
        ,
        set: function set(checked) {
          this.foundation_.setChecked(checked);
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get() {
          return this.nativeControl_.disabled;
        }
        /** @param {boolean} disabled */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
      }]);

      return MDCSwitch;
    }(MDCComponent$i);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MDC_SWITCH_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef((/**
         * @return {?}
         */
        function () { return MdcSwitch; })),
        multi: true
    };
    /**
     * Change event object emitted by MdcSwitch.
     */
    var   /**
     * Change event object emitted by MdcSwitch.
     */
    MdcSwitchChange = /** @class */ (function () {
        function MdcSwitchChange(source, checked) {
            this.source = source;
            this.checked = checked;
        }
        return MdcSwitchChange;
    }());
    /** @type {?} */
    var nextUniqueId$7 = 0;
    var MdcSwitch = /** @class */ (function () {
        function MdcSwitch(_changeDetectorRef, ripple, elementRef, _parentFormField) {
            this._changeDetectorRef = _changeDetectorRef;
            this.ripple = ripple;
            this.elementRef = elementRef;
            this._parentFormField = _parentFormField;
            this._uniqueId = "mdc-switch-" + ++nextUniqueId$7;
            this.id = this._uniqueId;
            this.name = null;
            this.tabIndex = 0;
            /**
             * The value attribute of the native input element
             */
            this.value = null;
            this._checked = false;
            this._disabled = false;
            this._required = false;
            /**
             * Used to set the aria-label attribute on the underlying input element.
             */
            this.ariaLabel = null;
            /**
             * Used to set the aria-labelledby attribute on the underlying input element.
             */
            this.ariaLabelledby = null;
            this.change = new core.EventEmitter();
            /**
             * View to model callback called when value changes
             */
            this._onChange = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
            /**
             * View to model callback called when control has been touched
             */
            this._onTouched = (/**
             * @return {?}
             */
            function () { });
            this._foundation = new MDCSwitchFoundation(this._createAdapter());
            if (this._parentFormField) {
                _parentFormField.elementRef.nativeElement.classList.add('mdc-form-field');
            }
        }
        Object.defineProperty(MdcSwitch.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () { return this._checked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this.disabled) {
                    return;
                }
                this._checked = toBoolean(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSwitch.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabledState(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSwitch.prototype, "required", {
            get: /**
             * @return {?}
             */
            function () { return this._required; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._required = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSwitch.prototype, "inputId", {
            get: /**
             * @return {?}
             */
            function () { return (this.id || this._uniqueId) + "-input"; },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcSwitch.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                setNativeControlChecked: (/**
                 * @param {?} checked
                 * @return {?}
                 */
                function (checked) { return _this._getInputElement().checked = checked; }),
                setNativeControlDisabled: (/**
                 * @param {?} disabled
                 * @return {?}
                 */
                function (disabled) { return _this._getInputElement().disabled = disabled; })
            };
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._initRipple();
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSwitch.prototype.onChange = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
            if (this.disabled) {
                return;
            }
            this._foundation.handleChange(evt);
            this._checked = this._inputElement.nativeElement.checked;
            this._foundation.setChecked(this._checked);
            this._emitChangeEvent();
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSwitch.prototype.onInputClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            this._onTouched();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSwitch.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.checked = !!value;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSwitch.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSwitch.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /** Toggles the checked state of the switch. */
        /**
         * Toggles the checked state of the switch.
         * @return {?}
         */
        MdcSwitch.prototype.toggle = /**
         * Toggles the checked state of the switch.
         * @return {?}
         */
        function () {
            this.checked = !this.checked;
            this._onChange(this.checked);
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSwitch.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = toBoolean(disabled);
            this._foundation.setDisabled(this._disabled);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.focus = /**
         * @return {?}
         */
        function () {
            this._inputElement.nativeElement.focus();
        };
        /**
         * @private
         * @return {?}
         */
        MdcSwitch.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.ripple.init({
                surface: this.thumbUnderlay.nativeElement,
                activator: this._inputElement.nativeElement
            }, Object.assign(this.ripple.createAdapter(), {
                isUnbounded: (/**
                 * @return {?}
                 */
                function () { return true; }),
                isSurfaceDisabled: (/**
                 * @return {?}
                 */
                function () { return _this._disabled; })
            }));
        };
        /**
         * Emits a change event on the `change` output. Also notifies the FormControl about the change.
         */
        /**
         * Emits a change event on the `change` output. Also notifies the FormControl about the change.
         * @private
         * @return {?}
         */
        MdcSwitch.prototype._emitChangeEvent = /**
         * Emits a change event on the `change` output. Also notifies the FormControl about the change.
         * @private
         * @return {?}
         */
        function () {
            this._onChange(this.checked);
            this.change.emit(new MdcSwitchChange(this, this.checked));
        };
        /** Retrieves the DOM element of the component input. */
        /**
         * Retrieves the DOM element of the component input.
         * @private
         * @return {?}
         */
        MdcSwitch.prototype._getInputElement = /**
         * Retrieves the DOM element of the component input.
         * @private
         * @return {?}
         */
        function () {
            return this._inputElement.nativeElement;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcSwitch.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcSwitch.decorators = [
            { type: core.Component, args: [{selector: 'mdc-switch',
                        host: {
                            '[id]': 'id',
                            '[attr.tabindex]': '0',
                            'class': 'mdc-switch',
                            '[class.mdc-switch--checked]': 'checked',
                            '[class.mdc-switch--disabled]': 'disabled',
                            '(focus)': '_inputElement.nativeElement.focus()'
                        },
                        template: "\n  <div class=\"mdc-switch__track\"></div>\n  <div #thumbUnderlay class=\"mdc-switch__thumb-underlay\">\n    <div class=\"mdc-switch__thumb\">\n      <input type=\"checkbox\"\n        #input\n        role=\"switch\"\n        class=\"mdc-switch__native-control\"\n        [id]=\"inputId\"\n        [attr.name]=\"name\"\n        [attr.aria-label]=\"ariaLabel\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [tabIndex]=\"tabIndex\"\n        [disabled]=\"disabled\"\n        [required]=\"required\"\n        [checked]=\"checked\"\n        (blur)=\"onBlur()\"\n        (click)=\"onInputClick($event)\"\n        (change)=\"onChange($event)\"/>\n    </div>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [
                            MDC_SWITCH_CONTROL_VALUE_ACCESSOR,
                            { provide: MdcFormFieldControl, useExisting: MdcSwitch },
                            MdcRipple
                        ]
                    },] },
        ];
        /** @nocollapse */
        MdcSwitch.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.ElementRef },
            { type: MdcFormField, decorators: [{ type: core.Optional }] }
        ]; };
        MdcSwitch.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            value: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            required: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            change: [{ type: core.Output }],
            _inputElement: [{ type: core.ViewChild, args: ['input',] }],
            thumbUnderlay: [{ type: core.ViewChild, args: ['thumbUnderlay',] }]
        };
        return MdcSwitch;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcSwitchModule = /** @class */ (function () {
        function MdcSwitchModule() {
        }
        MdcSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [MdcFormFieldModule],
                        exports: [
                            MdcFormFieldModule,
                            MdcSwitch
                        ],
                        declarations: [MdcSwitch]
                    },] },
        ];
        return MdcSwitchModule;
    }());

    function _classCallCheck$j(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$j(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$j(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$j(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$j(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$j(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$j(subClass, superClass);
    }

    function _getPrototypeOf$j(o) {
      _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$j(o);
    }

    function _setPrototypeOf$j(o, p) {
      _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$j(o, p);
    }

    function _assertThisInitialized$j(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$j(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$j(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$j =
    /*#__PURE__*/
    function () {
      _createClass$j(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$j(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$j(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$j =
    /*#__PURE__*/
    function () {
      _createClass$j(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$j());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$j(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$j(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Tab Indicator.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab Indicator into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTabIndicatorAdapter =
    /*#__PURE__*/
    function () {
      function MDCTabIndicatorAdapter() {
        _classCallCheck$j(this, MDCTabIndicatorAdapter);
      }

      _createClass$j(MDCTabIndicatorAdapter, [{
        key: "addClass",

        /**
         * Adds the given className to the root element.
         * @param {string} className The className to add
         */
        value: function addClass(className) {}
        /**
         * Removes the given className from the root element.
         * @param {string} className The className to remove
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the client rect of the content element.
         * @return {!ClientRect}
         */

      }, {
        key: "computeContentClientRect",
        value: function computeContentClientRect() {}
        /**
         * Sets a style property of the content element to the passed value
         * @param {string} propName The style property name to set
         * @param {string} value The style property value
         */

      }, {
        key: "setContentStyleProperty",
        value: function setContentStyleProperty(propName, value) {}
      }]);

      return MDCTabIndicatorAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$j = {
      ACTIVE: 'mdc-tab-indicator--active',
      FADE: 'mdc-tab-indicator--fade',
      NO_TRANSITION: 'mdc-tab-indicator--no-transition'
    };
    /** @enum {string} */

    var strings$h = {
      CONTENT_SELECTOR: '.mdc-tab-indicator__content'
    };

    /**
     * @extends {MDCFoundation<!MDCTabIndicatorAdapter>}
     * @abstract
     */

    var MDCTabIndicatorFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$j(MDCTabIndicatorFoundation, _MDCFoundation);

      _createClass$j(MDCTabIndicatorFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$j;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$h;
        }
        /**
         * @see MDCTabIndicatorAdapter for typing information
         * @return {!MDCTabIndicatorAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabIndicatorAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              computeContentClientRect: function computeContentClientRect() {},
              setContentStyleProperty: function setContentStyleProperty() {}
            }
          );
        }
        /** @param {!MDCTabIndicatorAdapter} adapter */

      }]);

      function MDCTabIndicatorFoundation(adapter) {
        _classCallCheck$j(this, MDCTabIndicatorFoundation);

        return _possibleConstructorReturn$j(this, _getPrototypeOf$j(MDCTabIndicatorFoundation).call(this, Object.assign(MDCTabIndicatorFoundation.defaultAdapter, adapter)));
      }
      /** @return {!ClientRect} */


      _createClass$j(MDCTabIndicatorFoundation, [{
        key: "computeContentClientRect",
        value: function computeContentClientRect() {
          return this.adapter_.computeContentClientRect();
        }
        /**
         * Activates the indicator
         * @param {!ClientRect=} previousIndicatorClientRect
         * @abstract
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {} // eslint-disable-line no-unused-vars

        /** @abstract */

      }, {
        key: "deactivate",
        value: function deactivate() {}
      }]);

      return MDCTabIndicatorFoundation;
    }(MDCFoundation$j);

    /**
     * @extends {MDCTabIndicatorFoundation}
     * @final
     */

    var MDCSlidingTabIndicatorFoundation =
    /*#__PURE__*/
    function (_MDCTabIndicatorFound) {
      _inherits$j(MDCSlidingTabIndicatorFoundation, _MDCTabIndicatorFound);

      function MDCSlidingTabIndicatorFoundation() {
        _classCallCheck$j(this, MDCSlidingTabIndicatorFoundation);

        return _possibleConstructorReturn$j(this, _getPrototypeOf$j(MDCSlidingTabIndicatorFoundation).apply(this, arguments));
      }

      _createClass$j(MDCSlidingTabIndicatorFoundation, [{
        key: "activate",

        /** @param {!ClientRect=} previousIndicatorClientRect */
        value: function activate(previousIndicatorClientRect) {
          // Early exit if no indicator is present to handle cases where an indicator
          // may be activated without a prior indicator state
          if (!previousIndicatorClientRect) {
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            return;
          } // This animation uses the FLIP approach. You can read more about it at the link below:
          // https://aerotwist.com/blog/flip-your-animations/
          // Calculate the dimensions based on the dimensions of the previous indicator


          var currentClientRect = this.computeContentClientRect();
          var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
          var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
          this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
          this.adapter_.setContentStyleProperty('transform', "translateX(".concat(xPosition, "px) scaleX(").concat(widthDelta, ")")); // Force repaint before updating classes and transform to ensure the transform properly takes effect

          this.computeContentClientRect();
          this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
          this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
          this.adapter_.setContentStyleProperty('transform', '');
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        }
      }]);

      return MDCSlidingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation);

    /**
     * @extends {MDCTabIndicatorFoundation}
     * @final
     */

    var MDCFadingTabIndicatorFoundation =
    /*#__PURE__*/
    function (_MDCTabIndicatorFound) {
      _inherits$j(MDCFadingTabIndicatorFoundation, _MDCTabIndicatorFound);

      function MDCFadingTabIndicatorFoundation() {
        _classCallCheck$j(this, MDCFadingTabIndicatorFoundation);

        return _possibleConstructorReturn$j(this, _getPrototypeOf$j(MDCFadingTabIndicatorFoundation).apply(this, arguments));
      }

      _createClass$j(MDCFadingTabIndicatorFoundation, [{
        key: "activate",
        value: function activate() {
          this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        }
      }]);

      return MDCFadingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation);

    /**
     * @extends {MDCComponent<!MDCTabIndicatorFoundation>}
     * @final
     */

    var MDCTabIndicator =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$j(MDCTabIndicator, _MDCComponent);

      _createClass$j(MDCTabIndicator, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTabIndicator}
         */
        value: function attachTo(root) {
          return new MDCTabIndicator(root);
        }
        /**
         * @param {...?} args
         */

      }]);

      function MDCTabIndicator() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$j(this, MDCTabIndicator);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$j(this, (_getPrototypeOf2 = _getPrototypeOf$j(MDCTabIndicator)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {?Element} */

        _this.content_;
        return _this;
      }

      _createClass$j(MDCTabIndicator, [{
        key: "initialize",
        value: function initialize() {
          this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
        }
        /**
         * @return {!ClientRect}
         */

      }, {
        key: "computeContentClientRect",
        value: function computeContentClientRect() {
          return this.foundation_.computeContentClientRect();
        }
        /**
         * @return {!MDCTabIndicatorFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          var adapter =
          /** @type {!MDCTabIndicatorAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            computeContentClientRect: function computeContentClientRect() {
              return _this2.content_.getBoundingClientRect();
            },
            setContentStyleProperty: function setContentStyleProperty(prop, value) {
              return _this2.content_.style.setProperty(prop, value);
            }
          });

          if (this.root_.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
            return new MDCFadingTabIndicatorFoundation(adapter);
          } // Default to the sliding indicator


          return new MDCSlidingTabIndicatorFoundation(adapter);
        }
        /**
         * @param {!ClientRect=} previousIndicatorClientRect
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {
          this.foundation_.activate(previousIndicatorClientRect);
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }]);

      return MDCTabIndicator;
    }(MDCComponent$j);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTabIndicator = /** @class */ (function () {
        function MdcTabIndicator(_platform, _changeDetectorRef, elementRef) {
            this._platform = _platform;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._isFoundationInit = false;
            this._active = false;
            this._fade = false;
            this._icon = null;
        }
        Object.defineProperty(MdcTabIndicator.prototype, "active", {
            get: /**
             * @return {?}
             */
            function () { return this._active; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (this._active !== newValue) {
                    this._active = toBoolean(newValue);
                    this._active ? this.activate(this.computeContentClientRect()) : this.deactivate();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabIndicator.prototype, "fade", {
            get: /**
             * @return {?}
             */
            function () { return this._fade; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._fade) {
                    this._fade = newValue;
                    this._initFoundation();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabIndicator.prototype, "icon", {
            get: /**
             * @return {?}
             */
            function () { return this._icon; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._icon = value;
                this._updateContentClasses();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcTabIndicator.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                computeContentClientRect: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    return _this.content.nativeElement.getBoundingClientRect();
                }),
                setContentStyleProperty: (/**
                 * @param {?} propName
                 * @param {?} value
                 * @return {?}
                 */
                function (propName, value) {
                    return _this.content.nativeElement.style.setProperty(propName, value);
                })
            };
        };
        /**
         * @return {?}
         */
        MdcTabIndicator.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (!this._isFoundationInit) {
                this._initFoundation();
                this._updateContentClasses();
            }
        };
        /**
         * @param {?} previousIndicatorClientRect
         * @return {?}
         */
        MdcTabIndicator.prototype.activate = /**
         * @param {?} previousIndicatorClientRect
         * @return {?}
         */
        function (previousIndicatorClientRect) {
            if (this._foundation) {
                this._foundation.activate(previousIndicatorClientRect);
            }
        };
        /**
         * @return {?}
         */
        MdcTabIndicator.prototype.deactivate = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.deactivate();
            }
        };
        /**
         * @return {?}
         */
        MdcTabIndicator.prototype.computeContentClientRect = /**
         * @return {?}
         */
        function () {
            return this._foundation.computeContentClientRect();
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabIndicator.prototype._initFoundation = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.fade) {
                this._foundation = new MDCFadingTabIndicatorFoundation(this._createAdapter());
            }
            else {
                this._foundation = new MDCSlidingTabIndicatorFoundation(this._createAdapter());
            }
            this._foundation.init();
            this._isFoundationInit = true;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabIndicator.prototype._updateContentClasses = /**
         * @private
         * @return {?}
         */
        function () {
            this.content.nativeElement.classList.remove('mdc-tab-indicator__content--underline');
            this.content.nativeElement.classList.remove('mdc-tab-indicator__content--icon');
            if (this.icon) {
                this.content.nativeElement.classList.add('mdc-tab-indicator__content--icon');
                this.content.nativeElement.classList.add('material-icons');
            }
            else {
                this.content.nativeElement.classList.add('mdc-tab-indicator__content--underline');
            }
            this._changeDetectorRef.markForCheck();
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcTabIndicator.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTabIndicator.decorators = [
            { type: core.Component, args: [{selector: '[mdcTabIndicator], mdc-tab-indicator',
                        exportAs: 'mdcTabIndicator',
                        host: {
                            'class': 'mdc-tab-indicator',
                            '[class.mdc-tab-indicator--active]': 'active',
                            '[class.mdc-tab-indicator--fade]': 'fade'
                        },
                        template: "\n  <span #content class=\"mdc-tab-indicator__content\">\n    <ng-container *ngIf=\"icon\">{{icon}}</ng-container>\n  </span>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcTabIndicator.ctorParameters = function () { return [
            { type: Platform },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcTabIndicator.propDecorators = {
            active: [{ type: core.Input }],
            fade: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            content: [{ type: core.ViewChild, args: ['content',] }]
        };
        return MdcTabIndicator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTabIndicatorModule = /** @class */ (function () {
        function MdcTabIndicatorModule() {
        }
        MdcTabIndicatorModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [MdcTabIndicator],
                        declarations: [MdcTabIndicator]
                    },] },
        ];
        return MdcTabIndicatorModule;
    }());

    function _classCallCheck$k(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$k(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$k(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$k(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$k(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$k(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$k(subClass, superClass);
    }

    function _getPrototypeOf$k(o) {
      _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$k(o);
    }

    function _setPrototypeOf$k(o, p) {
      _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$k(o, p);
    }

    function _assertThisInitialized$k(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$k(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$k(self);
    }

    function _superPropBase$a(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$k(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$a(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$a = Reflect.get;
      } else {
        _get$a = function _get(target, property, receiver) {
          var base = _superPropBase$a(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$a(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$k =
    /*#__PURE__*/
    function () {
      _createClass$k(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$k(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$k(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$k =
    /*#__PURE__*/
    function () {
      _createClass$k(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$k());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$k(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$k(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$8 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$k(this, MDCRippleAdapter);
      }

      _createClass$k(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$k = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$i = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$d = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$8;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$8;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$8(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$8(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$8;

      if (typeof supportsCssVariables_$8 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$8(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$8 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$8() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$8 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$8 = isSupported;
      }

      return supportsPassive_$8 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$8(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$8(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$9 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$9 = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$8 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$8 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$k(MDCRippleFoundation, _MDCFoundation);

      _createClass$k(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$k;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$i;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$d;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$k(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$k(this, _getPrototypeOf$k(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$k(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$9.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$9.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$9.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$9.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$8.length > 0 && activatedTargets$8.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$8.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$8 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$8(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$d.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$k);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$8 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$k(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$k(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$k(this, (_getPrototypeOf2 = _getPrototypeOf$k(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$k(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$8(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$8(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$8(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$8());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$8());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$8());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$8());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$k);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$8 = function RippleCapableSurface() {
      _classCallCheck$k(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$8.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$8.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$8.prototype.disabled;

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Tab Indicator.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab Indicator into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTabIndicatorAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCTabIndicatorAdapter() {
        _classCallCheck$k(this, MDCTabIndicatorAdapter);
      }

      _createClass$k(MDCTabIndicatorAdapter, [{
        key: "addClass",

        /**
         * Adds the given className to the root element.
         * @param {string} className The className to add
         */
        value: function addClass(className) {}
        /**
         * Removes the given className from the root element.
         * @param {string} className The className to remove
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the client rect of the content element.
         * @return {!ClientRect}
         */

      }, {
        key: "computeContentClientRect",
        value: function computeContentClientRect() {}
        /**
         * Sets a style property of the content element to the passed value
         * @param {string} propName The style property name to set
         * @param {string} value The style property value
         */

      }, {
        key: "setContentStyleProperty",
        value: function setContentStyleProperty(propName, value) {}
      }]);

      return MDCTabIndicatorAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1$b = {
      ACTIVE: 'mdc-tab-indicator--active',
      FADE: 'mdc-tab-indicator--fade',
      NO_TRANSITION: 'mdc-tab-indicator--no-transition'
    };
    /** @enum {string} */

    var strings$1$a = {
      CONTENT_SELECTOR: '.mdc-tab-indicator__content'
    };

    /**
     * @extends {MDCFoundation<!MDCTabIndicatorAdapter>}
     * @abstract
     */

    var MDCTabIndicatorFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$k(MDCTabIndicatorFoundation, _MDCFoundation);

      _createClass$k(MDCTabIndicatorFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$1$b;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$a;
        }
        /**
         * @see MDCTabIndicatorAdapter for typing information
         * @return {!MDCTabIndicatorAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabIndicatorAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              computeContentClientRect: function computeContentClientRect() {},
              setContentStyleProperty: function setContentStyleProperty() {}
            }
          );
        }
        /** @param {!MDCTabIndicatorAdapter} adapter */

      }]);

      function MDCTabIndicatorFoundation(adapter) {
        _classCallCheck$k(this, MDCTabIndicatorFoundation);

        return _possibleConstructorReturn$k(this, _getPrototypeOf$k(MDCTabIndicatorFoundation).call(this, Object.assign(MDCTabIndicatorFoundation.defaultAdapter, adapter)));
      }
      /** @return {!ClientRect} */


      _createClass$k(MDCTabIndicatorFoundation, [{
        key: "computeContentClientRect",
        value: function computeContentClientRect() {
          return this.adapter_.computeContentClientRect();
        }
        /**
         * Activates the indicator
         * @param {!ClientRect=} previousIndicatorClientRect
         * @abstract
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {} // eslint-disable-line no-unused-vars

        /** @abstract */

      }, {
        key: "deactivate",
        value: function deactivate() {}
      }]);

      return MDCTabIndicatorFoundation;
    }(MDCFoundation$k);

    /**
     * @extends {MDCTabIndicatorFoundation}
     * @final
     */

    var MDCSlidingTabIndicatorFoundation$1 =
    /*#__PURE__*/
    function (_MDCTabIndicatorFound) {
      _inherits$k(MDCSlidingTabIndicatorFoundation, _MDCTabIndicatorFound);

      function MDCSlidingTabIndicatorFoundation() {
        _classCallCheck$k(this, MDCSlidingTabIndicatorFoundation);

        return _possibleConstructorReturn$k(this, _getPrototypeOf$k(MDCSlidingTabIndicatorFoundation).apply(this, arguments));
      }

      _createClass$k(MDCSlidingTabIndicatorFoundation, [{
        key: "activate",

        /** @param {!ClientRect=} previousIndicatorClientRect */
        value: function activate(previousIndicatorClientRect) {
          // Early exit if no indicator is present to handle cases where an indicator
          // may be activated without a prior indicator state
          if (!previousIndicatorClientRect) {
            this.adapter_.addClass(MDCTabIndicatorFoundation$1.cssClasses.ACTIVE);
            return;
          } // This animation uses the FLIP approach. You can read more about it at the link below:
          // https://aerotwist.com/blog/flip-your-animations/
          // Calculate the dimensions based on the dimensions of the previous indicator


          var currentClientRect = this.computeContentClientRect();
          var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
          var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
          this.adapter_.addClass(MDCTabIndicatorFoundation$1.cssClasses.NO_TRANSITION);
          this.adapter_.setContentStyleProperty('transform', "translateX(".concat(xPosition, "px) scaleX(").concat(widthDelta, ")")); // Force repaint before updating classes and transform to ensure the transform properly takes effect

          this.computeContentClientRect();
          this.adapter_.removeClass(MDCTabIndicatorFoundation$1.cssClasses.NO_TRANSITION);
          this.adapter_.addClass(MDCTabIndicatorFoundation$1.cssClasses.ACTIVE);
          this.adapter_.setContentStyleProperty('transform', '');
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.removeClass(MDCTabIndicatorFoundation$1.cssClasses.ACTIVE);
        }
      }]);

      return MDCSlidingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation$1);

    /**
     * @extends {MDCTabIndicatorFoundation}
     * @final
     */

    var MDCFadingTabIndicatorFoundation$1 =
    /*#__PURE__*/
    function (_MDCTabIndicatorFound) {
      _inherits$k(MDCFadingTabIndicatorFoundation, _MDCTabIndicatorFound);

      function MDCFadingTabIndicatorFoundation() {
        _classCallCheck$k(this, MDCFadingTabIndicatorFoundation);

        return _possibleConstructorReturn$k(this, _getPrototypeOf$k(MDCFadingTabIndicatorFoundation).apply(this, arguments));
      }

      _createClass$k(MDCFadingTabIndicatorFoundation, [{
        key: "activate",
        value: function activate() {
          this.adapter_.addClass(MDCTabIndicatorFoundation$1.cssClasses.ACTIVE);
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.removeClass(MDCTabIndicatorFoundation$1.cssClasses.ACTIVE);
        }
      }]);

      return MDCFadingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation$1);

    /**
     * @extends {MDCComponent<!MDCTabIndicatorFoundation>}
     * @final
     */

    var MDCTabIndicator$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$k(MDCTabIndicator, _MDCComponent);

      _createClass$k(MDCTabIndicator, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTabIndicator}
         */
        value: function attachTo(root) {
          return new MDCTabIndicator(root);
        }
        /**
         * @param {...?} args
         */

      }]);

      function MDCTabIndicator() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$k(this, MDCTabIndicator);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$k(this, (_getPrototypeOf2 = _getPrototypeOf$k(MDCTabIndicator)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {?Element} */

        _this.content_;
        return _this;
      }

      _createClass$k(MDCTabIndicator, [{
        key: "initialize",
        value: function initialize() {
          this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation$1.strings.CONTENT_SELECTOR);
        }
        /**
         * @return {!ClientRect}
         */

      }, {
        key: "computeContentClientRect",
        value: function computeContentClientRect() {
          return this.foundation_.computeContentClientRect();
        }
        /**
         * @return {!MDCTabIndicatorFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          var adapter =
          /** @type {!MDCTabIndicatorAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            computeContentClientRect: function computeContentClientRect() {
              return _this2.content_.getBoundingClientRect();
            },
            setContentStyleProperty: function setContentStyleProperty(prop, value) {
              return _this2.content_.style.setProperty(prop, value);
            }
          });

          if (this.root_.classList.contains(MDCTabIndicatorFoundation$1.cssClasses.FADE)) {
            return new MDCFadingTabIndicatorFoundation$1(adapter);
          } // Default to the sliding indicator


          return new MDCSlidingTabIndicatorFoundation$1(adapter);
        }
        /**
         * @param {!ClientRect=} previousIndicatorClientRect
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {
          this.foundation_.activate(previousIndicatorClientRect);
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }]);

      return MDCTabIndicator;
    }(MDCComponent$k);

    /**
     * Adapter for MDC Tab.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab  into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTabAdapter =
    /*#__PURE__*/
    function () {
      function MDCTabAdapter() {
        _classCallCheck$k(this, MDCTabAdapter);
      }

      _createClass$k(MDCTabAdapter, [{
        key: "addClass",

        /**
         * Adds the given className to the root element.
         * @param {string} className The className to add
         */
        value: function addClass(className) {}
        /**
         * Removes the given className from the root element.
         * @param {string} className The className to remove
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns whether the root element has the given className.
         * @param {string} className The className to remove
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the given attrName of the root element to the given value.
         * @param {string} attr The attribute name to set
         * @param {string} value The value so give the attribute
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Activates the indicator element.
         * @param {!ClientRect=} previousIndicatorClientRect The client rect of the previously activated indicator
         */

      }, {
        key: "activateIndicator",
        value: function activateIndicator(previousIndicatorClientRect) {}
        /** Deactivates the indicator. */

      }, {
        key: "deactivateIndicator",
        value: function deactivateIndicator() {}
        /**
         * Emits the MDCTab:interacted event for use by parent components
         */

      }, {
        key: "notifyInteracted",
        value: function notifyInteracted() {}
        /**
         * Returns the offsetLeft value of the root element.
         * @return {number}
         */

      }, {
        key: "getOffsetLeft",
        value: function getOffsetLeft() {}
        /**
         * Returns the offsetWidth value of the root element.
         * @return {number}
         */

      }, {
        key: "getOffsetWidth",
        value: function getOffsetWidth() {}
        /**
         * Returns the offsetLeft of the content element.
         * @return {number}
         */

      }, {
        key: "getContentOffsetLeft",
        value: function getContentOffsetLeft() {}
        /**
         * Returns the offsetWidth of the content element.
         * @return {number}
         */

      }, {
        key: "getContentOffsetWidth",
        value: function getContentOffsetWidth() {}
        /**
         * Applies focus to the root element
         */

      }, {
        key: "focus",
        value: function focus() {}
      }]);

      return MDCTabAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$2$4 = {
      ACTIVE: 'mdc-tab--active'
    };
    /** @enum {string} */

    var strings$2$5 = {
      ARIA_SELECTED: 'aria-selected',
      RIPPLE_SELECTOR: '.mdc-tab__ripple',
      CONTENT_SELECTOR: '.mdc-tab__content',
      TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
      TABINDEX: 'tabIndex',
      INTERACTED_EVENT: 'MDCTab:interacted'
    };

    /**
     * @extends {MDCFoundation<!MDCTabAdapter>}
     * @final
     */

    var MDCTabFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$k(MDCTabFoundation, _MDCFoundation);

      _createClass$k(MDCTabFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$2$4;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$2$5;
        }
        /**
         * @see MDCTabAdapter for typing information
         * @return {!MDCTabAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setAttr: function setAttr() {},
              activateIndicator: function activateIndicator() {},
              deactivateIndicator: function deactivateIndicator() {},
              notifyInteracted: function notifyInteracted() {},
              getOffsetLeft: function getOffsetLeft() {},
              getOffsetWidth: function getOffsetWidth() {},
              getContentOffsetLeft: function getContentOffsetLeft() {},
              getContentOffsetWidth: function getContentOffsetWidth() {},
              focus: function focus() {}
            }
          );
        }
        /** @param {!MDCTabAdapter} adapter */

      }]);

      function MDCTabFoundation(adapter) {
        var _this;

        _classCallCheck$k(this, MDCTabFoundation);

        _this = _possibleConstructorReturn$k(this, _getPrototypeOf$k(MDCTabFoundation).call(this, Object.assign(MDCTabFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.focusOnActivate_ = true;
        return _this;
      }
      /**
       * Handles the "click" event
       */


      _createClass$k(MDCTabFoundation, [{
        key: "handleClick",
        value: function handleClick() {
          // It's up to the parent component to keep track of the active Tab and
          // ensure we don't activate a Tab that's already active.
          this.adapter_.notifyInteracted();
        }
        /**
         * Returns the Tab's active state
         * @return {boolean}
         */

      }, {
        key: "isActive",
        value: function isActive() {
          return this.adapter_.hasClass(cssClasses$2$4.ACTIVE);
        }
        /**
         * Sets whether the tab should focus itself when activated
         * @param {boolean} focusOnActivate
         */

      }, {
        key: "setFocusOnActivate",
        value: function setFocusOnActivate(focusOnActivate) {
          this.focusOnActivate_ = focusOnActivate;
        }
        /**
         * Activates the Tab
         * @param {!ClientRect=} previousIndicatorClientRect
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {
          this.adapter_.addClass(cssClasses$2$4.ACTIVE);
          this.adapter_.setAttr(strings$2$5.ARIA_SELECTED, 'true');
          this.adapter_.setAttr(strings$2$5.TABINDEX, '0');
          this.adapter_.activateIndicator(previousIndicatorClientRect);

          if (this.focusOnActivate_) {
            this.adapter_.focus();
          }
        }
        /**
         * Deactivates the Tab
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          // Early exit
          if (!this.isActive()) {
            return;
          }

          this.adapter_.removeClass(cssClasses$2$4.ACTIVE);
          this.adapter_.setAttr(strings$2$5.ARIA_SELECTED, 'false');
          this.adapter_.setAttr(strings$2$5.TABINDEX, '-1');
          this.adapter_.deactivateIndicator();
        }
        /**
         * Returns the dimensions of the Tab
         * @return {!MDCTabDimensions}
         */

      }, {
        key: "computeDimensions",
        value: function computeDimensions() {
          var rootWidth = this.adapter_.getOffsetWidth();
          var rootLeft = this.adapter_.getOffsetLeft();
          var contentWidth = this.adapter_.getContentOffsetWidth();
          var contentLeft = this.adapter_.getContentOffsetLeft();
          return {
            rootLeft: rootLeft,
            rootRight: rootLeft + rootWidth,
            contentLeft: rootLeft + contentLeft,
            contentRight: rootLeft + contentLeft + contentWidth
          };
        }
      }]);

      return MDCTabFoundation;
    }(MDCFoundation$k);

    /**
     * @extends {MDCComponent<!MDCTabFoundation>}
     * @final
     */

    var MDCTab =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$k(MDCTab, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCTab() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$k(this, MDCTab);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$k(this, (_getPrototypeOf2 = _getPrototypeOf$k(MDCTab)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {string} */

        _this.id;
        /** @private {?MDCRipple} */

        _this.ripple_;
        /** @private {?MDCTabIndicator} */

        _this.tabIndicator_;
        /** @private {?Element} */

        _this.content_;
        /** @private {?Function} */

        _this.handleClick_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCTab}
       */


      _createClass$k(MDCTab, [{
        key: "initialize",
        value: function initialize() {
          var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el, foundation) {
            return new MDCRipple$8(el, foundation);
          };
          var tabIndicatorFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCTabIndicator$1(el);
          };
          this.id = this.root_.id;
          var rippleSurface = this.root_.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
          var rippleAdapter = Object.assign(MDCRipple$8.createAdapter(
          /** @type {!RippleCapableSurface} */
          this), {
            addClass: function addClass(className) {
              return rippleSurface.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return rippleSurface.classList.remove(className);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return rippleSurface.style.setProperty(varName, value);
            }
          });
          var rippleFoundation = new MDCRippleFoundation$8(rippleAdapter);
          this.ripple_ = rippleFactory(this.root_, rippleFoundation);
          var tabIndicatorElement = this.root_.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
          this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
          this.content_ = this.root_.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
          this.listen('click', this.handleClick_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.unlisten('click',
          /** @type {!Function} */
          this.handleClick_);
          this.ripple_.destroy();

          _get$a(_getPrototypeOf$k(MDCTab.prototype), "destroy", this).call(this);
        }
        /**
         * @return {!MDCTabFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCTabFoundation(
          /** @type {!MDCTabAdapter} */
          {
            setAttr: function setAttr(attr, value) {
              return _this2.root_.setAttribute(attr, value);
            },
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            activateIndicator: function activateIndicator(previousIndicatorClientRect) {
              return _this2.tabIndicator_.activate(previousIndicatorClientRect);
            },
            deactivateIndicator: function deactivateIndicator() {
              return _this2.tabIndicator_.deactivate();
            },
            notifyInteracted: function notifyInteracted() {
              return _this2.emit(MDCTabFoundation.strings.INTERACTED_EVENT, {
                tabId: _this2.id
              }, true
              /* bubble */
              );
            },
            getOffsetLeft: function getOffsetLeft() {
              return _this2.root_.offsetLeft;
            },
            getOffsetWidth: function getOffsetWidth() {
              return _this2.root_.offsetWidth;
            },
            getContentOffsetLeft: function getContentOffsetLeft() {
              return _this2.content_.offsetLeft;
            },
            getContentOffsetWidth: function getContentOffsetWidth() {
              return _this2.content_.offsetWidth;
            },
            focus: function focus() {
              return _this2.root_.focus();
            }
          });
        }
        /**
         * Getter for the active state of the tab
         * @return {boolean}
         */

      }, {
        key: "activate",

        /**
         * Activates the tab
         * @param {!ClientRect=} computeIndicatorClientRect
         */
        value: function activate(computeIndicatorClientRect) {
          this.foundation_.activate(computeIndicatorClientRect);
        }
        /**
         * Deactivates the tab
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Returns the indicator's client rect
         * @return {!ClientRect}
         */

      }, {
        key: "computeIndicatorClientRect",
        value: function computeIndicatorClientRect() {
          return this.tabIndicator_.computeContentClientRect();
        }
        /**
         * @return {!MDCTabDimensions}
         */

      }, {
        key: "computeDimensions",
        value: function computeDimensions() {
          return this.foundation_.computeDimensions();
        }
        /**
         * Focuses the tab
         */

      }, {
        key: "focus",
        value: function focus() {
          this.root_.focus();
        }
      }, {
        key: "active",
        get: function get() {
          return this.foundation_.isActive();
        }
      }, {
        key: "focusOnActivate",
        set: function set(focusOnActivate) {
          this.foundation_.setFocusOnActivate(focusOnActivate);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTab(root);
        }
      }]);

      return MDCTab;
    }(MDCComponent$k);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token used to provide the parent MdcTabBar component to MdcTab.
     * @type {?}
     */
    var MDC_TAB_BAR_PARENT_COMPONENT = new core.InjectionToken('MDC_TAB_BAR_PARENT_COMPONENT');
    /** @type {?} */
    var nextUniqueId$8 = 0;
    var MdcTabLabel = /** @class */ (function () {
        function MdcTabLabel(elementRef) {
            this.elementRef = elementRef;
        }
        MdcTabLabel.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-tab-label, [mdcTabLabel]',
                        host: { 'class': 'mdc-tab__text-label' }
                    },] },
        ];
        /** @nocollapse */
        MdcTabLabel.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcTabLabel;
    }());
    var MdcTabIcon = /** @class */ (function () {
        function MdcTabIcon(elementRef) {
            this.elementRef = elementRef;
        }
        MdcTabIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-tab-icon, [mdcTabIcon]',
                        host: { 'class': 'mdc-tab__icon' }
                    },] },
        ];
        /** @nocollapse */
        MdcTabIcon.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcTabIcon;
    }());
    var MdcTab = /** @class */ (function () {
        function MdcTab(_ngZone, _changeDetectorRef, _ripple, elementRef, _parent) {
            this._ngZone = _ngZone;
            this._changeDetectorRef = _changeDetectorRef;
            this._ripple = _ripple;
            this.elementRef = elementRef;
            this._parent = _parent;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._uniqueId = "mdc-tab-" + ++nextUniqueId$8;
            this.id = this._uniqueId;
            this._stacked = false;
            this._fixed = false;
            this._disabled = false;
            this._focusOnActivate = true;
            this.interacted = new core.EventEmitter();
            this._foundation = new MDCTabFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcTab.prototype, "stacked", {
            get: /**
             * @return {?}
             */
            function () { return this._stacked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._stacked) {
                    this._stacked = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTab.prototype, "fixed", {
            get: /**
             * @return {?}
             */
            function () { return this._fixed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._fixed) {
                    this._fixed = newValue;
                    this._changeDetectorRef.detectChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTab.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTab.prototype, "focusOnActivate", {
            get: /**
             * @return {?}
             */
            function () { return this._focusOnActivate; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._focusOnActivate) {
                    this._focusOnActivate = newValue;
                    this._foundation.setFocusOnActivate(this._focusOnActivate);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcTab.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                setAttr: (/**
                 * @param {?} attr
                 * @param {?} value
                 * @return {?}
                 */
                function (attr, value) { return _this._getHostElement().setAttribute(attr, value); }),
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                activateIndicator: (/**
                 * @param {?} previousIndicatorClientRect
                 * @return {?}
                 */
                function (previousIndicatorClientRect) {
                    return _this.tabIndicator.activate(previousIndicatorClientRect);
                }),
                deactivateIndicator: (/**
                 * @return {?}
                 */
                function () { return _this.tabIndicator.deactivate(); }),
                notifyInteracted: (/**
                 * @return {?}
                 */
                function () { return _this.interacted.emit({ detail: { tabId: _this.id, tab: _this } }); }),
                getOffsetLeft: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().offsetLeft; }),
                getOffsetWidth: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().offsetWidth; }),
                getContentOffsetLeft: (/**
                 * @return {?}
                 */
                function () { return _this.content.nativeElement.offsetLeft; }),
                getContentOffsetWidth: (/**
                 * @return {?}
                 */
                function () { return _this.content.nativeElement.offsetWidth; }),
                focus: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().focus(); })
            };
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._initRipple();
            this._loadListeners();
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._ripple.destroy();
        };
        Object.defineProperty(MdcTab.prototype, "active", {
            /** Getter for the active state of the tab */
            get: /**
             * Getter for the active state of the tab
             * @return {?}
             */
            function () {
                return this._foundation.isActive();
            },
            enumerable: true,
            configurable: true
        });
        /** Activates the tab */
        /**
         * Activates the tab
         * @param {?} computeIndicatorClientRect
         * @return {?}
         */
        MdcTab.prototype.activate = /**
         * Activates the tab
         * @param {?} computeIndicatorClientRect
         * @return {?}
         */
        function (computeIndicatorClientRect) {
            this._foundation.activate(computeIndicatorClientRect);
        };
        /** Deactivates the tab */
        /**
         * Deactivates the tab
         * @return {?}
         */
        MdcTab.prototype.deactivate = /**
         * Deactivates the tab
         * @return {?}
         */
        function () {
            this._foundation.deactivate();
        };
        /** Returns the indicator's client rect */
        /**
         * Returns the indicator's client rect
         * @return {?}
         */
        MdcTab.prototype.computeIndicatorClientRect = /**
         * Returns the indicator's client rect
         * @return {?}
         */
        function () {
            return this.tabIndicator.computeContentClientRect();
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.computeDimensions = /**
         * @return {?}
         */
        function () {
            return this._foundation.computeDimensions();
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.getTabBarParent = /**
         * @return {?}
         */
        function () {
            return this._parent;
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.focus = /**
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
        };
        /**
         * @private
         * @return {?}
         */
        MdcTab.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ripple.init({
                surface: this._getHostElement()
            }, Object.assign(this._ripple.createAdapter(), {
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this.rippleSurface.nativeElement.classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this.rippleSurface.nativeElement.classList.remove(className); }),
                updateCssVariable: (/**
                 * @param {?} varName
                 * @param {?} value
                 * @return {?}
                 */
                function (varName, value) {
                    return _this.rippleSurface.nativeElement.style.setProperty(varName, value);
                }),
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcTab.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._getHostElement(), 'click').pipe(operators.takeUntil(_this._destroy))
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    if (!_this.active && !_this._disabled) {
                        _this._foundation.handleClick();
                    }
                })); }));
            }));
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcTab.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTab.decorators = [
            { type: core.Component, args: [{selector: '[mdcTab], mdc-tab',
                        exportAs: 'mdcTab',
                        host: {
                            '[id]': 'id',
                            'role': 'tab',
                            'class': 'mdc-tab',
                            '[class.mdc-tab--stacked]': 'stacked',
                            '[class.mdc-tab--min-width]': 'fixed',
                            '[class.ngx-mdc-tab--disabled]': 'disabled'
                        },
                        template: "\n  <div #content class=\"mdc-tab__content\">\n    <mdc-icon class=\"mdc-tab__icon\" *ngIf=\"icon\">{{icon}}</mdc-icon>\n    <ng-content select=\"mdc-icon\"></ng-content>\n    <span class=\"mdc-tab__text-label\" *ngIf=\"label\">{{label}}</span>\n    <ng-content></ng-content>\n    <ng-container *ngIf=\"fixed\">\n      <ng-container *ngTemplateOutlet=\"indicator\"></ng-container>\n    </ng-container>\n  </div>\n  <ng-container *ngIf=\"!fixed\">\n    <ng-container *ngTemplateOutlet=\"indicator\"></ng-container>\n  </ng-container>\n  <ng-template #indicator><mdc-tab-indicator></mdc-tab-indicator></ng-template>\n  <div #ripplesurface class=\"mdc-tab__ripple\"></div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcTab.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_TAB_BAR_PARENT_COMPONENT,] }] }
        ]; };
        MdcTab.propDecorators = {
            id: [{ type: core.Input }],
            label: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            stacked: [{ type: core.Input }],
            fixed: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            focusOnActivate: [{ type: core.Input }],
            interacted: [{ type: core.Output }],
            content: [{ type: core.ViewChild, args: ['content',] }],
            rippleSurface: [{ type: core.ViewChild, args: ['ripplesurface',] }],
            tabIndicator: [{ type: core.ViewChild, args: [MdcTabIndicator,] }]
        };
        return MdcTab;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TAB_DECLARATIONS = [
        MdcTab,
        MdcTabIcon,
        MdcTabLabel
    ];
    var MdcTabModule = /** @class */ (function () {
        function MdcTabModule() {
        }
        MdcTabModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            MdcTabIndicatorModule,
                            MdcIconModule
                        ],
                        exports: TAB_DECLARATIONS,
                        declarations: TAB_DECLARATIONS
                    },] },
        ];
        return MdcTabModule;
    }());

    function _classCallCheck$l(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$l(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$l(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$l(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$l(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$l(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$l(subClass, superClass);
    }

    function _getPrototypeOf$l(o) {
      _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$l(o);
    }

    function _setPrototypeOf$l(o, p) {
      _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$l(o, p);
    }

    function _assertThisInitialized$l(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$l(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$l(self);
    }

    function _superPropBase$b(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$l(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$b(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$b = Reflect.get;
      } else {
        _get$b = function _get(target, property, receiver) {
          var base = _superPropBase$b(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$b(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$l =
    /*#__PURE__*/
    function () {
      _createClass$l(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$l(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$l(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$l =
    /*#__PURE__*/
    function () {
      _createClass$l(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$l());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$l(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$l(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * Adapter for MDC Tab Scroller.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab  into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTabScrollerAdapter =
    /*#__PURE__*/
    function () {
      function MDCTabScrollerAdapter() {
        _classCallCheck$l(this, MDCTabScrollerAdapter);
      }

      _createClass$l(MDCTabScrollerAdapter, [{
        key: "addClass",

        /**
         * Adds the given className to the root element.
         * @param {string} className The className to add
         */
        value: function addClass(className) {}
        /**
         * Removes the given className from the root element.
         * @param {string} className The className to remove
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Adds the given className to the scroll area element.
         * @param {string} className The className to add
         */

      }, {
        key: "addScrollAreaClass",
        value: function addScrollAreaClass(className) {}
        /**
         * Returns whether the event target matches given className.
         * @param {EventTarget} evtTarget The event target
         * @param {string} selector The selector to check
         * @return {boolean}
         */

      }, {
        key: "eventTargetMatchesSelector",
        value: function eventTargetMatchesSelector(evtTarget, selector) {}
        /**
         * Sets a style property of the area element to the passed value.
         * @param {string} propName The style property name to set
         * @param {string} value The style property value
         */

      }, {
        key: "setScrollAreaStyleProperty",
        value: function setScrollAreaStyleProperty(propName, value) {}
        /**
         * Sets a style property of the content element to the passed value.
         * @param {string} propName The style property name to set
         * @param {string} value The style property value
         */

      }, {
        key: "setScrollContentStyleProperty",
        value: function setScrollContentStyleProperty(propName, value) {}
        /**
         * Returns the scroll content element's computed style value of the given css property `propertyName`.
         * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getScrollContentStyleValue",
        value: function getScrollContentStyleValue(propertyName) {}
        /**
         * Sets the scrollLeft value of the scroll area element to the passed value.
         * @param {number} scrollLeft The new scrollLeft value
         */

      }, {
        key: "setScrollAreaScrollLeft",
        value: function setScrollAreaScrollLeft(scrollLeft) {}
        /**
         * Returns the scrollLeft value of the scroll area element.
         * @return {number}
         */

      }, {
        key: "getScrollAreaScrollLeft",
        value: function getScrollAreaScrollLeft() {}
        /**
         * Returns the offsetWidth of the scroll content element.
         * @return {number}
         */

      }, {
        key: "getScrollContentOffsetWidth",
        value: function getScrollContentOffsetWidth() {}
        /**
         * Returns the offsetWitdth of the scroll area element.
         * @return {number}
         */

      }, {
        key: "getScrollAreaOffsetWidth",
        value: function getScrollAreaOffsetWidth() {}
        /**
         * Returns the bounding client rect of the scroll area element.
         * @return {!ClientRect}
         */

      }, {
        key: "computeScrollAreaClientRect",
        value: function computeScrollAreaClientRect() {}
        /**
         * Returns the bounding client rect of the scroll content element.
         * @return {!ClientRect}
         */

      }, {
        key: "computeScrollContentClientRect",
        value: function computeScrollContentClientRect() {}
        /**
         * Returns the height of the browser's horizontal scrollbars (in px).
         * @return {number}
         */

      }, {
        key: "computeHorizontalScrollbarHeight",
        value: function computeHorizontalScrollbarHeight() {}
      }]);

      return MDCTabScrollerAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$l = {
      ANIMATING: 'mdc-tab-scroller--animating',
      SCROLL_TEST: 'mdc-tab-scroller__test',
      SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll'
    };
    /** @enum {string} */

    var strings$j = {
      AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
      CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content'
    };

    /* eslint-enable no-unused-vars */

    /**
     * @abstract
     */

    var MDCTabScrollerRTL =
    /*#__PURE__*/
    function () {
      /** @param {!MDCTabScrollerAdapter} adapter */
      function MDCTabScrollerRTL(adapter) {
        _classCallCheck$l(this, MDCTabScrollerRTL);

        /** @private */
        this.adapter_ = adapter;
      }
      /**
       * @param {number} translateX The current translateX position
       * @return {number}
       * @abstract
       */


      _createClass$l(MDCTabScrollerRTL, [{
        key: "getScrollPositionRTL",
        value: function getScrollPositionRTL(translateX) {}
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         * @abstract
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {}
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         * @abstract
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {}
        /**
         * @param {number} scrollX The current scrollX position
         * @param {number} translateX The current translateX position
         * @return {number}
         * @abstract
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX, translateX) {}
      }]);

      return MDCTabScrollerRTL;
    }();

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCTabScrollerRTL}
     * @final
     */

    var MDCTabScrollerRTLDefault =
    /*#__PURE__*/
    function (_MDCTabScrollerRTL) {
      _inherits$l(MDCTabScrollerRTLDefault, _MDCTabScrollerRTL);

      function MDCTabScrollerRTLDefault() {
        _classCallCheck$l(this, MDCTabScrollerRTLDefault);

        return _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabScrollerRTLDefault).apply(this, arguments));
      }

      _createClass$l(MDCTabScrollerRTLDefault, [{
        key: "getScrollPositionRTL",

        /**
         * @return {number}
         */
        value: function getScrollPositionRTL() {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();

          var _this$calculateScroll = this.calculateScrollEdges_(),
              right = _this$calculateScroll.right; // Scroll values on most browsers are ints instead of floats so we round


          return Math.round(right - currentScrollLeft);
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {
          var edges = this.calculateScrollEdges_();
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX) {
          return scrollX;
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: 0,
              right: contentWidth - rootWidth
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.min(Math.max(edges.left, scrollX), edges.right);
        }
      }]);

      return MDCTabScrollerRTLDefault;
    }(MDCTabScrollerRTL);

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCTabScrollerRTL}
     * @final
     */

    var MDCTabScrollerRTLNegative =
    /*#__PURE__*/
    function (_MDCTabScrollerRTL) {
      _inherits$l(MDCTabScrollerRTLNegative, _MDCTabScrollerRTL);

      function MDCTabScrollerRTLNegative() {
        _classCallCheck$l(this, MDCTabScrollerRTLNegative);

        return _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabScrollerRTLNegative).apply(this, arguments));
      }

      _createClass$l(MDCTabScrollerRTLNegative, [{
        key: "getScrollPositionRTL",

        /**
         * @param {number} translateX The current translateX position
         * @return {number}
         */
        value: function getScrollPositionRTL(translateX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          return Math.round(translateX - currentScrollLeft);
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(-scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @param {number} translateX
         * @return {number}
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX, translateX) {
          return scrollX - translateX;
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: rootWidth - contentWidth,
              right: 0
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.max(Math.min(edges.right, scrollX), edges.left);
        }
      }]);

      return MDCTabScrollerRTLNegative;
    }(MDCTabScrollerRTL);

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCTabScrollerRTL}
     * @final
     */

    var MDCTabScrollerRTLReverse =
    /*#__PURE__*/
    function (_MDCTabScrollerRTL) {
      _inherits$l(MDCTabScrollerRTLReverse, _MDCTabScrollerRTL);

      function MDCTabScrollerRTLReverse() {
        _classCallCheck$l(this, MDCTabScrollerRTLReverse);

        return _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabScrollerRTLReverse).apply(this, arguments));
      }

      _createClass$l(MDCTabScrollerRTLReverse, [{
        key: "getScrollPositionRTL",

        /**
         * @param {number} translateX
         * @return {number}
         */
        value: function getScrollPositionRTL(translateX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // Scroll values on most browsers are ints instead of floats so we round

          return Math.round(currentScrollLeft - translateX);
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: currentScrollLeft - clampedScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: currentScrollLeft - clampedScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX, translateX) {
          return scrollX + translateX;
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: contentWidth - rootWidth,
              right: 0
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.min(Math.max(edges.right, scrollX), edges.left);
        }
      }]);

      return MDCTabScrollerRTLReverse;
    }(MDCTabScrollerRTL);

    /**
     * @extends {MDCFoundation<!MDCTabScrollerAdapter>}
     * @final
     */

    var MDCTabScrollerFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$l(MDCTabScrollerFoundation, _MDCFoundation);

      _createClass$l(MDCTabScrollerFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$l;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$j;
        }
        /**
         * @see MDCTabScrollerAdapter for typing information
         * @return {!MDCTabScrollerAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabScrollerAdapter} */
            {
              eventTargetMatchesSelector: function eventTargetMatchesSelector() {},
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              addScrollAreaClass: function addScrollAreaClass() {},
              setScrollAreaStyleProperty: function setScrollAreaStyleProperty() {},
              setScrollContentStyleProperty: function setScrollContentStyleProperty() {},
              getScrollContentStyleValue: function getScrollContentStyleValue() {},
              setScrollAreaScrollLeft: function setScrollAreaScrollLeft() {},
              getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {},
              getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {},
              getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {},
              computeScrollAreaClientRect: function computeScrollAreaClientRect() {},
              computeScrollContentClientRect: function computeScrollContentClientRect() {},
              computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight() {}
            }
          );
        }
        /** @param {!MDCTabScrollerAdapter} adapter */

      }]);

      function MDCTabScrollerFoundation(adapter) {
        var _this;

        _classCallCheck$l(this, MDCTabScrollerFoundation);

        _this = _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabScrollerFoundation).call(this, Object.assign(MDCTabScrollerFoundation.defaultAdapter, adapter)));
        /**
         * This boolean controls whether we should handle the transitionend and interaction events during the animation.
         * @private {boolean}
         */

        _this.isAnimating_ = false;
        /**
         * The MDCTabScrollerRTL instance varies per browser and allows us to encapsulate the peculiar browser behavior
         * of RTL scrolling in it's own class.
         * @private {?MDCTabScrollerRTL}
         */

        _this.rtlScrollerInstance_;
        return _this;
      }

      _createClass$l(MDCTabScrollerFoundation, [{
        key: "init",
        value: function init() {
          // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
          // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
          var horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
          this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
          this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
        }
        /**
         * Computes the current visual scroll position
         * @return {number}
         */

      }, {
        key: "getScrollPosition",
        value: function getScrollPosition() {
          if (this.isRTL_()) {
            return this.computeCurrentScrollPositionRTL_();
          }

          var currentTranslateX = this.calculateCurrentTranslateX_();
          var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
          return scrollLeft - currentTranslateX;
        }
        /**
         * Handles interaction events that occur during transition
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction() {
          // Early exit if we aren't animating
          if (!this.isAnimating_) {
            return;
          } // Prevent other event listeners from handling this event


          this.stopScrollAnimation_();
        }
        /**
         * Handles the transitionend event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Early exit if we aren't animating or the event was triggered by a different element.
          if (!this.isAnimating_ || !this.adapter_.eventTargetMatchesSelector(evt.target, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
            return;
          }

          this.isAnimating_ = false;
          this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
        }
        /**
         * Increment the scroll value by the scrollXIncrement
         * @param {number} scrollXIncrement The value by which to increment the scroll position
         */

      }, {
        key: "incrementScroll",
        value: function incrementScroll(scrollXIncrement) {
          // Early exit for non-operational increment values
          if (scrollXIncrement === 0) {
            return;
          }

          if (this.isRTL_()) {
            return this.incrementScrollRTL_(scrollXIncrement);
          }

          this.incrementScroll_(scrollXIncrement);
        }
        /**
         * Scrolls to the given scrollX value
         * @param {number} scrollX
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(scrollX) {
          if (this.isRTL_()) {
            return this.scrollToRTL_(scrollX);
          }

          this.scrollTo_(scrollX);
        }
        /**
         * Returns the appropriate version of the MDCTabScrollerRTL
         * @return {!MDCTabScrollerRTL}
         */

      }, {
        key: "getRTLScroller",
        value: function getRTLScroller() {
          if (!this.rtlScrollerInstance_) {
            this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
          }

          return this.rtlScrollerInstance_;
        }
        /**
         * Returns the translateX value from a CSS matrix transform function string
         * @return {number}
         * @private
         */

      }, {
        key: "calculateCurrentTranslateX_",
        value: function calculateCurrentTranslateX_() {
          var transformValue = this.adapter_.getScrollContentStyleValue('transform'); // Early exit if no transform is present

          if (transformValue === 'none') {
            return 0;
          } // The transform value comes back as a matrix transformation in the form
          // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
          // we're going to grab all the parenthesized values, strip out tx, and
          // parse it.


          var results = /\((.+)\)/.exec(transformValue)[1];
          var parts = results.split(',');
          return parseFloat(parts[4]);
        }
        /**
         * Calculates a safe scroll value that is > 0 and < the max scroll value
         * @param {number} scrollX The distance to scroll
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.min(Math.max(edges.left, scrollX), edges.right);
        }
        /**
         * @return {number}
         * @private
         */

      }, {
        key: "computeCurrentScrollPositionRTL_",
        value: function computeCurrentScrollPositionRTL_() {
          var translateX = this.calculateCurrentTranslateX_();
          return this.getRTLScroller().getScrollPositionRTL(translateX);
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: 0,
              right: contentWidth - rootWidth
            }
          );
        }
        /**
         * Internal scroll method
         * @param {number} scrollX The new scroll position
         * @private
         */

      }, {
        key: "scrollTo_",
        value: function scrollTo_(scrollX) {
          var currentScrollX = this.getScrollPosition();
          var safeScrollX = this.clampScrollValue_(scrollX);
          var scrollDelta = safeScrollX - currentScrollX;
          this.animate_(
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta
          });
        }
        /**
         * Internal RTL scroll method
         * @param {number} scrollX The new scroll position
         * @private
         */

      }, {
        key: "scrollToRTL_",
        value: function scrollToRTL_(scrollX) {
          var animation = this.getRTLScroller().scrollToRTL(scrollX);
          this.animate_(animation);
        }
        /**
         * Internal increment scroll method
         * @param {number} scrollX The new scroll position increment
         * @private
         */

      }, {
        key: "incrementScroll_",
        value: function incrementScroll_(scrollX) {
          var currentScrollX = this.getScrollPosition();
          var targetScrollX = scrollX + currentScrollX;
          var safeScrollX = this.clampScrollValue_(targetScrollX);
          var scrollDelta = safeScrollX - currentScrollX;
          this.animate_(
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta
          });
        }
        /**
         * Internal incremenet scroll RTL method
         * @param {number} scrollX The new scroll position RTL increment
         * @private
         */

      }, {
        key: "incrementScrollRTL_",
        value: function incrementScrollRTL_(scrollX) {
          var animation = this.getRTLScroller().incrementScrollRTL(scrollX);
          this.animate_(animation);
        }
        /**
         * Animates the tab scrolling
         * @param {!MDCTabScrollerAnimation} animation The animation to apply
         * @private
         */

      }, {
        key: "animate_",
        value: function animate_(animation) {
          var _this2 = this;

          // Early exit if translateX is 0, which means there's no animation to perform
          if (animation.scrollDelta === 0) {
            return;
          }

          this.stopScrollAnimation_(); // This animation uses the FLIP approach.
          // Read more here: https://aerotwist.com/blog/flip-your-animations/

          this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
          this.adapter_.setScrollContentStyleProperty('transform', "translateX(".concat(animation.scrollDelta, "px)")); // Force repaint

          this.adapter_.computeScrollAreaClientRect();
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);

            _this2.adapter_.setScrollContentStyleProperty('transform', 'none');
          });
          this.isAnimating_ = true;
        }
        /**
         * Stops scroll animation
         * @private
         */

      }, {
        key: "stopScrollAnimation_",
        value: function stopScrollAnimation_() {
          this.isAnimating_ = false;
          var currentScrollPosition = this.getAnimatingScrollPosition_();
          this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
          this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
          this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
        }
        /**
         * Gets the current scroll position during animation
         * @return {number}
         * @private
         */

      }, {
        key: "getAnimatingScrollPosition_",
        value: function getAnimatingScrollPosition_() {
          var currentTranslateX = this.calculateCurrentTranslateX_();
          var scrollLeft = this.adapter_.getScrollAreaScrollLeft();

          if (this.isRTL_()) {
            return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
          }

          return scrollLeft - currentTranslateX;
        }
        /**
         * Determines the RTL Scroller to use
         * @return {!MDCTabScrollerRTL}
         * @private
         */

      }, {
        key: "rtlScrollerFactory_",
        value: function rtlScrollerFactory_() {
          // Browsers have three different implementations of scrollLeft in RTL mode,
          // dependent on the browser. The behavior is based off the max LTR
          // scrollleft value and 0.
          //
          // * Default scrolling in RTL *
          //    - Left-most value: 0
          //    - Right-most value: Max LTR scrollLeft value
          //
          // * Negative scrolling in RTL *
          //    - Left-most value: Negated max LTR scrollLeft value
          //    - Right-most value: 0
          //
          // * Reverse scrolling in RTL *
          //    - Left-most value: Max LTR scrollLeft value
          //    - Right-most value: 0
          //
          // We use those principles below to determine which RTL scrollLeft
          // behavior is implemented in the current browser.
          var initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
          var newScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // If the newScrollLeft value is negative,then we know that the browser has
          // implemented negative RTL scrolling, since all other implementations have
          // only positive values.

          if (newScrollLeft < 0) {
            // Undo the scrollLeft test check
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
            return new MDCTabScrollerRTLNegative(this.adapter_);
          }

          var rootClientRect = this.adapter_.computeScrollAreaClientRect();
          var contentClientRect = this.adapter_.computeScrollContentClientRect();
          var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right); // Undo the scrollLeft test check

          this.adapter_.setScrollAreaScrollLeft(initialScrollLeft); // By calculating the clientRect of the root element and the clientRect of
          // the content element, we can determine how much the scroll value changed
          // when we performed the scrollLeft subtraction above.

          if (rightEdgeDelta === newScrollLeft) {
            return new MDCTabScrollerRTLReverse(this.adapter_);
          }

          return new MDCTabScrollerRTLDefault(this.adapter_);
        }
        /**
         * @return {boolean}
         * @private
         */

      }, {
        key: "isRTL_",
        value: function isRTL_() {
          return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
        }
      }]);

      return MDCTabScrollerFoundation;
    }(MDCFoundation$l);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
     * @private {number|undefined}
     */

    var horizontalScrollbarHeight_;
    /**
     * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
     * May return 0 (e.g. on OS X browsers under default configuration).
     * @param {!Document} documentObj
     * @param {boolean=} shouldCacheResult
     * @return {number}
     */

    function computeHorizontalScrollbarHeight(documentObj) {
      var shouldCacheResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
        return horizontalScrollbarHeight_;
      }

      var el = documentObj.createElement('div');
      el.classList.add(cssClasses$l.SCROLL_TEST);
      documentObj.body.appendChild(el);
      var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
      documentObj.body.removeChild(el);

      if (shouldCacheResult) {
        horizontalScrollbarHeight_ = horizontalScrollbarHeight;
      }

      return horizontalScrollbarHeight;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$9(HTMLElementPrototype) {
      return ['msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }

    /**
     * @extends {MDCComponent<!MDCTabScrollerFoundation>}
     * @final
     */

    var MDCTabScroller =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$l(MDCTabScroller, _MDCComponent);

      _createClass$l(MDCTabScroller, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTabScroller}
         */
        value: function attachTo(root) {
          return new MDCTabScroller(root);
        }
      }]);

      function MDCTabScroller() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$l(this, MDCTabScroller);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$l(this, (_getPrototypeOf2 = _getPrototypeOf$l(MDCTabScroller)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.content_;
        /** @private {?Element} */

        _this.area_;
        /** @private {?function(?Event): undefined} */

        _this.handleInteraction_;
        /** @private {?function(!Event): undefined} */

        _this.handleTransitionEnd_;
        return _this;
      }

      _createClass$l(MDCTabScroller, [{
        key: "initialize",
        value: function initialize() {
          this.area_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
          this.content_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.handleInteraction_ = function () {
            return _this2.foundation_.handleInteraction();
          };

          this.handleTransitionEnd_ = function (evt) {
            return _this2.foundation_.handleTransitionEnd(evt);
          };

          this.area_.addEventListener('wheel', this.handleInteraction_);
          this.area_.addEventListener('touchstart', this.handleInteraction_);
          this.area_.addEventListener('pointerdown', this.handleInteraction_);
          this.area_.addEventListener('mousedown', this.handleInteraction_);
          this.area_.addEventListener('keydown', this.handleInteraction_);
          this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$b(_getPrototypeOf$l(MDCTabScroller.prototype), "destroy", this).call(this);

          this.area_.removeEventListener('wheel', this.handleInteraction_);
          this.area_.removeEventListener('touchstart', this.handleInteraction_);
          this.area_.removeEventListener('pointerdown', this.handleInteraction_);
          this.area_.removeEventListener('mousedown', this.handleInteraction_);
          this.area_.removeEventListener('keydown', this.handleInteraction_);
          this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
        }
        /**
         * @return {!MDCTabScrollerFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          var adapter =
          /** @type {!MDCTabScrollerAdapter} */
          {
            eventTargetMatchesSelector: function eventTargetMatchesSelector(evtTarget, selector) {
              var MATCHES = getMatchesProperty$9(HTMLElement.prototype);
              return evtTarget[MATCHES](selector);
            },
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            addScrollAreaClass: function addScrollAreaClass(className) {
              return _this3.area_.classList.add(className);
            },
            setScrollAreaStyleProperty: function setScrollAreaStyleProperty(prop, value) {
              return _this3.area_.style.setProperty(prop, value);
            },
            setScrollContentStyleProperty: function setScrollContentStyleProperty(prop, value) {
              return _this3.content_.style.setProperty(prop, value);
            },
            getScrollContentStyleValue: function getScrollContentStyleValue(propName) {
              return window.getComputedStyle(_this3.content_).getPropertyValue(propName);
            },
            setScrollAreaScrollLeft: function setScrollAreaScrollLeft(scrollX) {
              return _this3.area_.scrollLeft = scrollX;
            },
            getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {
              return _this3.area_.scrollLeft;
            },
            getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {
              return _this3.content_.offsetWidth;
            },
            getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {
              return _this3.area_.offsetWidth;
            },
            computeScrollAreaClientRect: function computeScrollAreaClientRect() {
              return _this3.area_.getBoundingClientRect();
            },
            computeScrollContentClientRect: function computeScrollContentClientRect() {
              return _this3.content_.getBoundingClientRect();
            },
            computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight$1() {
              return computeHorizontalScrollbarHeight(document);
            }
          };
          return new MDCTabScrollerFoundation(adapter);
        }
        /**
         * Returns the current visual scroll position
         * @return {number}
         */

      }, {
        key: "getScrollPosition",
        value: function getScrollPosition() {
          return this.foundation_.getScrollPosition();
        }
        /**
         * Returns the width of the scroll content
         * @return {number}
         */

      }, {
        key: "getScrollContentWidth",
        value: function getScrollContentWidth() {
          return this.content_.offsetWidth;
        }
        /**
         * Increments the scroll value by the given amount
         * @param {number} scrollXIncrement The pixel value by which to increment the scroll value
         */

      }, {
        key: "incrementScroll",
        value: function incrementScroll(scrollXIncrement) {
          this.foundation_.incrementScroll(scrollXIncrement);
        }
        /**
         * Scrolls to the given pixel position
         * @param {number} scrollX The pixel value to scroll to
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(scrollX) {
          this.foundation_.scrollTo(scrollX);
        }
      }]);

      return MDCTabScroller;
    }(MDCComponent$l);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SCROLLER_EVENTS = [
        'keydown',
        'mousedown',
        'pointerdown',
        'touchstart',
        'wheel'
    ];
    var MdcTabScroller = /** @class */ (function () {
        function MdcTabScroller(_ngZone, _platform, elementRef) {
            this._ngZone = _ngZone;
            this._platform = _platform;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._align = null;
            this._scrollAreaEventsSubscription = null;
            this._foundation = new MDCTabScrollerFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcTabScroller.prototype, "align", {
            get: /**
             * @return {?}
             */
            function () { return this._align; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setAlign(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabScroller.prototype, "scrollAreaEvents", {
            /** Combined stream of all of the scroll area events. */
            get: /**
             * Combined stream of all of the scroll area events.
             * @return {?}
             */
            function () {
                var _this = this;
                return rxjs.merge.apply(void 0, SCROLLER_EVENTS.map((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) { return rxjs.fromEvent(_this._getScrollArea(), evt); })));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcTabScroller.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                eventTargetMatchesSelector: (/**
                 * @param {?} evtTarget
                 * @param {?} selector
                 * @return {?}
                 */
                function (evtTarget, selector) {
                    /** @type {?} */
                    var MATCHES = getMatchesProperty$9(HTMLElement.prototype);
                    return evtTarget[MATCHES](selector);
                }),
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                addScrollAreaClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this.area.nativeElement.classList.add(className); }),
                setScrollAreaStyleProperty: (/**
                 * @param {?} propName
                 * @param {?} value
                 * @return {?}
                 */
                function (propName, value) {
                    return _this.area.nativeElement.style.setProperty(propName, value);
                }),
                setScrollContentStyleProperty: (/**
                 * @param {?} propName
                 * @param {?} value
                 * @return {?}
                 */
                function (propName, value) {
                    return _this.content.nativeElement.style.setProperty(propName, value);
                }),
                getScrollContentStyleValue: (/**
                 * @param {?} propName
                 * @return {?}
                 */
                function (propName) {
                    return _this._platform.isBrowser ? window.getComputedStyle(_this.content.nativeElement).getPropertyValue(propName) : '';
                }),
                setScrollAreaScrollLeft: (/**
                 * @param {?} scrollX
                 * @return {?}
                 */
                function (scrollX) { return _this.area.nativeElement.scrollLeft = scrollX; }),
                getScrollAreaScrollLeft: (/**
                 * @return {?}
                 */
                function () { return _this.area.nativeElement.scrollLeft; }),
                getScrollContentOffsetWidth: (/**
                 * @return {?}
                 */
                function () { return _this.content.nativeElement.offsetWidth; }),
                getScrollAreaOffsetWidth: (/**
                 * @return {?}
                 */
                function () { return _this.area.nativeElement.offsetWidth; }),
                computeScrollAreaClientRect: (/**
                 * @return {?}
                 */
                function () {
                    return _this._platform.isBrowser ? _this.area.nativeElement.getBoundingClientRect() : {};
                }),
                computeScrollContentClientRect: (/**
                 * @return {?}
                 */
                function () {
                    return _this._platform.isBrowser ? _this.content.nativeElement.getBoundingClientRect() : {};
                }),
                computeHorizontalScrollbarHeight: (/**
                 * @return {?}
                 */
                function () {
                    return _this._platform.isBrowser ? computeHorizontalScrollbarHeight(document) : 0;
                })
            };
        };
        /**
         * @return {?}
         */
        MdcTabScroller.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._loadListeners();
        };
        /**
         * @return {?}
         */
        MdcTabScroller.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            if (this._scrollAreaEventsSubscription) {
                this._scrollAreaEventsSubscription.unsubscribe();
            }
        };
        /**
         * @param {?} align
         * @return {?}
         */
        MdcTabScroller.prototype.setAlign = /**
         * @param {?} align
         * @return {?}
         */
        function (align) {
            this._getHostElement().classList.remove("mdc-tab-scroller--align-" + this._align);
            this._align = align;
            if (align) {
                this._getHostElement().classList.add("mdc-tab-scroller--align-" + align);
            }
        };
        /** Returns the current visual scroll position */
        /**
         * Returns the current visual scroll position
         * @return {?}
         */
        MdcTabScroller.prototype.getScrollPosition = /**
         * Returns the current visual scroll position
         * @return {?}
         */
        function () {
            if (!this._platform.isBrowser) {
                return -1;
            }
            return this._foundation.getScrollPosition();
        };
        /** Returns the width of the scroll content */
        /**
         * Returns the width of the scroll content
         * @return {?}
         */
        MdcTabScroller.prototype.getScrollContentWidth = /**
         * Returns the width of the scroll content
         * @return {?}
         */
        function () {
            return this.content.nativeElement.offsetWidth;
        };
        /** Increments the scroll value by the given amount */
        /**
         * Increments the scroll value by the given amount
         * @param {?} scrollXIncrement
         * @return {?}
         */
        MdcTabScroller.prototype.incrementScroll = /**
         * Increments the scroll value by the given amount
         * @param {?} scrollXIncrement
         * @return {?}
         */
        function (scrollXIncrement) {
            if (!this._platform.isBrowser) {
                return -1;
            }
            this._foundation.incrementScroll(scrollXIncrement);
        };
        /** Scrolls to the given pixel position */
        /**
         * Scrolls to the given pixel position
         * @param {?} scrollX
         * @return {?}
         */
        MdcTabScroller.prototype.scrollTo = /**
         * Scrolls to the given pixel position
         * @param {?} scrollX
         * @return {?}
         */
        function (scrollX) {
            this._foundation.scrollTo(scrollX);
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabScroller.prototype._loadListeners = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._scrollAreaEventsSubscription = this.scrollAreaEvents.pipe()
                .subscribe((/**
             * @return {?}
             */
            function () { return _this._foundation.handleInteraction(); }));
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this._getScrollContent(), 'transitionend')
                    .pipe(operators.takeUntil(_this._destroy), operators.filter((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    return e.target === _this._getScrollContent();
                })))
                    .subscribe((/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this._foundation.handleTransitionEnd(evt); })); }));
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabScroller.prototype._getScrollArea = /**
         * @private
         * @return {?}
         */
        function () {
            return this.area.nativeElement;
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabScroller.prototype._getScrollContent = /**
         * @private
         * @return {?}
         */
        function () {
            return this.content.nativeElement;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcTabScroller.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTabScroller.decorators = [
            { type: core.Component, args: [{selector: '[mdcTabScroller], mdc-tab-scroller',
                        exportAs: 'mdcTabScroller',
                        host: {
                            'class': 'mdc-tab-scroller'
                        },
                        template: "\n  <div #area class=\"mdc-tab-scroller__scroll-area\">\n    <div #content class=\"mdc-tab-scroller__scroll-content\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcTabScroller.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: Platform },
            { type: core.ElementRef }
        ]; };
        MdcTabScroller.propDecorators = {
            align: [{ type: core.Input }],
            area: [{ type: core.ViewChild, args: ['area',] }],
            content: [{ type: core.ViewChild, args: ['content',] }]
        };
        return MdcTabScroller;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTabScrollerModule = /** @class */ (function () {
        function MdcTabScrollerModule() {
        }
        MdcTabScrollerModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcTabScroller],
                        declarations: [MdcTabScroller]
                    },] },
        ];
        return MdcTabScrollerModule;
    }());

    function _classCallCheck$m(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$m(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$m(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$m(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$m(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$m(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$m(subClass, superClass);
    }

    function _getPrototypeOf$m(o) {
      _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$m(o);
    }

    function _setPrototypeOf$m(o, p) {
      _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$m(o, p);
    }

    function _assertThisInitialized$m(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$m(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$m(self);
    }

    function _superPropBase$c(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$m(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$c(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$c = Reflect.get;
      } else {
        _get$c = function _get(target, property, receiver) {
          var base = _superPropBase$c(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$c(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$m =
    /*#__PURE__*/
    function () {
      _createClass$m(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$m(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$m(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$m =
    /*#__PURE__*/
    function () {
      _createClass$m(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$m());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$m(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$m(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$9 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$m(this, MDCRippleAdapter);
      }

      _createClass$m(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$m = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$k = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$e = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$9;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$9;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$9(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$9(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$9;

      if (typeof supportsCssVariables_$9 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$9(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$9 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$9() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$9 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$9 = isSupported;
      }

      return supportsPassive_$9 ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$a(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$9(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$a = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$a = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$9 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$9 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCRippleFoundation, _MDCFoundation);

      _createClass$m(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$m;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$k;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$e;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$m(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$m(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$a.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$a.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$a.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$a.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$9.length > 0 && activatedTargets$9.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$9.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$9 = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$9(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$e.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$m);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$9 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$m(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$m(this, (_getPrototypeOf2 = _getPrototypeOf$m(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$m(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$9(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$a(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$9(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$9());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$9());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$9());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$9());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$m);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$9 = function RippleCapableSurface() {
      _classCallCheck$m(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$9.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$9.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$9.prototype.disabled;

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Tab Indicator.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab Indicator into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTabIndicatorAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCTabIndicatorAdapter() {
        _classCallCheck$m(this, MDCTabIndicatorAdapter);
      }

      _createClass$m(MDCTabIndicatorAdapter, [{
        key: "addClass",

        /**
         * Adds the given className to the root element.
         * @param {string} className The className to add
         */
        value: function addClass(className) {}
        /**
         * Removes the given className from the root element.
         * @param {string} className The className to remove
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the client rect of the content element.
         * @return {!ClientRect}
         */

      }, {
        key: "computeContentClientRect",
        value: function computeContentClientRect() {}
        /**
         * Sets a style property of the content element to the passed value
         * @param {string} propName The style property name to set
         * @param {string} value The style property value
         */

      }, {
        key: "setContentStyleProperty",
        value: function setContentStyleProperty(propName, value) {}
      }]);

      return MDCTabIndicatorAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$1$c = {
      ACTIVE: 'mdc-tab-indicator--active',
      FADE: 'mdc-tab-indicator--fade',
      NO_TRANSITION: 'mdc-tab-indicator--no-transition'
    };
    /** @enum {string} */

    var strings$1$b = {
      CONTENT_SELECTOR: '.mdc-tab-indicator__content'
    };

    /**
     * @extends {MDCFoundation<!MDCTabIndicatorAdapter>}
     * @abstract
     */

    var MDCTabIndicatorFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCTabIndicatorFoundation, _MDCFoundation);

      _createClass$m(MDCTabIndicatorFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$1$c;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$b;
        }
        /**
         * @see MDCTabIndicatorAdapter for typing information
         * @return {!MDCTabIndicatorAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabIndicatorAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              computeContentClientRect: function computeContentClientRect() {},
              setContentStyleProperty: function setContentStyleProperty() {}
            }
          );
        }
        /** @param {!MDCTabIndicatorAdapter} adapter */

      }]);

      function MDCTabIndicatorFoundation(adapter) {
        _classCallCheck$m(this, MDCTabIndicatorFoundation);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTabIndicatorFoundation).call(this, Object.assign(MDCTabIndicatorFoundation.defaultAdapter, adapter)));
      }
      /** @return {!ClientRect} */


      _createClass$m(MDCTabIndicatorFoundation, [{
        key: "computeContentClientRect",
        value: function computeContentClientRect() {
          return this.adapter_.computeContentClientRect();
        }
        /**
         * Activates the indicator
         * @param {!ClientRect=} previousIndicatorClientRect
         * @abstract
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {} // eslint-disable-line no-unused-vars

        /** @abstract */

      }, {
        key: "deactivate",
        value: function deactivate() {}
      }]);

      return MDCTabIndicatorFoundation;
    }(MDCFoundation$m);

    /**
     * @extends {MDCTabIndicatorFoundation}
     * @final
     */

    var MDCSlidingTabIndicatorFoundation$2 =
    /*#__PURE__*/
    function (_MDCTabIndicatorFound) {
      _inherits$m(MDCSlidingTabIndicatorFoundation, _MDCTabIndicatorFound);

      function MDCSlidingTabIndicatorFoundation() {
        _classCallCheck$m(this, MDCSlidingTabIndicatorFoundation);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCSlidingTabIndicatorFoundation).apply(this, arguments));
      }

      _createClass$m(MDCSlidingTabIndicatorFoundation, [{
        key: "activate",

        /** @param {!ClientRect=} previousIndicatorClientRect */
        value: function activate(previousIndicatorClientRect) {
          // Early exit if no indicator is present to handle cases where an indicator
          // may be activated without a prior indicator state
          if (!previousIndicatorClientRect) {
            this.adapter_.addClass(MDCTabIndicatorFoundation$2.cssClasses.ACTIVE);
            return;
          } // This animation uses the FLIP approach. You can read more about it at the link below:
          // https://aerotwist.com/blog/flip-your-animations/
          // Calculate the dimensions based on the dimensions of the previous indicator


          var currentClientRect = this.computeContentClientRect();
          var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
          var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
          this.adapter_.addClass(MDCTabIndicatorFoundation$2.cssClasses.NO_TRANSITION);
          this.adapter_.setContentStyleProperty('transform', "translateX(".concat(xPosition, "px) scaleX(").concat(widthDelta, ")")); // Force repaint before updating classes and transform to ensure the transform properly takes effect

          this.computeContentClientRect();
          this.adapter_.removeClass(MDCTabIndicatorFoundation$2.cssClasses.NO_TRANSITION);
          this.adapter_.addClass(MDCTabIndicatorFoundation$2.cssClasses.ACTIVE);
          this.adapter_.setContentStyleProperty('transform', '');
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.removeClass(MDCTabIndicatorFoundation$2.cssClasses.ACTIVE);
        }
      }]);

      return MDCSlidingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation$2);

    /**
     * @extends {MDCTabIndicatorFoundation}
     * @final
     */

    var MDCFadingTabIndicatorFoundation$2 =
    /*#__PURE__*/
    function (_MDCTabIndicatorFound) {
      _inherits$m(MDCFadingTabIndicatorFoundation, _MDCTabIndicatorFound);

      function MDCFadingTabIndicatorFoundation() {
        _classCallCheck$m(this, MDCFadingTabIndicatorFoundation);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCFadingTabIndicatorFoundation).apply(this, arguments));
      }

      _createClass$m(MDCFadingTabIndicatorFoundation, [{
        key: "activate",
        value: function activate() {
          this.adapter_.addClass(MDCTabIndicatorFoundation$2.cssClasses.ACTIVE);
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.removeClass(MDCTabIndicatorFoundation$2.cssClasses.ACTIVE);
        }
      }]);

      return MDCFadingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation$2);

    /**
     * @extends {MDCComponent<!MDCTabIndicatorFoundation>}
     * @final
     */

    var MDCTabIndicator$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCTabIndicator, _MDCComponent);

      _createClass$m(MDCTabIndicator, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTabIndicator}
         */
        value: function attachTo(root) {
          return new MDCTabIndicator(root);
        }
        /**
         * @param {...?} args
         */

      }]);

      function MDCTabIndicator() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$m(this, MDCTabIndicator);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$m(this, (_getPrototypeOf2 = _getPrototypeOf$m(MDCTabIndicator)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {?Element} */

        _this.content_;
        return _this;
      }

      _createClass$m(MDCTabIndicator, [{
        key: "initialize",
        value: function initialize() {
          this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation$2.strings.CONTENT_SELECTOR);
        }
        /**
         * @return {!ClientRect}
         */

      }, {
        key: "computeContentClientRect",
        value: function computeContentClientRect() {
          return this.foundation_.computeContentClientRect();
        }
        /**
         * @return {!MDCTabIndicatorFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          var adapter =
          /** @type {!MDCTabIndicatorAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            computeContentClientRect: function computeContentClientRect() {
              return _this2.content_.getBoundingClientRect();
            },
            setContentStyleProperty: function setContentStyleProperty(prop, value) {
              return _this2.content_.style.setProperty(prop, value);
            }
          });

          if (this.root_.classList.contains(MDCTabIndicatorFoundation$2.cssClasses.FADE)) {
            return new MDCFadingTabIndicatorFoundation$2(adapter);
          } // Default to the sliding indicator


          return new MDCSlidingTabIndicatorFoundation$2(adapter);
        }
        /**
         * @param {!ClientRect=} previousIndicatorClientRect
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {
          this.foundation_.activate(previousIndicatorClientRect);
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }]);

      return MDCTabIndicator;
    }(MDCComponent$m);

    /**
     * Adapter for MDC Tab.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab  into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTabAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCTabAdapter() {
        _classCallCheck$m(this, MDCTabAdapter);
      }

      _createClass$m(MDCTabAdapter, [{
        key: "addClass",

        /**
         * Adds the given className to the root element.
         * @param {string} className The className to add
         */
        value: function addClass(className) {}
        /**
         * Removes the given className from the root element.
         * @param {string} className The className to remove
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns whether the root element has the given className.
         * @param {string} className The className to remove
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the given attrName of the root element to the given value.
         * @param {string} attr The attribute name to set
         * @param {string} value The value so give the attribute
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Activates the indicator element.
         * @param {!ClientRect=} previousIndicatorClientRect The client rect of the previously activated indicator
         */

      }, {
        key: "activateIndicator",
        value: function activateIndicator(previousIndicatorClientRect) {}
        /** Deactivates the indicator. */

      }, {
        key: "deactivateIndicator",
        value: function deactivateIndicator() {}
        /**
         * Emits the MDCTab:interacted event for use by parent components
         */

      }, {
        key: "notifyInteracted",
        value: function notifyInteracted() {}
        /**
         * Returns the offsetLeft value of the root element.
         * @return {number}
         */

      }, {
        key: "getOffsetLeft",
        value: function getOffsetLeft() {}
        /**
         * Returns the offsetWidth value of the root element.
         * @return {number}
         */

      }, {
        key: "getOffsetWidth",
        value: function getOffsetWidth() {}
        /**
         * Returns the offsetLeft of the content element.
         * @return {number}
         */

      }, {
        key: "getContentOffsetLeft",
        value: function getContentOffsetLeft() {}
        /**
         * Returns the offsetWidth of the content element.
         * @return {number}
         */

      }, {
        key: "getContentOffsetWidth",
        value: function getContentOffsetWidth() {}
        /**
         * Applies focus to the root element
         */

      }, {
        key: "focus",
        value: function focus() {}
      }]);

      return MDCTabAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$2$5 = {
      ACTIVE: 'mdc-tab--active'
    };
    /** @enum {string} */

    var strings$2$6 = {
      ARIA_SELECTED: 'aria-selected',
      RIPPLE_SELECTOR: '.mdc-tab__ripple',
      CONTENT_SELECTOR: '.mdc-tab__content',
      TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
      TABINDEX: 'tabIndex',
      INTERACTED_EVENT: 'MDCTab:interacted'
    };

    /**
     * @extends {MDCFoundation<!MDCTabAdapter>}
     * @final
     */

    var MDCTabFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCTabFoundation, _MDCFoundation);

      _createClass$m(MDCTabFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$2$5;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$2$6;
        }
        /**
         * @see MDCTabAdapter for typing information
         * @return {!MDCTabAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setAttr: function setAttr() {},
              activateIndicator: function activateIndicator() {},
              deactivateIndicator: function deactivateIndicator() {},
              notifyInteracted: function notifyInteracted() {},
              getOffsetLeft: function getOffsetLeft() {},
              getOffsetWidth: function getOffsetWidth() {},
              getContentOffsetLeft: function getContentOffsetLeft() {},
              getContentOffsetWidth: function getContentOffsetWidth() {},
              focus: function focus() {}
            }
          );
        }
        /** @param {!MDCTabAdapter} adapter */

      }]);

      function MDCTabFoundation(adapter) {
        var _this;

        _classCallCheck$m(this, MDCTabFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTabFoundation).call(this, Object.assign(MDCTabFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.focusOnActivate_ = true;
        return _this;
      }
      /**
       * Handles the "click" event
       */


      _createClass$m(MDCTabFoundation, [{
        key: "handleClick",
        value: function handleClick() {
          // It's up to the parent component to keep track of the active Tab and
          // ensure we don't activate a Tab that's already active.
          this.adapter_.notifyInteracted();
        }
        /**
         * Returns the Tab's active state
         * @return {boolean}
         */

      }, {
        key: "isActive",
        value: function isActive() {
          return this.adapter_.hasClass(cssClasses$2$5.ACTIVE);
        }
        /**
         * Sets whether the tab should focus itself when activated
         * @param {boolean} focusOnActivate
         */

      }, {
        key: "setFocusOnActivate",
        value: function setFocusOnActivate(focusOnActivate) {
          this.focusOnActivate_ = focusOnActivate;
        }
        /**
         * Activates the Tab
         * @param {!ClientRect=} previousIndicatorClientRect
         */

      }, {
        key: "activate",
        value: function activate(previousIndicatorClientRect) {
          this.adapter_.addClass(cssClasses$2$5.ACTIVE);
          this.adapter_.setAttr(strings$2$6.ARIA_SELECTED, 'true');
          this.adapter_.setAttr(strings$2$6.TABINDEX, '0');
          this.adapter_.activateIndicator(previousIndicatorClientRect);

          if (this.focusOnActivate_) {
            this.adapter_.focus();
          }
        }
        /**
         * Deactivates the Tab
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          // Early exit
          if (!this.isActive()) {
            return;
          }

          this.adapter_.removeClass(cssClasses$2$5.ACTIVE);
          this.adapter_.setAttr(strings$2$6.ARIA_SELECTED, 'false');
          this.adapter_.setAttr(strings$2$6.TABINDEX, '-1');
          this.adapter_.deactivateIndicator();
        }
        /**
         * Returns the dimensions of the Tab
         * @return {!MDCTabDimensions}
         */

      }, {
        key: "computeDimensions",
        value: function computeDimensions() {
          var rootWidth = this.adapter_.getOffsetWidth();
          var rootLeft = this.adapter_.getOffsetLeft();
          var contentWidth = this.adapter_.getContentOffsetWidth();
          var contentLeft = this.adapter_.getContentOffsetLeft();
          return {
            rootLeft: rootLeft,
            rootRight: rootLeft + rootWidth,
            contentLeft: rootLeft + contentLeft,
            contentRight: rootLeft + contentLeft + contentWidth
          };
        }
      }]);

      return MDCTabFoundation;
    }(MDCFoundation$m);

    /**
     * @extends {MDCComponent<!MDCTabFoundation>}
     * @final
     */

    var MDCTab$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCTab, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCTab() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$m(this, MDCTab);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$m(this, (_getPrototypeOf2 = _getPrototypeOf$m(MDCTab)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {string} */

        _this.id;
        /** @private {?MDCRipple} */

        _this.ripple_;
        /** @private {?MDCTabIndicator} */

        _this.tabIndicator_;
        /** @private {?Element} */

        _this.content_;
        /** @private {?Function} */

        _this.handleClick_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCTab}
       */


      _createClass$m(MDCTab, [{
        key: "initialize",
        value: function initialize() {
          var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el, foundation) {
            return new MDCRipple$9(el, foundation);
          };
          var tabIndicatorFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCTabIndicator$2(el);
          };
          this.id = this.root_.id;
          var rippleSurface = this.root_.querySelector(MDCTabFoundation$1.strings.RIPPLE_SELECTOR);
          var rippleAdapter = Object.assign(MDCRipple$9.createAdapter(
          /** @type {!RippleCapableSurface} */
          this), {
            addClass: function addClass(className) {
              return rippleSurface.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return rippleSurface.classList.remove(className);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return rippleSurface.style.setProperty(varName, value);
            }
          });
          var rippleFoundation = new MDCRippleFoundation$9(rippleAdapter);
          this.ripple_ = rippleFactory(this.root_, rippleFoundation);
          var tabIndicatorElement = this.root_.querySelector(MDCTabFoundation$1.strings.TAB_INDICATOR_SELECTOR);
          this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
          this.content_ = this.root_.querySelector(MDCTabFoundation$1.strings.CONTENT_SELECTOR);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
          this.listen('click', this.handleClick_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.unlisten('click',
          /** @type {!Function} */
          this.handleClick_);
          this.ripple_.destroy();

          _get$c(_getPrototypeOf$m(MDCTab.prototype), "destroy", this).call(this);
        }
        /**
         * @return {!MDCTabFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCTabFoundation$1(
          /** @type {!MDCTabAdapter} */
          {
            setAttr: function setAttr(attr, value) {
              return _this2.root_.setAttribute(attr, value);
            },
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            activateIndicator: function activateIndicator(previousIndicatorClientRect) {
              return _this2.tabIndicator_.activate(previousIndicatorClientRect);
            },
            deactivateIndicator: function deactivateIndicator() {
              return _this2.tabIndicator_.deactivate();
            },
            notifyInteracted: function notifyInteracted() {
              return _this2.emit(MDCTabFoundation$1.strings.INTERACTED_EVENT, {
                tabId: _this2.id
              }, true
              /* bubble */
              );
            },
            getOffsetLeft: function getOffsetLeft() {
              return _this2.root_.offsetLeft;
            },
            getOffsetWidth: function getOffsetWidth() {
              return _this2.root_.offsetWidth;
            },
            getContentOffsetLeft: function getContentOffsetLeft() {
              return _this2.content_.offsetLeft;
            },
            getContentOffsetWidth: function getContentOffsetWidth() {
              return _this2.content_.offsetWidth;
            },
            focus: function focus() {
              return _this2.root_.focus();
            }
          });
        }
        /**
         * Getter for the active state of the tab
         * @return {boolean}
         */

      }, {
        key: "activate",

        /**
         * Activates the tab
         * @param {!ClientRect=} computeIndicatorClientRect
         */
        value: function activate(computeIndicatorClientRect) {
          this.foundation_.activate(computeIndicatorClientRect);
        }
        /**
         * Deactivates the tab
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Returns the indicator's client rect
         * @return {!ClientRect}
         */

      }, {
        key: "computeIndicatorClientRect",
        value: function computeIndicatorClientRect() {
          return this.tabIndicator_.computeContentClientRect();
        }
        /**
         * @return {!MDCTabDimensions}
         */

      }, {
        key: "computeDimensions",
        value: function computeDimensions() {
          return this.foundation_.computeDimensions();
        }
        /**
         * Focuses the tab
         */

      }, {
        key: "focus",
        value: function focus() {
          this.root_.focus();
        }
      }, {
        key: "active",
        get: function get() {
          return this.foundation_.isActive();
        }
      }, {
        key: "focusOnActivate",
        set: function set(focusOnActivate) {
          this.foundation_.setFocusOnActivate(focusOnActivate);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTab(root);
        }
      }]);

      return MDCTab;
    }(MDCComponent$m);

    /**
     * Adapter for MDC Tab Scroller.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab  into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTabScrollerAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCTabScrollerAdapter() {
        _classCallCheck$m(this, MDCTabScrollerAdapter);
      }

      _createClass$m(MDCTabScrollerAdapter, [{
        key: "addClass",

        /**
         * Adds the given className to the root element.
         * @param {string} className The className to add
         */
        value: function addClass(className) {}
        /**
         * Removes the given className from the root element.
         * @param {string} className The className to remove
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Adds the given className to the scroll area element.
         * @param {string} className The className to add
         */

      }, {
        key: "addScrollAreaClass",
        value: function addScrollAreaClass(className) {}
        /**
         * Returns whether the event target matches given className.
         * @param {EventTarget} evtTarget The event target
         * @param {string} selector The selector to check
         * @return {boolean}
         */

      }, {
        key: "eventTargetMatchesSelector",
        value: function eventTargetMatchesSelector(evtTarget, selector) {}
        /**
         * Sets a style property of the area element to the passed value.
         * @param {string} propName The style property name to set
         * @param {string} value The style property value
         */

      }, {
        key: "setScrollAreaStyleProperty",
        value: function setScrollAreaStyleProperty(propName, value) {}
        /**
         * Sets a style property of the content element to the passed value.
         * @param {string} propName The style property name to set
         * @param {string} value The style property value
         */

      }, {
        key: "setScrollContentStyleProperty",
        value: function setScrollContentStyleProperty(propName, value) {}
        /**
         * Returns the scroll content element's computed style value of the given css property `propertyName`.
         * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getScrollContentStyleValue",
        value: function getScrollContentStyleValue(propertyName) {}
        /**
         * Sets the scrollLeft value of the scroll area element to the passed value.
         * @param {number} scrollLeft The new scrollLeft value
         */

      }, {
        key: "setScrollAreaScrollLeft",
        value: function setScrollAreaScrollLeft(scrollLeft) {}
        /**
         * Returns the scrollLeft value of the scroll area element.
         * @return {number}
         */

      }, {
        key: "getScrollAreaScrollLeft",
        value: function getScrollAreaScrollLeft() {}
        /**
         * Returns the offsetWidth of the scroll content element.
         * @return {number}
         */

      }, {
        key: "getScrollContentOffsetWidth",
        value: function getScrollContentOffsetWidth() {}
        /**
         * Returns the offsetWitdth of the scroll area element.
         * @return {number}
         */

      }, {
        key: "getScrollAreaOffsetWidth",
        value: function getScrollAreaOffsetWidth() {}
        /**
         * Returns the bounding client rect of the scroll area element.
         * @return {!ClientRect}
         */

      }, {
        key: "computeScrollAreaClientRect",
        value: function computeScrollAreaClientRect() {}
        /**
         * Returns the bounding client rect of the scroll content element.
         * @return {!ClientRect}
         */

      }, {
        key: "computeScrollContentClientRect",
        value: function computeScrollContentClientRect() {}
        /**
         * Returns the height of the browser's horizontal scrollbars (in px).
         * @return {number}
         */

      }, {
        key: "computeHorizontalScrollbarHeight",
        value: function computeHorizontalScrollbarHeight() {}
      }]);

      return MDCTabScrollerAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$3$2 = {
      ANIMATING: 'mdc-tab-scroller--animating',
      SCROLL_TEST: 'mdc-tab-scroller__test',
      SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll'
    };
    /** @enum {string} */

    var strings$3$2 = {
      AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
      CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content'
    };

    /* eslint-enable no-unused-vars */

    /**
     * @abstract
     */

    var MDCTabScrollerRTL$1 =
    /*#__PURE__*/
    function () {
      /** @param {!MDCTabScrollerAdapter} adapter */
      function MDCTabScrollerRTL(adapter) {
        _classCallCheck$m(this, MDCTabScrollerRTL);

        /** @private */
        this.adapter_ = adapter;
      }
      /**
       * @param {number} translateX The current translateX position
       * @return {number}
       * @abstract
       */


      _createClass$m(MDCTabScrollerRTL, [{
        key: "getScrollPositionRTL",
        value: function getScrollPositionRTL(translateX) {}
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         * @abstract
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {}
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         * @abstract
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {}
        /**
         * @param {number} scrollX The current scrollX position
         * @param {number} translateX The current translateX position
         * @return {number}
         * @abstract
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX, translateX) {}
      }]);

      return MDCTabScrollerRTL;
    }();

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCTabScrollerRTL}
     * @final
     */

    var MDCTabScrollerRTLDefault$1 =
    /*#__PURE__*/
    function (_MDCTabScrollerRTL) {
      _inherits$m(MDCTabScrollerRTLDefault, _MDCTabScrollerRTL);

      function MDCTabScrollerRTLDefault() {
        _classCallCheck$m(this, MDCTabScrollerRTLDefault);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTabScrollerRTLDefault).apply(this, arguments));
      }

      _createClass$m(MDCTabScrollerRTLDefault, [{
        key: "getScrollPositionRTL",

        /**
         * @return {number}
         */
        value: function getScrollPositionRTL() {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();

          var _this$calculateScroll = this.calculateScrollEdges_(),
              right = _this$calculateScroll.right; // Scroll values on most browsers are ints instead of floats so we round


          return Math.round(right - currentScrollLeft);
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {
          var edges = this.calculateScrollEdges_();
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX) {
          return scrollX;
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: 0,
              right: contentWidth - rootWidth
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.min(Math.max(edges.left, scrollX), edges.right);
        }
      }]);

      return MDCTabScrollerRTLDefault;
    }(MDCTabScrollerRTL$1);

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCTabScrollerRTL}
     * @final
     */

    var MDCTabScrollerRTLNegative$1 =
    /*#__PURE__*/
    function (_MDCTabScrollerRTL) {
      _inherits$m(MDCTabScrollerRTLNegative, _MDCTabScrollerRTL);

      function MDCTabScrollerRTLNegative() {
        _classCallCheck$m(this, MDCTabScrollerRTLNegative);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTabScrollerRTLNegative).apply(this, arguments));
      }

      _createClass$m(MDCTabScrollerRTLNegative, [{
        key: "getScrollPositionRTL",

        /**
         * @param {number} translateX The current translateX position
         * @return {number}
         */
        value: function getScrollPositionRTL(translateX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          return Math.round(translateX - currentScrollLeft);
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(-scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: clampedScrollLeft - currentScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @param {number} translateX
         * @return {number}
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX, translateX) {
          return scrollX - translateX;
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: rootWidth - contentWidth,
              right: 0
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.max(Math.min(edges.right, scrollX), edges.left);
        }
      }]);

      return MDCTabScrollerRTLNegative;
    }(MDCTabScrollerRTL$1);

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCTabScrollerRTL}
     * @final
     */

    var MDCTabScrollerRTLReverse$1 =
    /*#__PURE__*/
    function (_MDCTabScrollerRTL) {
      _inherits$m(MDCTabScrollerRTLReverse, _MDCTabScrollerRTL);

      function MDCTabScrollerRTLReverse() {
        _classCallCheck$m(this, MDCTabScrollerRTLReverse);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTabScrollerRTLReverse).apply(this, arguments));
      }

      _createClass$m(MDCTabScrollerRTLReverse, [{
        key: "getScrollPositionRTL",

        /**
         * @param {number} translateX
         * @return {number}
         */
        value: function getScrollPositionRTL(translateX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // Scroll values on most browsers are ints instead of floats so we round

          return Math.round(currentScrollLeft - translateX);
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "scrollToRTL",
        value: function scrollToRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: currentScrollLeft - clampedScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {!MDCTabScrollerAnimation}
         */

      }, {
        key: "incrementScrollRTL",
        value: function incrementScrollRTL(scrollX) {
          var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
          return (
            /** @type {!MDCTabScrollerAnimation} */
            {
              finalScrollPosition: clampedScrollLeft,
              scrollDelta: currentScrollLeft - clampedScrollLeft
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         */

      }, {
        key: "getAnimatingScrollPosition",
        value: function getAnimatingScrollPosition(scrollX, translateX) {
          return scrollX + translateX;
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: contentWidth - rootWidth,
              right: 0
            }
          );
        }
        /**
         * @param {number} scrollX
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.min(Math.max(edges.right, scrollX), edges.left);
        }
      }]);

      return MDCTabScrollerRTLReverse;
    }(MDCTabScrollerRTL$1);

    /**
     * @extends {MDCFoundation<!MDCTabScrollerAdapter>}
     * @final
     */

    var MDCTabScrollerFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCTabScrollerFoundation, _MDCFoundation);

      _createClass$m(MDCTabScrollerFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$3$2;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$3$2;
        }
        /**
         * @see MDCTabScrollerAdapter for typing information
         * @return {!MDCTabScrollerAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabScrollerAdapter} */
            {
              eventTargetMatchesSelector: function eventTargetMatchesSelector() {},
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              addScrollAreaClass: function addScrollAreaClass() {},
              setScrollAreaStyleProperty: function setScrollAreaStyleProperty() {},
              setScrollContentStyleProperty: function setScrollContentStyleProperty() {},
              getScrollContentStyleValue: function getScrollContentStyleValue() {},
              setScrollAreaScrollLeft: function setScrollAreaScrollLeft() {},
              getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {},
              getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {},
              getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {},
              computeScrollAreaClientRect: function computeScrollAreaClientRect() {},
              computeScrollContentClientRect: function computeScrollContentClientRect() {},
              computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight() {}
            }
          );
        }
        /** @param {!MDCTabScrollerAdapter} adapter */

      }]);

      function MDCTabScrollerFoundation(adapter) {
        var _this;

        _classCallCheck$m(this, MDCTabScrollerFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTabScrollerFoundation).call(this, Object.assign(MDCTabScrollerFoundation.defaultAdapter, adapter)));
        /**
         * This boolean controls whether we should handle the transitionend and interaction events during the animation.
         * @private {boolean}
         */

        _this.isAnimating_ = false;
        /**
         * The MDCTabScrollerRTL instance varies per browser and allows us to encapsulate the peculiar browser behavior
         * of RTL scrolling in it's own class.
         * @private {?MDCTabScrollerRTL}
         */

        _this.rtlScrollerInstance_;
        return _this;
      }

      _createClass$m(MDCTabScrollerFoundation, [{
        key: "init",
        value: function init() {
          // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
          // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
          var horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
          this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
          this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
        }
        /**
         * Computes the current visual scroll position
         * @return {number}
         */

      }, {
        key: "getScrollPosition",
        value: function getScrollPosition() {
          if (this.isRTL_()) {
            return this.computeCurrentScrollPositionRTL_();
          }

          var currentTranslateX = this.calculateCurrentTranslateX_();
          var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
          return scrollLeft - currentTranslateX;
        }
        /**
         * Handles interaction events that occur during transition
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction() {
          // Early exit if we aren't animating
          if (!this.isAnimating_) {
            return;
          } // Prevent other event listeners from handling this event


          this.stopScrollAnimation_();
        }
        /**
         * Handles the transitionend event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Early exit if we aren't animating or the event was triggered by a different element.
          if (!this.isAnimating_ || !this.adapter_.eventTargetMatchesSelector(evt.target, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
            return;
          }

          this.isAnimating_ = false;
          this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
        }
        /**
         * Increment the scroll value by the scrollXIncrement
         * @param {number} scrollXIncrement The value by which to increment the scroll position
         */

      }, {
        key: "incrementScroll",
        value: function incrementScroll(scrollXIncrement) {
          // Early exit for non-operational increment values
          if (scrollXIncrement === 0) {
            return;
          }

          if (this.isRTL_()) {
            return this.incrementScrollRTL_(scrollXIncrement);
          }

          this.incrementScroll_(scrollXIncrement);
        }
        /**
         * Scrolls to the given scrollX value
         * @param {number} scrollX
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(scrollX) {
          if (this.isRTL_()) {
            return this.scrollToRTL_(scrollX);
          }

          this.scrollTo_(scrollX);
        }
        /**
         * Returns the appropriate version of the MDCTabScrollerRTL
         * @return {!MDCTabScrollerRTL}
         */

      }, {
        key: "getRTLScroller",
        value: function getRTLScroller() {
          if (!this.rtlScrollerInstance_) {
            this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
          }

          return this.rtlScrollerInstance_;
        }
        /**
         * Returns the translateX value from a CSS matrix transform function string
         * @return {number}
         * @private
         */

      }, {
        key: "calculateCurrentTranslateX_",
        value: function calculateCurrentTranslateX_() {
          var transformValue = this.adapter_.getScrollContentStyleValue('transform'); // Early exit if no transform is present

          if (transformValue === 'none') {
            return 0;
          } // The transform value comes back as a matrix transformation in the form
          // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
          // we're going to grab all the parenthesized values, strip out tx, and
          // parse it.


          var results = /\((.+)\)/.exec(transformValue)[1];
          var parts = results.split(',');
          return parseFloat(parts[4]);
        }
        /**
         * Calculates a safe scroll value that is > 0 and < the max scroll value
         * @param {number} scrollX The distance to scroll
         * @return {number}
         * @private
         */

      }, {
        key: "clampScrollValue_",
        value: function clampScrollValue_(scrollX) {
          var edges = this.calculateScrollEdges_();
          return Math.min(Math.max(edges.left, scrollX), edges.right);
        }
        /**
         * @return {number}
         * @private
         */

      }, {
        key: "computeCurrentScrollPositionRTL_",
        value: function computeCurrentScrollPositionRTL_() {
          var translateX = this.calculateCurrentTranslateX_();
          return this.getRTLScroller().getScrollPositionRTL(translateX);
        }
        /**
         * @return {!MDCTabScrollerHorizontalEdges}
         * @private
         */

      }, {
        key: "calculateScrollEdges_",
        value: function calculateScrollEdges_() {
          var contentWidth = this.adapter_.getScrollContentOffsetWidth();
          var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
          return (
            /** @type {!MDCTabScrollerHorizontalEdges} */
            {
              left: 0,
              right: contentWidth - rootWidth
            }
          );
        }
        /**
         * Internal scroll method
         * @param {number} scrollX The new scroll position
         * @private
         */

      }, {
        key: "scrollTo_",
        value: function scrollTo_(scrollX) {
          var currentScrollX = this.getScrollPosition();
          var safeScrollX = this.clampScrollValue_(scrollX);
          var scrollDelta = safeScrollX - currentScrollX;
          this.animate_(
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta
          });
        }
        /**
         * Internal RTL scroll method
         * @param {number} scrollX The new scroll position
         * @private
         */

      }, {
        key: "scrollToRTL_",
        value: function scrollToRTL_(scrollX) {
          var animation = this.getRTLScroller().scrollToRTL(scrollX);
          this.animate_(animation);
        }
        /**
         * Internal increment scroll method
         * @param {number} scrollX The new scroll position increment
         * @private
         */

      }, {
        key: "incrementScroll_",
        value: function incrementScroll_(scrollX) {
          var currentScrollX = this.getScrollPosition();
          var targetScrollX = scrollX + currentScrollX;
          var safeScrollX = this.clampScrollValue_(targetScrollX);
          var scrollDelta = safeScrollX - currentScrollX;
          this.animate_(
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta
          });
        }
        /**
         * Internal incremenet scroll RTL method
         * @param {number} scrollX The new scroll position RTL increment
         * @private
         */

      }, {
        key: "incrementScrollRTL_",
        value: function incrementScrollRTL_(scrollX) {
          var animation = this.getRTLScroller().incrementScrollRTL(scrollX);
          this.animate_(animation);
        }
        /**
         * Animates the tab scrolling
         * @param {!MDCTabScrollerAnimation} animation The animation to apply
         * @private
         */

      }, {
        key: "animate_",
        value: function animate_(animation) {
          var _this2 = this;

          // Early exit if translateX is 0, which means there's no animation to perform
          if (animation.scrollDelta === 0) {
            return;
          }

          this.stopScrollAnimation_(); // This animation uses the FLIP approach.
          // Read more here: https://aerotwist.com/blog/flip-your-animations/

          this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
          this.adapter_.setScrollContentStyleProperty('transform', "translateX(".concat(animation.scrollDelta, "px)")); // Force repaint

          this.adapter_.computeScrollAreaClientRect();
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);

            _this2.adapter_.setScrollContentStyleProperty('transform', 'none');
          });
          this.isAnimating_ = true;
        }
        /**
         * Stops scroll animation
         * @private
         */

      }, {
        key: "stopScrollAnimation_",
        value: function stopScrollAnimation_() {
          this.isAnimating_ = false;
          var currentScrollPosition = this.getAnimatingScrollPosition_();
          this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
          this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
          this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
        }
        /**
         * Gets the current scroll position during animation
         * @return {number}
         * @private
         */

      }, {
        key: "getAnimatingScrollPosition_",
        value: function getAnimatingScrollPosition_() {
          var currentTranslateX = this.calculateCurrentTranslateX_();
          var scrollLeft = this.adapter_.getScrollAreaScrollLeft();

          if (this.isRTL_()) {
            return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
          }

          return scrollLeft - currentTranslateX;
        }
        /**
         * Determines the RTL Scroller to use
         * @return {!MDCTabScrollerRTL}
         * @private
         */

      }, {
        key: "rtlScrollerFactory_",
        value: function rtlScrollerFactory_() {
          // Browsers have three different implementations of scrollLeft in RTL mode,
          // dependent on the browser. The behavior is based off the max LTR
          // scrollleft value and 0.
          //
          // * Default scrolling in RTL *
          //    - Left-most value: 0
          //    - Right-most value: Max LTR scrollLeft value
          //
          // * Negative scrolling in RTL *
          //    - Left-most value: Negated max LTR scrollLeft value
          //    - Right-most value: 0
          //
          // * Reverse scrolling in RTL *
          //    - Left-most value: Max LTR scrollLeft value
          //    - Right-most value: 0
          //
          // We use those principles below to determine which RTL scrollLeft
          // behavior is implemented in the current browser.
          var initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
          this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
          var newScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // If the newScrollLeft value is negative,then we know that the browser has
          // implemented negative RTL scrolling, since all other implementations have
          // only positive values.

          if (newScrollLeft < 0) {
            // Undo the scrollLeft test check
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
            return new MDCTabScrollerRTLNegative$1(this.adapter_);
          }

          var rootClientRect = this.adapter_.computeScrollAreaClientRect();
          var contentClientRect = this.adapter_.computeScrollContentClientRect();
          var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right); // Undo the scrollLeft test check

          this.adapter_.setScrollAreaScrollLeft(initialScrollLeft); // By calculating the clientRect of the root element and the clientRect of
          // the content element, we can determine how much the scroll value changed
          // when we performed the scrollLeft subtraction above.

          if (rightEdgeDelta === newScrollLeft) {
            return new MDCTabScrollerRTLReverse$1(this.adapter_);
          }

          return new MDCTabScrollerRTLDefault$1(this.adapter_);
        }
        /**
         * @return {boolean}
         * @private
         */

      }, {
        key: "isRTL_",
        value: function isRTL_() {
          return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
        }
      }]);

      return MDCTabScrollerFoundation;
    }(MDCFoundation$m);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
     * @private {number|undefined}
     */

    var horizontalScrollbarHeight_$1;
    /**
     * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
     * May return 0 (e.g. on OS X browsers under default configuration).
     * @param {!Document} documentObj
     * @param {boolean=} shouldCacheResult
     * @return {number}
     */

    function computeHorizontalScrollbarHeight$1(documentObj) {
      var shouldCacheResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (shouldCacheResult && typeof horizontalScrollbarHeight_$1 !== 'undefined') {
        return horizontalScrollbarHeight_$1;
      }

      var el = documentObj.createElement('div');
      el.classList.add(cssClasses$3$2.SCROLL_TEST);
      documentObj.body.appendChild(el);
      var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
      documentObj.body.removeChild(el);

      if (shouldCacheResult) {
        horizontalScrollbarHeight_$1 = horizontalScrollbarHeight;
      }

      return horizontalScrollbarHeight;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$1$1(HTMLElementPrototype) {
      return ['msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }

    /**
     * @extends {MDCComponent<!MDCTabScrollerFoundation>}
     * @final
     */

    var MDCTabScroller$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCTabScroller, _MDCComponent);

      _createClass$m(MDCTabScroller, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTabScroller}
         */
        value: function attachTo(root) {
          return new MDCTabScroller(root);
        }
      }]);

      function MDCTabScroller() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$m(this, MDCTabScroller);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$m(this, (_getPrototypeOf2 = _getPrototypeOf$m(MDCTabScroller)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.content_;
        /** @private {?Element} */

        _this.area_;
        /** @private {?function(?Event): undefined} */

        _this.handleInteraction_;
        /** @private {?function(!Event): undefined} */

        _this.handleTransitionEnd_;
        return _this;
      }

      _createClass$m(MDCTabScroller, [{
        key: "initialize",
        value: function initialize() {
          this.area_ = this.root_.querySelector(MDCTabScrollerFoundation$1.strings.AREA_SELECTOR);
          this.content_ = this.root_.querySelector(MDCTabScrollerFoundation$1.strings.CONTENT_SELECTOR);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.handleInteraction_ = function () {
            return _this2.foundation_.handleInteraction();
          };

          this.handleTransitionEnd_ = function (evt) {
            return _this2.foundation_.handleTransitionEnd(evt);
          };

          this.area_.addEventListener('wheel', this.handleInteraction_);
          this.area_.addEventListener('touchstart', this.handleInteraction_);
          this.area_.addEventListener('pointerdown', this.handleInteraction_);
          this.area_.addEventListener('mousedown', this.handleInteraction_);
          this.area_.addEventListener('keydown', this.handleInteraction_);
          this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$c(_getPrototypeOf$m(MDCTabScroller.prototype), "destroy", this).call(this);

          this.area_.removeEventListener('wheel', this.handleInteraction_);
          this.area_.removeEventListener('touchstart', this.handleInteraction_);
          this.area_.removeEventListener('pointerdown', this.handleInteraction_);
          this.area_.removeEventListener('mousedown', this.handleInteraction_);
          this.area_.removeEventListener('keydown', this.handleInteraction_);
          this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
        }
        /**
         * @return {!MDCTabScrollerFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          var adapter =
          /** @type {!MDCTabScrollerAdapter} */
          {
            eventTargetMatchesSelector: function eventTargetMatchesSelector(evtTarget, selector) {
              var MATCHES = getMatchesProperty$1$1(HTMLElement.prototype);
              return evtTarget[MATCHES](selector);
            },
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            addScrollAreaClass: function addScrollAreaClass(className) {
              return _this3.area_.classList.add(className);
            },
            setScrollAreaStyleProperty: function setScrollAreaStyleProperty(prop, value) {
              return _this3.area_.style.setProperty(prop, value);
            },
            setScrollContentStyleProperty: function setScrollContentStyleProperty(prop, value) {
              return _this3.content_.style.setProperty(prop, value);
            },
            getScrollContentStyleValue: function getScrollContentStyleValue(propName) {
              return window.getComputedStyle(_this3.content_).getPropertyValue(propName);
            },
            setScrollAreaScrollLeft: function setScrollAreaScrollLeft(scrollX) {
              return _this3.area_.scrollLeft = scrollX;
            },
            getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {
              return _this3.area_.scrollLeft;
            },
            getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {
              return _this3.content_.offsetWidth;
            },
            getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {
              return _this3.area_.offsetWidth;
            },
            computeScrollAreaClientRect: function computeScrollAreaClientRect() {
              return _this3.area_.getBoundingClientRect();
            },
            computeScrollContentClientRect: function computeScrollContentClientRect() {
              return _this3.content_.getBoundingClientRect();
            },
            computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight$1$1() {
              return computeHorizontalScrollbarHeight$1(document);
            }
          };
          return new MDCTabScrollerFoundation$1(adapter);
        }
        /**
         * Returns the current visual scroll position
         * @return {number}
         */

      }, {
        key: "getScrollPosition",
        value: function getScrollPosition() {
          return this.foundation_.getScrollPosition();
        }
        /**
         * Returns the width of the scroll content
         * @return {number}
         */

      }, {
        key: "getScrollContentWidth",
        value: function getScrollContentWidth() {
          return this.content_.offsetWidth;
        }
        /**
         * Increments the scroll value by the given amount
         * @param {number} scrollXIncrement The pixel value by which to increment the scroll value
         */

      }, {
        key: "incrementScroll",
        value: function incrementScroll(scrollXIncrement) {
          this.foundation_.incrementScroll(scrollXIncrement);
        }
        /**
         * Scrolls to the given pixel position
         * @param {number} scrollX The pixel value to scroll to
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(scrollX) {
          this.foundation_.scrollTo(scrollX);
        }
      }]);

      return MDCTabScroller;
    }(MDCComponent$m);

    /* eslint-enable no-unused-vars */

    /**
     * Adapter for MDC Tab Bar.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Tab Bar into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTabBarAdapter =
    /*#__PURE__*/
    function () {
      function MDCTabBarAdapter() {
        _classCallCheck$m(this, MDCTabBarAdapter);
      }

      _createClass$m(MDCTabBarAdapter, [{
        key: "scrollTo",

        /**
         * Scrolls to the given position
         * @param {number} scrollX The position to scroll to
         */
        value: function scrollTo(scrollX) {}
        /**
         * Increments the current scroll position by the given amount
         * @param {number} scrollXIncrement The amount to increment scroll
         */

      }, {
        key: "incrementScroll",
        value: function incrementScroll(scrollXIncrement) {}
        /**
         * Returns the current scroll position
         * @return {number}
         */

      }, {
        key: "getScrollPosition",
        value: function getScrollPosition() {}
        /**
         * Returns the width of the scroll content
         * @return {number}
         */

      }, {
        key: "getScrollContentWidth",
        value: function getScrollContentWidth() {}
        /**
         * Returns the root element's offsetWidth
         * @return {number}
         */

      }, {
        key: "getOffsetWidth",
        value: function getOffsetWidth() {}
        /**
         * Returns if the Tab Bar language direction is RTL
         * @return {boolean}
         */

      }, {
        key: "isRTL",
        value: function isRTL() {}
        /**
         * Sets the tab at the given index to be activated
         * @param {number} index The index of the tab to activate
         */

      }, {
        key: "setActiveTab",
        value: function setActiveTab(index) {}
        /**
         * Activates the tab at the given index with the given client rect
         * @param {number} index The index of the tab to activate
         * @param {!ClientRect} clientRect The client rect of the previously active Tab Indicator
         */

      }, {
        key: "activateTabAtIndex",
        value: function activateTabAtIndex(index, clientRect) {}
        /**
         * Deactivates the tab at the given index
         * @param {number} index The index of the tab to deactivate
         */

      }, {
        key: "deactivateTabAtIndex",
        value: function deactivateTabAtIndex(index) {}
        /**
         * Focuses the tab at the given index
         * @param {number} index The index of the tab to focus
         */

      }, {
        key: "focusTabAtIndex",
        value: function focusTabAtIndex(index) {}
        /**
         * Returns the client rect of the tab's indicator
         * @param {number} index The index of the tab
         * @return {!ClientRect}
         */

      }, {
        key: "getTabIndicatorClientRectAtIndex",
        value: function getTabIndicatorClientRectAtIndex(index) {}
        /**
         * Returns the tab dimensions of the tab at the given index
         * @param {number} index The index of the tab
         * @return {!MDCTabDimensions}
         */

      }, {
        key: "getTabDimensionsAtIndex",
        value: function getTabDimensionsAtIndex(index) {}
        /**
         * Returns the length of the tab list
         * @return {number}
         */

      }, {
        key: "getTabListLength",
        value: function getTabListLength() {}
        /**
         * Returns the index of the previously active tab
         * @return {number}
         */

      }, {
        key: "getPreviousActiveTabIndex",
        value: function getPreviousActiveTabIndex() {}
        /**
         * Returns the index of the focused tab
         * @return {number}
         */

      }, {
        key: "getFocusedTabIndex",
        value: function getFocusedTabIndex() {}
        /**
         * Returns the index of the given tab
         * @param {string} id The ID of the tab whose index to determine
         * @return {number}
         */

      }, {
        key: "getIndexOfTabById",
        value: function getIndexOfTabById(id) {}
        /**
         * Emits the MDCTabBar:activated event
         * @param {number} index The index of the activated tab
         */

      }, {
        key: "notifyTabActivated",
        value: function notifyTabActivated(index) {}
      }]);

      return MDCTabBarAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$4$2 = {
      TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
      TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
      TAB_SELECTOR: '.mdc-tab',
      ARROW_LEFT_KEY: 'ArrowLeft',
      ARROW_RIGHT_KEY: 'ArrowRight',
      END_KEY: 'End',
      HOME_KEY: 'Home',
      ENTER_KEY: 'Enter',
      SPACE_KEY: 'Space'
    };
    /** @enum {number} */

    var numbers$1$4 = {
      EXTRA_SCROLL_AMOUNT: 20,
      ARROW_LEFT_KEYCODE: 37,
      ARROW_RIGHT_KEYCODE: 39,
      END_KEYCODE: 35,
      HOME_KEYCODE: 36,
      ENTER_KEYCODE: 13,
      SPACE_KEYCODE: 32
    };

    /* eslint-enable no-unused-vars */

    /**
     * @type {Set<string>}
     */

    var ACCEPTABLE_KEYS = new Set(); // IE11 has no support for new Set with iterable so we need to initialize this by hand

    ACCEPTABLE_KEYS.add(strings$4$2.ARROW_LEFT_KEY);
    ACCEPTABLE_KEYS.add(strings$4$2.ARROW_RIGHT_KEY);
    ACCEPTABLE_KEYS.add(strings$4$2.END_KEY);
    ACCEPTABLE_KEYS.add(strings$4$2.HOME_KEY);
    ACCEPTABLE_KEYS.add(strings$4$2.ENTER_KEY);
    ACCEPTABLE_KEYS.add(strings$4$2.SPACE_KEY);
    /**
     * @type {Map<number, string>}
     */

    var KEYCODE_MAP = new Map(); // IE11 has no support for new Map with iterable so we need to initialize this by hand

    KEYCODE_MAP.set(numbers$1$4.ARROW_LEFT_KEYCODE, strings$4$2.ARROW_LEFT_KEY);
    KEYCODE_MAP.set(numbers$1$4.ARROW_RIGHT_KEYCODE, strings$4$2.ARROW_RIGHT_KEY);
    KEYCODE_MAP.set(numbers$1$4.END_KEYCODE, strings$4$2.END_KEY);
    KEYCODE_MAP.set(numbers$1$4.HOME_KEYCODE, strings$4$2.HOME_KEY);
    KEYCODE_MAP.set(numbers$1$4.ENTER_KEYCODE, strings$4$2.ENTER_KEY);
    KEYCODE_MAP.set(numbers$1$4.SPACE_KEYCODE, strings$4$2.SPACE_KEY);
    /**
     * @extends {MDCFoundation<!MDCTabBarAdapter>}
     * @final
     */

    var MDCTabBarFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCTabBarFoundation, _MDCFoundation);

      _createClass$m(MDCTabBarFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$4$2;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$4;
        }
        /**
         * @see MDCTabBarAdapter for typing information
         * @return {!MDCTabBarAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTabBarAdapter} */
            {
              scrollTo: function scrollTo() {},
              incrementScroll: function incrementScroll() {},
              getScrollPosition: function getScrollPosition() {},
              getScrollContentWidth: function getScrollContentWidth() {},
              getOffsetWidth: function getOffsetWidth() {},
              isRTL: function isRTL() {},
              setActiveTab: function setActiveTab() {},
              activateTabAtIndex: function activateTabAtIndex() {},
              deactivateTabAtIndex: function deactivateTabAtIndex() {},
              focusTabAtIndex: function focusTabAtIndex() {},
              getTabIndicatorClientRectAtIndex: function getTabIndicatorClientRectAtIndex() {},
              getTabDimensionsAtIndex: function getTabDimensionsAtIndex() {},
              getPreviousActiveTabIndex: function getPreviousActiveTabIndex() {},
              getFocusedTabIndex: function getFocusedTabIndex() {},
              getIndexOfTabById: function getIndexOfTabById() {},
              getTabListLength: function getTabListLength() {},
              notifyTabActivated: function notifyTabActivated() {}
            }
          );
        }
        /**
         * @param {!MDCTabBarAdapter} adapter
         * */

      }]);

      function MDCTabBarFoundation(adapter) {
        var _this;

        _classCallCheck$m(this, MDCTabBarFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTabBarFoundation).call(this, Object.assign(MDCTabBarFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.useAutomaticActivation_ = false;
        return _this;
      }
      /**
       * Switches between automatic and manual activation modes.
       * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
       * @param {boolean} useAutomaticActivation
       */


      _createClass$m(MDCTabBarFoundation, [{
        key: "setUseAutomaticActivation",
        value: function setUseAutomaticActivation(useAutomaticActivation) {
          this.useAutomaticActivation_ = useAutomaticActivation;
        }
        /**
         * Activates the tab at the given index
         * @param {number} index
         */

      }, {
        key: "activateTab",
        value: function activateTab(index) {
          var previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();

          if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
            return;
          }

          this.adapter_.deactivateTabAtIndex(previousActiveIndex);
          this.adapter_.activateTabAtIndex(index, this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex));
          this.scrollIntoView(index);
          this.adapter_.notifyTabActivated(index);
        }
        /**
         * Handles the keydown event
         * @param {!Event} evt
         */

      }, {
        key: "handleKeyDown",
        value: function handleKeyDown(evt) {
          // Get the key from the event
          var key = this.getKeyFromEvent_(evt); // Early exit if the event key isn't one of the keyboard navigation keys

          if (key === undefined) {
            return;
          } // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple


          if (!this.isActivationKey_(key)) {
            evt.preventDefault();
          }

          if (this.useAutomaticActivation_) {
            if (this.isActivationKey_(key)) {
              return;
            }

            var index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
            this.adapter_.setActiveTab(index);
            this.scrollIntoView(index);
          } else {
            var focusedTabIndex = this.adapter_.getFocusedTabIndex();

            if (this.isActivationKey_(key)) {
              this.adapter_.setActiveTab(focusedTabIndex);
            } else {
              var _index = this.determineTargetFromKey_(focusedTabIndex, key);

              this.adapter_.focusTabAtIndex(_index);
              this.scrollIntoView(_index);
            }
          }
        }
        /**
         * Handles the MDCTab:interacted event
         * @param {!CustomEvent} evt
         */

      }, {
        key: "handleTabInteraction",
        value: function handleTabInteraction(evt) {
          this.adapter_.setActiveTab(this.adapter_.getIndexOfTabById(evt.detail.tabId));
        }
        /**
         * Scrolls the tab at the given index into view
         * @param {number} index The tab index to make visible
         */

      }, {
        key: "scrollIntoView",
        value: function scrollIntoView(index) {
          // Early exit if the index is out of range
          if (!this.indexIsInRange_(index)) {
            return;
          } // Always scroll to 0 if scrolling to the 0th index


          if (index === 0) {
            return this.adapter_.scrollTo(0);
          } // Always scroll to the max value if scrolling to the Nth index
          // MDCTabScroller.scrollTo() will never scroll past the max possible value


          if (index === this.adapter_.getTabListLength() - 1) {
            return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
          }

          if (this.isRTL_()) {
            return this.scrollIntoViewRTL_(index);
          }

          this.scrollIntoView_(index);
        }
        /**
         * Private method for determining the index of the destination tab based on what key was pressed
         * @param {number} origin The original index from which to determine the destination
         * @param {string} key The name of the key
         * @return {number}
         * @private
         */

      }, {
        key: "determineTargetFromKey_",
        value: function determineTargetFromKey_(origin, key) {
          var isRTL = this.isRTL_();
          var maxIndex = this.adapter_.getTabListLength() - 1;
          var shouldGoToEnd = key === strings$4$2.END_KEY;
          var shouldDecrement = key === strings$4$2.ARROW_LEFT_KEY && !isRTL || key === strings$4$2.ARROW_RIGHT_KEY && isRTL;
          var shouldIncrement = key === strings$4$2.ARROW_RIGHT_KEY && !isRTL || key === strings$4$2.ARROW_LEFT_KEY && isRTL;
          var index = origin;

          if (shouldGoToEnd) {
            index = maxIndex;
          } else if (shouldDecrement) {
            index -= 1;
          } else if (shouldIncrement) {
            index += 1;
          } else {
            index = 0;
          }

          if (index < 0) {
            index = maxIndex;
          } else if (index > maxIndex) {
            index = 0;
          }

          return index;
        }
        /**
         * Calculates the scroll increment that will make the tab at the given index visible
         * @param {number} index The index of the tab
         * @param {number} nextIndex The index of the next tab
         * @param {number} scrollPosition The current scroll position
         * @param {number} barWidth The width of the Tab Bar
         * @return {number}
         * @private
         */

      }, {
        key: "calculateScrollIncrement_",
        value: function calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth) {
          var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
          var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
          var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
          var leftIncrement = relativeContentRight - numbers$1$4.EXTRA_SCROLL_AMOUNT;
          var rightIncrement = relativeContentLeft + numbers$1$4.EXTRA_SCROLL_AMOUNT;

          if (nextIndex < index) {
            return Math.min(leftIncrement, 0);
          }

          return Math.max(rightIncrement, 0);
        }
        /**
         * Calculates the scroll increment that will make the tab at the given index visible in RTL
         * @param {number} index The index of the tab
         * @param {number} nextIndex The index of the next tab
         * @param {number} scrollPosition The current scroll position
         * @param {number} barWidth The width of the Tab Bar
         * @param {number} scrollContentWidth The width of the scroll content
         * @return {number}
         * @private
         */

      }, {
        key: "calculateScrollIncrementRTL_",
        value: function calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
          var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
          var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
          var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
          var leftIncrement = relativeContentRight + numbers$1$4.EXTRA_SCROLL_AMOUNT;
          var rightIncrement = relativeContentLeft - numbers$1$4.EXTRA_SCROLL_AMOUNT;

          if (nextIndex > index) {
            return Math.max(leftIncrement, 0);
          }

          return Math.min(rightIncrement, 0);
        }
        /**
         * Determines the index of the adjacent tab closest to either edge of the Tab Bar
         * @param {number} index The index of the tab
         * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
         * @param {number} scrollPosition The current scroll position
         * @param {number} barWidth The width of the tab bar
         * @return {number}
         * @private
         */

      }, {
        key: "findAdjacentTabIndexClosestToEdge_",
        value: function findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth) {
          /**
           * Tabs are laid out in the Tab Scroller like this:
           *
           *    Scroll Position
           *    +---+
           *    |   |   Bar Width
           *    |   +-----------------------------------+
           *    |   |                                   |
           *    |   V                                   V
           *    |   +-----------------------------------+
           *    V   |             Tab Scroller          |
           *    +------------+--------------+-------------------+
           *    |    Tab     |      Tab     |        Tab        |
           *    +------------+--------------+-------------------+
           *        |                                   |
           *        +-----------------------------------+
           *
           * To determine the next adjacent index, we look at the Tab root left and
           * Tab root right, both relative to the scroll position. If the Tab root
           * left is less than 0, then we know it's out of view to the left. If the
           * Tab root right minus the bar width is greater than 0, we know the Tab is
           * out of view to the right. From there, we either increment or decrement
           * the index.
           */
          var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
          var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
          var relativeRootDelta = relativeRootLeft + relativeRootRight;
          var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
          var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;

          if (leftEdgeIsCloser) {
            return index - 1;
          }

          if (rightEdgeIsCloser) {
            return index + 1;
          }

          return -1;
        }
        /**
         * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
         * @param {number} index The index of the tab
         * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
         * @param {number} scrollPosition The current scroll position
         * @param {number} barWidth The width of the tab bar
         * @param {number} scrollContentWidth The width of the scroller content
         * @return {number}
         * @private
         */

      }, {
        key: "findAdjacentTabIndexClosestToEdgeRTL_",
        value: function findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
          var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
          var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
          var rootDelta = rootLeft + rootRight;
          var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
          var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;

          if (leftEdgeIsCloser) {
            return index + 1;
          }

          if (rightEdgeIsCloser) {
            return index - 1;
          }

          return -1;
        }
        /**
         * Returns the key associated with a keydown event
         * @param {!Event} evt The keydown event
         * @return {string}
         * @private
         */

      }, {
        key: "getKeyFromEvent_",
        value: function getKeyFromEvent_(evt) {
          if (ACCEPTABLE_KEYS.has(evt.key)) {
            return evt.key;
          }

          return KEYCODE_MAP.get(evt.keyCode);
        }
      }, {
        key: "isActivationKey_",
        value: function isActivationKey_(key) {
          return key === strings$4$2.SPACE_KEY || key === strings$4$2.ENTER_KEY;
        }
        /**
         * Returns whether a given index is inclusively between the ends
         * @param {number} index The index to test
         * @private
         */

      }, {
        key: "indexIsInRange_",
        value: function indexIsInRange_(index) {
          return index >= 0 && index < this.adapter_.getTabListLength();
        }
        /**
         * Returns the view's RTL property
         * @return {boolean}
         * @private
         */

      }, {
        key: "isRTL_",
        value: function isRTL_() {
          return this.adapter_.isRTL();
        }
        /**
         * Scrolls the tab at the given index into view for left-to-right useragents
         * @param {number} index The index of the tab to scroll into view
         * @private
         */

      }, {
        key: "scrollIntoView_",
        value: function scrollIntoView_(index) {
          var scrollPosition = this.adapter_.getScrollPosition();
          var barWidth = this.adapter_.getOffsetWidth();
          var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
          var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);

          if (!this.indexIsInRange_(nextIndex)) {
            return;
          }

          var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
          this.adapter_.incrementScroll(scrollIncrement);
        }
        /**
         * Scrolls the tab at the given index into view in RTL
         * @param {number} index The tab index to make visible
         * @private
         */

      }, {
        key: "scrollIntoViewRTL_",
        value: function scrollIntoViewRTL_(index) {
          var scrollPosition = this.adapter_.getScrollPosition();
          var barWidth = this.adapter_.getOffsetWidth();
          var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
          var scrollWidth = this.adapter_.getScrollContentWidth();
          var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);

          if (!this.indexIsInRange_(nextIndex)) {
            return;
          }

          var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
          this.adapter_.incrementScroll(scrollIncrement);
        }
      }]);

      return MDCTabBarFoundation;
    }(MDCFoundation$m);

    var tabIdCounter = 0;
    /**
     * @extends {MDCComponent<!MDCTabBarFoundation>}
     * @final
     */

    var MDCTabBar =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCTabBar, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCTabBar() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$m(this, MDCTabBar);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$m(this, (_getPrototypeOf2 = _getPrototypeOf$m(MDCTabBar)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Array<!MDCTab>} */

        _this.tabList_;
        /** @private {?MDCTabScroller} */

        _this.tabScroller_;
        /** @private {?function(?Event): undefined} */

        _this.handleTabInteraction_;
        /** @private {?function(?Event): undefined} */

        _this.handleKeyDown_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCTabBar}
       */


      _createClass$m(MDCTabBar, [{
        key: "initialize",

        /**
         * @param {(function(!Element): !MDCTab)=} tabFactory A function which creates a new MDCTab
         * @param {(function(!Element): !MDCTabScroller)=} tabScrollerFactory A function which creates a new MDCTabScroller
         */
        value: function initialize() {
          var tabFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCTab$1(el);
          };
          var tabScrollerFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCTabScroller$1(el);
          };
          this.tabList_ = this.instantiateTabs_(tabFactory);
          this.tabScroller_ = this.instantiateTabScroller_(tabScrollerFactory);
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.handleTabInteraction_ = function (evt) {
            return _this2.foundation_.handleTabInteraction(evt);
          };

          this.handleKeyDown_ = function (evt) {
            return _this2.foundation_.handleKeyDown(evt);
          };

          this.root_.addEventListener(MDCTabFoundation$1.strings.INTERACTED_EVENT, this.handleTabInteraction_);
          this.root_.addEventListener('keydown', this.handleKeyDown_);

          for (var i = 0; i < this.tabList_.length; i++) {
            if (this.tabList_[i].active) {
              this.scrollIntoView(i);
              break;
            }
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$c(_getPrototypeOf$m(MDCTabBar.prototype), "destroy", this).call(this);

          this.root_.removeEventListener(MDCTabFoundation$1.strings.INTERACTED_EVENT, this.handleTabInteraction_);
          this.root_.removeEventListener('keydown', this.handleKeyDown_);
          this.tabList_.forEach(function (tab) {
            return tab.destroy();
          });
          this.tabScroller_.destroy();
        }
        /**
         * @return {!MDCTabBarFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCTabBarFoundation(
          /** @type {!MDCTabBarAdapter} */
          {
            scrollTo: function scrollTo(scrollX) {
              return _this3.tabScroller_.scrollTo(scrollX);
            },
            incrementScroll: function incrementScroll(scrollXIncrement) {
              return _this3.tabScroller_.incrementScroll(scrollXIncrement);
            },
            getScrollPosition: function getScrollPosition() {
              return _this3.tabScroller_.getScrollPosition();
            },
            getScrollContentWidth: function getScrollContentWidth() {
              return _this3.tabScroller_.getScrollContentWidth();
            },
            getOffsetWidth: function getOffsetWidth() {
              return _this3.root_.offsetWidth;
            },
            isRTL: function isRTL() {
              return window.getComputedStyle(_this3.root_).getPropertyValue('direction') === 'rtl';
            },
            setActiveTab: function setActiveTab(index) {
              return _this3.foundation_.activateTab(index);
            },
            activateTabAtIndex: function activateTabAtIndex(index, clientRect) {
              return _this3.tabList_[index].activate(clientRect);
            },
            deactivateTabAtIndex: function deactivateTabAtIndex(index) {
              return _this3.tabList_[index].deactivate();
            },
            focusTabAtIndex: function focusTabAtIndex(index) {
              return _this3.tabList_[index].focus();
            },
            getTabIndicatorClientRectAtIndex: function getTabIndicatorClientRectAtIndex(index) {
              return _this3.tabList_[index].computeIndicatorClientRect();
            },
            getTabDimensionsAtIndex: function getTabDimensionsAtIndex(index) {
              return _this3.tabList_[index].computeDimensions();
            },
            getPreviousActiveTabIndex: function getPreviousActiveTabIndex() {
              for (var i = 0; i < _this3.tabList_.length; i++) {
                if (_this3.tabList_[i].active) {
                  return i;
                }
              }

              return -1;
            },
            getFocusedTabIndex: function getFocusedTabIndex() {
              var tabElements = _this3.getTabElements_();

              var activeElement = document.activeElement;
              return tabElements.indexOf(activeElement);
            },
            getIndexOfTabById: function getIndexOfTabById(id) {
              for (var i = 0; i < _this3.tabList_.length; i++) {
                if (_this3.tabList_[i].id === id) {
                  return i;
                }
              }

              return -1;
            },
            getTabListLength: function getTabListLength() {
              return _this3.tabList_.length;
            },
            notifyTabActivated: function notifyTabActivated(index) {
              return _this3.emit(MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT, {
                index: index
              }, true);
            }
          });
        }
        /**
         * Activates the tab at the given index
         * @param {number} index The index of the tab
         */

      }, {
        key: "activateTab",
        value: function activateTab(index) {
          this.foundation_.activateTab(index);
        }
        /**
         * Scrolls the tab at the given index into view
         * @param {number} index THe index of the tab
         */

      }, {
        key: "scrollIntoView",
        value: function scrollIntoView(index) {
          this.foundation_.scrollIntoView(index);
        }
        /**
         * Returns all the tab elements in a nice clean array
         * @return {!Array<!Element>}
         * @private
         */

      }, {
        key: "getTabElements_",
        value: function getTabElements_() {
          return [].slice.call(this.root_.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
        }
        /**
         * Instantiates tab components on all child tab elements
         * @param {(function(!Element): !MDCTab)} tabFactory
         * @return {!Array<!MDCTab>}
         * @private
         */

      }, {
        key: "instantiateTabs_",
        value: function instantiateTabs_(tabFactory) {
          return this.getTabElements_().map(function (el) {
            el.id = el.id || "mdc-tab-".concat(++tabIdCounter);
            return tabFactory(el);
          });
        }
        /**
         * Instantiates tab scroller component on the child tab scroller element
         * @param {(function(!Element): !MDCTabScroller)} tabScrollerFactory
         * @return {?MDCTabScroller}
         * @private
         */

      }, {
        key: "instantiateTabScroller_",
        value: function instantiateTabScroller_(tabScrollerFactory) {
          var tabScrollerElement = this.root_.querySelector(MDCTabBarFoundation.strings.TAB_SCROLLER_SELECTOR);

          if (tabScrollerElement) {
            return tabScrollerFactory(tabScrollerElement);
          }

          return null;
        }
      }, {
        key: "focusOnActivate",
        set: function set(focusOnActivate) {
          this.tabList_.forEach(function (tab) {
            return tab.focusOnActivate = focusOnActivate;
          });
        }
      }, {
        key: "useAutomaticActivation",
        set: function set(useAutomaticActivation) {
          this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTabBar(root);
        }
      }]);

      return MDCTabBar;
    }(MDCComponent$m);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTabActivatedEvent = /** @class */ (function () {
        function MdcTabActivatedEvent(source, index, tab) {
            this.source = source;
            this.index = index;
            this.tab = tab;
        }
        return MdcTabActivatedEvent;
    }());
    var MdcTabBar = /** @class */ (function () {
        function MdcTabBar(_platform, _changeDetectorRef, elementRef) {
            this._platform = _platform;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._fade = false;
            this._stacked = false;
            this._fixed = false;
            this._align = null;
            this._iconIndicator = null;
            this._useAutomaticActivation = true;
            this._activeTabIndex = 0;
            this._focusOnActivate = true;
            this.activated = new core.EventEmitter();
            /**
             * Subscription to changes in tabs.
             */
            this._changeSubscription = null;
            /**
             * Subscription to interaction events in tabs.
             */
            this._tabInteractionSubscription = null;
            this._foundation = new MDCTabBarFoundation(this._createAdapter());
        }
        Object.defineProperty(MdcTabBar.prototype, "fade", {
            get: /**
             * @return {?}
             */
            function () { return this._fade; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fade = toBoolean(value);
                this._syncTabs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "stacked", {
            get: /**
             * @return {?}
             */
            function () { return this._stacked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._stacked = toBoolean(value);
                this._syncTabs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "fixed", {
            get: /**
             * @return {?}
             */
            function () { return this._fixed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fixed = toBoolean(value);
                this._syncTabs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "align", {
            get: /**
             * @return {?}
             */
            function () { return this._align; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._align = value || 'start';
                this.tabScroller.align = this.align;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "iconIndicator", {
            get: /**
             * @return {?}
             */
            function () { return this._iconIndicator; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._iconIndicator = value;
                this._syncTabs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "useAutomaticActivation", {
            get: /**
             * @return {?}
             */
            function () { return this._useAutomaticActivation; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._useAutomaticActivation = toBoolean(value);
                this._foundation.setUseAutomaticActivation(this._useAutomaticActivation);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "activeTabIndex", {
            get: /**
             * @return {?}
             */
            function () { return this._activeTabIndex; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this.activeTabIndex !== value) {
                    this._activeTabIndex = value;
                    this.activateTab(this.activeTabIndex);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "focusOnActivate", {
            get: /**
             * @return {?}
             */
            function () { return this._focusOnActivate; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._focusOnActivate = toBoolean(value);
                this._syncTabs();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "tabInteractions", {
            /** Combined stream of all of the tab interaction events. */
            get: /**
             * Combined stream of all of the tab interaction events.
             * @return {?}
             */
            function () {
                return rxjs.merge.apply(void 0, this.tabs.map((/**
                 * @param {?} tab
                 * @return {?}
                 */
                function (tab) { return tab.interacted; })));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcTabBar.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                scrollTo: (/**
                 * @param {?} scrollX
                 * @return {?}
                 */
                function (scrollX) { return _this.tabScroller.scrollTo(scrollX); }),
                incrementScroll: (/**
                 * @param {?} scrollXIncrement
                 * @return {?}
                 */
                function (scrollXIncrement) { return _this.tabScroller.incrementScroll(scrollXIncrement); }),
                getScrollPosition: (/**
                 * @return {?}
                 */
                function () { return _this.tabScroller.getScrollPosition(); }),
                getScrollContentWidth: (/**
                 * @return {?}
                 */
                function () { return _this.tabScroller.getScrollContentWidth(); }),
                getOffsetWidth: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().offsetWidth; }),
                isRTL: (/**
                 * @return {?}
                 */
                function () { return _this._platform.isBrowser ?
                    window.getComputedStyle(_this._getHostElement()).getPropertyValue('direction') === 'rtl' : false; }),
                setActiveTab: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) { return _this.activateTab(index); }),
                activateTabAtIndex: (/**
                 * @param {?} index
                 * @param {?} clientRect
                 * @return {?}
                 */
                function (index, clientRect) {
                    if (_this._indexIsInRange(index)) {
                        _this.tabs.toArray()[index].activate(clientRect);
                    }
                }),
                deactivateTabAtIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) {
                    if (_this._indexIsInRange(index)) {
                        _this.tabs.toArray()[index].deactivate();
                    }
                }),
                focusTabAtIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) { return _this.tabs.toArray()[index].focus(); }),
                getTabIndicatorClientRectAtIndex: (/**
                 * @param {?} previousActiveIndex
                 * @return {?}
                 */
                function (previousActiveIndex) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    if (!_this._indexIsInRange(previousActiveIndex)) {
                        previousActiveIndex = _this.activeTabIndex;
                    }
                    return _this.tabs.toArray()[previousActiveIndex].computeIndicatorClientRect();
                }),
                getTabDimensionsAtIndex: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) { return _this.tabs.toArray()[index].computeDimensions(); }),
                getPreviousActiveTabIndex: (/**
                 * @return {?}
                 */
                function () { return _this.tabs.toArray().findIndex((/**
                 * @param {?} _
                 * @return {?}
                 */
                function (_) { return _.active; })); }),
                getFocusedTabIndex: (/**
                 * @return {?}
                 */
                function () {
                    return _this._platform.isBrowser ? _this.tabs.toArray().findIndex((/**
                     * @param {?} tab
                     * @return {?}
                     */
                    function (tab) {
                        return tab.elementRef.nativeElement === (/** @type {?} */ (document.activeElement));
                    })) : -1;
                }),
                getIndexOfTabById: (/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.tabs.toArray().findIndex((/**
                 * @param {?} tab
                 * @return {?}
                 */
                function (tab) { return id === tab.id; })); }),
                getTabListLength: (/**
                 * @return {?}
                 */
                function () { return _this.tabs.length; }),
                notifyTabActivated: (/**
                 * @param {?} index
                 * @return {?}
                 */
                function (index) {
                    return _this.activated.emit({ source: _this, index: index, tab: _this.tabs.toArray()[index] });
                })
            };
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            // When the list changes, re-subscribe
            this._changeSubscription = this.tabs.changes.pipe(operators.startWith(null)).subscribe((/**
             * @return {?}
             */
            function () {
                Promise.resolve().then((/**
                 * @return {?}
                 */
                function () {
                    if (_this.tabs.length) {
                        _this._syncTabs();
                        _this.activateTab(_this.activeTabIndex);
                        _this._resetTabSubscriptions();
                    }
                }));
            }));
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            if (this._changeSubscription) {
                this._changeSubscription.unsubscribe();
            }
            this._dropSubscriptions();
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabBar.prototype._syncTabs = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.tabs) {
                return;
            }
            this.tabs.forEach((/**
             * @param {?} tab
             * @return {?}
             */
            function (tab) {
                tab.stacked = _this._stacked;
                tab.fixed = _this._fixed;
                tab.tabIndicator.fade = _this._fade;
                tab.tabIndicator.icon = _this._iconIndicator;
                tab.focusOnActivate = _this._focusOnActivate;
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabBar.prototype._resetTabSubscriptions = /**
         * @private
         * @return {?}
         */
        function () {
            this._dropSubscriptions();
            this._listenToTabInteraction();
        };
        /**
         * @private
         * @return {?}
         */
        MdcTabBar.prototype._dropSubscriptions = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._tabInteractionSubscription) {
                this._tabInteractionSubscription.unsubscribe();
                this._tabInteractionSubscription = null;
            }
        };
        /** Listens to interaction events on each tab. */
        /**
         * Listens to interaction events on each tab.
         * @private
         * @return {?}
         */
        MdcTabBar.prototype._listenToTabInteraction = /**
         * Listens to interaction events on each tab.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._tabInteractionSubscription = this.tabInteractions.subscribe((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                /** @type {?} */
                var previousTab = _this.getActiveTab();
                if (previousTab) {
                    previousTab.tabIndicator.active = false;
                }
                event.detail.tab.tabIndicator.active = true;
                _this._foundation.handleTabInteraction(event);
            }));
        };
        /** Activates the tab at the given index */
        /**
         * Activates the tab at the given index
         * @param {?} index
         * @return {?}
         */
        MdcTabBar.prototype.activateTab = /**
         * Activates the tab at the given index
         * @param {?} index
         * @return {?}
         */
        function (index) {
            if (!this.tabs) {
                return;
            }
            this.activeTabIndex = index;
            if (this._platform.isBrowser) {
                this._foundation.activateTab(index);
            }
            this._changeDetectorRef.markForCheck();
        };
        /** Scrolls the tab at the given index into view */
        /**
         * Scrolls the tab at the given index into view
         * @param {?} index
         * @return {?}
         */
        MdcTabBar.prototype.scrollIntoView = /**
         * Scrolls the tab at the given index into view
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this._foundation.scrollIntoView(index);
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.getActiveTabIndex = /**
         * @return {?}
         */
        function () {
            return this.tabs.toArray().findIndex((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.active; }));
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.getActiveTab = /**
         * @return {?}
         */
        function () {
            return this.tabs.toArray().find((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _.active; }));
        };
        /** Returns an index for given tab */
        /**
         * Returns an index for given tab
         * @param {?} tab
         * @return {?}
         */
        MdcTabBar.prototype.getTabIndex = /**
         * Returns an index for given tab
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            return this.tabs.toArray().indexOf(tab);
        };
        /** Disable or enable the tab at the given index */
        /**
         * Disable or enable the tab at the given index
         * @param {?} index
         * @param {?} disabled
         * @return {?}
         */
        MdcTabBar.prototype.disableTab = /**
         * Disable or enable the tab at the given index
         * @param {?} index
         * @param {?} disabled
         * @return {?}
         */
        function (index, disabled) {
            if (!this.tabs) {
                return;
            }
            this.tabs.toArray()[index].disabled = toBoolean(disabled);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcTabBar.prototype._onKeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleKeyDown(evt);
        };
        /**
         * @private
         * @param {?} index
         * @return {?}
         */
        MdcTabBar.prototype._indexIsInRange = /**
         * @private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return index >= 0 && index < this.tabs.length;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcTabBar.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTabBar.decorators = [
            { type: core.Component, args: [{selector: '[mdcTabBar], mdc-tab-bar',
                        exportAs: 'mdcTabBar',
                        host: {
                            'role': 'tablist',
                            'class': 'mdc-tab-bar',
                            '(keydown)': '_onKeydown($event)'
                        },
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [{ provide: MDC_TAB_BAR_PARENT_COMPONENT, useExisting: MdcTabBar }]
                    },] },
        ];
        /** @nocollapse */
        MdcTabBar.ctorParameters = function () { return [
            { type: Platform },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcTabBar.propDecorators = {
            fade: [{ type: core.Input }],
            stacked: [{ type: core.Input }],
            fixed: [{ type: core.Input }],
            align: [{ type: core.Input }],
            iconIndicator: [{ type: core.Input }],
            useAutomaticActivation: [{ type: core.Input }],
            activeTabIndex: [{ type: core.Input }],
            focusOnActivate: [{ type: core.Input }],
            activated: [{ type: core.Output }],
            tabScroller: [{ type: core.ContentChild, args: [MdcTabScroller,] }],
            tabs: [{ type: core.ContentChildren, args: [MdcTab, { descendants: true },] }]
        };
        return MdcTabBar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTabBarModule = /** @class */ (function () {
        function MdcTabBarModule() {
        }
        MdcTabBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            MdcTabIndicatorModule,
                            MdcTabModule,
                            MdcTabScrollerModule
                        ],
                        exports: [
                            MdcTabBar,
                            MdcTabIndicatorModule,
                            MdcTabModule,
                            MdcTabScrollerModule
                        ],
                        declarations: [MdcTabBar]
                    },] },
        ];
        return MdcTabBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTextFieldIcon = /** @class */ (function (_super) {
        __extends(MdcTextFieldIcon, _super);
        function MdcTextFieldIcon() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._leading = false;
            _this._trailing = false;
            return _this;
        }
        Object.defineProperty(MdcTextFieldIcon.prototype, "leading", {
            get: /**
             * @return {?}
             */
            function () { return this._leading; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._leading = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextFieldIcon.prototype, "trailing", {
            get: /**
             * @return {?}
             */
            function () { return this._trailing; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._trailing = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        MdcTextFieldIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcTextFieldIcon]',
                        exportAs: 'mdcTextFieldIcon',
                        host: { 'class': 'mdc-text-field__icon' }
                    },] },
        ];
        MdcTextFieldIcon.propDecorators = {
            leading: [{ type: core.Input }],
            trailing: [{ type: core.Input }]
        };
        return MdcTextFieldIcon;
    }(MdcIcon));

    function _classCallCheck$n(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$n(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$n(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$n(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$n(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$n(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$n(subClass, superClass);
    }

    function _getPrototypeOf$n(o) {
      _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$n(o);
    }

    function _setPrototypeOf$n(o, p) {
      _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$n(o, p);
    }

    function _assertThisInitialized$n(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$n(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$n(self);
    }

    function _superPropBase$d(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$n(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$d(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$d = Reflect.get;
      } else {
        _get$d = function _get(target, property, receiver) {
          var base = _superPropBase$d(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$d(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$n =
    /*#__PURE__*/
    function () {
      _createClass$n(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$n(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$n(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$n =
    /*#__PURE__*/
    function () {
      _createClass$n(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$n());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$n(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$n(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Helper Text.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the TextField helper text into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldHelperTextAdapter =
    /*#__PURE__*/
    function () {
      function MDCTextFieldHelperTextAdapter() {
        _classCallCheck$n(this, MDCTextFieldHelperTextAdapter);
      }

      _createClass$n(MDCTextFieldHelperTextAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the helper text element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the helper text element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns whether or not the helper text element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets an attribute with a given value on the helper text element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Removes an attribute from the helper text element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}
        /**
         * Sets the text content for the helper text element.
         * @param {string} content
         */

      }, {
        key: "setContent",
        value: function setContent(content) {}
      }]);

      return MDCTextFieldHelperTextAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$n = {
      ROOT: 'mdc-text-field-helper-text',
      HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
      HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
    };
    /** @enum {string} */

    var strings$l = {
      ARIA_HIDDEN: 'aria-hidden',
      ROLE: 'role',
      ROOT_SELECTOR: ".".concat(cssClasses$n.ROOT)
    };

    /**
     * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
     * @final
     */

    var MDCTextFieldHelperTextFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCTextFieldHelperTextFoundation, _MDCFoundation);

      _createClass$n(MDCTextFieldHelperTextFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$n;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$l;
        }
        /**
         * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldHelperTextAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldHelperTextAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              setContent: function setContent() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldHelperTextAdapter} adapter
         */

      }]);

      function MDCTextFieldHelperTextFoundation(adapter) {
        _classCallCheck$n(this, MDCTextFieldHelperTextFoundation);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCTextFieldHelperTextFoundation).call(this, Object.assign(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
      }
      /**
       * Sets the content of the helper text field.
       * @param {string} content
       */


      _createClass$n(MDCTextFieldHelperTextFoundation, [{
        key: "setContent",
        value: function setContent(content) {
          this.adapter_.setContent(content);
        }
        /** @param {boolean} isPersistent Sets the persistency of the helper text. */

      }, {
        key: "setPersistent",
        value: function setPersistent(isPersistent) {
          if (isPersistent) {
            this.adapter_.addClass(cssClasses$n.HELPER_TEXT_PERSISTENT);
          } else {
            this.adapter_.removeClass(cssClasses$n.HELPER_TEXT_PERSISTENT);
          }
        }
        /**
         * @param {boolean} isValidation True to make the helper text act as an
         *   error validation message.
         */

      }, {
        key: "setValidation",
        value: function setValidation(isValidation) {
          if (isValidation) {
            this.adapter_.addClass(cssClasses$n.HELPER_TEXT_VALIDATION_MSG);
          } else {
            this.adapter_.removeClass(cssClasses$n.HELPER_TEXT_VALIDATION_MSG);
          }
        }
        /** Makes the helper text visible to the screen reader. */

      }, {
        key: "showToScreenReader",
        value: function showToScreenReader() {
          this.adapter_.removeAttr(strings$l.ARIA_HIDDEN);
        }
        /**
         * Sets the validity of the helper text based on the input validity.
         * @param {boolean} inputIsValid
         */

      }, {
        key: "setValidity",
        value: function setValidity(inputIsValid) {
          var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$n.HELPER_TEXT_PERSISTENT);
          var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$n.HELPER_TEXT_VALIDATION_MSG);
          var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

          if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(strings$l.ROLE, 'alert');
          } else {
            this.adapter_.removeAttr(strings$l.ROLE);
          }

          if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
          }
        }
        /**
         * Hides the help text from screen readers.
         * @private
         */

      }, {
        key: "hide_",
        value: function hide_() {
          this.adapter_.setAttr(strings$l.ARIA_HIDDEN, 'true');
        }
      }]);

      return MDCTextFieldHelperTextFoundation;
    }(MDCFoundation$n);

    /**
     * @extends {MDCComponent<!MDCTextFieldHelperTextFoundation>}
     * @final
     */

    var MDCTextFieldHelperText =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCTextFieldHelperText, _MDCComponent);

      function MDCTextFieldHelperText() {
        _classCallCheck$n(this, MDCTextFieldHelperText);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCTextFieldHelperText).apply(this, arguments));
      }

      _createClass$n(MDCTextFieldHelperText, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTextFieldHelperTextFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCTextFieldHelperTextFoundation(
          /** @type {!MDCTextFieldHelperTextAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setAttr: function setAttr(attr, value) {
              return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
              return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCTextFieldHelperTextFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTextFieldHelperText}
         */
        value: function attachTo(root) {
          return new MDCTextFieldHelperText(root);
        }
      }]);

      return MDCTextFieldHelperText;
    }(MDCComponent$n);

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$a =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$n(this, MDCRippleAdapter);
      }

      _createClass$n(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1$d = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$c = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$f = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$a;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$a;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$a(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$a(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$a;

      if (typeof supportsCssVariables_$a === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$a(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$a = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$a() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$a === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$a = isSupported;
      }

      return supportsPassive_$a ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$b(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$a(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$b = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$b = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$a = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$a =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCRippleFoundation, _MDCFoundation);

      _createClass$n(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$d;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$c;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$f;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$n(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$n(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$b.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$b.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$b.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$b.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$a.length > 0 && activatedTargets$a.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$a.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$a = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$a(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$f.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$n);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$a =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$n(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$n(this, (_getPrototypeOf2 = _getPrototypeOf$n(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$n(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$a(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$b(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$a(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$a());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$a());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$a());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$a());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$n);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$a = function RippleCapableSurface() {
      _classCallCheck$n(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$a.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$a.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$a.prototype.disabled;

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$2$7 = {
      ARIA_CONTROLS: 'aria-controls',
      INPUT_SELECTOR: '.mdc-text-field__input',
      LABEL_SELECTOR: '.mdc-floating-label',
      ICON_SELECTOR: '.mdc-text-field__icon',
      OUTLINE_SELECTOR: '.mdc-notched-outline',
      LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'
    };
    /** @enum {string} */

    var cssClasses$2$6 = {
      ROOT: 'mdc-text-field',
      DISABLED: 'mdc-text-field--disabled',
      DENSE: 'mdc-text-field--dense',
      FOCUSED: 'mdc-text-field--focused',
      INVALID: 'mdc-text-field--invalid',
      TEXTAREA: 'mdc-text-field--textarea',
      OUTLINED: 'mdc-text-field--outlined',
      WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon',
      HELPER_LINE: 'mdc-text-field-helper-line'
    };
    /** @enum {number} */

    var numbers$1$5 = {
      LABEL_SCALE: 0.75,
      DENSE_LABEL_SCALE: 0.923
    }; // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
    // under section: `Validation-related attributes`

    var VALIDATION_ATTR_WHITELIST$1 = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength']; // Label should always float for these types as they show some UI even if value is empty.

    var ALWAYS_FLOAT_TYPES = ['color', 'date', 'datetime-local', 'month', 'range', 'time', 'week'];

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Character Counter.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the TextField character counter into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldCharacterCounterAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCTextFieldCharacterCounterAdapter() {
        _classCallCheck$n(this, MDCTextFieldCharacterCounterAdapter);
      }

      _createClass$n(MDCTextFieldCharacterCounterAdapter, [{
        key: "setContent",

        /**
         * Sets the text content of character counter element.
         * @param {string} content
         */
        value: function setContent(content) {}
      }]);

      return MDCTextFieldCharacterCounterAdapter;
    }();

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$3$3 = {
      ROOT: 'mdc-text-field-character-counter'
    };
    /** @enum {string} */

    var strings$3$3 = {
      ROOT_SELECTOR: ".".concat(cssClasses$3$3.ROOT)
    };

    /**
     * @extends {MDCFoundation<!MDCTextFieldCharacterCounterAdapter>}
     * @final
     */

    var MDCTextFieldCharacterCounterFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCTextFieldCharacterCounterFoundation, _MDCFoundation);

      _createClass$n(MDCTextFieldCharacterCounterFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$3$3;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$3$3;
        }
        /**
         * {@see MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldCharacterCounterAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldCharacterCounterAdapter} */
            {
              setContent: function setContent() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldCharacterCounterAdapter} adapter
         */

      }]);

      function MDCTextFieldCharacterCounterFoundation(adapter) {
        _classCallCheck$n(this, MDCTextFieldCharacterCounterFoundation);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCTextFieldCharacterCounterFoundation).call(this, Object.assign(MDCTextFieldCharacterCounterFoundation.defaultAdapter, adapter)));
      }
      /**
       * @param {number} currentLength
       * @param {number} maxLength
       */


      _createClass$n(MDCTextFieldCharacterCounterFoundation, [{
        key: "setCounterValue",
        value: function setCounterValue(currentLength, maxLength) {
          currentLength = Math.min(currentLength, maxLength);
          this.adapter_.setContent("".concat(currentLength, " / ").concat(maxLength));
        }
      }]);

      return MDCTextFieldCharacterCounterFoundation;
    }(MDCFoundation$n);

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Icon.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the text field icon into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldIconAdapter =
    /*#__PURE__*/
    function () {
      function MDCTextFieldIconAdapter() {
        _classCallCheck$n(this, MDCTextFieldIconAdapter);
      }

      _createClass$n(MDCTextFieldIconAdapter, [{
        key: "getAttr",

        /**
         * Gets the value of an attribute on the icon element.
         * @param {string} attr
         * @return {string}
         */
        value: function getAttr(attr) {}
        /**
         * Sets an attribute on the icon element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Removes an attribute from the icon element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}
        /**
         * Sets the text content of the icon element.
         * @param {string} content
         */

      }, {
        key: "setContent",
        value: function setContent(content) {}
        /**
         * Registers an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
         */

      }, {
        key: "notifyIconAction",
        value: function notifyIconAction() {}
      }]);

      return MDCTextFieldIconAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$4$3 = {
      ICON_EVENT: 'MDCTextField:icon',
      ICON_ROLE: 'button'
    };

    /**
     * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
     * @final
     */

    var MDCTextFieldIconFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCTextFieldIconFoundation, _MDCFoundation);

      _createClass$n(MDCTextFieldIconFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$4$3;
        }
        /**
         * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldIconAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldIconAdapter} */
            {
              getAttr: function getAttr() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              setContent: function setContent() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {},
              notifyIconAction: function notifyIconAction() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldIconAdapter} adapter
         */

      }]);

      function MDCTextFieldIconFoundation(adapter) {
        var _this;

        _classCallCheck$n(this, MDCTextFieldIconFoundation);

        _this = _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCTextFieldIconFoundation).call(this, Object.assign(MDCTextFieldIconFoundation.defaultAdapter, adapter)));
        /** @private {string?} */

        _this.savedTabIndex_ = null;
        /** @private {function(!Event): undefined} */

        _this.interactionHandler_ = function (evt) {
          return _this.handleInteraction(evt);
        };

        return _this;
      }

      _createClass$n(MDCTextFieldIconFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
          });
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          if (!this.savedTabIndex_) {
            return;
          }

          if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
          } else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', strings$4$3.ICON_ROLE);
          }
        }
        /** @param {string} label */

      }, {
        key: "setAriaLabel",
        value: function setAriaLabel(label) {
          this.adapter_.setAttr('aria-label', label);
        }
        /** @param {string} content */

      }, {
        key: "setContent",
        value: function setContent(content) {
          this.adapter_.setContent(content);
        }
        /**
         * Handles an interaction event
         * @param {!Event} evt
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction(evt) {
          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyIconAction();
          }
        }
      }]);

      return MDCTextFieldIconFoundation;
    }(MDCFoundation$n);

    /**
     * Adapter for MDC Text Field.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Text Field into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTextFieldAdapter =
    /*#__PURE__*/
    function () {
      function MDCTextFieldAdapter() {
        _classCallCheck$n(this, MDCTextFieldAdapter);
      }

      _createClass$n(MDCTextFieldAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root Element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root Element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root element contains the given class name.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Registers an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerTextFieldInteractionHandler",
        value: function registerTextFieldInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterTextFieldInteractionHandler",
        value: function deregisterTextFieldInteractionHandler(type, handler) {}
        /**
         * Registers an event listener on the native input element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInputInteractionHandler",
        value: function registerInputInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the native input element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInputInteractionHandler",
        value: function deregisterInputInteractionHandler(evtType, handler) {}
        /**
         * Registers a validation attribute change listener on the input element.
         * Handler accepts list of attribute names.
         * @param {function(!Array<string>): undefined} handler
         * @return {!MutationObserver}
         */

      }, {
        key: "registerValidationAttributeChangeHandler",
        value: function registerValidationAttributeChangeHandler(handler) {}
        /**
         * Disconnects a validation attribute observer on the input element.
         * @param {!MutationObserver} observer
         */

      }, {
        key: "deregisterValidationAttributeChangeHandler",
        value: function deregisterValidationAttributeChangeHandler(observer) {}
        /**
         * Returns an object representing the native text input element, with a
         * similar API shape. The object returned should include the value, disabled
         * and badInput properties, as well as the checkValidity() function. We never
         * alter the value within our code, however we do update the disabled
         * property, so if you choose to duck-type the return value for this method
         * in your implementation it's important to keep this in mind. Also note that
         * this method can return null, which the foundation will handle gracefully.
         * @return {?Element|?NativeInputType}
         */

      }, {
        key: "getNativeInput",
        value: function getNativeInput() {}
        /**
         * Returns true if the textfield is focused.
         * We achieve this via `document.activeElement === this.root_`.
         * @return {boolean}
         */

      }, {
        key: "isFocused",
        value: function isFocused() {}
        /**
         * Activates the line ripple.
         */

      }, {
        key: "activateLineRipple",
        value: function activateLineRipple() {}
        /**
         * Deactivates the line ripple.
         */

      }, {
        key: "deactivateLineRipple",
        value: function deactivateLineRipple() {}
        /**
         * Sets the transform origin of the line ripple.
         * @param {number} normalizedX
         */

      }, {
        key: "setLineRippleTransformOrigin",
        value: function setLineRippleTransformOrigin(normalizedX) {}
        /**
         * Only implement if label exists.
         * Shakes label if shouldShake is true.
         * @param {boolean} shouldShake
         */

      }, {
        key: "shakeLabel",
        value: function shakeLabel(shouldShake) {}
        /**
         * Only implement if label exists.
         * Floats the label above the input element if shouldFloat is true.
         * @param {boolean} shouldFloat
         */

      }, {
        key: "floatLabel",
        value: function floatLabel(shouldFloat) {}
        /**
         * Returns true if label element exists, false if it doesn't.
         * @return {boolean}
         */

      }, {
        key: "hasLabel",
        value: function hasLabel() {}
        /**
         * Only implement if label exists.
         * Returns width of label in pixels.
         * @return {number}
         */

      }, {
        key: "getLabelWidth",
        value: function getLabelWidth() {}
        /**
         * Returns true if outline element exists, false if it doesn't.
         * @return {boolean}
         */

      }, {
        key: "hasOutline",
        value: function hasOutline() {}
        /**
         * Only implement if outline element exists.
         * @param {number} labelWidth
         */

      }, {
        key: "notchOutline",
        value: function notchOutline(labelWidth) {}
        /**
         * Only implement if outline element exists.
         * Closes notch in outline element.
         */

      }, {
        key: "closeOutline",
        value: function closeOutline() {}
      }]);

      return MDCTextFieldAdapter;
    }();

    /**
     * @extends {MDCFoundation<!MDCTextFieldAdapter>}
     * @final
     */

    var MDCTextFieldFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCTextFieldFoundation, _MDCFoundation);

      _createClass$n(MDCTextFieldFoundation, [{
        key: "shouldShake",

        /** @return {boolean} */
        get: function get() {
          return !this.isValid() && !this.isFocused_ && !!this.getValue();
        }
        /**
         * @return {boolean}
         * @private
         */

      }, {
        key: "shouldAlwaysFloat_",
        get: function get() {
          var type = this.getNativeInput_().type;
          return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
        }
        /** @return {boolean} */

      }, {
        key: "shouldFloat",
        get: function get() {
          return this.shouldAlwaysFloat_ || this.isFocused_ || !!this.getValue() || this.isBadInput_();
        }
        /**
         * {@see MDCTextFieldAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldAdapter}
         */

      }], [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$2$6;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$2$7;
        }
        /** @return enum {string} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$5;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
              deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
              registerInputInteractionHandler: function registerInputInteractionHandler() {},
              deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
              registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
              deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
              getNativeInput: function getNativeInput() {},
              isFocused: function isFocused() {},
              activateLineRipple: function activateLineRipple() {},
              deactivateLineRipple: function deactivateLineRipple() {},
              setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
              shakeLabel: function shakeLabel() {},
              floatLabel: function floatLabel() {},
              hasLabel: function hasLabel() {},
              getLabelWidth: function getLabelWidth() {},
              hasOutline: function hasOutline() {},
              notchOutline: function notchOutline() {},
              closeOutline: function closeOutline() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldAdapter} adapter
         * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
         */

      }]);

      function MDCTextFieldFoundation(adapter) {
        var _this;

        var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :
        /** @type {!FoundationMapType} */
        {};

        _classCallCheck$n(this, MDCTextFieldFoundation);

        _this = _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCTextFieldFoundation).call(this, Object.assign(MDCTextFieldFoundation.defaultAdapter, adapter)));
        /** @type {!MDCTextFieldHelperTextFoundation|undefined} */

        _this.helperText_ = foundationMap.helperText;
        /** @type {!MDCTextFieldCharacterCounterFoundation|undefined} */

        _this.characterCounter_ = foundationMap.characterCounter;
        /** @type {!MDCTextFieldIconFoundation|undefined} */

        _this.leadingIcon_ = foundationMap.leadingIcon;
        /** @type {!MDCTextFieldIconFoundation|undefined} */

        _this.trailingIcon_ = foundationMap.trailingIcon;
        /** @private {boolean} */

        _this.isFocused_ = false;
        /** @private {boolean} */

        _this.receivedUserInput_ = false;
        /** @private {boolean} */

        _this.useCustomValidityChecking_ = false;
        /** @private {boolean} */

        _this.isValid_ = true;
        /** @private {boolean} */

        _this.useNativeValidation_ = true;
        /** @private {function(): undefined} */

        _this.inputFocusHandler_ = function () {
          return _this.activateFocus();
        };
        /** @private {function(): undefined} */


        _this.inputBlurHandler_ = function () {
          return _this.deactivateFocus();
        };
        /** @private {function(): undefined} */


        _this.inputInputHandler_ = function () {
          return _this.handleInput();
        };
        /** @private {function(!Event): undefined} */


        _this.setPointerXOffset_ = function (evt) {
          return _this.setTransformOrigin(evt);
        };
        /** @private {function(!Event): undefined} */


        _this.textFieldInteractionHandler_ = function () {
          return _this.handleTextFieldInteraction();
        };
        /** @private {function(!Array): undefined} */


        _this.validationAttributeChangeHandler_ = function (attributesList) {
          return _this.handleValidationAttributeChange(attributesList);
        };
        /** @private {!MutationObserver} */


        _this.validationObserver_;
        return _this;
      }

      _createClass$n(MDCTextFieldFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          if (this.adapter_.isFocused()) {
            this.inputFocusHandler_();
          } else if (this.adapter_.hasLabel() && this.shouldFloat) {
            this.notchOutline(true);
            this.adapter_.floatLabel(true);
          }

          this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
          this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
          this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
          });
          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
          });
          this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
          this.setCharacterCounter_(this.getValue().length);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
          this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
          this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
          });
          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
          });
          this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
        }
        /**
         * Handles user interactions with the Text Field.
         */

      }, {
        key: "handleTextFieldInteraction",
        value: function handleTextFieldInteraction() {
          if (this.adapter_.getNativeInput().disabled) {
            return;
          }

          this.receivedUserInput_ = true;
        }
        /**
         * Handles validation attribute changes
         * @param {!Array<string>} attributesList
         */

      }, {
        key: "handleValidationAttributeChange",
        value: function handleValidationAttributeChange(attributesList) {
          var _this4 = this;

          attributesList.some(function (attributeName) {
            if (VALIDATION_ATTR_WHITELIST$1.indexOf(attributeName) > -1) {
              _this4.styleValidity_(true);

              return true;
            }
          });

          if (attributesList.indexOf('maxlength') > -1) {
            this.setCharacterCounter_(this.getValue().length);
          }
        }
        /**
         * Opens/closes the notched outline.
         * @param {boolean} openNotch
         */

      }, {
        key: "notchOutline",
        value: function notchOutline(openNotch) {
          if (!this.adapter_.hasOutline()) {
            return;
          }

          if (openNotch) {
            var isDense = this.adapter_.hasClass(cssClasses$2$6.DENSE);
            var labelScale = isDense ? numbers$1$5.DENSE_LABEL_SCALE : numbers$1$5.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            this.adapter_.notchOutline(labelWidth);
          } else {
            this.adapter_.closeOutline();
          }
        }
        /**
         * Activates the text field focus state.
         */

      }, {
        key: "activateFocus",
        value: function activateFocus() {
          this.isFocused_ = true;
          this.styleFocused_(this.isFocused_);
          this.adapter_.activateLineRipple();

          if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
          }

          if (this.helperText_) {
            this.helperText_.showToScreenReader();
          }
        }
        /**
         * Sets the line ripple's transform origin, so that the line ripple activate
         * animation will animate out from the user's click location.
         * @param {!Event} evt
         */

      }, {
        key: "setTransformOrigin",
        value: function setTransformOrigin(evt) {
          var targetEvent;

          if (evt.touches) {
            targetEvent = evt.touches[0];
          } else {
            targetEvent = evt;
          }

          var targetClientRect = targetEvent.target.getBoundingClientRect();
          var normalizedX = targetEvent.clientX - targetClientRect.left;
          this.adapter_.setLineRippleTransformOrigin(normalizedX);
        }
        /**
         * Handles input change of text input and text area.
         */

      }, {
        key: "handleInput",
        value: function handleInput() {
          this.autoCompleteFocus();
          this.setCharacterCounter_(this.getValue().length);
        }
        /**
         * Activates the Text Field's focus state in cases when the input value
         * changes without user input (e.g. programatically).
         */

      }, {
        key: "autoCompleteFocus",
        value: function autoCompleteFocus() {
          if (!this.receivedUserInput_) {
            this.activateFocus();
          }
        }
        /**
         * Deactivates the Text Field's focus state.
         */

      }, {
        key: "deactivateFocus",
        value: function deactivateFocus() {
          this.isFocused_ = false;
          this.adapter_.deactivateLineRipple();
          var isValid = this.isValid();
          this.styleValidity_(isValid);
          this.styleFocused_(this.isFocused_);

          if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
          }

          if (!this.shouldFloat) {
            this.receivedUserInput_ = false;
          }
        }
        /**
         * @return {string} The value of the input Element.
         */

      }, {
        key: "getValue",
        value: function getValue() {
          return this.getNativeInput_().value;
        }
        /**
         * @param {string} value The value to set on the input Element.
         */

      }, {
        key: "setValue",
        value: function setValue(value) {
          // Prevent Safari from moving the caret to the end of the input when the value has not changed.
          if (this.getValue() !== value) {
            this.getNativeInput_().value = value;
          }

          var isValid = this.isValid();
          this.styleValidity_(isValid);

          if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
          }
        }
        /**
         * @return {boolean} If a custom validity is set, returns that value.
         *     Otherwise, returns the result of native validity checks.
         */

      }, {
        key: "isValid",
        value: function isValid() {
          return this.useNativeValidation_ ? this.isNativeInputValid_() : this.isValid_;
        }
        /**
         * @param {boolean} isValid Sets the validity state of the Text Field.
         */

      }, {
        key: "setValid",
        value: function setValid(isValid) {
          this.isValid_ = isValid;
          this.styleValidity_(isValid);
          var shouldShake = !isValid && !this.isFocused_;

          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(shouldShake);
          }
        }
        /**
         * Enables or disables the use of native validation. Use this for custom validation.
         * @param {boolean} useNativeValidation Set this to false to ignore native input validation.
         */

      }, {
        key: "setUseNativeValidation",
        value: function setUseNativeValidation(useNativeValidation) {
          this.useNativeValidation_ = useNativeValidation;
        }
        /**
         * @return {boolean} True if the Text Field is disabled.
         */

      }, {
        key: "isDisabled",
        value: function isDisabled() {
          return this.getNativeInput_().disabled;
        }
        /**
         * @param {boolean} disabled Sets the text-field disabled or enabled.
         */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          this.getNativeInput_().disabled = disabled;
          this.styleDisabled_(disabled);
        }
        /**
         * @param {string} content Sets the content of the helper text.
         */

      }, {
        key: "setHelperTextContent",
        value: function setHelperTextContent(content) {
          if (this.helperText_) {
            this.helperText_.setContent(content);
          }
        }
        /**
         * Sets character counter values that shows characters used and the total character limit.
         * @param {number} currentLength
         * @private
         */

      }, {
        key: "setCharacterCounter_",
        value: function setCharacterCounter_(currentLength) {
          if (!this.characterCounter_) return;
          var maxLength = this.getNativeInput_().maxLength;

          if (maxLength === -1) {
            throw new Error('MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.');
          }

          this.characterCounter_.setCounterValue(currentLength, maxLength);
        }
        /**
         * Sets the aria label of the leading icon.
         * @param {string} label
         */

      }, {
        key: "setLeadingIconAriaLabel",
        value: function setLeadingIconAriaLabel(label) {
          if (this.leadingIcon_) {
            this.leadingIcon_.setAriaLabel(label);
          }
        }
        /**
         * Sets the text content of the leading icon.
         * @param {string} content
         */

      }, {
        key: "setLeadingIconContent",
        value: function setLeadingIconContent(content) {
          if (this.leadingIcon_) {
            this.leadingIcon_.setContent(content);
          }
        }
        /**
         * Sets the aria label of the trailing icon.
         * @param {string} label
         */

      }, {
        key: "setTrailingIconAriaLabel",
        value: function setTrailingIconAriaLabel(label) {
          if (this.trailingIcon_) {
            this.trailingIcon_.setAriaLabel(label);
          }
        }
        /**
         * Sets the text content of the trailing icon.
         * @param {string} content
         */

      }, {
        key: "setTrailingIconContent",
        value: function setTrailingIconContent(content) {
          if (this.trailingIcon_) {
            this.trailingIcon_.setContent(content);
          }
        }
        /**
         * @return {boolean} True if the Text Field input fails in converting the
         *     user-supplied value.
         * @private
         */

      }, {
        key: "isBadInput_",
        value: function isBadInput_() {
          return this.getNativeInput_().validity.badInput;
        }
        /**
         * @return {boolean} The result of native validity checking
         *     (ValidityState.valid).
         */

      }, {
        key: "isNativeInputValid_",
        value: function isNativeInputValid_() {
          return this.getNativeInput_().validity.valid;
        }
        /**
         * Styles the component based on the validity state.
         * @param {boolean} isValid
         * @private
         */

      }, {
        key: "styleValidity_",
        value: function styleValidity_(isValid) {
          var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

          if (isValid) {
            this.adapter_.removeClass(INVALID);
          } else {
            this.adapter_.addClass(INVALID);
          }

          if (this.helperText_) {
            this.helperText_.setValidity(isValid);
          }
        }
        /**
         * Styles the component based on the focused state.
         * @param {boolean} isFocused
         * @private
         */

      }, {
        key: "styleFocused_",
        value: function styleFocused_(isFocused) {
          var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

          if (isFocused) {
            this.adapter_.addClass(FOCUSED);
          } else {
            this.adapter_.removeClass(FOCUSED);
          }
        }
        /**
         * Styles the component based on the disabled state.
         * @param {boolean} isDisabled
         * @private
         */

      }, {
        key: "styleDisabled_",
        value: function styleDisabled_(isDisabled) {
          var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
              DISABLED = _MDCTextFieldFoundati.DISABLED,
              INVALID = _MDCTextFieldFoundati.INVALID;

          if (isDisabled) {
            this.adapter_.addClass(DISABLED);
            this.adapter_.removeClass(INVALID);
          } else {
            this.adapter_.removeClass(DISABLED);
          }

          if (this.leadingIcon_) {
            this.leadingIcon_.setDisabled(isDisabled);
          }

          if (this.trailingIcon_) {
            this.trailingIcon_.setDisabled(isDisabled);
          }
        }
        /**
         * @return {!Element|!NativeInputType} The native text input from the
         * host environment, or a dummy if none exists.
         * @private
         */

      }, {
        key: "getNativeInput_",
        value: function getNativeInput_() {
          return this.adapter_.getNativeInput() ||
          /** @type {!NativeInputType} */
          {
            value: '',
            disabled: false,
            validity: {
              badInput: false,
              valid: true
            }
          };
        }
      }]);

      return MDCTextFieldFoundation;
    }(MDCFoundation$n);

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC TextField Line Ripple.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the line ripple into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCLineRippleAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCLineRippleAdapter() {
        _classCallCheck$n(this, MDCLineRippleAdapter);
      }

      _createClass$n(MDCLineRippleAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the line ripple element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the line ripple element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the style property with propertyName to value on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(propertyName, value) {}
        /**
         * Registers an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
      }]);

      return MDCLineRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$4$2 = {
      LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
      LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
    };

    /**
     * @extends {MDCFoundation<!MDCLineRippleAdapter>}
     * @final
     */

    var MDCLineRippleFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCLineRippleFoundation, _MDCFoundation);

      _createClass$n(MDCLineRippleFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$4$2;
        }
        /**
         * {@see MDCLineRippleAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCLineRippleAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCLineRippleAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setStyle: function setStyle() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {}
            }
          );
        }
        /**
         * @param {!MDCLineRippleAdapter=} adapter
         */

      }]);

      function MDCLineRippleFoundation(adapter) {
        var _this;

        _classCallCheck$n(this, MDCLineRippleFoundation);

        _this = _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCLineRippleFoundation).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };

        return _this;
      }

      _createClass$n(MDCLineRippleFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        }
        /**
         * Activates the line ripple
         */

      }, {
        key: "activate",
        value: function activate() {
          this.adapter_.removeClass(cssClasses$4$2.LINE_RIPPLE_DEACTIVATING);
          this.adapter_.addClass(cssClasses$4$2.LINE_RIPPLE_ACTIVE);
        }
        /**
         * Sets the center of the ripple animation to the given X coordinate.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.addClass(cssClasses$4$2.LINE_RIPPLE_DEACTIVATING);
        }
        /**
         * Handles a transition end event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Wait for the line ripple to be either transparent or opaque
          // before emitting the animation end event
          var isDeactivating = this.adapter_.hasClass(cssClasses$4$2.LINE_RIPPLE_DEACTIVATING);

          if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
              this.adapter_.removeClass(cssClasses$4$2.LINE_RIPPLE_ACTIVE);
              this.adapter_.removeClass(cssClasses$4$2.LINE_RIPPLE_DEACTIVATING);
            }
          }
        }
      }]);

      return MDCLineRippleFoundation;
    }(MDCFoundation$n);

    /**
     * @extends {MDCComponent<!MDCLineRippleFoundation>}
     * @final
     */

    var MDCLineRipple$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCLineRipple, _MDCComponent);

      function MDCLineRipple() {
        _classCallCheck$n(this, MDCLineRipple);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCLineRipple).apply(this, arguments));
      }

      _createClass$n(MDCLineRipple, [{
        key: "activate",

        /**
         * Activates the line ripple
         */
        value: function activate() {
          this.foundation_.activate();
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Sets the transform origin given a user's click location. The `rippleCenter` is the
         * x-coordinate of the middle of the ripple.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.foundation_.setRippleCenter(xCoordinate);
        }
        /**
         * @return {!MDCLineRippleFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLineRippleFoundation$2(
          /** @type {!MDCLineRippleAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setStyle: function setStyle(propertyName, value) {
              return _this.root_.style[propertyName] = value;
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          }));
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCLineRipple}
         */
        value: function attachTo(root) {
          return new MDCLineRipple(root);
        }
      }]);

      return MDCLineRipple;
    }(MDCComponent$n);

    /**
     * @extends {MDCComponent<!MDCTextFieldCharacterCounterFoundation>}
     * @final
     */

    var MDCTextFieldCharacterCounter$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCTextFieldCharacterCounter, _MDCComponent);

      function MDCTextFieldCharacterCounter() {
        _classCallCheck$n(this, MDCTextFieldCharacterCounter);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCTextFieldCharacterCounter).apply(this, arguments));
      }

      _createClass$n(MDCTextFieldCharacterCounter, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTextFieldCharacterCounterFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCTextFieldCharacterCounterFoundation$1(
          /** @type {!MDCTextFieldCharacterCounterAdapter} */
          Object.assign({
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCTextFieldCharacterCounterFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTextFieldCharacterCounter}
         */
        value: function attachTo(root) {
          return new MDCTextFieldCharacterCounter(root);
        }
      }]);

      return MDCTextFieldCharacterCounter;
    }(MDCComponent$n);

    /**
     * @extends {MDCComponent<!MDCTextFieldIconFoundation>}
     * @final
     */

    var MDCTextFieldIcon =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCTextFieldIcon, _MDCComponent);

      function MDCTextFieldIcon() {
        _classCallCheck$n(this, MDCTextFieldIcon);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCTextFieldIcon).apply(this, arguments));
      }

      _createClass$n(MDCTextFieldIcon, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTextFieldIconFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCTextFieldIconFoundation(
          /** @type {!MDCTextFieldIconAdapter} */
          Object.assign({
            getAttr: function getAttr(attr) {
              return _this.root_.getAttribute(attr);
            },
            setAttr: function setAttr(attr, value) {
              return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
              return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            },
            notifyIconAction: function notifyIconAction() {
              return _this.emit(MDCTextFieldIconFoundation.strings.ICON_EVENT, {}
              /* evtData */
              , true
              /* shouldBubble */
              );
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCTextFieldIconFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTextFieldIcon}
         */
        value: function attachTo(root) {
          return new MDCTextFieldIcon(root);
        }
      }]);

      return MDCTextFieldIcon;
    }(MDCComponent$n);

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter$3 =
    /*#__PURE__*/
    function () {
      function MDCFloatingLabelAdapter() {
        _classCallCheck$n(this, MDCFloatingLabelAdapter);
      }

      _createClass$n(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);

      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$5$2 = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake',
      ROOT: 'mdc-floating-label'
    };

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation$3 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCFloatingLabelFoundation, _MDCFoundation);

      _createClass$n(MDCFloatingLabelFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$5$2;
        }
        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCFloatingLabelAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }
        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        var _this;

        _classCallCheck$n(this, MDCFloatingLabelFoundation);

        _this = _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };

        return _this;
      }

      _createClass$n(MDCFloatingLabelFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.adapter_.getWidth();
        }
        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: "shake",
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: "handleShakeAnimationEnd_",
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);

      return MDCFloatingLabelFoundation;
    }(MDCFoundation$n);

    /**
     * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
     * @final
     */

    var MDCFloatingLabel$3 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCFloatingLabel, _MDCComponent);

      function MDCFloatingLabel() {
        _classCallCheck$n(this, MDCFloatingLabel);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCFloatingLabel).apply(this, arguments));
      }

      _createClass$n(MDCFloatingLabel, [{
        key: "shake",

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake styles the label to shake by adding shake class
         * if true, otherwise will stop shaking by removing shake class.
         */
        value: function shake(shouldShake) {
          this.foundation_.shake(shouldShake);
        }
        /**
         * Styles label to float/dock.
         * @param {boolean} shouldFloat styles the label to float by adding float class
         * if true, otherwise docks the label by removing the float class.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          this.foundation_.float(shouldFloat);
        }
        /**
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.foundation_.getWidth();
        }
        /**
         * @return {!MDCFloatingLabelFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCFloatingLabelFoundation$3({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
              return _this.root_.scrollWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCFloatingLabel}
         */
        value: function attachTo(root) {
          return new MDCFloatingLabel(root);
        }
      }]);

      return MDCFloatingLabel;
    }(MDCComponent$n);

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Notched Outline.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Notched Outline into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCNotchedOutlineAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCNotchedOutlineAdapter() {
        _classCallCheck$n(this, MDCNotchedOutlineAdapter);
      }

      _createClass$n(MDCNotchedOutlineAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets the width style property of the notch element.
         * @param {number} width
         */

      }, {
        key: "setNotchWidthProperty",
        value: function setNotchWidthProperty(width) {}
        /**
         * Removes the width style property from the notch element.
         */

      }, {
        key: "removeNotchWidthProperty",
        value: function removeNotchWidthProperty() {}
      }]);

      return MDCNotchedOutlineAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var strings$5$2 = {
      NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch'
    };
    /** @enum {number} */

    var numbers$2$2 = {
      // This should stay in sync with $mdc-notched-outline-padding * 2.
      NOTCH_ELEMENT_PADDING: 8
    };
    /** @enum {string} */

    var cssClasses$6$2 = {
      OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
      OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
      NO_LABEL: 'mdc-notched-outline--no-label'
    };

    /**
     * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
     * @final
     */

    var MDCNotchedOutlineFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCNotchedOutlineFoundation, _MDCFoundation);

      _createClass$n(MDCNotchedOutlineFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$5$2;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$6$2;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$2$2;
        }
        /**
         * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCNotchedOutlineAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCNotchedOutlineAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              setNotchWidthProperty: function setNotchWidthProperty() {},
              removeNotchWidthProperty: function removeNotchWidthProperty() {}
            }
          );
        }
        /**
         * @param {!MDCNotchedOutlineAdapter} adapter
         */

      }]);

      function MDCNotchedOutlineFoundation(adapter) {
        _classCallCheck$n(this, MDCNotchedOutlineFoundation);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCNotchedOutlineFoundation).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
      }
      /**
       * Adds the outline notched selector and updates the notch width
       * calculated based off of notchWidth.
       * @param {number} notchWidth
       */


      _createClass$n(MDCNotchedOutlineFoundation, [{
        key: "notch",
        value: function notch(notchWidth) {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

          if (notchWidth > 0) {
            notchWidth += numbers$2$2.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
          }

          this.adapter_.setNotchWidthProperty(notchWidth);
          this.adapter_.addClass(OUTLINE_NOTCHED);
        }
        /**
         * Removes notched outline selector to close the notch in the outline.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.removeClass(OUTLINE_NOTCHED);
          this.adapter_.removeNotchWidthProperty();
        }
      }]);

      return MDCNotchedOutlineFoundation;
    }(MDCFoundation$n);

    /**
     * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
     * @final
     */

    var MDCNotchedOutline$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCNotchedOutline, _MDCComponent);

      _createClass$n(MDCNotchedOutline, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCNotchedOutline}
         */
        value: function attachTo(root) {
          return new MDCNotchedOutline(root);
        }
        /** @param {...?} args */

      }]);

      function MDCNotchedOutline() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$n(this, MDCNotchedOutline);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$n(this, (_getPrototypeOf2 = _getPrototypeOf$n(MDCNotchedOutline)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {Element} */

        _this.notchElement_;
        return _this;
      }

      _createClass$n(MDCNotchedOutline, [{
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var label = this.root_.querySelector('.' + MDCFloatingLabelFoundation$3.cssClasses.ROOT);
          this.notchElement_ = this.root_.querySelector(strings$5$2.NOTCH_ELEMENT_SELECTOR);

          if (label) {
            label.style.transitionDuration = '0s';
            this.root_.classList.add(cssClasses$6$2.OUTLINE_UPGRADED);
            requestAnimationFrame(function () {
              label.style.transitionDuration = '';
            });
          } else {
            this.root_.classList.add(cssClasses$6$2.NO_LABEL);
          }
        }
        /**
          * Updates classes and styles to open the notch to the specified width.
          * @param {number} notchWidth The notch width in the outline.
          */

      }, {
        key: "notch",
        value: function notch(notchWidth) {
          this.foundation_.notch(notchWidth);
        }
        /**
         * Updates classes and styles to close the notch.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          this.foundation_.closeNotch();
        }
        /**
         * @return {!MDCNotchedOutlineFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCNotchedOutlineFoundation$2(
          /** @type {!MDCNotchedOutlineAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            setNotchWidthProperty: function setNotchWidthProperty(width) {
              return _this2.notchElement_.style.setProperty('width', width + 'px');
            },
            removeNotchWidthProperty: function removeNotchWidthProperty() {
              return _this2.notchElement_.style.removeProperty('width');
            }
          }));
        }
      }]);

      return MDCNotchedOutline;
    }(MDCComponent$n);

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCComponent<!MDCTextFieldFoundation>}
     * @final
     */

    var MDCTextField =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCTextField, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCTextField() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$n(this, MDCTextField);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$n(this, (_getPrototypeOf2 = _getPrototypeOf$n(MDCTextField)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.input_;
        /** @type {?MDCRipple} */

        _this.ripple;
        /** @private {?MDCLineRipple} */

        _this.lineRipple_;
        /** @private {?MDCTextFieldHelperText} */

        _this.helperText_;
        /** @private {?MDCTextFieldCharacterCounter} */

        _this.characterCounter_;
        /** @private {?MDCTextFieldIcon} */

        _this.leadingIcon_;
        /** @private {?MDCTextFieldIcon} */

        _this.trailingIcon_;
        /** @private {?MDCFloatingLabel} */

        _this.label_;
        /** @private {?MDCNotchedOutline} */

        _this.outline_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCTextField}
       */


      _createClass$n(MDCTextField, [{
        key: "initialize",

        /**
         * @param {(function(!Element, MDCRippleFoundation): !MDCRipple)=} rippleFactory A function which
         * creates a new MDCRipple.
         * @param {(function(!Element): !MDCLineRipple)=} lineRippleFactory A function which
         * creates a new MDCLineRipple.
         * @param {(function(!Element): !MDCTextFieldHelperText)=} helperTextFactory A function which
         * creates a new MDCTextFieldHelperText.
         * @param {(function(!Element): !MDCTextFieldCharacterCounter)=} characterCounterFactory A function which
         * creates a new MDCTextFieldCharacterCounter.
         * @param {(function(!Element): !MDCTextFieldIcon)=} iconFactory A function which
         * creates a new MDCTextFieldIcon.
         * @param {(function(!Element): !MDCFloatingLabel)=} labelFactory A function which
         * creates a new MDCFloatingLabel.
         * @param {(function(!Element): !MDCNotchedOutline)=} outlineFactory A function which
         * creates a new MDCNotchedOutline.
         */
        value: function initialize() {
          var _this2 = this;

          var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el, foundation) {
            return new MDCRipple$a(el, foundation);
          };
          var lineRippleFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCLineRipple$2(el);
          };
          var helperTextFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el) {
            return new MDCTextFieldHelperText(el);
          };
          var characterCounterFactory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (el) {
            return new MDCTextFieldCharacterCounter$1(el);
          };
          var iconFactory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (el) {
            return new MDCTextFieldIcon(el);
          };
          var labelFactory = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (el) {
            return new MDCFloatingLabel$3(el);
          };
          var outlineFactory = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (el) {
            return new MDCNotchedOutline$2(el);
          };
          this.input_ = this.root_.querySelector(strings$2$7.INPUT_SELECTOR);
          var labelElement = this.root_.querySelector(strings$2$7.LABEL_SELECTOR);

          if (labelElement) {
            this.label_ = labelFactory(labelElement);
          }

          var lineRippleElement = this.root_.querySelector(strings$2$7.LINE_RIPPLE_SELECTOR);

          if (lineRippleElement) {
            this.lineRipple_ = lineRippleFactory(lineRippleElement);
          }

          var outlineElement = this.root_.querySelector(strings$2$7.OUTLINE_SELECTOR);

          if (outlineElement) {
            this.outline_ = outlineFactory(outlineElement);
          } // Helper text


          var helperTextStrings = MDCTextFieldHelperTextFoundation.strings;
          var nextElementSibling = this.root_.nextElementSibling;
          var hasHelperLine = nextElementSibling && nextElementSibling.classList.contains(cssClasses$2$6.HELPER_LINE);
          var helperTextEl = hasHelperLine && nextElementSibling.querySelector(helperTextStrings.ROOT_SELECTOR);

          if (helperTextEl) {
            this.helperText_ = helperTextFactory(helperTextEl);
          } // Character counter


          var characterCounterStrings = MDCTextFieldCharacterCounterFoundation$1.strings;
          var characterCounterEl = this.root_.querySelector(characterCounterStrings.ROOT_SELECTOR); // If character counter is not found in root element search in sibling element.

          if (!characterCounterEl && hasHelperLine) {
            characterCounterEl = nextElementSibling.querySelector(characterCounterStrings.ROOT_SELECTOR);
          }

          if (characterCounterEl) {
            this.characterCounter_ = characterCounterFactory(characterCounterEl);
          }

          var iconElements = this.root_.querySelectorAll(strings$2$7.ICON_SELECTOR);

          if (iconElements.length > 0) {
            if (iconElements.length > 1) {
              // Has both icons.
              this.leadingIcon_ = iconFactory(iconElements[0]);
              this.trailingIcon_ = iconFactory(iconElements[1]);
            } else {
              if (this.root_.classList.contains(cssClasses$2$6.WITH_LEADING_ICON)) {
                this.leadingIcon_ = iconFactory(iconElements[0]);
              } else {
                this.trailingIcon_ = iconFactory(iconElements[0]);
              }
            }
          }

          this.ripple = null;

          if (!this.root_.classList.contains(cssClasses$2$6.TEXTAREA) && !this.root_.classList.contains(cssClasses$2$6.OUTLINED)) {
            var MATCHES = getMatchesProperty$b(HTMLElement.prototype);
            var adapter = Object.assign(MDCRipple$a.createAdapter(
            /** @type {!RippleCapableSurface} */
            this), {
              isSurfaceActive: function isSurfaceActive() {
                return _this2.input_[MATCHES](':active');
              },
              registerInteractionHandler: function registerInteractionHandler(type, handler) {
                return _this2.input_.addEventListener(type, handler);
              },
              deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
                return _this2.input_.removeEventListener(type, handler);
              }
            });
            var foundation = new MDCRippleFoundation$a(adapter);
            this.ripple = rippleFactory(this.root_, foundation);
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.ripple) {
            this.ripple.destroy();
          }

          if (this.lineRipple_) {
            this.lineRipple_.destroy();
          }

          if (this.helperText_) {
            this.helperText_.destroy();
          }

          if (this.characterCounter_) {
            this.characterCounter_.destroy();
          }

          if (this.leadingIcon_) {
            this.leadingIcon_.destroy();
          }

          if (this.trailingIcon_) {
            this.trailingIcon_.destroy();
          }

          if (this.label_) {
            this.label_.destroy();
          }

          if (this.outline_) {
            this.outline_.destroy();
          }

          _get$d(_getPrototypeOf$n(MDCTextField.prototype), "destroy", this).call(this);
        }
        /**
         * Initiliazes the Text Field's internal state based on the environment's
         * state.
         */

      }, {
        key: "initialSyncWithDom",
        value: function initialSyncWithDom() {
          this.disabled = this.input_.disabled;
        }
        /**
         * @return {string} The value of the input.
         */

      }, {
        key: "focus",

        /**
         * Focuses the input element.
         */
        value: function focus() {
          this.input_.focus();
        }
        /**
         * Recomputes the outline SVG path for the outline element.
         */

      }, {
        key: "layout",
        value: function layout() {
          var openNotch = this.foundation_.shouldFloat;
          this.foundation_.notchOutline(openNotch);
        }
        /**
         * @return {!MDCTextFieldFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCTextFieldFoundation(
          /** @type {!MDCTextFieldAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
              return _this3.root_.addEventListener(evtType, handler);
            },
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
              return _this3.root_.removeEventListener(evtType, handler);
            },
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
              var getAttributesList = function getAttributesList(mutationsList) {
                return mutationsList.map(function (mutation) {
                  return mutation.attributeName;
                });
              };

              var observer = new MutationObserver(function (mutationsList) {
                return handler(getAttributesList(mutationsList));
              });

              var targetNode = _this3.root_.querySelector(strings$2$7.INPUT_SELECTOR);

              var config = {
                attributes: true
              };
              observer.observe(targetNode, config);
              return observer;
            },
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
              return observer.disconnect();
            },
            isFocused: function isFocused() {
              return document.activeElement === _this3.root_.querySelector(strings$2$7.INPUT_SELECTOR);
            }
          }, this.getInputAdapterMethods_(), this.getLabelAdapterMethods_(), this.getLineRippleAdapterMethods_(), this.getOutlineAdapterMethods_()), this.getFoundationMap_());
        }
        /**
         * @return {!{
         *   shakeLabel: function(boolean): undefined,
         *   floatLabel: function(boolean): undefined,
         *   hasLabel: function(): boolean,
         *   getLabelWidth: function(): number,
         * }}
         */

      }, {
        key: "getLabelAdapterMethods_",
        value: function getLabelAdapterMethods_() {
          var _this4 = this;

          return {
            shakeLabel: function shakeLabel(shouldShake) {
              return _this4.label_.shake(shouldShake);
            },
            floatLabel: function floatLabel(shouldFloat) {
              return _this4.label_.float(shouldFloat);
            },
            hasLabel: function hasLabel() {
              return !!_this4.label_;
            },
            getLabelWidth: function getLabelWidth() {
              return _this4.label_ ? _this4.label_.getWidth() : 0;
            }
          };
        }
        /**
         * @return {!{
         *   activateLineRipple: function(): undefined,
         *   deactivateLineRipple: function(): undefined,
         *   setLineRippleTransformOrigin: function(number): undefined,
         * }}
         */

      }, {
        key: "getLineRippleAdapterMethods_",
        value: function getLineRippleAdapterMethods_() {
          var _this5 = this;

          return {
            activateLineRipple: function activateLineRipple() {
              if (_this5.lineRipple_) {
                _this5.lineRipple_.activate();
              }
            },
            deactivateLineRipple: function deactivateLineRipple() {
              if (_this5.lineRipple_) {
                _this5.lineRipple_.deactivate();
              }
            },
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
              if (_this5.lineRipple_) {
                _this5.lineRipple_.setRippleCenter(normalizedX);
              }
            }
          };
        }
        /**
         * @return {!{
         *   notchOutline: function(number, boolean): undefined,
         *   hasOutline: function(): boolean,
         * }}
         */

      }, {
        key: "getOutlineAdapterMethods_",
        value: function getOutlineAdapterMethods_() {
          var _this6 = this;

          return {
            notchOutline: function notchOutline(labelWidth) {
              return _this6.outline_.notch(labelWidth);
            },
            closeOutline: function closeOutline() {
              return _this6.outline_.closeNotch();
            },
            hasOutline: function hasOutline() {
              return !!_this6.outline_;
            }
          };
        }
        /**
         * @return {!{
         *   registerInputInteractionHandler: function(string, function()): undefined,
         *   deregisterInputInteractionHandler: function(string, function()): undefined,
         *   getNativeInput: function(): ?Element,
         * }}
         */

      }, {
        key: "getInputAdapterMethods_",
        value: function getInputAdapterMethods_() {
          var _this7 = this;

          return {
            registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
              return _this7.input_.addEventListener(evtType, handler);
            },
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
              return _this7.input_.removeEventListener(evtType, handler);
            },
            getNativeInput: function getNativeInput() {
              return _this7.input_;
            }
          };
        }
        /**
         * Returns a map of all subcomponents to subfoundations.
         * @return {!FoundationMapType}
         */

      }, {
        key: "getFoundationMap_",
        value: function getFoundationMap_() {
          return {
            helperText: this.helperText_ ? this.helperText_.foundation : undefined,
            characterCounter: this.characterCounter_ ? this.characterCounter_.foundation : undefined,
            leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
            trailingIcon: this.trailingIcon_ ? this.trailingIcon_.foundation : undefined
          };
        }
      }, {
        key: "value",
        get: function get() {
          return this.foundation_.getValue();
        }
        /**
         * @param {string} value The value to set on the input.
         */
        ,
        set: function set(value) {
          this.foundation_.setValue(value);
        }
        /**
         * @return {boolean} True if the Text Field is disabled.
         */

      }, {
        key: "disabled",
        get: function get() {
          return this.foundation_.isDisabled();
        }
        /**
         * @param {boolean} disabled Sets the Text Field disabled or enabled.
         */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
        /**
         * @return {boolean} valid True if the Text Field is valid.
         */

      }, {
        key: "valid",
        get: function get() {
          return this.foundation_.isValid();
        }
        /**
         * @param {boolean} valid Sets the Text Field valid or invalid.
         */
        ,
        set: function set(valid) {
          this.foundation_.setValid(valid);
        }
        /**
         * @return {boolean} True if the Text Field is required.
         */

      }, {
        key: "required",
        get: function get() {
          return this.input_.required;
        }
        /**
         * @param {boolean} required Sets the Text Field to required.
         */
        ,
        set: function set(required) {
          this.input_.required = required;
        }
        /**
         * @return {string} The input element's validation pattern.
         */

      }, {
        key: "pattern",
        get: function get() {
          return this.input_.pattern;
        }
        /**
         * @param {string} pattern Sets the input element's validation pattern.
         */
        ,
        set: function set(pattern) {
          this.input_.pattern = pattern;
        }
        /**
         * @return {number} The input element's minLength.
         */

      }, {
        key: "minLength",
        get: function get() {
          return this.input_.minLength;
        }
        /**
         * @param {number} minLength Sets the input element's minLength.
         */
        ,
        set: function set(minLength) {
          this.input_.minLength = minLength;
        }
        /**
         * @return {number} The input element's maxLength.
         */

      }, {
        key: "maxLength",
        get: function get() {
          return this.input_.maxLength;
        }
        /**
         * @param {number} maxLength Sets the input element's maxLength.
         */
        ,
        set: function set(maxLength) {
          // Chrome throws exception if maxLength is set < 0
          if (maxLength < 0) {
            this.input_.removeAttribute('maxLength');
          } else {
            this.input_.maxLength = maxLength;
          }
        }
        /**
         * @return {string} The input element's min.
         */

      }, {
        key: "min",
        get: function get() {
          return this.input_.min;
        }
        /**
         * @param {string} min Sets the input element's min.
         */
        ,
        set: function set(min) {
          this.input_.min = min;
        }
        /**
         * @return {string} The input element's max.
         */

      }, {
        key: "max",
        get: function get() {
          return this.input_.max;
        }
        /**
         * @param {string} max Sets the input element's max.
         */
        ,
        set: function set(max) {
          this.input_.max = max;
        }
        /**
         * @return {string} The input element's step.
         */

      }, {
        key: "step",
        get: function get() {
          return this.input_.step;
        }
        /**
         * @param {string} step Sets the input element's step.
         */
        ,
        set: function set(step) {
          this.input_.step = step;
        }
        /**
         * Sets the helper text element content.
         * @param {string} content
         */

      }, {
        key: "helperTextContent",
        set: function set(content) {
          this.foundation_.setHelperTextContent(content);
        }
        /**
         * Sets the aria label of the leading icon.
         * @param {string} label
         */

      }, {
        key: "leadingIconAriaLabel",
        set: function set(label) {
          this.foundation_.setLeadingIconAriaLabel(label);
        }
        /**
         * Sets the text content of the leading icon.
         * @param {string} content
         */

      }, {
        key: "leadingIconContent",
        set: function set(content) {
          this.foundation_.setLeadingIconContent(content);
        }
        /**
         * Sets the aria label of the trailing icon.
         * @param {string} label
         */

      }, {
        key: "trailingIconAriaLabel",
        set: function set(label) {
          this.foundation_.setTrailingIconAriaLabel(label);
        }
        /**
         * Sets the text content of the trailing icon.
         * @param {string} content
         */

      }, {
        key: "trailingIconContent",
        set: function set(content) {
          this.foundation_.setTrailingIconContent(content);
        }
        /**
         * Enables or disables the use of native validation. Use this for custom validation.
         * @param {boolean} useNativeValidation Set this to false to ignore native input validation.
         */

      }, {
        key: "useNativeValidation",
        set: function set(useNativeValidation) {
          this.foundation_.setUseNativeValidation(useNativeValidation);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTextField(root);
        }
      }]);

      return MDCTextField;
    }(MDCComponent$n);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to configure the default options for all
     * mdc-text-field usage within an app.
     * @type {?}
     */
    var MDC_TEXT_FIELD_DEFAULT_OPTIONS = new core.InjectionToken('MDC_TEXT_FIELD_DEFAULT_OPTIONS');
    var MdcTextFieldBase = /** @class */ (function () {
        function MdcTextFieldBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
            this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this.ngControl = ngControl;
        }
        return MdcTextFieldBase;
    }());
    /** @type {?} */
    var _MdcTextFieldMixinBase = mixinErrorState(MdcTextFieldBase);
    /** @type {?} */
    var nextUniqueId$9 = 0;
    /**
     * Time in milliseconds for which to ignore mouse events, after
     * receiving a touch event. Used to avoid doing double work for
     * touch devices where the browser fires fake mouse events, in
     * addition to touch events.
     * @type {?}
     */
    var MOUSE_EVENT_IGNORE_TIME$1 = 800;
    var MdcTextField = /** @class */ (function (_super) {
        __extends(MdcTextField, _super);
        function MdcTextField(_platform, _changeDetectorRef, elementRef, _defaultErrorStateMatcher, _parentFormField, _ripple, ngControl, _parentForm, _parentFormGroup, _defaults) {
            var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
            _this._platform = _platform;
            _this._changeDetectorRef = _changeDetectorRef;
            _this.elementRef = elementRef;
            _this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
            _this._parentFormField = _parentFormField;
            _this._ripple = _ripple;
            _this.ngControl = ngControl;
            _this._defaults = _defaults;
            _this._uid = "mdc-input-" + nextUniqueId$9++;
            _this._initialized = false;
            /**
             * Time in milliseconds when the last touchstart event happened.
             */
            _this._lastTouchStartEvent = 0;
            _this.controlType = 'mdc-text-field';
            _this.label = null;
            _this.placeholder = null;
            _this.tabIndex = 0;
            _this._id = '';
            _this._type = 'text';
            _this._outlined = false;
            _this._disabled = false;
            _this._required = false;
            _this._readonly = false;
            _this._fullwidth = false;
            _this._dense = false;
            _this._helperText = null;
            _this._useNativeValidation = true;
            _this._characterCounter = false;
            _this.change = new core.EventEmitter();
            _this.input = new core.EventEmitter();
            _this.blur = new core.EventEmitter();
            /**
             * View to model callback called when value changes
             */
            _this._onChange = (/**
             * @return {?}
             */
            function () { });
            /**
             * View to model callback called when text field has been touched
             */
            _this._onTouched = (/**
             * @return {?}
             */
            function () { });
            _this._foundation = new MDCTextFieldFoundation(_this._createAdapter());
            if (_this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                _this.ngControl.valueAccessor = _this;
            }
            if (_this._parentFormField) {
                _parentFormField.elementRef.nativeElement.classList.add('ngx-form-field-text-field');
            }
            // Force setter to be called in case id was not specified.
            _this.id = _this.id;
            return _this;
        }
        Object.defineProperty(MdcTextField.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () { return this._id; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) { this._id = value || this._uid; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "type", {
            /** Input type of the element. */
            get: /**
             * Input type of the element.
             * @return {?}
             */
            function () { return this._type; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._type = value || 'text';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "outlined", {
            get: /**
             * @return {?}
             */
            function () { return this._outlined; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._outlined) {
                    this._outlined = newValue || (this._defaults && this._defaults.outlined) || false;
                    this.layout();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabledState(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "required", {
            get: /**
             * @return {?}
             */
            function () { return this._required; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._required) {
                    this._required = newValue;
                    if (this._initialized) {
                        if (!this.valid) {
                            this._foundation.setValid(true);
                            this._changeDetectorRef.markForCheck();
                        }
                        if (this.ngControl) {
                            this._required ? this._getInputElement().setAttribute('required', '') :
                                this._getInputElement().removeAttribute('required');
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "readonly", {
            get: /**
             * @return {?}
             */
            function () { return this._readonly; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._readonly = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "fullwidth", {
            get: /**
             * @return {?}
             */
            function () { return this._fullwidth; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._fullwidth) {
                    this._fullwidth = newValue;
                    this.placeholder = this.fullwidth ? this.label : '';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "dense", {
            get: /**
             * @return {?}
             */
            function () { return this._dense; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._dense = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "helperText", {
            get: /**
             * @return {?}
             */
            function () { return this._helperText; },
            set: /**
             * @param {?} helperText
             * @return {?}
             */
            function (helperText) {
                this._helperText = helperText;
                if (this._helperText) {
                    this._initHelperText();
                    this._helperText.characterCounter = this._characterCounter;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "valid", {
            /** Sets the Text Field valid or invalid. */
            get: /**
             * Sets the Text Field valid or invalid.
             * @return {?}
             */
            function () { return this._valid; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._valid) {
                    this._valid = value;
                    this._foundation.setValid(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "useNativeValidation", {
            /** Enables or disables the use of native validation. Use this for custom validation. */
            get: /**
             * Enables or disables the use of native validation. Use this for custom validation.
             * @return {?}
             */
            function () { return this._useNativeValidation; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._useNativeValidation) {
                    this._useNativeValidation = newValue;
                    this._foundation.setUseNativeValidation(this._useNativeValidation);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "characterCounter", {
            get: /**
             * @return {?}
             */
            function () { return this._characterCounter; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var newValue = toBoolean(value);
                if (newValue !== this._characterCounter) {
                    this._characterCounter = newValue;
                    if (this.helperText) {
                        this.helperText.characterCounter = this._characterCounter;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (!this._initialized) {
                    this.ngControl ? this._initializeValue() : this._initializeValue(newValue);
                }
                else {
                    this.setValue(newValue, true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "textarea", {
            get: /**
             * @return {?}
             */
            function () { return this._getHostElement().nodeName.toLowerCase() === 'mdc-textarea'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "focused", {
            get: /**
             * @return {?}
             */
            function () {
                return this._platform.isBrowser ?
                    (/** @type {?} */ (document.activeElement)) === this._getInputElement() : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "leadingIcon", {
            get: /**
             * @return {?}
             */
            function () {
                return this._icons ?
                    this._icons.find((/**
                     * @param {?} icon
                     * @return {?}
                     */
                    function (icon) { return icon.leading; })) : undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "trailingIcon", {
            get: /**
             * @return {?}
             */
            function () {
                return this._icons ?
                    this._icons.find((/**
                     * @param {?} icon
                     * @return {?}
                     */
                    function (icon) { return icon.trailing; })) : undefined;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return Object.assign({
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.remove(className); }),
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                isFocused: (/**
                 * @return {?}
                 */
                function () { return _this._platform.isBrowser ? (/** @type {?} */ (document.activeElement)) === _this._getInputElement() : false; })
            }, this._getInputAdapterMethods(), this._getLabelAdapterMethods(), this._getLineRippleAdapterMethods(), this._getOutlineAdapterMethods());
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getInputAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                getNativeInput: (/**
                 * @return {?}
                 */
                function () {
                    return {
                        maxLength: _this.maxlength,
                        type: _this._type,
                        value: _this._platform.isBrowser ? _this._input.nativeElement.value : _this._value,
                        disabled: _this._disabled,
                        validity: {
                            valid: _this._isValid(),
                            badInput: _this._platform.isBrowser ? _this._input.nativeElement.validity.badInput : false
                        }
                    };
                })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getLabelAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                shakeLabel: (/**
                 * @param {?} shouldShake
                 * @return {?}
                 */
                function (shouldShake) { return _this._getFloatingLabel().shake(shouldShake); }),
                floatLabel: (/**
                 * @param {?} shouldFloat
                 * @return {?}
                 */
                function (shouldFloat) { return _this._getFloatingLabel().float(shouldFloat); }),
                hasLabel: (/**
                 * @return {?}
                 */
                function () { return _this._hasFloatingLabel(); }),
                getLabelWidth: (/**
                 * @return {?}
                 */
                function () { return _this._hasFloatingLabel() ? _this._getFloatingLabel().getWidth() : 0; })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getLineRippleAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                activateLineRipple: (/**
                 * @return {?}
                 */
                function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.activate();
                    }
                }),
                deactivateLineRipple: (/**
                 * @return {?}
                 */
                function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.deactivate();
                    }
                }),
                setLineRippleTransformOrigin: (/**
                 * @param {?} normalizedX
                 * @return {?}
                 */
                function (normalizedX) {
                    if (_this._lineRipple) {
                        _this._lineRipple.setRippleCenter(normalizedX);
                    }
                })
            };
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getOutlineAdapterMethods = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                hasOutline: (/**
                 * @return {?}
                 */
                function () { return _this._notchedOutline; }),
                notchOutline: (/**
                 * @param {?} labelWidth
                 * @return {?}
                 */
                function (labelWidth) { return (/** @type {?} */ (_this._notchedOutline)).notch(labelWidth); }),
                closeOutline: (/**
                 * @return {?}
                 */
                function () { return (/** @type {?} */ (_this._notchedOutline)).closeNotch(); })
            };
        };
        /** Returns a map of all subcomponents to subfoundations.*/
        /**
         * Returns a map of all subcomponents to subfoundations.
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getFoundationMap = /**
         * Returns a map of all subcomponents to subfoundations.
         * @private
         * @return {?}
         */
        function () {
            return {
                helperText: this._helperText || undefined,
                characterCounter: this.characterCounterFoundation()
            };
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._setDefaultOptions();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.init();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                // We need to re-evaluate this on every change detection cycle, because there are some
                // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                // that whatever logic is in here has to be super lean or we risk destroying the performance.
                this.updateErrorState();
            }
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.init = /**
         * @return {?}
         */
        function () {
            this._foundation = new MDCTextFieldFoundation(this._createAdapter(), this._getFoundationMap());
            this._initRipple();
            this._foundation.init();
            this._checkCustomValidity();
            this._initialized = true;
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.onTextFieldInteraction = /**
         * @return {?}
         */
        function () {
            if (this._initialized) {
                this._foundation.handleTextFieldInteraction();
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcTextField.prototype.onInputInteraction = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (evt instanceof MouseEvent) {
                /** @type {?} */
                var isSyntheticEvent = this._lastTouchStartEvent &&
                    Date.now() < this._lastTouchStartEvent + MOUSE_EVENT_IGNORE_TIME$1;
                if (isSyntheticEvent) {
                    return;
                }
            }
            else {
                this._lastTouchStartEvent = Date.now();
            }
            this._foundation.setTransformOrigin(evt);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcTextField.prototype.onInput = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var value = ((/** @type {?} */ (evt.target))).value;
            this.setValue(value, true);
            this._foundation.handleInput();
            this.input.emit(value);
            evt.stopPropagation();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.onFocus = /**
         * @return {?}
         */
        function () {
            if (this._initialized) {
                this._foundation.activateFocus();
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcTextField.prototype.onChange = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            /** @type {?} */
            var value = ((/** @type {?} */ (evt.target))).value;
            this.setValue(value, true);
            this.change.emit(value);
            evt.stopPropagation();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            this._onTouched();
            this._foundation.deactivateFocus();
            this.blur.emit(this.value);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcTextField.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setValue(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcTextField.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcTextField.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @private
         * @param {?=} value
         * @return {?}
         */
        MdcTextField.prototype._initializeValue = /**
         * @private
         * @param {?=} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                _this.setValue(_this.ngControl ? _this.ngControl.value : value);
            }));
        };
        /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcTextField.prototype.setValue = /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        function (value, isUserInput) {
            /** @type {?} */
            var newValue = this.type === 'number' ? toNumber(value, null) : value;
            if (this._value === newValue) {
                // Reset validity for numeric form inputs
                if (newValue === null) {
                    this.valid = true;
                }
                return;
            }
            this._value = newValue !== undefined ? newValue : null;
            if (this._getInputElement().value !== this._value) {
                this._getInputElement().value = this._value;
            }
            this._foundation.setValue(this._value);
            if (isUserInput) {
                this._onChange(this._value);
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.isBadInput = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var validity = this._getInputElement().validity;
            return validity && validity.badInput;
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.focus = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._getInputElement().focus();
            }
        };
        /** Initializes Text Field's internal state based on the environment state */
        /**
         * Initializes Text Field's internal state based on the environment state
         * @private
         * @return {?}
         */
        MdcTextField.prototype.layout = /**
         * Initializes Text Field's internal state based on the environment state
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._destroy();
            this.init();
            this._changeDetectorRef.markForCheck();
            setTimeout((/**
             * @return {?}
             */
            function () {
                if (_this._outlined) {
                    _this._foundation.notchOutline(_this._foundation.shouldFloat);
                }
                if (_this._hasFloatingLabel()) {
                    _this._getFloatingLabel().float(_this._foundation.shouldFloat);
                }
            }));
        };
        /** Implemented as part of ControlValueAccessor. */
        /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} isDisabled
         * @return {?}
         */
        MdcTextField.prototype.setDisabledState = /**
         * Implemented as part of ControlValueAccessor.
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            /** @type {?} */
            var newValue = toBoolean(isDisabled);
            if (newValue !== this._disabled) {
                this._disabled = newValue;
                this._foundation.setDisabled(this._disabled);
            }
            this._changeDetectorRef.markForCheck();
        };
        /** Set the default options here. */
        /**
         * Set the default options here.
         * @private
         * @return {?}
         */
        MdcTextField.prototype._setDefaultOptions = /**
         * Set the default options here.
         * @private
         * @return {?}
         */
        function () {
            if (this._defaults && this._defaults.outlined) {
                this._outlined = this._defaults.outlined;
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._checkCustomValidity = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                if (_this._valid !== undefined) {
                    _this._foundation.setValid(_this._valid);
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._initHelperText = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var helper = this.helperText;
            if (helper) {
                helper.addHelperTextClass(this.controlType);
                helper.init(MDCTextFieldHelperTextFoundation);
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._initRipple = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this._ripple || this._ripple.initialized) {
                return;
            }
            if (!this.fullwidth && !this.outlined && !this.textarea) {
                this._ripple.init({
                    surface: this.elementRef.nativeElement,
                    activator: this._getInputElement()
                });
            }
            else {
                this._ripple.destroy();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._destroy = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._lineRipple) {
                this._lineRipple.destroy();
            }
            if (this._ripple) {
                this._ripple.destroy();
            }
            this._foundation.destroy();
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._isValid = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.ngControl) {
                return !this.errorState;
            }
            return this._valid ? this._valid : this._platform.isBrowser ?
                this._input.nativeElement.validity.valid : true;
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._hasFloatingLabel = /**
         * @private
         * @return {?}
         */
        function () {
            return this.label && (this._floatingLabel || this._notchedOutline) ? true : false;
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getFloatingLabel = /**
         * @private
         * @return {?}
         */
        function () {
            return this._floatingLabel || (/** @type {?} */ (this._notchedOutline)).floatingLabel;
        };
        /**
         * @protected
         * @return {?}
         */
        MdcTextField.prototype.characterCounterFoundation = /**
         * @protected
         * @return {?}
         */
        function () {
            return this.helperText && this.characterCounter ?
                (/** @type {?} */ (this.helperText._characterCounterElement)).getDefaultFoundation() : undefined;
        };
        /**
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getInputElement = /**
         * @private
         * @return {?}
         */
        function () {
            return this._input.nativeElement;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcTextField.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTextField.decorators = [
            { type: core.Component, args: [{selector: 'mdc-text-field',
                        exportAs: 'mdcTextField',
                        host: {
                            'class': 'mdc-text-field',
                            '[class.mdc-text-field--disabled]': 'disabled',
                            '[class.mdc-text-field--outlined]': 'outlined',
                            '[class.mdc-text-field--dense]': 'dense',
                            '[class.mdc-text-field--fullwidth]': 'fullwidth',
                            '[class.mdc-text-field--with-leading-icon]': 'leadingIcon',
                            '[class.mdc-text-field--with-trailing-icon]': 'trailingIcon',
                            '[class.mdc-text-field--no-label]': '!label || label && fullwidth',
                            '[class.mdc-text-field--invalid]': 'errorState',
                            '(click)': 'onTextFieldInteraction()',
                            '(keydown)': 'onTextFieldInteraction()'
                        },
                        template: "\n  <ng-content *ngIf=\"leadingIcon\"></ng-content>\n  <input #inputElement class=\"mdc-text-field__input\"\n    [id]=\"id\"\n    [type]=\"type\"\n    [tabindex]=\"tabIndex\"\n    [attr.aria-invalid]=\"errorState\"\n    [attr.autocomplete]=\"autocomplete\"\n    [attr.pattern]=\"pattern\"\n    [attr.placeholder]=\"placeholder\"\n    [attr.maxlength]=\"maxlength\"\n    [attr.minlength]=\"minlength\"\n    [attr.max]=\"max\"\n    [attr.min]=\"min\"\n    [attr.size]=\"size\"\n    [attr.step]=\"step\"\n    [disabled]=\"disabled\"\n    [readonly]=\"readonly\"\n    [required]=\"required\"\n    (mousedown)=\"onInputInteraction($event)\"\n    (touchstart)=\"onInputInteraction($event)\"\n    (focus)=\"onFocus()\"\n    (input)=\"onInput($event)\"\n    (change)=\"onChange($event)\"\n    (blur)=\"onBlur()\" />\n    <ng-content></ng-content>\n    <label mdcFloatingLabel [for]=\"id\" *ngIf=\"!this.placeholder && !outlined\">{{label}}</label>\n    <mdc-line-ripple *ngIf=\"!this.outlined && !this.textarea\"></mdc-line-ripple>\n    <mdc-notched-outline *ngIf=\"outlined\" [label]=\"label\" [for]=\"id\"></mdc-notched-outline>",
                        providers: [
                            MdcRipple,
                            { provide: MdcFormFieldControl, useExisting: MdcTextField }
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcTextField.ctorParameters = function () { return [
            { type: Platform },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: ErrorStateMatcher },
            { type: MdcFormField, decorators: [{ type: core.Optional }] },
            { type: MdcRipple, decorators: [{ type: core.Optional }] },
            { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
            { type: forms.NgForm, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_TEXT_FIELD_DEFAULT_OPTIONS,] }] }
        ]; };
        MdcTextField.propDecorators = {
            label: [{ type: core.Input }],
            maxlength: [{ type: core.Input }],
            minlength: [{ type: core.Input }],
            pattern: [{ type: core.Input }],
            autocomplete: [{ type: core.Input }],
            max: [{ type: core.Input }],
            min: [{ type: core.Input }],
            size: [{ type: core.Input }],
            step: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            id: [{ type: core.Input }],
            type: [{ type: core.Input }],
            outlined: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            required: [{ type: core.Input }],
            readonly: [{ type: core.Input }],
            fullwidth: [{ type: core.Input }],
            dense: [{ type: core.Input }],
            helperText: [{ type: core.Input }],
            valid: [{ type: core.Input }],
            useNativeValidation: [{ type: core.Input }],
            characterCounter: [{ type: core.Input }],
            value: [{ type: core.Input }],
            errorStateMatcher: [{ type: core.Input }],
            change: [{ type: core.Output }],
            input: [{ type: core.Output }],
            blur: [{ type: core.Output }],
            _input: [{ type: core.ViewChild, args: ['inputElement',] }],
            _lineRipple: [{ type: core.ViewChild, args: [MdcLineRipple,] }],
            _notchedOutline: [{ type: core.ViewChild, args: [MdcNotchedOutline,] }],
            _floatingLabel: [{ type: core.ViewChild, args: [MdcFloatingLabel,] }],
            _icons: [{ type: core.ContentChildren, args: [MdcTextFieldIcon, { descendants: true },] }]
        };
        return MdcTextField;
    }(_MdcTextFieldMixinBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTextarea = /** @class */ (function (_super) {
        __extends(MdcTextarea, _super);
        function MdcTextarea() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @protected
         * @return {?}
         */
        MdcTextarea.prototype.characterCounterFoundation = /**
         * @protected
         * @return {?}
         */
        function () {
            return this.characterCounter ? this._characterCounterElement.getDefaultFoundation() : undefined;
        };
        MdcTextarea.decorators = [
            { type: core.Component, args: [{selector: 'mdc-textarea',
                        exportAs: 'mdcTextarea',
                        host: {
                            'class': 'mdc-text-field',
                            '[class.mdc-text-field--textarea]': 'true',
                            '[class.mdc-text-field--no-label]': '!label',
                            '[class.mdc-text-field--dense]': 'dense',
                            '[class.mdc-text-field--fullwidth]': 'fullwidth',
                            '[class.mdc-text-field--invalid]': 'errorState'
                        },
                        template: "\n  <div mdcCharacterCounter *ngIf=\"characterCounter\"></div>\n  <textarea #inputElement class=\"mdc-text-field__input\"\n    [id]=\"id\"\n    [rows]=\"rows\"\n    [cols]=\"cols\"\n    [tabindex]=\"tabIndex\"\n    [attr.aria-invalid]=\"errorState\"\n    [attr.maxlength]=\"maxlength\"\n    [attr.minlength]=\"minlength\"\n    [disabled]=\"disabled\"\n    [required]=\"required\"\n    (mousedown)=\"onInputInteraction($event)\"\n    (touchstart)=\"onInputInteraction($event)\"\n    (focus)=\"onFocus()\"\n    (input)=\"onInput($event)\"\n    (change)=\"onChange($event)\"\n    (blur)=\"onBlur()\"></textarea>\n  <mdc-notched-outline [label]=\"label\" [for]=\"id\"></mdc-notched-outline>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        MdcTextarea.propDecorators = {
            rows: [{ type: core.Input }],
            cols: [{ type: core.Input }],
            _characterCounterElement: [{ type: core.ViewChild, args: [MdcCharacterCounter,] }]
        };
        return MdcTextarea;
    }(MdcTextField));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TEXTFIELD_DECLARATIONS = [
        MdcTextarea,
        MdcTextField,
        MdcTextFieldIcon
    ];
    var MdcTextFieldModule = /** @class */ (function () {
        function MdcTextFieldModule() {
        }
        MdcTextFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            MdcFormFieldModule,
                            MdcLineRippleModule,
                            MdcFloatingLabelModule,
                            MdcNotchedOutlineModule
                        ],
                        exports: [
                            MdcFormFieldModule,
                            TEXTFIELD_DECLARATIONS
                        ],
                        declarations: TEXTFIELD_DECLARATIONS
                    },] },
        ];
        return MdcTextFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTopAppBarFixedAdjust = /** @class */ (function () {
        function MdcTopAppBarFixedAdjust(elementRef) {
            this.elementRef = elementRef;
        }
        MdcTopAppBarFixedAdjust.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcTopAppBarFixedAdjust]',
                        host: { 'class': 'mdc-top-app-bar--fixed-adjust' }
                    },] },
        ];
        /** @nocollapse */
        MdcTopAppBarFixedAdjust.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcTopAppBarFixedAdjust;
    }());
    var MdcTopAppBarRow = /** @class */ (function () {
        function MdcTopAppBarRow(elementRef) {
            this.elementRef = elementRef;
        }
        MdcTopAppBarRow.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-top-app-bar-row, [mdcTopAppBarRow]',
                        exportAs: 'mdcTopAppBarRow',
                        host: { 'class': 'mdc-top-app-bar__row' }
                    },] },
        ];
        /** @nocollapse */
        MdcTopAppBarRow.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcTopAppBarRow;
    }());
    var MdcTopAppBarSection = /** @class */ (function () {
        function MdcTopAppBarSection(elementRef) {
            this.elementRef = elementRef;
        }
        MdcTopAppBarSection.decorators = [
            { type: core.Component, args: [{selector: 'mdc-top-app-bar-section, [mdcTopAppBarSection]',
                        exportAs: 'mdcTopAppBarSection',
                        host: {
                            'role': 'toolbar',
                            'class': 'mdc-top-app-bar__section',
                            '[class.mdc-top-app-bar__section--align-start]': 'align === "start"',
                            '[class.mdc-top-app-bar__section--align-end]': 'align === "end"'
                        },
                        template: "\n  <ng-content></ng-content>\n  <span class=\"mdc-top-app-bar__title\" *ngIf=\"title\">{{title}}</span>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcTopAppBarSection.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcTopAppBarSection.propDecorators = {
            title: [{ type: core.Input }],
            align: [{ type: core.Input }]
        };
        return MdcTopAppBarSection;
    }());
    var MdcTopAppBarActionItem = /** @class */ (function () {
        function MdcTopAppBarActionItem(elementRef, _ripple) {
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this._ripple.init({ surface: this.elementRef.nativeElement, unbounded: true });
        }
        /**
         * @return {?}
         */
        MdcTopAppBarActionItem.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._ripple.destroy();
        };
        MdcTopAppBarActionItem.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcTopAppBarActionItem], mdc-top-app-bar-action-item',
                        exportAs: 'mdcTopAppBarActionItem',
                        host: {
                            'role': 'button',
                            'class': 'mdc-top-app-bar__action-item'
                        },
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcTopAppBarActionItem.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        return MdcTopAppBarActionItem;
    }());
    var MdcTopAppBarNavigationIcon = /** @class */ (function () {
        function MdcTopAppBarNavigationIcon(elementRef, _ripple) {
            this.elementRef = elementRef;
            this._ripple = _ripple;
            _ripple.init({ surface: this.elementRef.nativeElement, unbounded: true });
        }
        /**
         * @return {?}
         */
        MdcTopAppBarNavigationIcon.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._ripple.destroy();
        };
        MdcTopAppBarNavigationIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcTopAppBarNavIcon], mdc-icon[mdcTopAppBarNavigationIcon]',
                        exportAs: 'mdcTopAppBarNavigationIcon',
                        host: {
                            'role': 'button',
                            'class': 'mdc-top-app-bar__navigation-icon'
                        },
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcTopAppBarNavigationIcon.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        return MdcTopAppBarNavigationIcon;
    }());
    var MdcTopAppBarTitle = /** @class */ (function () {
        function MdcTopAppBarTitle(elementRef) {
            this.elementRef = elementRef;
        }
        MdcTopAppBarTitle.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-top-app-bar-title, [mdcTopAppBarTitle]',
                        exportAs: 'mdcTopAppBarTitle',
                        host: { 'class': 'mdc-top-app-bar__title' },
                    },] },
        ];
        /** @nocollapse */
        MdcTopAppBarTitle.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcTopAppBarTitle;
    }());

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** @enum {string} */
    var cssClasses$o = {
      FIXED_CLASS: 'mdc-top-app-bar--fixed',
      FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
      SHORT_CLASS: 'mdc-top-app-bar--short',
      SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
      SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
    };
    /** @enum {number} */

    var numbers$g = {
      DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
      MAX_TOP_APP_BAR_HEIGHT: 128
    };
    /** @enum {string} */

    var strings$m = {
      ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
      NAVIGATION_EVENT: 'MDCTopAppBar:nav',
      NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
      ROOT_SELECTOR: '.mdc-top-app-bar',
      TITLE_SELECTOR: '.mdc-top-app-bar__title'
    };

    function _classCallCheck$o(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$o(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$o(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$o(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$o(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$o(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$o(subClass, superClass);
    }

    function _getPrototypeOf$o(o) {
      _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$o(o);
    }

    function _setPrototypeOf$o(o, p) {
      _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$o(o, p);
    }

    function _assertThisInitialized$o(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$o(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$o(self);
    }

    function _superPropBase$e(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$o(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$e(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$e = Reflect.get;
      } else {
        _get$e = function _get(target, property, receiver) {
          var base = _superPropBase$e(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$e(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Top App Bar
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Top App Bar into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTopAppBarAdapter =
    /*#__PURE__*/
    function () {
      function MDCTopAppBarAdapter() {
        _classCallCheck$o(this, MDCTopAppBarAdapter);
      }

      _createClass$o(MDCTopAppBarAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root Element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root Element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root Element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the specified inline style property on the root Element to the given value.
         * @param {string} property
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(property, value) {}
        /**
         * Gets the height of the top app bar.
         * @return {number}
         */

      }, {
        key: "getTopAppBarHeight",
        value: function getTopAppBarHeight() {}
        /**
         * Registers an event handler on the navigation icon element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerNavigationIconInteractionHandler",
        value: function registerNavigationIconInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the navigation icon element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterNavigationIconInteractionHandler",
        value: function deregisterNavigationIconInteractionHandler(type, handler) {}
        /**
         * Emits an event when the navigation icon is clicked.
         */

      }, {
        key: "notifyNavigationIconClicked",
        value: function notifyNavigationIconClicked() {}
        /** @param {function(!Event)} handler */

      }, {
        key: "registerScrollHandler",
        value: function registerScrollHandler(handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "deregisterScrollHandler",
        value: function deregisterScrollHandler(handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /** @return {number} */

      }, {
        key: "getViewportScrollY",
        value: function getViewportScrollY() {}
        /** @return {number} */

      }, {
        key: "getTotalActionItems",
        value: function getTotalActionItems() {}
      }]);

      return MDCTopAppBarAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * @template A
     */
    var MDCFoundation$o =
    /*#__PURE__*/
    function () {
      _createClass$o(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$o(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$o(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$o =
    /*#__PURE__*/
    function () {
      _createClass$o(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$o());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$o(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$o(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$b =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$o(this, MDCRippleAdapter);
      }

      _createClass$o(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1$e = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$d = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$1$6 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$b;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$b;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$b(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$b(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$b;

      if (typeof supportsCssVariables_$b === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$b(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$b = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|!EventListenerOptions}
     */


    function applyPassive$b() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$b === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
              return isSupported;
            }

          });
        } catch (e) {}

        supportsPassive_$b = isSupported;
      }

      return supportsPassive_$b ?
      /** @type {!EventListenerOptions} */
      {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {string}
     */


    function getMatchesProperty$c(HTMLElementPrototype) {
      /**
       * Order is important because we return the first existing method we find.
       * Do not change the order of the items in the below array.
       */
      var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
      var method = 'matches';

      for (var i = 0; i < matchesMethods.length; i++) {
        var matchesMethod = matchesMethods[i];

        if (matchesMethod in HTMLElementPrototype) {
          method = matchesMethod;
          break;
        }
      }

      return method;
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$b(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        ev =
        /** @type {!TouchEvent} */
        ev;
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        ev =
        /** @type {!MouseEvent} */
        ev;
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$c = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$c = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$b = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$b =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$o(MDCRippleFoundation, _MDCFoundation);

      _createClass$o(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$e;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$d;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$6;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$o(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$o(this, _getPrototypeOf$o(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event=)} */


        _this.deactivateHandler_ = function () {
          return _this.deactivate_();
        };
        /** @private {function(!Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(!Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {!Event|undefined} */


        _this.previousActivationEvent_;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$o(MDCRippleFoundation, [{
        key: "supportsPressRipple_",
        value: function supportsPressRipple_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: undefined,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          var supportsPressRipple = this.supportsPressRipple_();
          this.registerRootHandlers_(supportsPressRipple);

          if (supportsPressRipple) {
            var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$.ROOT,
                UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
            requestAnimationFrame(function () {
              _this2.adapter_.addClass(ROOT);

              if (_this2.adapter_.isUnbounded()) {
                _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


                _this2.layoutInternal_();
              }
            });
          }
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
              clearTimeout(this.activationTimer_);
              this.activationTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }

            if (this.fgDeactivationRemovalTimer_) {
              clearTimeout(this.fgDeactivationRemovalTimer_);
              this.fgDeactivationRemovalTimer_ = 0;
              this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }

            var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
                ROOT = _MDCRippleFoundation$2.ROOT,
                UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
            requestAnimationFrame(function () {
              _this3.adapter_.removeClass(ROOT);

              _this3.adapter_.removeClass(UNBOUNDED);

              _this3.removeCssVars_();
            });
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
        }
        /**
         * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
         * @private
         */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_(supportsPressRipple) {
          var _this4 = this;

          if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES$c.forEach(function (type) {
              _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
            });

            if (this.adapter_.isUnbounded()) {
              this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
          }

          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$c.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$c.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$c.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === undefined;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
          var hasActivatedChild = e !== undefined && activatedTargets$b.length > 0 && activatedTargets$b.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e !== undefined) {
            activatedTargets$b.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$b = [];

            if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {!Event=} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {!Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate(event) {
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$b(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$1$6.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = undefined;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_() {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(state);

              _this13.resetActivationState_();
            });
          }
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.deactivate_();
        }
        /**
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(_ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$o);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$b =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$o(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$o(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$o(this, (_getPrototypeOf2 = _getPrototypeOf$o(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$o(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$b(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$c(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$b(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$b());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$b());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$b());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$b());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$o);
    /**
     * See Material Design spec for more details on when to use ripples.
     * https://material.io/guidelines/motion/choreography.html#choreography-creation
     * @record
     */


    var RippleCapableSurface$b = function RippleCapableSurface() {
      _classCallCheck$o(this, RippleCapableSurface);
    };
    /** @protected {!Element} */


    RippleCapableSurface$b.prototype.root_;
    /**
     * Whether or not the ripple bleeds out of the bounds of the element.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$b.prototype.unbounded;
    /**
     * Whether or not the ripple is attached to a disabled component.
     * @type {boolean|undefined}
     */

    RippleCapableSurface$b.prototype.disabled;

    /**
     * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
     */

    var MDCTopAppBarBaseFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$o(MDCTopAppBarBaseFoundation, _MDCFoundation);

      _createClass$o(MDCTopAppBarBaseFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$m;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$o;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$g;
        }
        /**
         * {@see MDCTopAppBarAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTopAppBarAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTopAppBarAdapter} */
            {
              hasClass: function hasClass()
              /* className: string */
              {},
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              setStyle: function setStyle()
              /* property: string, value: string */
              {},
              getTopAppBarHeight: function getTopAppBarHeight() {},
              registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
              registerScrollHandler: function registerScrollHandler()
              /* handler: EventListener */
              {},
              deregisterScrollHandler: function deregisterScrollHandler()
              /* handler: EventListener */
              {},
              registerResizeHandler: function registerResizeHandler()
              /* handler: EventListener */
              {},
              deregisterResizeHandler: function deregisterResizeHandler()
              /* handler: EventListener */
              {},
              getViewportScrollY: function getViewportScrollY() {
                return (
                  /* number */
                  0
                );
              },
              getTotalActionItems: function getTotalActionItems() {
                return (
                  /* number */
                  0
                );
              }
            }
          );
        }
        /**
         * @param {!MDCTopAppBarAdapter} adapter
         */

      }]);

      function MDCTopAppBarBaseFoundation(
      /** @type {!MDCTopAppBarAdapter} */
      adapter) {
        var _this;

        _classCallCheck$o(this, MDCTopAppBarBaseFoundation);

        _this = _possibleConstructorReturn$o(this, _getPrototypeOf$o(MDCTopAppBarBaseFoundation).call(this, Object.assign(MDCTopAppBarBaseFoundation.defaultAdapter, adapter)));

        _this.navClickHandler_ = function () {
          return _this.adapter_.notifyNavigationIconClicked();
        };

        _this.scrollHandler_ = function () {};

        return _this;
      }

      _createClass$o(MDCTopAppBarBaseFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
        }
      }, {
        key: "initScrollHandler",
        value: function initScrollHandler() {
          this.adapter_.registerScrollHandler(this.scrollHandler_);
        }
      }, {
        key: "destroyScrollHandler",
        value: function destroyScrollHandler() {
          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
        }
      }]);

      return MDCTopAppBarBaseFoundation;
    }(MDCFoundation$o);

    /**
     * @extends {MDCTopAppBarFoundation<!MDCFixedTopAppBarFoundation>}
     * @final
     */

    var MDCFixedTopAppBarFoundation =
    /*#__PURE__*/
    function (_MDCTopAppBarFoundati) {
      _inherits$o(MDCFixedTopAppBarFoundation, _MDCTopAppBarFoundati);

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */
      function MDCFixedTopAppBarFoundation(adapter) {
        var _this;

        _classCallCheck$o(this, MDCFixedTopAppBarFoundation);

        _this = _possibleConstructorReturn$o(this, _getPrototypeOf$o(MDCFixedTopAppBarFoundation).call(this, adapter));
        /** State variable for the previous scroll iteration top app bar state */

        _this.wasScrolled_ = false;

        _this.scrollHandler_ = function () {
          return _this.fixedScrollHandler_();
        };

        return _this;
      }

      _createClass$o(MDCFixedTopAppBarFoundation, [{
        key: "init",
        value: function init() {
          _get$e(_getPrototypeOf$o(MDCFixedTopAppBarFoundation.prototype), "init", this).call(this);

          this.adapter_.registerScrollHandler(this.scrollHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$e(_getPrototypeOf$o(MDCFixedTopAppBarFoundation.prototype), "destroy", this).call(this);

          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
        }
        /**
         * Scroll handler for applying/removing the modifier class
         * on the fixed top app bar.
         */

      }, {
        key: "fixedScrollHandler_",
        value: function fixedScrollHandler_() {
          var currentScroll = this.adapter_.getViewportScrollY();

          if (currentScroll <= 0) {
            if (this.wasScrolled_) {
              this.adapter_.removeClass(cssClasses$o.FIXED_SCROLLED_CLASS);
              this.wasScrolled_ = false;
            }
          } else {
            if (!this.wasScrolled_) {
              this.adapter_.addClass(cssClasses$o.FIXED_SCROLLED_CLASS);
              this.wasScrolled_ = true;
            }
          }
        }
      }]);

      return MDCFixedTopAppBarFoundation;
    }(MDCTopAppBarBaseFoundation);

    /**
     * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
     * @final
     */

    var MDCShortTopAppBarFoundation =
    /*#__PURE__*/
    function (_MDCTopAppBarBaseFoun) {
      _inherits$o(MDCShortTopAppBarFoundation, _MDCTopAppBarBaseFoun);

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */
      function MDCShortTopAppBarFoundation(adapter) {
        var _this;

        _classCallCheck$o(this, MDCShortTopAppBarFoundation);

        _this = _possibleConstructorReturn$o(this, _getPrototypeOf$o(MDCShortTopAppBarFoundation).call(this, adapter)); // State variable for the current top app bar state

        _this.isCollapsed = false;

        _this.scrollHandler_ = function () {
          return _this.shortAppBarScrollHandler_();
        };

        return _this;
      }

      _createClass$o(MDCShortTopAppBarFoundation, [{
        key: "init",
        value: function init() {
          _get$e(_getPrototypeOf$o(MDCShortTopAppBarFoundation.prototype), "init", this).call(this);

          var isAlwaysCollapsed = this.adapter_.hasClass(cssClasses$o.SHORT_COLLAPSED_CLASS);

          if (this.adapter_.getTotalActionItems() > 0) {
            this.adapter_.addClass(cssClasses$o.SHORT_HAS_ACTION_ITEM_CLASS);
          }

          if (!isAlwaysCollapsed) {
            this.adapter_.registerScrollHandler(this.scrollHandler_);
            this.shortAppBarScrollHandler_();
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$e(_getPrototypeOf$o(MDCShortTopAppBarFoundation.prototype), "destroy", this).call(this);

          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
        }
        /**
         * Scroll handler for applying/removing the collapsed modifier class
         * on the short top app bar.
         * @private
         */

      }, {
        key: "shortAppBarScrollHandler_",
        value: function shortAppBarScrollHandler_() {
          var currentScroll = this.adapter_.getViewportScrollY();

          if (currentScroll <= 0) {
            if (this.isCollapsed) {
              this.adapter_.removeClass(cssClasses$o.SHORT_COLLAPSED_CLASS);
              this.isCollapsed = false;
            }
          } else {
            if (!this.isCollapsed) {
              this.adapter_.addClass(cssClasses$o.SHORT_COLLAPSED_CLASS);
              this.isCollapsed = true;
            }
          }
        }
      }]);

      return MDCShortTopAppBarFoundation;
    }(MDCTopAppBarBaseFoundation);

    var INITIAL_VALUE = 0;
    /**
     * @extends {MDCTopAppBarBaseFoundation<!MDCTopAppBarFoundation>}
     * @final
     */

    var MDCTopAppBarFoundation =
    /*#__PURE__*/
    function (_MDCTopAppBarBaseFoun) {
      _inherits$o(MDCTopAppBarFoundation, _MDCTopAppBarBaseFoun);

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */
      function MDCTopAppBarFoundation(adapter) {
        var _this;

        _classCallCheck$o(this, MDCTopAppBarFoundation);

        _this = _possibleConstructorReturn$o(this, _getPrototypeOf$o(MDCTopAppBarFoundation).call(this, adapter));
        /**
         * Used for diffs of current scroll position vs previous scroll position
         * @private {number}
         */

        _this.lastScrollPosition_ = _this.adapter_.getViewportScrollY();
        /**
         * Used to verify when the top app bar is completely showing or completely hidden
         * @private {number}
         */

        _this.topAppBarHeight_ = _this.adapter_.getTopAppBarHeight();
        /**
         * wasDocked_ is used to indicate if the top app bar was docked in the previous
         * scroll handler iteration.
         * @private {boolean}
         */

        _this.wasDocked_ = true;
        /**
         * isDockedShowing_ is used to indicate if the top app bar is docked in the fully
         * shown position.
         * @private {boolean}
         */

        _this.isDockedShowing_ = true;
        /**
         * Variable for current scroll position of the top app bar
         * @private {number}
         */

        _this.currentAppBarOffsetTop_ = 0;
        /**
         * Used to prevent the top app bar from being scrolled out of view during resize events
         * @private {boolean} */

        _this.isCurrentlyBeingResized_ = false;
        /**
         * The timeout that's used to throttle the resize events
         * @private {number}
         */

        _this.resizeThrottleId_ = INITIAL_VALUE;
        /**
         * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize
         * @private {number}
         */

        _this.resizeDebounceId_ = INITIAL_VALUE;

        _this.scrollHandler_ = function () {
          return _this.topAppBarScrollHandler_();
        };

        _this.resizeHandler_ = function () {
          return _this.topAppBarResizeHandler_();
        };

        return _this;
      }

      _createClass$o(MDCTopAppBarFoundation, [{
        key: "init",
        value: function init() {
          _get$e(_getPrototypeOf$o(MDCTopAppBarFoundation.prototype), "init", this).call(this);

          this.adapter_.registerScrollHandler(this.scrollHandler_);
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$e(_getPrototypeOf$o(MDCTopAppBarFoundation.prototype), "destroy", this).call(this);

          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          this.adapter_.setStyle('top', '');
        }
        /**
         * Function to determine if the DOM needs to update.
         * @return {boolean}
         * @private
         */

      }, {
        key: "checkForUpdate_",
        value: function checkForUpdate_() {
          var offscreenBoundaryTop = -this.topAppBarHeight_;
          var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
          var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
          var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen; // If it's partially showing, it can't be docked.

          if (partiallyShowing) {
            this.wasDocked_ = false;
          } else {
            // Not previously docked and not partially showing, it's now docked.
            if (!this.wasDocked_) {
              this.wasDocked_ = true;
              return true;
            } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
              this.isDockedShowing_ = hasAnyPixelsOnscreen;
              return true;
            }
          }

          return partiallyShowing;
        }
        /**
         * Function to move the top app bar if needed.
         * @private
         */

      }, {
        key: "moveTopAppBar_",
        value: function moveTopAppBar_() {
          if (this.checkForUpdate_()) {
            // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
            // so the top app bar doesn't show if the window resizes and the new height > the old height.
            var offset = this.currentAppBarOffsetTop_;

            if (Math.abs(offset) >= this.topAppBarHeight_) {
              offset = -numbers$g.MAX_TOP_APP_BAR_HEIGHT;
            }

            this.adapter_.setStyle('top', offset + 'px');
          }
        }
        /**
         * Scroll handler for the default scroll behavior of the top app bar.
         * @private
         */

      }, {
        key: "topAppBarScrollHandler_",
        value: function topAppBarScrollHandler_() {
          var currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);
          var diff = currentScrollPosition - this.lastScrollPosition_;
          this.lastScrollPosition_ = currentScrollPosition; // If the window is being resized the lastScrollPosition_ needs to be updated but the
          // current scroll of the top app bar should stay in the same position.

          if (!this.isCurrentlyBeingResized_) {
            this.currentAppBarOffsetTop_ -= diff;

            if (this.currentAppBarOffsetTop_ > 0) {
              this.currentAppBarOffsetTop_ = 0;
            } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
              this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
            }

            this.moveTopAppBar_();
          }
        }
        /**
         * Top app bar resize handler that throttle/debounce functions that execute updates.
         * @private
         */

      }, {
        key: "topAppBarResizeHandler_",
        value: function topAppBarResizeHandler_() {
          var _this2 = this;

          // Throttle resize events 10 p/s
          if (!this.resizeThrottleId_) {
            this.resizeThrottleId_ = setTimeout(function () {
              _this2.resizeThrottleId_ = INITIAL_VALUE;

              _this2.throttledResizeHandler_();
            }, numbers$g.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
          }

          this.isCurrentlyBeingResized_ = true;

          if (this.resizeDebounceId_) {
            clearTimeout(this.resizeDebounceId_);
          }

          this.resizeDebounceId_ = setTimeout(function () {
            _this2.topAppBarScrollHandler_();

            _this2.isCurrentlyBeingResized_ = false;
            _this2.resizeDebounceId_ = INITIAL_VALUE;
          }, numbers$g.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
        }
        /**
         * Throttled function that updates the top app bar scrolled values if the
         * top app bar height changes.
         * @private
         */

      }, {
        key: "throttledResizeHandler_",
        value: function throttledResizeHandler_() {
          var currentHeight = this.adapter_.getTopAppBarHeight();

          if (this.topAppBarHeight_ !== currentHeight) {
            this.wasDocked_ = false; // Since the top app bar has a different height depending on the screen width, this
            // will ensure that the top app bar remains in the correct location if
            // completely hidden and a resize makes the top app bar a different height.

            this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
            this.topAppBarHeight_ = currentHeight;
          }

          this.topAppBarScrollHandler_();
        }
      }]);

      return MDCTopAppBarFoundation;
    }(MDCTopAppBarBaseFoundation);

    /**
     * @extends {MDCComponent<!MDCTopAppBarBaseFoundation>}
     * @final
     */

    var MDCTopAppBar =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$o(MDCTopAppBar, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCTopAppBar() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$o(this, MDCTopAppBar);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$o(this, (_getPrototypeOf2 = _getPrototypeOf$o(MDCTopAppBar)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.navIcon_;
        /** @type {?Array<MDCRipple>} */

        _this.iconRipples_;
        /** @type {Object} */

        _this.scrollTarget_;
        return _this;
      }

      _createClass$o(MDCTopAppBar, [{
        key: "initialize",
        value: function initialize() {
          var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return MDCRipple$b.attachTo(el);
          };
          this.navIcon_ = this.root_.querySelector(strings$m.NAVIGATION_ICON_SELECTOR); // Get all icons in the toolbar and instantiate the ripples

          var icons = [].slice.call(this.root_.querySelectorAll(strings$m.ACTION_ITEM_SELECTOR));

          if (this.navIcon_) {
            icons.push(this.navIcon_);
          }

          this.iconRipples_ = icons.map(function (icon) {
            var ripple = rippleFactory(icon);
            ripple.unbounded = true;
            return ripple;
          });
          this.scrollTarget_ = window;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.iconRipples_.forEach(function (iconRipple) {
            return iconRipple.destroy();
          });

          _get$e(_getPrototypeOf$o(MDCTopAppBar.prototype), "destroy", this).call(this);
        }
      }, {
        key: "setScrollTarget",
        value: function setScrollTarget(target) {
          this.foundation_.destroyScrollHandler();
          this.scrollTarget_ = target;
          this.foundation_.initScrollHandler();
        }
        /**
         * @param {!Element} root
         * @return {!MDCTopAppBar}
         */

      }, {
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTopAppBarBaseFoundation}
         */
        value: function getDefaultFoundation() {
          var _this2 = this;

          /** @type {!MDCTopAppBarAdapter} */
          var adapter =
          /** @type {!MDCTopAppBarAdapter} */
          Object.assign({
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            setStyle: function setStyle(property, value) {
              return _this2.root_.style.setProperty(property, value);
            },
            getTopAppBarHeight: function getTopAppBarHeight() {
              return _this2.root_.clientHeight;
            },
            registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(evtType, handler) {
              if (_this2.navIcon_) {
                _this2.navIcon_.addEventListener(evtType, handler);
              }
            },
            deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(evtType, handler) {
              if (_this2.navIcon_) {
                _this2.navIcon_.removeEventListener(evtType, handler);
              }
            },
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {
              _this2.emit(strings$m.NAVIGATION_EVENT, {});
            },
            registerScrollHandler: function registerScrollHandler(handler) {
              return _this2.scrollTarget_.addEventListener('scroll', handler);
            },
            deregisterScrollHandler: function deregisterScrollHandler(handler) {
              return _this2.scrollTarget_.removeEventListener('scroll', handler);
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            getViewportScrollY: function getViewportScrollY() {
              return _this2.scrollTarget_[_this2.scrollTarget_ === window ? 'pageYOffset' : 'scrollTop'];
            },
            getTotalActionItems: function getTotalActionItems() {
              return _this2.root_.querySelectorAll(strings$m.ACTION_ITEM_SELECTOR).length;
            }
          });
          /** @type {!MDCTopAppBarBaseFoundation} */

          var foundation;

          if (this.root_.classList.contains(cssClasses$o.SHORT_CLASS)) {
            foundation = new MDCShortTopAppBarFoundation(adapter);
          } else if (this.root_.classList.contains(cssClasses$o.FIXED_CLASS)) {
            foundation = new MDCFixedTopAppBarFoundation(adapter);
          } else {
            foundation = new MDCTopAppBarFoundation(adapter);
          }

          return foundation;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTopAppBar(root);
        }
      }]);

      return MDCTopAppBar;
    }(MDCComponent$o);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Event object emitted by MdcTopAppBar navigation icon selected.
     */
    var   /**
     * Event object emitted by MdcTopAppBar navigation icon selected.
     */
    MdcTopAppBarNavSelected = /** @class */ (function () {
        function MdcTopAppBarNavSelected(source) {
            this.source = source;
        }
        return MdcTopAppBarNavSelected;
    }());
    var MdcTopAppBar = /** @class */ (function () {
        function MdcTopAppBar(_ngZone, _platform, _changeDetectorRef, elementRef) {
            this._ngZone = _ngZone;
            this._platform = _platform;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroyed = new rxjs.Subject();
            this._isFoundationInit = false;
            this._fixed = false;
            this._prominent = false;
            this._short = false;
            this._shortCollapsed = false;
            this._dense = false;
            this._fixedAdjustElement = null;
            this._scrollTarget = this._platform.isBrowser ? this._scrollTarget || window : undefined;
            /**
             * Event emitted when the navigation icon is selected.
             */
            this.navigationSelected = new core.EventEmitter();
            this._scrollTargetSubscription = null;
        }
        Object.defineProperty(MdcTopAppBar.prototype, "fixed", {
            get: /**
             * @return {?}
             */
            function () { return this._fixed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._fixed) {
                    this.setFixed(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTopAppBar.prototype, "prominent", {
            get: /**
             * @return {?}
             */
            function () { return this._prominent; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._prominent) {
                    this.setProminent(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTopAppBar.prototype, "short", {
            get: /**
             * @return {?}
             */
            function () { return this._short; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._short) {
                    this.setShort(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTopAppBar.prototype, "shortCollapsed", {
            get: /**
             * @return {?}
             */
            function () { return this._shortCollapsed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._shortCollapsed) {
                    this.setShortCollapsed(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTopAppBar.prototype, "dense", {
            get: /**
             * @return {?}
             */
            function () { return this._dense; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._dense) {
                    this.setDense(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTopAppBar.prototype, "fixedAdjustElement", {
            get: /**
             * @return {?}
             */
            function () { return this._fixedAdjustElement; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (this._fixedAdjustElement !== element) {
                    this._fixedAdjustElement = element;
                    this._initTopAppBar();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTopAppBar.prototype, "scrollTarget", {
            get: /**
             * @return {?}
             */
            function () { return this._scrollTarget; },
            set: /**
             * @param {?} target
             * @return {?}
             */
            function (target) {
                if (target !== this._scrollTarget) {
                    this._scrollTarget = target ? target : this._platform.isBrowser ? window : undefined;
                    this._initScrollHandler();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._createAdapter = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                hasClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.contains(className); }),
                addClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._getHostElement().classList.add(className); }),
                removeClass: (/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) {
                    if (className === cssClasses$o.SHORT_COLLAPSED_CLASS && _this.shortCollapsed) {
                        return;
                    }
                    _this._getHostElement().classList.remove(className);
                }),
                setStyle: (/**
                 * @param {?} property
                 * @param {?} value
                 * @return {?}
                 */
                function (property, value) { return _this._getHostElement().style.setProperty(property, value); }),
                getTopAppBarHeight: (/**
                 * @return {?}
                 */
                function () { return _this._getHostElement().clientHeight; }),
                notifyNavigationIconClicked: (/**
                 * @return {?}
                 */
                function () { return _this.navigationSelected.emit({ source: _this }); }),
                registerResizeHandler: (/**
                 * @param {?} handler
                 * @return {?}
                 */
                function (handler) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    window.addEventListener('resize', handler);
                }),
                deregisterResizeHandler: (/**
                 * @param {?} handler
                 * @return {?}
                 */
                function (handler) {
                    if (!_this._platform.isBrowser) {
                        return;
                    }
                    window.removeEventListener('resize', handler);
                }),
                getViewportScrollY: (/**
                 * @return {?}
                 */
                function () {
                    if (!_this._platform.isBrowser) {
                        return 0;
                    }
                    return _this._scrollTarget[_this._scrollTarget === window ? 'pageYOffset' : 'scrollTop'];
                }),
                getTotalActionItems: (/**
                 * @return {?}
                 */
                function () { return _this.actions ? _this.actions.length : 0; })
            };
        };
        /**
         * @return {?}
         */
        MdcTopAppBar.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.actions.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroyed))
                .subscribe((/**
             * @return {?}
             */
            function () {
                if (_this.short && _this.actions.length) {
                    _this._getHostElement().classList.toggle(cssClasses$o.SHORT_HAS_ACTION_ITEM_CLASS);
                }
            }));
        };
        /**
         * @return {?}
         */
        MdcTopAppBar.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (!this._isFoundationInit) {
                this._initFoundation();
            }
        };
        /**
         * @return {?}
         */
        MdcTopAppBar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroyed.next();
            this._destroyed.complete();
            if (this._scrollTargetSubscription) {
                this._scrollTargetSubscription.unsubscribe();
            }
            this._destroyFoundation();
        };
        /** Sets the top app bar to fixed or not. */
        /**
         * Sets the top app bar to fixed or not.
         * @param {?} fixed
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcTopAppBar.prototype.setFixed = /**
         * Sets the top app bar to fixed or not.
         * @param {?} fixed
         * @param {?=} isUserInput
         * @return {?}
         */
        function (fixed, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._fixed = toBoolean(fixed);
            if (this.fixed && this.short) {
                this.setShort(false, false);
            }
            if (isUserInput) {
                this._initFoundation();
            }
        };
        /** Sets the top app bar to prominent or not. */
        /**
         * Sets the top app bar to prominent or not.
         * @param {?} prominent
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcTopAppBar.prototype.setProminent = /**
         * Sets the top app bar to prominent or not.
         * @param {?} prominent
         * @param {?=} isUserInput
         * @return {?}
         */
        function (prominent, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._prominent = toBoolean(prominent);
            if (this.prominent && this.short) {
                this.setShort(false, false);
            }
            if (isUserInput) {
                this._initFoundation();
            }
        };
        /** Sets the top app bar to dense variant. */
        /**
         * Sets the top app bar to dense variant.
         * @param {?} dense
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcTopAppBar.prototype.setDense = /**
         * Sets the top app bar to dense variant.
         * @param {?} dense
         * @param {?=} isUserInput
         * @return {?}
         */
        function (dense, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._dense = toBoolean(dense);
            if (this.dense && this.short) {
                this.setShort(false, false);
            }
            if (isUserInput) {
                this._initFoundation();
            }
        };
        /** Sets the top app bar to short or not. */
        /**
         * Sets the top app bar to short or not.
         * @param {?} short
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcTopAppBar.prototype.setShort = /**
         * Sets the top app bar to short or not.
         * @param {?} short
         * @param {?=} isUserInput
         * @return {?}
         */
        function (short, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._short = toBoolean(short);
            if (this.short) {
                this.setProminent(false, false);
                this.setDense(false, false);
                this.setFixed(false, false);
            }
            else {
                this.setShortCollapsed(false, false);
            }
            if (isUserInput) {
                this._initFoundation();
            }
        };
        /** Sets the top app bar to short-collapsed or not. */
        /**
         * Sets the top app bar to short-collapsed or not.
         * @param {?} shortCollapsed
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcTopAppBar.prototype.setShortCollapsed = /**
         * Sets the top app bar to short-collapsed or not.
         * @param {?} shortCollapsed
         * @param {?=} isUserInput
         * @return {?}
         */
        function (shortCollapsed, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._shortCollapsed = toBoolean(shortCollapsed);
            if (this.shortCollapsed && !this.short) {
                this.setShort(true, false);
            }
            if (isUserInput) {
                this._initFoundation();
            }
        };
        /**
         * @return {?}
         */
        MdcTopAppBar.prototype.isCollapsed = /**
         * @return {?}
         */
        function () {
            return this._getHostElement().classList.contains(cssClasses$o.SHORT_COLLAPSED_CLASS);
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._initFoundation = /**
         * @private
         * @return {?}
         */
        function () {
            this._destroyFoundation();
            this._getHostElement().style.top = '0px';
            this._resetFixedShort();
            if (this.short) {
                this._foundation = new MDCShortTopAppBarFoundation(this._createAdapter());
            }
            else if (this.fixed) {
                this._foundation = new MDCFixedTopAppBarFoundation(this._createAdapter());
            }
            else {
                this._foundation = new MDCTopAppBarFoundation(this._createAdapter());
            }
            this._foundation.init();
            this._isFoundationInit = true;
            this._initTopAppBar();
            this._initScrollHandler();
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._resetFixedShort = /**
         * @private
         * @return {?}
         */
        function () {
            this._getHostElement().classList.remove(cssClasses$o.SHORT_HAS_ACTION_ITEM_CLASS);
            this._getHostElement().classList.remove(cssClasses$o.SHORT_COLLAPSED_CLASS);
            this._getHostElement().classList.remove(cssClasses$o.FIXED_SCROLLED_CLASS);
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._initTopAppBar = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this.fixed) {
                this._getHostElement().classList.remove(cssClasses$o.FIXED_SCROLLED_CLASS);
            }
            if (this.fixed && this._getScrollOffset() > 0) {
                this._getHostElement().classList.add(cssClasses$o.FIXED_SCROLLED_CLASS);
            }
            if (!this.short) {
                this._getHostElement().classList.remove(cssClasses$o.SHORT_HAS_ACTION_ITEM_CLASS);
                this._getHostElement().classList.remove(cssClasses$o.SHORT_COLLAPSED_CLASS);
            }
            if (this.short && this._getScrollOffset() > 0) {
                this._getHostElement().classList.add(cssClasses$o.SHORT_COLLAPSED_CLASS);
            }
            if (this.shortCollapsed) {
                this._getHostElement().classList.add(cssClasses$o.SHORT_COLLAPSED_CLASS);
            }
            if (this.fixedAdjustElement) {
                this._removeFixedAdjustClasses();
                this._addFixedAdjustClass();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._removeFixedAdjustClasses = /**
         * @private
         * @return {?}
         */
        function () {
            (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--short-fixed-adjust');
            (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--fixed-adjust');
            (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--dense-fixed-adjust');
            (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--prominent-fixed-adjust');
            (/** @type {?} */ (this.fixedAdjustElement)).classList.remove('mdc-top-app-bar--dense-prominent-fixed-adjust');
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._addFixedAdjustClass = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._short) {
                (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--short-fixed-adjust');
            }
            else if (this._dense && this._prominent) {
                (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--dense-prominent-fixed-adjust');
            }
            else if (this._dense) {
                (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--dense-fixed-adjust');
            }
            else if (this._prominent) {
                (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--prominent-fixed-adjust');
            }
            else {
                (/** @type {?} */ (this.fixedAdjustElement)).classList.add('mdc-top-app-bar--fixed-adjust');
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._destroyFoundation = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._initScrollHandler = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._scrollTargetSubscription) {
                this._scrollTargetSubscription.unsubscribe();
            }
            if (!this._platform.isBrowser) {
                return;
            }
            this._scrollTargetSubscription = this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(_this.scrollTarget || window, 'scroll')
                    .subscribe((/**
                 * @return {?}
                 */
                function () { return _this._ngZone.run((/**
                 * @return {?}
                 */
                function () {
                    if (_this.fixed) {
                        _this._foundation.fixedScrollHandler_();
                    }
                    else if (_this.short) {
                        _this._foundation.shortAppBarScrollHandler_();
                    }
                    else {
                        _this._foundation.topAppBarScrollHandler_();
                    }
                })); }));
            }));
        };
        /**
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._getScrollOffset = /**
         * @private
         * @return {?}
         */
        function () {
            if (!this._platform.isBrowser) {
                return 0;
            }
            return this.scrollTarget ? this.scrollTarget.scrollTop : window.pageYOffset;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        MdcTopAppBar.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTopAppBar.decorators = [
            { type: core.Component, args: [{
                        selector: 'mdc-top-app-bar, [mdc-top-app-bar]',
                        exportAs: 'mdcTopAppBar',
                        host: {
                            'class': 'mdc-top-app-bar',
                            '[class.mdc-top-app-bar--prominent]': 'prominent',
                            '[class.mdc-top-app-bar--dense]': 'dense',
                            '[class.mdc-top-app-bar--short]': 'short',
                            '[class.mdc-top-app-bar--fixed]': 'fixed'
                        },
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcTopAppBar.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: Platform },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcTopAppBar.propDecorators = {
            fixed: [{ type: core.Input }],
            prominent: [{ type: core.Input }],
            short: [{ type: core.Input }],
            shortCollapsed: [{ type: core.Input }],
            dense: [{ type: core.Input }],
            fixedAdjustElement: [{ type: core.Input }],
            scrollTarget: [{ type: core.Input }],
            navigationSelected: [{ type: core.Output }],
            navigationIcon: [{ type: core.ContentChild, args: [MdcTopAppBarNavigationIcon,] }],
            actions: [{ type: core.ContentChildren, args: [MdcTopAppBarActionItem, { descendants: true },] }]
        };
        return MdcTopAppBar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TOP_APP_BAR_DECLARATIONS = [
        MdcTopAppBar,
        MdcTopAppBarActionItem,
        MdcTopAppBarFixedAdjust,
        MdcTopAppBarNavigationIcon,
        MdcTopAppBarRow,
        MdcTopAppBarSection,
        MdcTopAppBarTitle
    ];
    var MdcTopAppBarModule = /** @class */ (function () {
        function MdcTopAppBarModule() {
        }
        MdcTopAppBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: TOP_APP_BAR_DECLARATIONS,
                        declarations: TOP_APP_BAR_DECLARATIONS
                    },] },
        ];
        return MdcTopAppBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MdcTypography = /** @class */ (function () {
        function MdcTypography() {
        }
        MdcTypography.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-typography], [mdcTypography]',
                        host: { 'class': 'mdc-typography' }
                    },] },
        ];
        return MdcTypography;
    }());
    var MdcHeadline1 = /** @class */ (function () {
        function MdcHeadline1() {
        }
        MdcHeadline1.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline1]',
                        host: { 'class': 'mdc-typography--headline1' }
                    },] },
        ];
        return MdcHeadline1;
    }());
    var MdcHeadline2 = /** @class */ (function () {
        function MdcHeadline2() {
        }
        MdcHeadline2.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline2]',
                        host: { 'class': 'mdc-typography--headline2' }
                    },] },
        ];
        return MdcHeadline2;
    }());
    var MdcHeadline3 = /** @class */ (function () {
        function MdcHeadline3() {
        }
        MdcHeadline3.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline3]',
                        host: { 'class': 'mdc-typography--headline3' }
                    },] },
        ];
        return MdcHeadline3;
    }());
    var MdcHeadline4 = /** @class */ (function () {
        function MdcHeadline4() {
        }
        MdcHeadline4.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline4]',
                        host: { 'class': 'mdc-typography--headline4' }
                    },] },
        ];
        return MdcHeadline4;
    }());
    var MdcHeadline5 = /** @class */ (function () {
        function MdcHeadline5() {
        }
        MdcHeadline5.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline5]',
                        host: { 'class': 'mdc-typography--headline5' }
                    },] },
        ];
        return MdcHeadline5;
    }());
    var MdcHeadline6 = /** @class */ (function () {
        function MdcHeadline6() {
        }
        MdcHeadline6.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline6]',
                        host: { 'class': 'mdc-typography--headline6' }
                    },] },
        ];
        return MdcHeadline6;
    }());
    var MdcSubtitle1 = /** @class */ (function () {
        function MdcSubtitle1() {
        }
        MdcSubtitle1.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcSubtitle1]',
                        host: { 'class': 'mdc-typography--subtitle1' }
                    },] },
        ];
        return MdcSubtitle1;
    }());
    var MdcSubtitle2 = /** @class */ (function () {
        function MdcSubtitle2() {
        }
        MdcSubtitle2.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcSubtitle2]',
                        host: { 'class': 'mdc-typography--subtitle2' }
                    },] },
        ];
        return MdcSubtitle2;
    }());
    var MdcBody2 = /** @class */ (function () {
        function MdcBody2() {
        }
        MdcBody2.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcBody2]',
                        host: { 'class': 'mdc-typography--body2' }
                    },] },
        ];
        return MdcBody2;
    }());
    var MdcBody1 = /** @class */ (function () {
        function MdcBody1() {
        }
        MdcBody1.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcBody1]',
                        host: { 'class': 'mdc-typography--body1' }
                    },] },
        ];
        return MdcBody1;
    }());
    var MdcCaption = /** @class */ (function () {
        function MdcCaption() {
        }
        MdcCaption.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcCaption]',
                        host: { 'class': 'mdc-typography--caption' }
                    },] },
        ];
        return MdcCaption;
    }());
    var MdcTypographyButton = /** @class */ (function () {
        function MdcTypographyButton() {
        }
        MdcTypographyButton.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcButton]',
                        host: { 'class': 'mdc-typography--button' }
                    },] },
        ];
        return MdcTypographyButton;
    }());
    var MdcOverline = /** @class */ (function () {
        function MdcOverline() {
        }
        MdcOverline.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcOverline]',
                        host: { 'class': 'mdc-typography--overline' }
                    },] },
        ];
        return MdcOverline;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TYPOGRAPHY_DECLARATIONS = [
        MdcTypography,
        MdcBody1,
        MdcBody2,
        MdcTypographyButton,
        MdcCaption,
        MdcHeadline1,
        MdcHeadline2,
        MdcHeadline3,
        MdcHeadline4,
        MdcHeadline5,
        MdcHeadline6,
        MdcOverline,
        MdcSubtitle1,
        MdcSubtitle2
    ];
    var MdcTypographyModule = /** @class */ (function () {
        function MdcTypographyModule() {
        }
        MdcTypographyModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: TYPOGRAPHY_DECLARATIONS,
                        declarations: TYPOGRAPHY_DECLARATIONS
                    },] },
        ];
        return MdcTypographyModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Current version of Angular MDC.
     * @type {?}
     */
    var VERSION = new core.Version('0.44.0');

    exports.VERSION = VERSION;
    exports.MdcButtonModule = MdcButtonModule;
    exports.MdcButtonLabel = MdcButtonLabel;
    exports.MdcButton = MdcButton;
    exports.MdcCardModule = MdcCardModule;
    exports.MdcCardMediaContent = MdcCardMediaContent;
    exports.MdcCardMedia = MdcCardMedia;
    exports.MdcCardPrimaryAction = MdcCardPrimaryAction;
    exports.MdcCardActions = MdcCardActions;
    exports.MdcCardActionButtons = MdcCardActionButtons;
    exports.MdcCardActionIcons = MdcCardActionIcons;
    exports.MdcCardAction = MdcCardAction;
    exports.MdcCard = MdcCard;
    exports.MdcCheckboxModule = MdcCheckboxModule;
    exports.MdcCheckboxChange = MdcCheckboxChange;
    exports.MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR = MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR;
    exports.MdcCheckbox = MdcCheckbox;
    exports.CHIP_DECLARATIONS = CHIP_DECLARATIONS;
    exports.MdcChipsModule = MdcChipsModule;
    exports.MDC_CHIPSET_PARENT_COMPONENT = MDC_CHIPSET_PARENT_COMPONENT;
    exports.MdcChipCheckmark = MdcChipCheckmark;
    exports.MdcChipText = MdcChipText;
    exports.MdcChip = MdcChip;
    exports.MdcChipIcon = MdcChipIcon;
    exports.MdcChipSetChange = MdcChipSetChange;
    exports.MdcChipSet = MdcChipSet;
    exports.toBoolean = toBoolean;
    exports.UP_ARROW = UP_ARROW;
    exports.DOWN_ARROW = DOWN_ARROW;
    exports.RIGHT_ARROW = RIGHT_ARROW;
    exports.LEFT_ARROW = LEFT_ARROW;
    exports.PAGE_UP = PAGE_UP;
    exports.PAGE_DOWN = PAGE_DOWN;
    exports.HOME = HOME;
    exports.END = END;
    exports.ENTER = ENTER;
    exports.SPACE = SPACE;
    exports.TAB = TAB;
    exports.ESCAPE = ESCAPE;
    exports.BACKSPACE = BACKSPACE;
    exports.DELETE = DELETE;
    exports.A = A;
    exports.Z = Z;
    exports.ZERO = ZERO;
    exports.NINE = NINE;
    exports.COMMA = COMMA;
    exports.toNumber = toNumber;
    exports._isNumberValue = _isNumberValue;
    exports.Platform = Platform;
    exports.UniqueSelectionDispatcher = UniqueSelectionDispatcher;
    exports.MdcDialogModule = MdcDialogModule;
    exports.MDC_DIALOG_DATA = MDC_DIALOG_DATA;
    exports.MDC_DIALOG_DEFAULT_OPTIONS = MDC_DIALOG_DEFAULT_OPTIONS;
    exports.MdcDialog = MdcDialog;
    exports.MdcDialogComponent = MdcDialogComponent;
    exports.throwMdcDialogContentAlreadyAttachedError = throwMdcDialogContentAlreadyAttachedError;
    exports.MdcDialogPortal = MdcDialogPortal;
    exports.MdcDialogAction = MdcDialogAction;
    exports.MdcDialogScrim = MdcDialogScrim;
    exports.MdcDialogContainer = MdcDialogContainer;
    exports.MdcDialogSurface = MdcDialogSurface;
    exports.MdcDialogTitle = MdcDialogTitle;
    exports.MdcDialogContent = MdcDialogContent;
    exports.MdcDialogActions = MdcDialogActions;
    exports.MdcDialogButton = MdcDialogButton;
    exports.MdcDialogConfig = MdcDialogConfig;
    exports.MdcDialogRef = MdcDialogRef;
    exports.MdcDrawerModule = MdcDrawerModule;
    exports.MdcDrawerHeader = MdcDrawerHeader;
    exports.MdcDrawerTitle = MdcDrawerTitle;
    exports.MdcDrawerSubtitle = MdcDrawerSubtitle;
    exports.MdcDrawerContent = MdcDrawerContent;
    exports.MdcDrawerAppContent = MdcDrawerAppContent;
    exports.MdcDrawer = MdcDrawer;
    exports.MdcElevationModule = MdcElevationModule;
    exports.MdcElevation = MdcElevation;
    exports.MdcFabModule = MdcFabModule;
    exports.MdcFabLabel = MdcFabLabel;
    exports.MdcFab = MdcFab;
    exports.MdcFloatingLabelModule = MdcFloatingLabelModule;
    exports.MdcFloatingLabel = MdcFloatingLabel;
    exports.MdcCharacterCounter = MdcCharacterCounter;
    exports.mixinErrorState = mixinErrorState;
    exports.ErrorStateMatcher = ErrorStateMatcher;
    exports.MdcFormField = MdcFormField;
    exports.MdcFormFieldControl = MdcFormFieldControl;
    exports.MdcFormFieldModule = MdcFormFieldModule;
    exports.MdcHelperText = MdcHelperText;
    exports.MdcIconModule = MdcIconModule;
    exports.MDC_ICON_LOCATION_FACTORY = MDC_ICON_LOCATION_FACTORY;
    exports.MDC_ICON_LOCATION = MDC_ICON_LOCATION;
    exports.MdcIcon = MdcIcon;
    exports.getMdcIconNameNotFoundError = getMdcIconNameNotFoundError;
    exports.getMdcIconNoHttpProviderError = getMdcIconNoHttpProviderError;
    exports.getMdcIconFailedToSanitizeUrlError = getMdcIconFailedToSanitizeUrlError;
    exports.getMdcIconFailedToSanitizeLiteralError = getMdcIconFailedToSanitizeLiteralError;
    exports.ICON_REGISTRY_PROVIDER_FACTORY = ICON_REGISTRY_PROVIDER_FACTORY;
    exports.MdcIconRegistry = MdcIconRegistry;
    exports.ICON_REGISTRY_PROVIDER = ICON_REGISTRY_PROVIDER;
    exports.MdcMaterialIcons = MdcMaterialIcons;
    exports.MdcIconButtonModule = MdcIconButtonModule;
    exports.MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR = MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR;
    exports.MdcIconButtonChange = MdcIconButtonChange;
    exports.MdcIconOn = MdcIconOn;
    exports.MdcIconButton = MdcIconButton;
    exports.MdcImageListModule = MdcImageListModule;
    exports.MdcImageListItem = MdcImageListItem;
    exports.MdcImageListImageAspect = MdcImageListImageAspect;
    exports.MdcImageListImage = MdcImageListImage;
    exports.MdcImageListSupporting = MdcImageListSupporting;
    exports.MdcImageListLabel = MdcImageListLabel;
    exports.MdcImageList = MdcImageList;
    exports.MdcLineRippleModule = MdcLineRippleModule;
    exports.MdcLineRipple = MdcLineRipple;
    exports.MdcLinearProgressModule = MdcLinearProgressModule;
    exports.MdcLinearProgress = MdcLinearProgress;
    exports.MdcListItemChange = MdcListItemChange;
    exports.MdcListGroup = MdcListGroup;
    exports.MdcListGroupSubheader = MdcListGroupSubheader;
    exports.MdcList = MdcList;
    exports.MdcListDivider = MdcListDivider;
    exports.MdcListSelectionChange = MdcListSelectionChange;
    exports.MDC_LIST_PARENT_COMPONENT = MDC_LIST_PARENT_COMPONENT;
    exports.MdcListItemGraphic = MdcListItemGraphic;
    exports.MdcListItemMeta = MdcListItemMeta;
    exports.MdcListItemText = MdcListItemText;
    exports.MdcListItemSecondary = MdcListItemSecondary;
    exports.MdcListItem = MdcListItem;
    exports.MdcListModule = MdcListModule;
    exports.MdcMenuModule = MdcMenuModule;
    exports.MdcMenuSelectedEvent = MdcMenuSelectedEvent;
    exports.MdcMenuSelectionGroup = MdcMenuSelectionGroup;
    exports.MdcMenuSelectionGroupIcon = MdcMenuSelectionGroupIcon;
    exports.MdcMenu = MdcMenu;
    exports.MdcMenuSurfaceModule = MdcMenuSurfaceModule;
    exports.MdcMenuSurface = MdcMenuSurface;
    exports.MdcMenuSurfaceBase = MdcMenuSurfaceBase;
    exports.MdcMenuSurfaceAnchor = MdcMenuSurfaceAnchor;
    exports.MdcNotchedOutlineModule = MdcNotchedOutlineModule;
    exports.MdcNotchedOutline = MdcNotchedOutline;
    exports.Overlay = Overlay;
    exports.OverlayContainer = OverlayContainer;
    exports.OverlayRef = OverlayRef;
    exports.OverlayConfig = OverlayConfig;
    exports.OverlayModule = OverlayModule;
    exports.DomPortalHost = DomPortalOutlet;
    exports.DomPortalOutlet = DomPortalOutlet;
    exports.PortalHostDirective = CdkPortalOutlet;
    exports.CdkPortalOutlet = CdkPortalOutlet;
    exports.TemplatePortalDirective = CdkPortal;
    exports.CdkPortal = CdkPortal;
    exports.BasePortalHost = BasePortalOutlet;
    exports.BasePortalOutlet = BasePortalOutlet;
    exports.Portal = Portal;
    exports.ComponentPortal = ComponentPortal;
    exports.TemplatePortal = TemplatePortal;
    exports.PortalModule = PortalModule;
    exports.PortalInjector = PortalInjector;
    exports.MdcRadioModule = MdcRadioModule;
    exports.MDC_RADIO_GROUP_PARENT_COMPONENT = MDC_RADIO_GROUP_PARENT_COMPONENT;
    exports.MdcRadioChange = MdcRadioChange;
    exports.MdcRadio = MdcRadio;
    exports.MDC_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = MDC_RADIO_GROUP_CONTROL_VALUE_ACCESSOR;
    exports.MdcRadioGroup = MdcRadioGroup;
    exports.MdcRippleModule = MdcRippleModule;
    exports.MdcRippleConfig = MdcRippleConfig;
    exports.MdcRipple = MdcRipple;
    exports.MdcRippleComponent = MdcRippleComponent;
    exports.MdcRippleDirective = MdcRippleDirective;
    exports.MdcSelectModule = MdcSelectModule;
    exports.MDC_SELECT_DEFAULT_OPTIONS = MDC_SELECT_DEFAULT_OPTIONS;
    exports.MdcSelectBase = MdcSelectBase;
    exports._MdcSelectMixinBase = _MdcSelectMixinBase;
    exports.MdcSelectChange = MdcSelectChange;
    exports.MdcSelectOption = MdcSelectOption;
    exports.MdcSelect = MdcSelect;
    exports.MdcSelectIcon = MdcSelectIcon;
    exports.MdcSliderModule = MdcSliderModule;
    exports.MDC_SLIDER_CONTROL_VALUE_ACCESSOR = MDC_SLIDER_CONTROL_VALUE_ACCESSOR;
    exports.MdcSliderChange = MdcSliderChange;
    exports.MdcSlider = MdcSlider;
    exports.MdcSnackbarModule = MdcSnackbarModule;
    exports.MdcSnackbarContainer = MdcSnackbarContainer;
    exports.MDC_SNACKBAR_DATA = MDC_SNACKBAR_DATA;
    exports.MdcSnackbarConfig = MdcSnackbarConfig;
    exports.MdcSnackbarRef = MdcSnackbarRef;
    exports.MdcSnackbarComponent = MdcSnackbarComponent;
    exports.MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY = MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY;
    exports.MDC_SNACKBAR_DEFAULT_OPTIONS = MDC_SNACKBAR_DEFAULT_OPTIONS;
    exports.MdcSnackbar = MdcSnackbar;
    exports.MdcSwitchModule = MdcSwitchModule;
    exports.MDC_SWITCH_CONTROL_VALUE_ACCESSOR = MDC_SWITCH_CONTROL_VALUE_ACCESSOR;
    exports.MdcSwitchChange = MdcSwitchChange;
    exports.MdcSwitch = MdcSwitch;
    exports.MdcTabModule = MdcTabModule;
    exports.MDC_TAB_BAR_PARENT_COMPONENT = MDC_TAB_BAR_PARENT_COMPONENT;
    exports.MdcTabLabel = MdcTabLabel;
    exports.MdcTabIcon = MdcTabIcon;
    exports.MdcTab = MdcTab;
    exports.MdcTabBarModule = MdcTabBarModule;
    exports.MdcTabActivatedEvent = MdcTabActivatedEvent;
    exports.MdcTabBar = MdcTabBar;
    exports.MdcTabIndicatorModule = MdcTabIndicatorModule;
    exports.MdcTabIndicator = MdcTabIndicator;
    exports.MdcTabScrollerModule = MdcTabScrollerModule;
    exports.MdcTabScroller = MdcTabScroller;
    exports.MdcTextFieldModule = MdcTextFieldModule;
    exports.MDC_TEXT_FIELD_DEFAULT_OPTIONS = MDC_TEXT_FIELD_DEFAULT_OPTIONS;
    exports.MdcTextFieldBase = MdcTextFieldBase;
    exports._MdcTextFieldMixinBase = _MdcTextFieldMixinBase;
    exports.MdcTextField = MdcTextField;
    exports.MdcTextFieldIcon = MdcTextFieldIcon;
    exports.MdcTextarea = MdcTextarea;
    exports.MdcTopAppBarModule = MdcTopAppBarModule;
    exports.MdcTopAppBarFixedAdjust = MdcTopAppBarFixedAdjust;
    exports.MdcTopAppBarRow = MdcTopAppBarRow;
    exports.MdcTopAppBarSection = MdcTopAppBarSection;
    exports.MdcTopAppBarActionItem = MdcTopAppBarActionItem;
    exports.MdcTopAppBarNavigationIcon = MdcTopAppBarNavigationIcon;
    exports.MdcTopAppBarTitle = MdcTopAppBarTitle;
    exports.MdcTopAppBarNavSelected = MdcTopAppBarNavSelected;
    exports.MdcTopAppBar = MdcTopAppBar;
    exports.MdcTypographyModule = MdcTypographyModule;
    exports.MdcTypography = MdcTypography;
    exports.MdcHeadline1 = MdcHeadline1;
    exports.MdcHeadline2 = MdcHeadline2;
    exports.MdcHeadline3 = MdcHeadline3;
    exports.MdcHeadline4 = MdcHeadline4;
    exports.MdcHeadline5 = MdcHeadline5;
    exports.MdcHeadline6 = MdcHeadline6;
    exports.MdcSubtitle1 = MdcSubtitle1;
    exports.MdcSubtitle2 = MdcSubtitle2;
    exports.MdcBody2 = MdcBody2;
    exports.MdcBody1 = MdcBody1;
    exports.MdcCaption = MdcCaption;
    exports.MdcTypographyButton = MdcTypographyButton;
    exports.MdcOverline = MdcOverline;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=web.umd.js.map
