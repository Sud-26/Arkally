/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular-mdc/web/overlay'), require('@angular-mdc/web/portal'), require('rxjs'), require('rxjs/operators'), require('@angular-mdc/web/common'), require('@angular-mdc/web/button'), require('@angular-mdc/web/ripple')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/dialog', ['exports', '@angular/core', '@angular-mdc/web/overlay', '@angular-mdc/web/portal', 'rxjs', 'rxjs/operators', '@angular-mdc/web/common', '@angular-mdc/web/button', '@angular-mdc/web/ripple'], factory) :
  (global = global || self, factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.dialog = {}), global.ng.core, global.ng.web.overlay, global.ng.web.portal, global.rxjs, global.rxjs.operators, global.ng.web.common, global.ng.web.button, global.ng.web.ripple));
}(this, function (exports, core, overlay, portal, rxjs, operators, common, button, ripple) { 'use strict';

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'];
  var candidateSelector = candidateSelectors.join(',');
  var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  function tabbable(el, options) {
    options = options || {};
    var elementDocument = el.ownerDocument || el;
    var regularTabbables = [];
    var orderedTabbables = [];
    var untouchabilityChecker = new UntouchabilityChecker(elementDocument);
    var candidates = el.querySelectorAll(candidateSelector);

    if (options.includeContainer) {
      if (matches.call(el, candidateSelector)) {
        candidates = Array.prototype.slice.apply(candidates);
        candidates.unshift(el);
      }
    }

    var i, candidate, candidateTabindex;

    for (i = 0; i < candidates.length; i++) {
      candidate = candidates[i];
      if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;
      candidateTabindex = getTabindex(candidate);

      if (candidateTabindex === 0) {
        regularTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          documentOrder: i,
          tabIndex: candidateTabindex,
          node: candidate
        });
      }
    }

    var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {
      return a.node;
    }).concat(regularTabbables);
    return tabbableNodes;
  }

  tabbable.isTabbable = isTabbable;
  tabbable.isFocusable = isFocusable;

  function isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {
    if (!isNodeMatchingSelectorFocusable(node, untouchabilityChecker) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
      return false;
    }

    return true;
  }

  function isTabbable(node, untouchabilityChecker) {
    if (!node) throw new Error('No node provided');
    if (matches.call(node, candidateSelector) === false) return false;
    return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);
  }

  function isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {
    untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);

    if (node.disabled || isHiddenInput(node) || untouchabilityChecker.isUntouchable(node)) {
      return false;
    }

    return true;
  }

  var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');

  function isFocusable(node, untouchabilityChecker) {
    if (!node) throw new Error('No node provided');
    if (matches.call(node, focusableCandidateSelector) === false) return false;
    return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);
  }

  function getTabindex(node) {
    var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
    if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.

    if (isContentEditable(node)) return 0;
    return node.tabIndex;
  }

  function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
  } // Array.prototype.find not available in IE.


  function find(list, predicate) {
    for (var i = 0, length = list.length; i < length; i++) {
      if (predicate(list[i])) return list[i];
    }
  }

  function isContentEditable(node) {
    return node.contentEditable === 'true';
  }

  function isInput(node) {
    return node.tagName === 'INPUT';
  }

  function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
  }

  function isRadio(node) {
    return isInput(node) && node.type === 'radio';
  }

  function isNonTabbableRadio(node) {
    return isRadio(node) && !isTabbableRadio(node);
  }

  function getCheckedRadio(nodes) {
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].checked) {
        return nodes[i];
      }
    }
  }

  function isTabbableRadio(node) {
    if (!node.name) return true; // This won't account for the edge case where you have radio groups with the same
    // in separate forms on the same page.

    var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
    var checked = getCheckedRadio(radioSet);
    return !checked || checked === node;
  } // An element is "untouchable" if *it or one of its ancestors* has
  // `visibility: hidden` or `display: none`.


  function UntouchabilityChecker(elementDocument) {
    this.doc = elementDocument; // Node cache must be refreshed on every check, in case
    // the content of the element has changed. The cache contains tuples
    // mapping nodes to their boolean result.

    this.cache = [];
  } // getComputedStyle accurately reflects `visibility: hidden` of ancestors
  // but not `display: none`, so we need to recursively check parents.


  UntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {
    if (node.nodeType !== Node.ELEMENT_NODE) return false; // Search for a cached result.

    var cached = find(this.cache, function (item) {
      return item === node;
    });
    if (cached) return cached[1];
    nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);
    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = this.hasDisplayNone(node.parentNode);
    }

    this.cache.push([node, result]);
    return result;
  };

  UntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {
    if (node === this.doc.documentElement) return false;
    var computedStyle = this.doc.defaultView.getComputedStyle(node);
    if (this.hasDisplayNone(node, computedStyle)) return true;
    return computedStyle.visibility === 'hidden';
  };

  var tabbable_1 = tabbable;

  var immutable = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  }

  var activeFocusTraps = function () {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];

          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }

        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          // move this existing trap to the front of the queue
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }

        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();

  function focusTrap(element, userOptions) {
    var doc = document;
    var container = typeof element === 'string' ? doc.querySelector(element) : element;
    var config = immutable({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true
    }, userOptions);
    var state = {
      firstTabbableNode: null,
      lastTabbableNode: null,
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false
    };
    var trap = {
      activate: activate,
      deactivate: deactivate,
      pause: pause,
      unpause: unpause
    };
    return trap;

    function activate(activateOptions) {
      if (state.active) return;
      updateTabbableNodes();
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;

      if (onActivate) {
        onActivate();
      }

      addListeners();
      return trap;
    }

    function deactivate(deactivateOptions) {
      if (!state.active) return;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;

      if (onDeactivate) {
        onDeactivate();
      }

      var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;

      if (returnFocus) {
        delay(function () {
          tryFocus(state.nodeFocusedBeforeActivation);
        });
      }

      return trap;
    }

    function pause() {
      if (state.paused || !state.active) return;
      state.paused = true;
      removeListeners();
    }

    function unpause() {
      if (!state.paused || !state.active) return;
      state.paused = false;
      addListeners();
    }

    function addListeners() {
      if (!state.active) return; // There can be only one listening focus trap at a time

      activeFocusTraps.activateTrap(trap);
      updateTabbableNodes(); // Delay ensures that the focused element doesn't capture the event
      // that caused the focus trap activation.

      delay(function () {
        tryFocus(getInitialFocusNode());
      });
      doc.addEventListener('focusin', checkFocusIn, true);
      doc.addEventListener('mousedown', checkPointerDown, true);
      doc.addEventListener('touchstart', checkPointerDown, true);
      doc.addEventListener('click', checkClick, true);
      doc.addEventListener('keydown', checkKey, true);
      return trap;
    }

    function removeListeners() {
      if (!state.active) return;
      doc.removeEventListener('focusin', checkFocusIn, true);
      doc.removeEventListener('mousedown', checkPointerDown, true);
      doc.removeEventListener('touchstart', checkPointerDown, true);
      doc.removeEventListener('click', checkClick, true);
      doc.removeEventListener('keydown', checkKey, true);
      return trap;
    }

    function getNodeForOption(optionName) {
      var optionValue = config[optionName];
      var node = optionValue;

      if (!optionValue) {
        return null;
      }

      if (typeof optionValue === 'string') {
        node = doc.querySelector(optionValue);

        if (!node) {
          throw new Error('`' + optionName + '` refers to no known node');
        }
      }

      if (typeof optionValue === 'function') {
        node = optionValue();

        if (!node) {
          throw new Error('`' + optionName + '` did not return a node');
        }
      }

      return node;
    }

    function getInitialFocusNode() {
      var node;

      if (getNodeForOption('initialFocus') !== null) {
        node = getNodeForOption('initialFocus');
      } else if (container.contains(doc.activeElement)) {
        node = doc.activeElement;
      } else {
        node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
      }

      if (!node) {
        throw new Error("You can't have a focus-trap without at least one focusable element");
      }

      return node;
    } // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event.


    function checkPointerDown(e) {
      if (container.contains(e.target)) return;

      if (config.clickOutsideDeactivates) {
        deactivate({
          returnFocus: !tabbable_1.isFocusable(e.target)
        });
      } else {
        e.preventDefault();
      }
    } // In case focus escapes the trap for some strange reason, pull it back in.


    function checkFocusIn(e) {
      // In Firefox when you Tab out of an iframe the Document is briefly focused.
      if (container.contains(e.target) || e.target instanceof Document) {
        return;
      }

      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }

    function checkKey(e) {
      if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
        e.preventDefault();
        deactivate();
        return;
      }

      if (isTabEvent(e)) {
        checkTab(e);
        return;
      }
    } // Hijack Tab events on the first and last focusable nodes of the trap,
    // in order to prevent focus from escaping. If it escapes for even a
    // moment it can end up scrolling the page and causing confusion so we
    // kind of need to capture the action at the keydown phase.


    function checkTab(e) {
      updateTabbableNodes();

      if (e.shiftKey && e.target === state.firstTabbableNode) {
        e.preventDefault();
        tryFocus(state.lastTabbableNode);
        return;
      }

      if (!e.shiftKey && e.target === state.lastTabbableNode) {
        e.preventDefault();
        tryFocus(state.firstTabbableNode);
        return;
      }
    }

    function checkClick(e) {
      if (config.clickOutsideDeactivates) return;
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    function updateTabbableNodes() {
      var tabbableNodes = tabbable_1(container);
      state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
      state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
    }

    function tryFocus(node) {
      if (node === doc.activeElement) return;

      if (!node || !node.focus) {
        tryFocus(getInitialFocusNode());
        return;
      }

      node.focus();
      state.mostRecentlyFocusedNode = node;

      if (isSelectableInput(node)) {
        node.select();
      }
    }
  }

  function isSelectableInput(node) {
    return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
  }

  function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  }

  function isTabEvent(e) {
    return e.key === 'Tab' || e.keyCode === 9;
  }

  function delay(fn) {
    return setTimeout(fn, 0);
  }

  var focusTrap_1 = focusTrap;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcDialogAction = /** @class */ (function () {
      function MdcDialogAction(elementRef) {
          this.elementRef = elementRef;
          this._action = '';
      }
      Object.defineProperty(MdcDialogAction.prototype, "action", {
          get: /**
           * @return {?}
           */
          function () { return this._action; },
          set: /**
           * @param {?} action
           * @return {?}
           */
          function (action) {
              // If the directive is set without a name (updated programatically), then this setter will
              // trigger with an empty string and should not overwrite the programatically set value.
              if (!action) {
                  return;
              }
              this._action = action;
              this.elementRef.nativeElement.setAttribute('data-mdc-dialog-action', this._action);
          },
          enumerable: true,
          configurable: true
      });
      MdcDialogAction.decorators = [
          { type: core.Directive, args: [{ selector: '[mdcDialogAction]' },] },
      ];
      /** @nocollapse */
      MdcDialogAction.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcDialogAction.propDecorators = {
          action: [{ type: core.Input, args: ['mdcDialogAction',] }]
      };
      return MdcDialogAction;
  }());
  var MdcDialogScrim = /** @class */ (function () {
      function MdcDialogScrim(elementRef) {
          this.elementRef = elementRef;
      }
      MdcDialogScrim.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mdc-dialog-scrim',
                      host: { 'class': 'mdc-dialog__scrim' }
                  },] },
      ];
      /** @nocollapse */
      MdcDialogScrim.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      return MdcDialogScrim;
  }());
  var MdcDialogContainer = /** @class */ (function () {
      function MdcDialogContainer(elementRef) {
          this.elementRef = elementRef;
      }
      MdcDialogContainer.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcDialogContainer], mdc-dialog-container',
                      host: { 'class': 'mdc-dialog__container' }
                  },] },
      ];
      /** @nocollapse */
      MdcDialogContainer.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      return MdcDialogContainer;
  }());
  var MdcDialogSurface = /** @class */ (function () {
      function MdcDialogSurface(elementRef) {
          this.elementRef = elementRef;
      }
      MdcDialogSurface.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcDialogSurface], mdc-dialog-surface',
                      host: { 'class': 'mdc-dialog__surface' }
                  },] },
      ];
      /** @nocollapse */
      MdcDialogSurface.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      return MdcDialogSurface;
  }());
  var MdcDialogTitle = /** @class */ (function () {
      function MdcDialogTitle(elementRef) {
          this.elementRef = elementRef;
      }
      MdcDialogTitle.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcDialogTitle], mdc-dialog-title',
                      host: { 'class': 'mdc-dialog__title' }
                  },] },
      ];
      /** @nocollapse */
      MdcDialogTitle.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      return MdcDialogTitle;
  }());
  var MdcDialogContent = /** @class */ (function () {
      function MdcDialogContent(elementRef) {
          this.elementRef = elementRef;
      }
      MdcDialogContent.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcDialogContent], mdc-dialog-content',
                      host: { 'class': 'mdc-dialog__content' }
                  },] },
      ];
      /** @nocollapse */
      MdcDialogContent.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      return MdcDialogContent;
  }());
  var MdcDialogActions = /** @class */ (function () {
      function MdcDialogActions(elementRef) {
          this.elementRef = elementRef;
          this._stacked = false;
      }
      Object.defineProperty(MdcDialogActions.prototype, "stacked", {
          get: /**
           * @return {?}
           */
          function () { return this._stacked; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._stacked = common.toBoolean(value);
          },
          enumerable: true,
          configurable: true
      });
      MdcDialogActions.decorators = [
          { type: core.Component, args: [{selector: 'mdc-dialog-actions, [mdcDialogActions]',
                      template: '<ng-content></ng-content>',
                      exportAs: 'mdcDialogActions',
                      host: {
                          'class': 'mdc-dialog__actions',
                          '[class.mdc-dialog--stacked]': 'stacked'
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MdcDialogActions.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcDialogActions.propDecorators = {
          stacked: [{ type: core.Input }]
      };
      return MdcDialogActions;
  }());
  var MdcDialogButton = /** @class */ (function (_super) {
      __extends(MdcDialogButton, _super);
      function MdcDialogButton() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._default = false;
          return _this;
      }
      Object.defineProperty(MdcDialogButton.prototype, "default", {
          get: /**
           * @return {?}
           */
          function () { return this._default; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._default = common.toBoolean(value);
          },
          enumerable: true,
          configurable: true
      });
      MdcDialogButton.decorators = [
          { type: core.Component, args: [{selector: '[mdcDialogButton]',
                      exportAs: 'mdcDialogButton',
                      host: {
                          'class': 'mdc-dialog__button',
                          '[class.mdc-button]': 'true',
                          '[class.mdc-dialog__button--default]': 'default'
                      },
                      template: '<ng-content></ng-content>',
                      providers: [ripple.MdcRipple],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      MdcDialogButton.propDecorators = {
          default: [{ type: core.Input }]
      };
      return MdcDialogButton;
  }(button.MdcButton));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Unique id for the created dialog.
   * @type {?}
   */
  var uniqueId = 0;
  /**
   * Reference to a dialog dispatched from the MdcDialog service.
   * @template T, R
   */
  var   /**
   * Reference to a dialog dispatched from the MdcDialog service.
   * @template T, R
   */
  MdcDialogRef = /** @class */ (function () {
      function MdcDialogRef(_overlayRef, _portalInstance, id) {
          if (id === void 0) { id = "mdc-dialog-" + uniqueId++; }
          var _this = this;
          this._overlayRef = _overlayRef;
          this._portalInstance = _portalInstance;
          this.id = id;
          /**
           * Subject for notifying the user that the dialog has finished opening.
           */
          this._afterOpened = new rxjs.Subject();
          /**
           * Subject for notifying the user that the dialog has started closing.
           */
          this._beforeClosed = new rxjs.Subject();
          /**
           * Subject for notifying the user that the dialog has finished closing.
           */
          this._afterClosed = new rxjs.Subject();
          // Pass the id along to the portal.
          _portalInstance._id = id;
          _overlayRef.detachments().subscribe((/**
           * @return {?}
           */
          function () {
              _this._beforeClosed.next(_this._result);
              _this._beforeClosed.complete();
              _this._afterClosed.next(_this._result);
              _this._afterClosed.complete();
              _this.componentInstance = (/** @type {?} */ (null));
              _this._overlayRef.dispose();
          }));
      }
      /**
       * Close the dialog.
       * @param dialogResult Optional result to return to the dialog opener.
       */
      /**
       * Close the dialog.
       * @param {?=} dialogResult Optional result to return to the dialog opener.
       * @return {?}
       */
      MdcDialogRef.prototype.close = /**
       * Close the dialog.
       * @param {?=} dialogResult Optional result to return to the dialog opener.
       * @return {?}
       */
      function (dialogResult) {
          this._result = dialogResult;
          this._overlayRef.dispose();
      };
      /** Marks the dialog as opened. */
      /**
       * Marks the dialog as opened.
       * @return {?}
       */
      MdcDialogRef.prototype.opened = /**
       * Marks the dialog as opened.
       * @return {?}
       */
      function () {
          if (!this._afterOpened.closed) {
              this._afterOpened.next();
              this._afterOpened.complete();
          }
      };
      /** Gets an observable that is notified when the dialog is finished opening. */
      /**
       * Gets an observable that is notified when the dialog is finished opening.
       * @return {?}
       */
      MdcDialogRef.prototype.afterOpened = /**
       * Gets an observable that is notified when the dialog is finished opening.
       * @return {?}
       */
      function () {
          return this._afterOpened.asObservable();
      };
      /** Gets an observable that is notified when the dialog has started closing. */
      /**
       * Gets an observable that is notified when the dialog has started closing.
       * @return {?}
       */
      MdcDialogRef.prototype.beforeClosed = /**
       * Gets an observable that is notified when the dialog has started closing.
       * @return {?}
       */
      function () {
          return this._beforeClosed.asObservable();
      };
      /** Gets an observable that is notified when the dialog is finished closing. */
      /**
       * Gets an observable that is notified when the dialog is finished closing.
       * @return {?}
       */
      MdcDialogRef.prototype.afterClosed = /**
       * Gets an observable that is notified when the dialog is finished closing.
       * @return {?}
       */
      function () {
          return this._afterClosed.asObservable();
      };
      return MdcDialogRef;
  }());

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /**
   * @param {!Element} surfaceEl
   * @param {?Element=} initialFocusEl
   * @param {function(!Element, !FocusTrapCreateOptions): !FocusTrapInstance} focusTrapFactory
   * @return {!FocusTrapInstance}
   */

  function createFocusTrapInstance(surfaceEl) {
    var focusTrapFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : focusTrap_1;
    var initialFocusEl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return focusTrapFactory(surfaceEl, {
      initialFocus: initialFocusEl,
      escapeDeactivates: false,
      // Dialog foundation handles escape key
      clickOutsideDeactivates: true // Allow handling of scrim clicks

    });
  }
  /**
   * @param {!Element} el
   * @return {boolean}
   */


  function isScrollable(el) {
    return el.scrollHeight > el.offsetHeight;
  }
  /**
   * @param {!Array<!Element>|!NodeList} els
   * @return {boolean}
   */


  function areTopsMisaligned(els) {
    var tops = new Set();
    [].forEach.call(els, function (el) {
      return tops.add(el.offsetTop);
    });
    return tops.size > 1;
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses = {
    OPEN: 'mdc-dialog--open',
    OPENING: 'mdc-dialog--opening',
    CLOSING: 'mdc-dialog--closing',
    SCROLLABLE: 'mdc-dialog--scrollable',
    STACKED: 'mdc-dialog--stacked',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock'
  };
  var strings = {
    SCRIM_SELECTOR: '.mdc-dialog__scrim',
    CONTAINER_SELECTOR: '.mdc-dialog__container',
    SURFACE_SELECTOR: '.mdc-dialog__surface',
    CONTENT_SELECTOR: '.mdc-dialog__content',
    BUTTON_SELECTOR: '.mdc-dialog__button',
    DEFAULT_BUTTON_SELECTOR: '.mdc-dialog__button--default',
    SUPPRESS_DEFAULT_PRESS_SELECTOR: ['textarea', '.mdc-menu .mdc-list-item'].join(', '),
    OPENING_EVENT: 'MDCDialog:opening',
    OPENED_EVENT: 'MDCDialog:opened',
    CLOSING_EVENT: 'MDCDialog:closing',
    CLOSED_EVENT: 'MDCDialog:closed',
    ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
    CLOSE_ACTION: 'close',
    DESTROY_ACTION: 'destroy'
  };
  var numbers = {
    DIALOG_ANIMATION_OPEN_TIME_MS: 150,
    DIALOG_ANIMATION_CLOSE_TIME_MS: 75
  };

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
   * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
   */

  /**
   * @param {!Element} element
   * @param {string} selector
   * @return {?Element}
   */
  function closest(element, selector) {
    if (element.closest) {
      return element.closest(selector);
    }

    var el = element;

    while (el) {
      if (matches$1(el, selector)) {
        return el;
      }

      el = el.parentElement;
    }

    return null;
  }
  /**
   * @param {!Element} element
   * @param {string} selector
   * @return {boolean}
   */


  function matches$1(element, selector) {
    var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
    return nativeMatches.call(element, selector);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter =
  /*#__PURE__*/
  function () {
    function MDCRippleAdapter() {
      _classCallCheck(this, MDCRippleAdapter);
    }

    _createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}
      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}
      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}
      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}
      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}
      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);

    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$1 = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };
  var strings$1 = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };
  var numbers$1 = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225,
    // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150,
    // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_;
  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */

  var supportsPassive_;
  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */

  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }
  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */


  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var supportsCssVariables = supportsCssVariables_;

    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari

    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }

    return supportsCssVariables;
  } //

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|!EventListenerOptions}
   */


  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;

      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = true;
            return isSupported;
          }

        });
      } catch (e) {}

      supportsPassive_ = isSupported;
    }

    return supportsPassive_ ?
    /** @type {!EventListenerOptions} */
    {
      passive: true
    } : false;
  }
  /**
   * @param {!Object} HTMLElementPrototype
   * @return {string}
   */


  function getMatchesProperty(HTMLElementPrototype) {
    /**
     * Order is important because we return the first existing method we find.
     * Do not change the order of the items in the below array.
     */
    var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
    var method = 'matches';

    for (var i = 0; i < matchesMethods.length; i++) {
      var matchesMethod = matchesMethods[i];

      if (matchesMethod in HTMLElementPrototype) {
        method = matchesMethod;
        break;
      }
    }

    return method;
  }
  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */


  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY; // Determine touch point relative to the ripple container.

    if (ev.type === 'touchstart') {
      ev =
      /** @type {!TouchEvent} */
      ev;
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      ev =
      /** @type {!MouseEvent} */
      ev;
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return {
      x: normalizedX,
      y: normalizedY
    };
  }

  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

  /** @type {!Array<!EventTarget>} */

  var activatedTargets = [];
  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCRippleFoundation, _MDCFoundation);

    _createClass(MDCRippleFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$1;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$1;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers$1;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars()
          /* boolean - cached */
          {},
          isUnbounded: function isUnbounded()
          /* boolean */
          {},
          isSurfaceActive: function isSurfaceActive()
          /* boolean */
          {},
          isSurfaceDisabled: function isSurfaceDisabled()
          /* boolean */
          {},
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          containsEventTarget: function containsEventTarget()
          /* target: !EventTarget */
          {},
          registerInteractionHandler: function registerInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerResizeHandler: function registerResizeHandler()
          /* handler: EventListener */
          {},
          deregisterResizeHandler: function deregisterResizeHandler()
          /* handler: EventListener */
          {},
          updateCssVariable: function updateCssVariable()
          /* varName: string, value: string */
          {},
          computeBoundingRect: function computeBoundingRect()
          /* ClientRect */
          {},
          getWindowPageOffset: function getWindowPageOffset()
          /* {x: number, y: number} */
          {}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCRippleFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
      /** @private {number} */

      _this.layoutFrame_ = 0;
      /** @private {!ClientRect} */

      _this.frame_ =
      /** @type {!ClientRect} */
      {
        width: 0,
        height: 0
      };
      /** @private {!ActivationStateType} */

      _this.activationState_ = _this.defaultActivationState_();
      /** @private {number} */

      _this.initialSize_ = 0;
      /** @private {number} */

      _this.maxRadius_ = 0;
      /** @private {function(!Event)} */

      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };
      /** @private {function(!Event=)} */


      _this.deactivateHandler_ = function () {
        return _this.deactivate_();
      };
      /** @private {function(!Event=)} */


      _this.focusHandler_ = function () {
        return _this.handleFocus();
      };
      /** @private {function(!Event=)} */


      _this.blurHandler_ = function () {
        return _this.handleBlur();
      };
      /** @private {!Function} */


      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      /** @private {{left: number, top:number}} */


      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };
      /** @private {number} */

      _this.fgScale_ = 0;
      /** @private {number} */

      _this.activationTimer_ = 0;
      /** @private {number} */

      _this.fgDeactivationRemovalTimer_ = 0;
      /** @private {boolean} */

      _this.activationAnimationHasEnded_ = false;
      /** @private {!Function} */

      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;

        _this.runDeactivationUXLogicIfReady_();
      };
      /** @private {!Event|undefined} */


      _this.previousActivationEvent_;
      return _this;
    }
    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    _createClass(MDCRippleFoundation, [{
      key: "supportsPressRipple_",
      value: function supportsPressRipple_() {
        return this.adapter_.browserSupportsCssVars();
      }
      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: "defaultActivationState_",
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: undefined,
          isProgrammatic: false
        };
      }
      /** @override */

    }, {
      key: "init",
      value: function init() {
        var _this2 = this;

        var supportsPressRipple = this.supportsPressRipple_();
        this.registerRootHandlers_(supportsPressRipple);

        if (supportsPressRipple) {
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
      }
      /** @override */

    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        if (this.supportsPressRipple_()) {
          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
          }

          if (this.fgDeactivationRemovalTimer_) {
            clearTimeout(this.fgDeactivationRemovalTimer_);
            this.fgDeactivationRemovalTimer_ = 0;
            this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
          }

          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();
      }
      /**
       * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
       * @private
       */

    }, {
      key: "registerRootHandlers_",
      value: function registerRootHandlers_(supportsPressRipple) {
        var _this4 = this;

        if (supportsPressRipple) {
          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }

        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      }
      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: "registerDeactivationHandlers_",
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }
      /** @private */

    }, {
      key: "deregisterRootHandlers_",
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }
      /** @private */

    }, {
      key: "deregisterDeactivationHandlers_",
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }
      /** @private */

    }, {
      key: "removeCssVars_",
      value: function removeCssVars_() {
        var _this8 = this;

        var strings = MDCRippleFoundation.strings;
        Object.keys(strings).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings[k], null);
          }
        });
      }
      /**
       * @param {!Event=} e
       * @private
       */

    }, {
      key: "activate_",
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;

        if (activationState.isActivated) {
          return;
        } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === undefined;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
        var hasActivatedChild = e !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });

        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e !== undefined) {
          activatedTargets.push(
          /** @type {!EventTarget} */
          e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];

          if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }
      /**
       * @param {!Event=} e
       * @private
       */

    }, {
      key: "checkElementMadeActive_",
      value: function checkElementMadeActive_(e) {
        return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }
      /**
       * @param {!Event=} event Optional event containing position information.
       */

    }, {
      key: "activate",
      value: function activate(event) {
        this.activate_(event);
      }
      /** @private */

    }, {
      key: "animateActivation_",
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
        this.layoutInternal_();
        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
              startPoint = _this$getFgTranslatio.startPoint,
              endPoint = _this$getFgTranslatio.endPoint;

          translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
          translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }
      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: "getFgTranslationCoordinates_",
      value: function getFgTranslationCoordinates_() {
        var _this$activationState = this.activationState_,
            activationEvent = _this$activationState.activationEvent,
            wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
        var startPoint;

        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */
          activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        } // Center the element around the start point.


        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };
        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };
        return {
          startPoint: startPoint,
          endPoint: endPoint
        };
      }
      /** @private */

    }, {
      key: "runDeactivationUXLogicIfReady_",
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _this$activationState2 = this.activationState_,
            hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
            isActivated = _this$activationState2.isActivated;
        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers$1.FG_DEACTIVATION_MS);
        }
      }
      /** @private */

    }, {
      key: "rmBoundedActivationClasses_",
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: "resetActivationState_",
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.

        setTimeout(function () {
          return _this12.previousActivationEvent_ = undefined;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }
      /**
       * @private
       */

    }, {
      key: "deactivate_",
      value: function deactivate_() {
        var _this13 = this;

        var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

        if (!activationState.isActivated) {
          return;
        }

        var state =
        /** @type {!ActivationStateType} */
        Object.assign({}, activationState);

        if (activationState.isProgrammatic) {
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;

            _this13.animateDeactivation_(state);

            _this13.resetActivationState_();
          });
        }
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.deactivate_();
      }
      /**
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: "animateDeactivation_",
      value: function animateDeactivation_(_ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();

          _this14.layoutFrame_ = 0;
        });
      }
      /** @private */

    }, {
      key: "layoutInternal_",
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.

        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

        this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
        this.fgScale_ = this.maxRadius_ / this.initialSize_;
        this.updateLayoutCssVars_();
      }
      /** @private */

    }, {
      key: "updateLayoutCssVars_",
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
        this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };
          this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
          this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
        }
      }
      /** @param {boolean} unbounded */

    }, {
      key: "setUnbounded",
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }, {
      key: "handleFocus",
      value: function handleFocus() {
        var _this16 = this;

        requestAnimationFrame(function () {
          return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }, {
      key: "handleBlur",
      value: function handleBlur() {
        var _this17 = this;

        requestAnimationFrame(function () {
          return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }]);

    return MDCRippleFoundation;
  }(MDCFoundation);

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @type {boolean} */

      _this.disabled = false;
      /** @private {boolean} */

      _this.unbounded_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    _createClass(MDCRipple, [{
      key: "setUnbounded_",

      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: "activate",
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
      /**
       * @return {!MDCRippleFoundation}
       * @override
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
      }
      /** @override */

    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: "unbounded",

      /** @return {boolean} */
      get: function get() {
        return this.unbounded_;
      }
      /** @param {boolean} unbounded */
      ,
      set: function set(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$isUnbounded = _ref.isUnbounded,
            isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

        var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

        if (isUnbounded !== undefined) {
          ripple.unbounded =
          /** @type {boolean} */
          isUnbounded;
        }

        return ripple;
      }
      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: "createAdapter",
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty(HTMLElement.prototype);
        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return {
              x: window.pageXOffset,
              y: window.pageYOffset
            };
          }
        };
      }
    }]);

    return MDCRipple;
  }(MDCComponent);
  /**
   * See Material Design spec for more details on when to use ripples.
   * https://material.io/guidelines/motion/choreography.html#choreography-creation
   * @record
   */


  var RippleCapableSurface = function RippleCapableSurface() {
    _classCallCheck(this, RippleCapableSurface);
  };
  /** @protected {!Element} */


  RippleCapableSurface.prototype.root_;
  /**
   * Whether or not the ripple bleeds out of the bounds of the element.
   * @type {boolean|undefined}
   */

  RippleCapableSurface.prototype.unbounded;
  /**
   * Whether or not the ripple is attached to a disabled component.
   * @type {boolean|undefined}
   */

  RippleCapableSurface.prototype.disabled;

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Dialog. Provides an interface for managing:
   * - CSS classes
   * - DOM
   * - Event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCDialogAdapter =
  /*#__PURE__*/
  function () {
    function MDCDialogAdapter() {
      _classCallCheck(this, MDCDialogAdapter);
    }

    _createClass(MDCDialogAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /** @param {string} className */

    }, {
      key: "addBodyClass",
      value: function addBodyClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeBodyClass",
      value: function removeBodyClass(className) {}
      /**
       * @param {!EventTarget} target
       * @param {string} selector
       * @return {boolean}
       */

    }, {
      key: "eventTargetMatches",
      value: function eventTargetMatches(target, selector) {}
    }, {
      key: "trapFocus",
      value: function trapFocus() {}
    }, {
      key: "releaseFocus",
      value: function releaseFocus() {}
      /** @return {boolean} */

    }, {
      key: "isContentScrollable",
      value: function isContentScrollable() {}
      /** @return {boolean} */

    }, {
      key: "areButtonsStacked",
      value: function areButtonsStacked() {}
      /**
       * @param {!Event} event
       * @return {?string}
       */

    }, {
      key: "getActionFromEvent",
      value: function getActionFromEvent(event) {}
    }, {
      key: "clickDefaultButton",
      value: function clickDefaultButton() {}
    }, {
      key: "reverseButtons",
      value: function reverseButtons() {}
    }, {
      key: "notifyOpening",
      value: function notifyOpening() {}
    }, {
      key: "notifyOpened",
      value: function notifyOpened() {}
      /**
       * @param {string} action
       */

    }, {
      key: "notifyClosing",
      value: function notifyClosing(action) {}
      /**
       * @param {string} action
       */

    }, {
      key: "notifyClosed",
      value: function notifyClosed(action) {}
    }]);

    return MDCDialogAdapter;
  }();

  var MDCDialogFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCDialogFoundation, _MDCFoundation);

    _createClass(MDCDialogFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCDialogAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            hasClass: function hasClass()
            /* className: string */
            {},
            addBodyClass: function addBodyClass()
            /* className: string */
            {},
            removeBodyClass: function removeBodyClass()
            /* className: string */
            {},
            eventTargetMatches: function eventTargetMatches()
            /* target: !EventTarget, selector: string */
            {},
            trapFocus: function trapFocus() {},
            releaseFocus: function releaseFocus() {},
            isContentScrollable: function isContentScrollable() {},
            areButtonsStacked: function areButtonsStacked() {},
            getActionFromEvent: function getActionFromEvent()
            /* event: !Event */
            {},
            clickDefaultButton: function clickDefaultButton() {},
            reverseButtons: function reverseButtons() {},
            notifyOpening: function notifyOpening() {},
            notifyOpened: function notifyOpened() {},
            notifyClosing: function notifyClosing()
            /* action: ?string */
            {},
            notifyClosed: function notifyClosed()
            /* action: ?string */
            {}
          }
        );
      }
      /**
       * @param {!MDCDialogAdapter=} adapter
       */

    }]);

    function MDCDialogFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCDialogFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCDialogFoundation).call(this, Object.assign(MDCDialogFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.isOpen_ = false;
      /** @private {number} */

      _this.animationFrame_ = 0;
      /** @private {number} */

      _this.animationTimer_ = 0;
      /** @private {number} */

      _this.layoutFrame_ = 0;
      /** @private {string} */

      _this.escapeKeyAction_ = strings.CLOSE_ACTION;
      /** @private {string} */

      _this.scrimClickAction_ = strings.CLOSE_ACTION;
      /** @private {boolean} */

      _this.autoStackButtons_ = true;
      /** @private {boolean} */

      _this.areButtonsStacked_ = false;
      return _this;
    }

    _createClass(MDCDialogFoundation, [{
      key: "init",
      value: function init() {
        if (this.adapter_.hasClass(cssClasses.STACKED)) {
          this.setAutoStackButtons(false);
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.isOpen_) {
          this.close(strings.DESTROY_ACTION);
        }

        if (this.animationTimer_) {
          clearTimeout(this.animationTimer_);
          this.handleAnimationTimerEnd_();
        }

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
          this.layoutFrame_ = 0;
        }
      }
    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        this.isOpen_ = true;
        this.adapter_.notifyOpening();
        this.adapter_.addClass(cssClasses.OPENING); // Wait a frame once display is no longer "none", to establish basis for animation

        this.runNextAnimationFrame_(function () {
          _this2.adapter_.addClass(cssClasses.OPEN);

          _this2.adapter_.addBodyClass(cssClasses.SCROLL_LOCK);

          _this2.layout();

          _this2.animationTimer_ = setTimeout(function () {
            _this2.handleAnimationTimerEnd_();

            _this2.adapter_.trapFocus();

            _this2.adapter_.notifyOpened();
          }, numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
        });
      }
      /**
       * @param {string=} action
       */

    }, {
      key: "close",
      value: function close() {
        var _this3 = this;

        var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        if (!this.isOpen_) {
          // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
          return;
        }

        this.isOpen_ = false;
        this.adapter_.notifyClosing(action);
        this.adapter_.addClass(cssClasses.CLOSING);
        this.adapter_.removeClass(cssClasses.OPEN);
        this.adapter_.removeBodyClass(cssClasses.SCROLL_LOCK);
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = setTimeout(function () {
          _this3.adapter_.releaseFocus();

          _this3.handleAnimationTimerEnd_();

          _this3.adapter_.notifyClosed(action);
        }, numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
      }
    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.isOpen_;
      }
      /** @return {string} */

    }, {
      key: "getEscapeKeyAction",
      value: function getEscapeKeyAction() {
        return this.escapeKeyAction_;
      }
      /** @param {string} action */

    }, {
      key: "setEscapeKeyAction",
      value: function setEscapeKeyAction(action) {
        this.escapeKeyAction_ = action;
      }
      /** @return {string} */

    }, {
      key: "getScrimClickAction",
      value: function getScrimClickAction() {
        return this.scrimClickAction_;
      }
      /** @param {string} action */

    }, {
      key: "setScrimClickAction",
      value: function setScrimClickAction(action) {
        this.scrimClickAction_ = action;
      }
      /** @return {boolean} */

    }, {
      key: "getAutoStackButtons",
      value: function getAutoStackButtons() {
        return this.autoStackButtons_;
      }
      /** @param {boolean} autoStack */

    }, {
      key: "setAutoStackButtons",
      value: function setAutoStackButtons(autoStack) {
        this.autoStackButtons_ = autoStack;
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this4 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this4.layoutInternal_();

          _this4.layoutFrame_ = 0;
        });
      }
    }, {
      key: "layoutInternal_",
      value: function layoutInternal_() {
        if (this.autoStackButtons_) {
          this.detectStackedButtons_();
        }

        this.detectScrollableContent_();
      }
      /** @private */

    }, {
      key: "detectStackedButtons_",
      value: function detectStackedButtons_() {
        // Remove the class first to let us measure the buttons' natural positions.
        this.adapter_.removeClass(cssClasses.STACKED);
        var areButtonsStacked = this.adapter_.areButtonsStacked();

        if (areButtonsStacked) {
          this.adapter_.addClass(cssClasses.STACKED);
        }

        if (areButtonsStacked !== this.areButtonsStacked_) {
          this.adapter_.reverseButtons();
          this.areButtonsStacked_ = areButtonsStacked;
        }
      }
      /** @private */

    }, {
      key: "detectScrollableContent_",
      value: function detectScrollableContent_() {
        // Remove the class first to let us measure the natural height of the content.
        this.adapter_.removeClass(cssClasses.SCROLLABLE);

        if (this.adapter_.isContentScrollable()) {
          this.adapter_.addClass(cssClasses.SCROLLABLE);
        }
      }
      /**
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "handleInteraction",
      value: function handleInteraction(evt) {
        var isClick = evt.type === 'click';
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13; // Check for scrim click first since it doesn't require querying ancestors

        if (isClick && this.adapter_.eventTargetMatches(evt.target, strings.SCRIM_SELECTOR) && this.scrimClickAction_ !== '') {
          this.close(this.scrimClickAction_);
        } else if (isClick || evt.key === 'Space' || evt.keyCode === 32 || isEnter) {
          var action = this.adapter_.getActionFromEvent(evt);

          if (action) {
            this.close(action);
          } else if (isEnter && !this.adapter_.eventTargetMatches(evt.target, strings.SUPPRESS_DEFAULT_PRESS_SELECTOR)) {
            this.adapter_.clickDefaultButton();
          }
        }
      }
      /**
       * @param {!KeyboardEvent} evt
       * @private
       */

    }, {
      key: "handleDocumentKeydown",
      value: function handleDocumentKeydown(evt) {
        if ((evt.key === 'Escape' || evt.keyCode === 27) && this.escapeKeyAction_ !== '') {
          this.close(this.escapeKeyAction_);
        }
      }
      /** @private */

    }, {
      key: "handleAnimationTimerEnd_",
      value: function handleAnimationTimerEnd_() {
        this.animationTimer_ = 0;
        this.adapter_.removeClass(cssClasses.OPENING);
        this.adapter_.removeClass(cssClasses.CLOSING);
      }
      /**
       * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
       * @param {Function} callback
       * @private
       */

    }, {
      key: "runNextAnimationFrame_",
      value: function runNextAnimationFrame_(callback) {
        var _this5 = this;

        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
          _this5.animationFrame_ = 0;
          clearTimeout(_this5.animationTimer_);
          _this5.animationTimer_ = setTimeout(callback, 0);
        });
      }
    }]);

    return MDCDialogFoundation;
  }(MDCFoundation);

  var strings$2 = MDCDialogFoundation.strings;

  var MDCDialog =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCDialog, _MDCComponent);

    function MDCDialog() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCDialog);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCDialog)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /**
       * @type {!Array<!MDCRipple>}
       * @private
       */

      _this.buttonRipples_;
      /** @private {!Array<!Element>} */

      _this.buttons_;
      /** @private {?Element} */

      _this.defaultButton_;
      /** @private {!Element} */

      _this.container_;
      /** @private {?Element} */

      _this.content_;
      /** @private {?Element} */

      _this.initialFocusEl_;
      /** @private {!Function} */

      _this.focusTrapFactory_;
      /** @private {!FocusTrapInstance} */

      _this.focusTrap_;
      /** @private {!Function} */

      _this.handleInteraction_;
      /** @private {!Function} */

      _this.handleDocumentKeydown_;
      /** @private {!Function} */

      _this.handleOpening_;
      /** @private {!Function} */

      _this.handleClosing_;
      /** @private {Function} */

      _this.layout_;
      return _this;
    }

    _createClass(MDCDialog, [{
      key: "initialize",
      value: function initialize() {
        var focusTrapFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : focusTrap_1;
        var initialFocusEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        this.container_ =
        /** @type {!Element} */
        this.root_.querySelector(strings$2.CONTAINER_SELECTOR);
        this.content_ = this.root_.querySelector(strings$2.CONTENT_SELECTOR);
        this.buttons_ = [].slice.call(this.root_.querySelectorAll(strings$2.BUTTON_SELECTOR));
        this.defaultButton_ = this.root_.querySelector(strings$2.DEFAULT_BUTTON_SELECTOR);
        this.buttonRipples_ = [];
        this.focusTrapFactory_ = focusTrapFactory;
        this.initialFocusEl_ = initialFocusEl;

        for (var i = 0, buttonEl; buttonEl = this.buttons_[i]; i++) {
          this.buttonRipples_.push(new MDCRipple(buttonEl));
        }
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        var _this2 = this;

        this.focusTrap_ = createFocusTrapInstance(this.container_, this.focusTrapFactory_, this.initialFocusEl_);
        this.handleInteraction_ = this.foundation_.handleInteraction.bind(this.foundation_);
        this.handleDocumentKeydown_ = this.foundation_.handleDocumentKeydown.bind(this.foundation_);
        this.layout_ = this.layout.bind(this);
        var LAYOUT_EVENTS = ['resize', 'orientationchange'];

        this.handleOpening_ = function () {
          LAYOUT_EVENTS.forEach(function (type) {
            return window.addEventListener(type, _this2.layout_);
          });
          document.addEventListener('keydown', _this2.handleDocumentKeydown_);
        };

        this.handleClosing_ = function () {
          LAYOUT_EVENTS.forEach(function (type) {
            return window.removeEventListener(type, _this2.layout_);
          });
          document.removeEventListener('keydown', _this2.handleDocumentKeydown_);
        };

        this.listen('click', this.handleInteraction_);
        this.listen('keydown', this.handleInteraction_);
        this.listen(strings$2.OPENING_EVENT, this.handleOpening_);
        this.listen(strings$2.CLOSING_EVENT, this.handleClosing_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.unlisten('click', this.handleInteraction_);
        this.unlisten('keydown', this.handleInteraction_);
        this.unlisten(strings$2.OPENING_EVENT, this.handleOpening_);
        this.unlisten(strings$2.CLOSING_EVENT, this.handleClosing_);
        this.handleClosing_();
        this.buttonRipples_.forEach(function (ripple) {
          return ripple.destroy();
        });

        _get(_getPrototypeOf(MDCDialog.prototype), "destroy", this).call(this);
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
    }, {
      key: "open",
      value: function open() {
        this.foundation_.open();
      }
      /**
       * @param {string=} action
       */

    }, {
      key: "close",
      value: function close() {
        var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        this.foundation_.close(action);
      }
    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this3 = this;

        return new MDCDialogFoundation({
          addClass: function addClass(className) {
            return _this3.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this3.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this3.root_.classList.contains(className);
          },
          addBodyClass: function addBodyClass(className) {
            return document.body.classList.add(className);
          },
          removeBodyClass: function removeBodyClass(className) {
            return document.body.classList.remove(className);
          },
          eventTargetMatches: function eventTargetMatches(target, selector) {
            return matches$1(target, selector);
          },
          trapFocus: function trapFocus() {
            return _this3.focusTrap_.activate();
          },
          releaseFocus: function releaseFocus() {
            return _this3.focusTrap_.deactivate();
          },
          isContentScrollable: function isContentScrollable() {
            return !!_this3.content_ && isScrollable(
            /** @type {!Element} */
            _this3.content_);
          },
          areButtonsStacked: function areButtonsStacked() {
            return areTopsMisaligned(_this3.buttons_);
          },
          getActionFromEvent: function getActionFromEvent(event) {
            var element = closest(event.target, "[".concat(strings$2.ACTION_ATTRIBUTE, "]"));
            return element && element.getAttribute(strings$2.ACTION_ATTRIBUTE);
          },
          clickDefaultButton: function clickDefaultButton() {
            if (_this3.defaultButton_) {
              _this3.defaultButton_.click();
            }
          },
          reverseButtons: function reverseButtons() {
            _this3.buttons_.reverse();

            _this3.buttons_.forEach(function (button) {
              return button.parentElement.appendChild(button);
            });
          },
          notifyOpening: function notifyOpening() {
            return _this3.emit(strings$2.OPENING_EVENT, {});
          },
          notifyOpened: function notifyOpened() {
            return _this3.emit(strings$2.OPENED_EVENT, {});
          },
          notifyClosing: function notifyClosing(action) {
            return _this3.emit(strings$2.CLOSING_EVENT, action ? {
              action: action
            } : {});
          },
          notifyClosed: function notifyClosed(action) {
            return _this3.emit(strings$2.CLOSED_EVENT, action ? {
              action: action
            } : {});
          }
        });
      }
    }, {
      key: "isOpen",
      get: function get() {
        return this.foundation_.isOpen();
      }
    }, {
      key: "escapeKeyAction",
      get: function get() {
        return this.foundation_.getEscapeKeyAction();
      },
      set: function set(action) {
        this.foundation_.setEscapeKeyAction(action);
      }
    }, {
      key: "scrimClickAction",
      get: function get() {
        return this.foundation_.getScrimClickAction();
      },
      set: function set(action) {
        this.foundation_.setScrimClickAction(action);
      }
    }, {
      key: "autoStackButtons",
      get: function get() {
        return this.foundation_.getAutoStackButtons();
      },
      set: function set(autoStack) {
        this.foundation_.setAutoStackButtons(autoStack);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCDialog(root);
      }
    }]);

    return MDCDialog;
  }(MDCComponent);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var LAYOUT_EVENTS = ['resize', 'orientationchange'];
  var MdcDialogComponent = /** @class */ (function () {
      function MdcDialogComponent(_ngZone, _platform, _elementRef, dialogRef) {
          this._ngZone = _ngZone;
          this._platform = _platform;
          this._elementRef = _elementRef;
          this.dialogRef = dialogRef;
          /**
           * Emits whenever the component is destroyed.
           */
          this._destroy = new rxjs.Subject();
          this._focusTrapInstance = null;
          this._scrollable = true;
          this._layoutEventSubscription = null;
          this.config = dialogRef._portalInstance._config;
      }
      Object.defineProperty(MdcDialogComponent.prototype, "layoutEvents", {
          /** Combined stream of all of the dialog layout events. */
          get: /**
           * Combined stream of all of the dialog layout events.
           * @return {?}
           */
          function () {
              return rxjs.merge.apply(void 0, LAYOUT_EVENTS.map((/**
               * @param {?} evt
               * @return {?}
               */
              function (evt) { return rxjs.fromEvent(window, evt); })));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @private
       * @return {?}
       */
      MdcDialogComponent.prototype._createAdapter = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              addClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getDialog().classList.add(className); }),
              removeClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getDialog().classList.remove(className); }),
              hasClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getDialog().classList.contains(className); }),
              addBodyClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) {
                  if (_this._platform.isBrowser) {
                      (/** @type {?} */ (document.body)).classList.add(className);
                  }
              }),
              removeBodyClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) {
                  if (_this._platform.isBrowser) {
                      (/** @type {?} */ (document.body)).classList.remove(className);
                  }
              }),
              eventTargetMatches: (/**
               * @param {?} target
               * @param {?} selector
               * @return {?}
               */
              function (target, selector) { return matches$1(target, selector); }),
              trapFocus: (/**
               * @return {?}
               */
              function () { return (/** @type {?} */ (_this._focusTrapInstance)).activate(); }),
              releaseFocus: (/**
               * @return {?}
               */
              function () { return (/** @type {?} */ (_this._focusTrapInstance)).deactivate(); }),
              isContentScrollable: (/**
               * @return {?}
               */
              function () {
                  return !!_this._content && _this._scrollable && isScrollable(_this._content.elementRef.nativeElement);
              }),
              areButtonsStacked: (/**
               * @return {?}
               */
              function () { return areTopsMisaligned(_this._buttons); }),
              getActionFromEvent: (/**
               * @param {?} event
               * @return {?}
               */
              function (event) {
                  /** @type {?} */
                  var element = closest(event.target, "[" + strings.ACTION_ATTRIBUTE + "]");
                  return element && element.getAttribute(strings.ACTION_ATTRIBUTE);
              }),
              clickDefaultButton: (/**
               * @return {?}
               */
              function () {
                  /** @type {?} */
                  var defaultBtn = _this._getDefaultButton();
                  if (defaultBtn) {
                      defaultBtn.click();
                  }
              }),
              reverseButtons: (/**
               * @return {?}
               */
              function () {
                  if (!_this._buttons) {
                      return;
                  }
                  _this._buttons.toArray().reverse();
                  _this._buttons.forEach((/**
                   * @param {?} button
                   * @return {?}
                   */
                  function (button) { return (/** @type {?} */ (button.getHostElement().parentElement)).appendChild(button.getHostElement()); }));
              }),
              notifyOpened: (/**
               * @return {?}
               */
              function () { return _this.dialogRef.opened(); }),
              notifyClosed: (/**
               * @param {?} action
               * @return {?}
               */
              function (action) { return _this._closeDialogByRef(action); })
          };
      };
      /**
       * @return {?}
       */
      MdcDialogComponent.prototype.ngAfterViewInit = /**
       * @return {?}
       */
      function () {
          this._foundation = new MDCDialogFoundation(this._createAdapter());
          this._focusTrapInstance = this._createFocusTrapInstance();
          this._initialize();
          this._loadListeners();
          this._foundation.open();
      };
      /**
       * @private
       * @return {?}
       */
      MdcDialogComponent.prototype._initialize = /**
       * @private
       * @return {?}
       */
      function () {
          this._scrollable = !!this.config.scrollable;
          if (!this.config.clickOutsideToClose) {
              this._foundation.setScrimClickAction('');
          }
          if (!this.config.escapeToClose) {
              this._foundation.setEscapeKeyAction('');
          }
          if (!this.config.buttonsStacked) {
              this._foundation.setAutoStackButtons(false);
          }
      };
      /**
       * @return {?}
       */
      MdcDialogComponent.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._destroy.next();
          this._destroy.complete();
          if (this._layoutEventSubscription) {
              this._layoutEventSubscription.unsubscribe();
          }
          if (this._foundation) {
              this._foundation.destroy();
          }
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcDialogComponent.prototype._onInteraction = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleInteraction(evt);
      };
      /**
       * @private
       * @return {?}
       */
      MdcDialogComponent.prototype._getDefaultButton = /**
       * @private
       * @return {?}
       */
      function () {
          /** @type {?} */
          var defaultBtn = this._buttons ? this._buttons.find((/**
           * @param {?} _
           * @return {?}
           */
          function (_) { return _.default; })) : undefined;
          return defaultBtn ? defaultBtn.getHostElement() : undefined;
      };
      /**
       * @private
       * @param {?=} action
       * @return {?}
       */
      MdcDialogComponent.prototype._closeDialogByRef = /**
       * @private
       * @param {?=} action
       * @return {?}
       */
      function (action) {
          this.dialogRef.close(action);
      };
      /**
       * @private
       * @return {?}
       */
      MdcDialogComponent.prototype._loadListeners = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          this._layoutEventSubscription = this.layoutEvents.pipe()
              .subscribe((/**
           * @return {?}
           */
          function () { return _this._foundation.layout(); }));
          if (this._platform.isBrowser) {
              this._ngZone.runOutsideAngular((/**
               * @return {?}
               */
              function () {
                  return rxjs.fromEvent(document, 'keydown').pipe(operators.takeUntil(_this._destroy))
                      .subscribe((/**
                   * @param {?} evt
                   * @return {?}
                   */
                  function (evt) { return _this._ngZone.run((/**
                   * @return {?}
                   */
                  function () { return _this._foundation.handleDocumentKeydown(evt); })); }));
              }));
          }
      };
      /**
       * @private
       * @param {?=} focusTrapFactory
       * @return {?}
       */
      MdcDialogComponent.prototype._createFocusTrapInstance = /**
       * @private
       * @param {?=} focusTrapFactory
       * @return {?}
       */
      function (focusTrapFactory) {
          if (focusTrapFactory === void 0) { focusTrapFactory = focusTrap_1; }
          return focusTrapFactory(this._getDialog(), {
              initialFocus: this._getDefaultButton(),
              clickOutsideDeactivates: true,
              // Allow handling of scrim clicks
              escapeDeactivates: false // Dialog foundation handles escape key
          });
      };
      /** Retrieves the DOM element of the component host. */
      /**
       * Retrieves the DOM element of the component host.
       * @private
       * @return {?}
       */
      MdcDialogComponent.prototype._getDialog = /**
       * Retrieves the DOM element of the component host.
       * @private
       * @return {?}
       */
      function () {
          return this._elementRef.nativeElement;
      };
      MdcDialogComponent.decorators = [
          { type: core.Component, args: [{selector: 'mdc-dialog',
                      exportAs: 'mdc-dialog',
                      host: {
                          '[attr.id]': 'config?.id',
                          'role': 'alertdialog',
                          'class': 'mdc-dialog',
                          '[attr.aria-modal]': 'true',
                          '[attr.aria-labelledby]': 'config?.ariaLabel',
                          '[attr.aria-label]': 'config?.ariaLabel',
                          '[attr.aria-describedby]': 'config?.ariaDescribedBy || null',
                          '(click)': '_onInteraction($event)',
                          '(keydown)': '_onInteraction($event)'
                      },
                      template: "\n  <mdc-dialog-scrim></mdc-dialog-scrim>\n  <ng-content></ng-content>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MdcDialogComponent.ctorParameters = function () { return [
          { type: core.NgZone },
          { type: common.Platform },
          { type: core.ElementRef },
          { type: MdcDialogRef }
      ]; };
      MdcDialogComponent.propDecorators = {
          _surface: [{ type: core.ContentChild, args: [MdcDialogSurface,] }],
          _content: [{ type: core.ContentChild, args: [MdcDialogContent,] }],
          _buttons: [{ type: core.ContentChildren, args: [MdcDialogButton, { descendants: true },] }]
      };
      return MdcDialogComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @template D
   */
  var   /**
   * @template D
   */
  MdcDialogConfig = /** @class */ (function () {
      function MdcDialogConfig() {
          /**
           * ID of the element that describes the dialog.
           */
          this.ariaDescribedBy = null;
          /**
           * Aria label to assign to the dialog element
           */
          this.ariaLabel = null;
          /**
           * Whether the user can use escape key to close the dialog
           */
          this.escapeToClose = true;
          /**
           * Whether the user can click outside to close the dialog
           */
          this.clickOutsideToClose = true;
          /**
           * Applied automatically when the dialog has overflowing content to warrant scrolling.
           */
          this.scrollable = true;
          /**
           * Applied automatically when the dialog's action buttons can't fit on a single line and must be stacked.
           */
          this.buttonsStacked = true;
          /**
           * Data to be injected into the dialog content.
           */
          this.data = null;
      }
      return MdcDialogConfig;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Throws an exception for the case when a ComponentPortal is
   * attached to a DomPortalOutlet without an origin.
   * @return {?}
   */
  function throwMdcDialogContentAlreadyAttachedError() {
      throw Error('Attempting to attach dialog content after content is already attached');
  }
  var MdcDialogPortal = /** @class */ (function (_super) {
      __extends(MdcDialogPortal, _super);
      function MdcDialogPortal(_config) {
          var _this = _super.call(this) || this;
          _this._config = _config;
          /**
           * A subject emitting after the dialog exits the view.
           */
          _this._afterExit = new rxjs.Subject();
          return _this;
      }
      /**
       * Attach a ComponentPortal as content to this dialog container.
       * @param portal Portal to be attached as the dialog content.
       */
      /**
       * Attach a ComponentPortal as content to this dialog container.
       * @template T
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
      MdcDialogPortal.prototype.attachComponentPortal = /**
       * Attach a ComponentPortal as content to this dialog container.
       * @template T
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
      function (portal) {
          if (this._portalOutlet.hasAttached()) {
              throwMdcDialogContentAlreadyAttachedError();
          }
          return this._portalOutlet.attachComponentPortal(portal);
      };
      /**
       * Attach a TemplatePortal as content to this dialog container.
       * @param portal Portal to be attached as the dialog content.
       */
      /**
       * Attach a TemplatePortal as content to this dialog container.
       * @template C
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
      MdcDialogPortal.prototype.attachTemplatePortal = /**
       * Attach a TemplatePortal as content to this dialog container.
       * @template C
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
      function (portal) {
          if (this._portalOutlet.hasAttached()) {
              throwMdcDialogContentAlreadyAttachedError();
          }
          return this._portalOutlet.attachTemplatePortal(portal);
      };
      MdcDialogPortal.decorators = [
          { type: core.Component, args: [{selector: 'mdc-dialog-portal',
                      host: {
                          '[attr.id]': '_id'
                      },
                      template: '<ng-template cdkPortalOutlet></ng-template>',
                      encapsulation: core.ViewEncapsulation.None
                  },] },
      ];
      /** @nocollapse */
      MdcDialogPortal.ctorParameters = function () { return [
          { type: MdcDialogConfig }
      ]; };
      MdcDialogPortal.propDecorators = {
          _portalOutlet: [{ type: core.ViewChild, args: [portal.CdkPortalOutlet,] }]
      };
      return MdcDialogPortal;
  }(portal.BasePortalOutlet));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to access the data that was passed in to a dialog.
   * @type {?}
   */
  var MDC_DIALOG_DATA = new core.InjectionToken('MdcDialogData');
  /**
   * Injection token that can be used to specify default dialog options.
   * @type {?}
   */
  var MDC_DIALOG_DEFAULT_OPTIONS = new core.InjectionToken('mdc-dialog-default-options');
  var MdcDialog = /** @class */ (function () {
      function MdcDialog(_overlay, _injector, _defaultOptions, _parentDialog) {
          var _this = this;
          this._overlay = _overlay;
          this._injector = _injector;
          this._defaultOptions = _defaultOptions;
          this._parentDialog = _parentDialog;
          this._openDialogsAtThisLevel = [];
          this._afterAllClosedAtThisLevel = new rxjs.Subject();
          this._afterOpenedAtThisLevel = new rxjs.Subject();
          this._ariaHiddenElements = new Map();
          /**
           * Stream that emits when all open dialog have finished closing.
           * Will emit on subscribe if there are no open dialogs to begin with.
           */
          this.afterAllClosed = rxjs.defer((/**
           * @return {?}
           */
          function () { return _this.openDialogs.length ?
              _this._afterAllClosed :
              _this._afterAllClosed.pipe(operators.startWith(undefined)); }));
      }
      Object.defineProperty(MdcDialog.prototype, "openDialogs", {
          /** Keeps track of the currently-open dialogs. */
          get: /**
           * Keeps track of the currently-open dialogs.
           * @return {?}
           */
          function () {
              return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcDialog.prototype, "afterOpened", {
          /** Stream that emits when a dialog has been opened. */
          get: /**
           * Stream that emits when a dialog has been opened.
           * @return {?}
           */
          function () {
              return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcDialog.prototype, "_afterAllClosed", {
          get: /**
           * @return {?}
           */
          function () {
              /** @type {?} */
              var parent = this._parentDialog;
              return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Opens a modal dialog containing the given template.
       * @param componentOrTemplateRef Type of the component to load into the dialog,
       *     or a TemplateRef to instantiate as the dialog content.
       * @param config Extra configuration options.
       * @returns Reference to the newly-opened dialog.
       */
      /**
       * Opens a modal dialog containing the given template.
       * @template T, D
       * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
       *     or a TemplateRef to instantiate as the dialog content.
       * @param {?=} config Extra configuration options.
       * @return {?} Reference to the newly-opened dialog.
       */
      MdcDialog.prototype.open = /**
       * Opens a modal dialog containing the given template.
       * @template T, D
       * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
       *     or a TemplateRef to instantiate as the dialog content.
       * @param {?=} config Extra configuration options.
       * @return {?} Reference to the newly-opened dialog.
       */
      function (componentOrTemplateRef, config) {
          var _this = this;
          config = _applyConfigDefaults(config, this._defaultOptions || new MdcDialogConfig());
          if (config.id && this.getDialogById(config.id)) {
              throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
          }
          /** @type {?} */
          var overlayRef = this._createOverlay();
          /** @type {?} */
          var dialogContainer = this._attachDialogContainer(overlayRef, config);
          /** @type {?} */
          var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
          this.openDialogs.push(dialogRef);
          dialogRef.afterClosed().subscribe((/**
           * @return {?}
           */
          function () { return _this._removeOpenDialog(dialogRef); }));
          this.afterOpened.next(dialogRef);
          return dialogRef;
      };
      /** Closes all of the currently-open dialogs. */
      /**
       * Closes all of the currently-open dialogs.
       * @return {?}
       */
      MdcDialog.prototype.closeAll = /**
       * Closes all of the currently-open dialogs.
       * @return {?}
       */
      function () {
          this._closeDialogs(this.openDialogs);
      };
      /**
       * Finds an open dialog by its id.
       * @param id ID to use when looking up the dialog.
       */
      /**
       * Finds an open dialog by its id.
       * @param {?} id ID to use when looking up the dialog.
       * @return {?}
       */
      MdcDialog.prototype.getDialogById = /**
       * Finds an open dialog by its id.
       * @param {?} id ID to use when looking up the dialog.
       * @return {?}
       */
      function (id) {
          return this.openDialogs.find((/**
           * @param {?} dialog
           * @return {?}
           */
          function (dialog) { return dialog.id === id; }));
      };
      /**
       * @return {?}
       */
      MdcDialog.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          // Only close the dialogs at this level on destroy
          // since the parent service may still be active.
          this._closeDialogs(this._openDialogsAtThisLevel);
          this._afterAllClosedAtThisLevel.complete();
          this._afterOpenedAtThisLevel.complete();
      };
      /**
       * Creates the overlay into which the dialog will be loaded.
       * @returns A promise resolving to the OverlayRef for the created overlay.
       */
      /**
       * Creates the overlay into which the dialog will be loaded.
       * @private
       * @return {?} A promise resolving to the OverlayRef for the created overlay.
       */
      MdcDialog.prototype._createOverlay = /**
       * Creates the overlay into which the dialog will be loaded.
       * @private
       * @return {?} A promise resolving to the OverlayRef for the created overlay.
       */
      function () {
          return this._overlay.create();
      };
      /**
       * Attaches an MdcDialogPortal to a dialog's already-created overlay.
       * @param overlay Reference to the dialog's underlying overlay.
       * @param config The dialog configuration.
       * @returns A promise resolving to a ComponentRef for the attached container.
       */
      /**
       * Attaches an MdcDialogPortal to a dialog's already-created overlay.
       * @private
       * @param {?} overlay Reference to the dialog's underlying overlay.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to a ComponentRef for the attached container.
       */
      MdcDialog.prototype._attachDialogContainer = /**
       * Attaches an MdcDialogPortal to a dialog's already-created overlay.
       * @private
       * @param {?} overlay Reference to the dialog's underlying overlay.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to a ComponentRef for the attached container.
       */
      function (overlay, config) {
          /** @type {?} */
          var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
          /** @type {?} */
          var injector = new portal.PortalInjector(userInjector || this._injector, new WeakMap([
              [MdcDialogConfig, config]
          ]));
          /** @type {?} */
          var containerPortal = new portal.ComponentPortal(MdcDialogPortal, config.viewContainerRef, injector);
          /** @type {?} */
          var containerRef = overlay.attach(containerPortal);
          return containerRef.instance;
      };
      /**
       * Attaches the user-provided component to the already-created MdcDialogPortal.
       * @param componentOrTemplateRef The type of component being loaded into the dialog,
       *     or a TemplateRef to instantiate as the content.
       * @param dialogContainer Reference to the wrapping MdcDialogPortal.
       * @param overlayRef Reference to the overlay in which the dialog resides.
       * @param config The dialog configuration.
       * @returns A promise resolving to the MdcDialogRef that should be returned to the user.
       */
      /**
       * Attaches the user-provided component to the already-created MdcDialogPortal.
       * @private
       * @template T
       * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
       *     or a TemplateRef to instantiate as the content.
       * @param {?} dialogContainer Reference to the wrapping MdcDialogPortal.
       * @param {?} overlayRef Reference to the overlay in which the dialog resides.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to the MdcDialogRef that should be returned to the user.
       */
      MdcDialog.prototype._attachDialogContent = /**
       * Attaches the user-provided component to the already-created MdcDialogPortal.
       * @private
       * @template T
       * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
       *     or a TemplateRef to instantiate as the content.
       * @param {?} dialogContainer Reference to the wrapping MdcDialogPortal.
       * @param {?} overlayRef Reference to the overlay in which the dialog resides.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to the MdcDialogRef that should be returned to the user.
       */
      function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
          // Create a reference to the dialog we're creating in order to give the user a handle
          // to modify and close it.
          /** @type {?} */
          var dialogRef = new MdcDialogRef(overlayRef, dialogContainer, config.id);
          if (componentOrTemplateRef instanceof core.TemplateRef) {
              dialogContainer.attachTemplatePortal(new portal.TemplatePortal(componentOrTemplateRef, (/** @type {?} */ (null)), (/** @type {?} */ ({ $implicit: config.data, dialogRef: dialogRef }))));
          }
          else {
              /** @type {?} */
              var injector = this._createInjector(config, dialogRef, dialogContainer);
              /** @type {?} */
              var contentRef = dialogContainer.attachComponentPortal(new portal.ComponentPortal(componentOrTemplateRef, undefined, injector));
              dialogRef.componentInstance = contentRef.instance;
          }
          return dialogRef;
      };
      /**
       * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
       * of a dialog to close itself and, optionally, to return a value.
       * @param config Config object that is used to construct the dialog.
       * @param dialogRef Reference to the dialog.
       * @param container Dialog container element that wraps all of the contents.
       * @returns The custom injector that can be used inside the dialog.
       */
      /**
       * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
       * of a dialog to close itself and, optionally, to return a value.
       * @private
       * @template T
       * @param {?} config Config object that is used to construct the dialog.
       * @param {?} dialogRef Reference to the dialog.
       * @param {?} portalContainer
       * @return {?} The custom injector that can be used inside the dialog.
       */
      MdcDialog.prototype._createInjector = /**
       * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
       * of a dialog to close itself and, optionally, to return a value.
       * @private
       * @template T
       * @param {?} config Config object that is used to construct the dialog.
       * @param {?} dialogRef Reference to the dialog.
       * @param {?} portalContainer
       * @return {?} The custom injector that can be used inside the dialog.
       */
      function (config, dialogRef, portalContainer) {
          /** @type {?} */
          var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
          // The MdcDialogPortal is injected in the portal as the MdcDialogPortal and the dialog's
          // content are created out of the same ViewContainerRef and as such, are siblings for injector
          // purposes. To allow the hierarchy that is expected, the MdcDialogPortal is explicitly
          // added to the injection tokens.
          /** @type {?} */
          var injectionTokens = new WeakMap([
              [MdcDialogPortal, portalContainer],
              [MDC_DIALOG_DATA, config.data],
              [MdcDialogRef, dialogRef]
          ]);
          return new portal.PortalInjector(userInjector || this._injector, injectionTokens);
      };
      /**
       * Removes a dialog from the array of open dialogs.
       * @param dialogRef Dialog to be removed.
       */
      /**
       * Removes a dialog from the array of open dialogs.
       * @private
       * @param {?} dialogRef Dialog to be removed.
       * @return {?}
       */
      MdcDialog.prototype._removeOpenDialog = /**
       * Removes a dialog from the array of open dialogs.
       * @private
       * @param {?} dialogRef Dialog to be removed.
       * @return {?}
       */
      function (dialogRef) {
          /** @type {?} */
          var index = this.openDialogs.indexOf(dialogRef);
          if (index > -1) {
              this.openDialogs.splice(index, 1);
              // If all the dialogs were closed, remove/restore the `aria-hidden`
              // to a the siblings and emit to the `afterAllClosed` stream.
              if (!this.openDialogs.length) {
                  this._ariaHiddenElements.forEach((/**
                   * @param {?} previousValue
                   * @param {?} element
                   * @return {?}
                   */
                  function (previousValue, element) {
                      if (previousValue) {
                          element.setAttribute('aria-hidden', previousValue);
                      }
                      else {
                          element.removeAttribute('aria-hidden');
                      }
                  }));
                  this._ariaHiddenElements.clear();
                  this._afterAllClosed.next();
              }
          }
      };
      /** Closes all of the dialogs in an array. */
      /**
       * Closes all of the dialogs in an array.
       * @private
       * @param {?} dialogs
       * @return {?}
       */
      MdcDialog.prototype._closeDialogs = /**
       * Closes all of the dialogs in an array.
       * @private
       * @param {?} dialogs
       * @return {?}
       */
      function (dialogs) {
          /** @type {?} */
          var i = dialogs.length;
          while (i--) {
              // The `_openDialogs` property isn't updated after close until the rxjs subscription
              // runs on the next microtask, in addition to modifying the array as we're going
              // through it. We loop through all of them and call close without assuming that
              // they'll be removed from the list instantaneously.
              dialogs[i].close();
          }
      };
      MdcDialog.decorators = [
          { type: core.Injectable },
      ];
      /** @nocollapse */
      MdcDialog.ctorParameters = function () { return [
          { type: overlay.Overlay },
          { type: core.Injector },
          { type: MdcDialogConfig, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MDC_DIALOG_DEFAULT_OPTIONS,] }] },
          { type: MdcDialog, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
      ]; };
      return MdcDialog;
  }());
  /**
   * Applies default options to the dialog config.
   * @param {?=} config Config to be modified.
   * @param {?=} defaultOptions Default options provided.
   * @return {?} The new configuration object.
   */
  function _applyConfigDefaults(config, defaultOptions) {
      return _assign({}, defaultOptions, config);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var DIALOG_DECLARATIONS = [
      MdcDialogAction,
      MdcDialogActions,
      MdcDialogButton,
      MdcDialogComponent,
      MdcDialogContainer,
      MdcDialogPortal,
      MdcDialogContent,
      MdcDialogScrim,
      MdcDialogSurface,
      MdcDialogSurface,
      MdcDialogTitle
  ];
  var MdcDialogModule = /** @class */ (function () {
      function MdcDialogModule() {
      }
      MdcDialogModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          overlay.OverlayModule,
                          portal.PortalModule
                      ],
                      exports: DIALOG_DECLARATIONS,
                      declarations: DIALOG_DECLARATIONS,
                      providers: [MdcDialog],
                      entryComponents: [
                          MdcDialogPortal,
                          MdcDialogComponent
                      ]
                  },] },
      ];
      return MdcDialogModule;
  }());

  exports.MdcDialogModule = MdcDialogModule;
  exports.MDC_DIALOG_DATA = MDC_DIALOG_DATA;
  exports.MDC_DIALOG_DEFAULT_OPTIONS = MDC_DIALOG_DEFAULT_OPTIONS;
  exports.MdcDialog = MdcDialog;
  exports.MdcDialogComponent = MdcDialogComponent;
  exports.throwMdcDialogContentAlreadyAttachedError = throwMdcDialogContentAlreadyAttachedError;
  exports.MdcDialogPortal = MdcDialogPortal;
  exports.MdcDialogAction = MdcDialogAction;
  exports.MdcDialogScrim = MdcDialogScrim;
  exports.MdcDialogContainer = MdcDialogContainer;
  exports.MdcDialogSurface = MdcDialogSurface;
  exports.MdcDialogTitle = MdcDialogTitle;
  exports.MdcDialogContent = MdcDialogContent;
  exports.MdcDialogActions = MdcDialogActions;
  exports.MdcDialogButton = MdcDialogButton;
  exports.MdcDialogConfig = MdcDialogConfig;
  exports.MdcDialogRef = MdcDialogRef;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=web-dialog.umd.js.map
