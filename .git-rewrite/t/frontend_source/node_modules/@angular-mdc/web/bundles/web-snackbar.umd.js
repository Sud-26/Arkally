/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular-mdc/web/overlay'), require('@angular-mdc/web/portal'), require('@angular-mdc/web/button'), require('rxjs'), require('rxjs/operators')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/snackbar', ['exports', '@angular/core', '@angular/common', '@angular-mdc/web/overlay', '@angular-mdc/web/portal', '@angular-mdc/web/button', 'rxjs', 'rxjs/operators'], factory) :
  (global = global || self, factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.snackbar = {}), global.ng.core, global.ng.common, global.ng.web.overlay, global.ng.web.portal, global.ng.web.button, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, common, overlay, portal, button, rxjs, operators) { 'use strict';

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Reference to a snackbar dispatched from the snackbar service.
   * @template T
   */
  var   /**
   * Reference to a snackbar dispatched from the snackbar service.
   * @template T
   */
  MdcSnackbarRef = /** @class */ (function () {
      function MdcSnackbarRef(containerInstance, _overlayRef) {
          this.containerInstance = containerInstance;
          this._overlayRef = _overlayRef;
          /**
           * Subject for notifying the user that the snackbar has been dismissed.
           */
          this._afterDismiss = new rxjs.Subject();
          this.componentInstance = containerInstance;
      }
      /** Gets an observable that is notified when the snackbar is finished closing. */
      /**
       * Gets an observable that is notified when the snackbar is finished closing.
       * @return {?}
       */
      MdcSnackbarRef.prototype.afterDismiss = /**
       * Gets an observable that is notified when the snackbar is finished closing.
       * @return {?}
       */
      function () {
          return this._afterDismiss.asObservable();
      };
      /**
       * @param {?=} reason
       * @return {?}
       */
      MdcSnackbarRef.prototype.dismiss = /**
       * @param {?=} reason
       * @return {?}
       */
      function (reason) {
          if (!this._afterDismiss.closed) {
              this._dismissedReason = reason;
              this._finishDismiss();
          }
      };
      /** Cleans up the DOM after closing. */
      /**
       * Cleans up the DOM after closing.
       * @private
       * @return {?}
       */
      MdcSnackbarRef.prototype._finishDismiss = /**
       * Cleans up the DOM after closing.
       * @private
       * @return {?}
       */
      function () {
          this._overlayRef.dispose();
          this._afterDismiss.next(this._dismissedReason);
          this._afterDismiss.complete();
      };
      return MdcSnackbarRef;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to access the data that was passed in to a snackbar.
   * @type {?}
   */
  var MDC_SNACKBAR_DATA = new core.InjectionToken('MdcSnackbarData');
  /**
   * @template D
   */
  var   /**
   * @template D
   */
  MdcSnackbarConfig = /** @class */ (function () {
      function MdcSnackbarConfig() {
          /**
           * Data being injected into the child component.
           */
          this.data = null;
          /**
           * Positions the action button/icon below the label instead of alongside it.
           */
          this.stacked = false;
          /**
           * Positions the snackbar on the leading edge of the screen
           */
          this.leading = false;
          /**
           * Positions the snackbar on the trailing edge of the screen
           */
          this.trailing = false;
          /**
           * The layout direction of the snackbar content
           */
          this.direction = 'ltr';
          /**
           * Show dismiss ("X") icon
           */
          this.dismiss = false;
          /**
           * Whether the snackbar closes when it is focused and the user presses the ESC key
           */
          this.closeOnEscape = true;
      }
      return MdcSnackbarConfig;
  }());

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses = {
    OPENING: 'mdc-snackbar--opening',
    OPEN: 'mdc-snackbar--open',
    CLOSING: 'mdc-snackbar--closing'
  };
  var strings = {
    SURFACE_SELECTOR: '.mdc-snackbar__surface',
    LABEL_SELECTOR: '.mdc-snackbar__label',
    ACTION_SELECTOR: '.mdc-snackbar__action',
    DISMISS_SELECTOR: '.mdc-snackbar__dismiss',
    OPENING_EVENT: 'MDCSnackbar:opening',
    OPENED_EVENT: 'MDCSnackbar:opened',
    CLOSING_EVENT: 'MDCSnackbar:closing',
    CLOSED_EVENT: 'MDCSnackbar:closed',
    REASON_ACTION: 'action',
    REASON_DISMISS: 'dismiss',
    ARIA_LIVE_LABEL_TEXT_ATTR: 'data-mdc-snackbar-label-text'
  };
  var numbers = {
    MIN_AUTO_DISMISS_TIMEOUT_MS: 4000,
    MAX_AUTO_DISMISS_TIMEOUT_MS: 10000,
    DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,
    // These variables need to be kept in sync with the values in _variables.scss.
    SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
    SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,

    /**
     * Number of milliseconds to wait between temporarily clearing the label text
     * in the DOM and subsequently restoring it. This is necessary to force IE 11
     * to pick up the `aria-live` content change and announce it to the user.
     */
    ARIA_LIVE_DELAY_MS: 1000
  };

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var ARIA_LIVE_DELAY_MS = numbers.ARIA_LIVE_DELAY_MS;
  var ARIA_LIVE_LABEL_TEXT_ATTR = strings.ARIA_LIVE_LABEL_TEXT_ATTR;
  /**
   * @param {!HTMLElement} ariaEl
   * @param {!HTMLElement=} labelEl
   */

  function announce(ariaEl) {
    var labelEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ariaEl;
    var priority = ariaEl.getAttribute('aria-live');
    var labelText = labelEl.textContent.trim(); // Ignore `&nbsp;` (see below)

    if (!labelText) {
      return;
    } // Temporarily disable `aria-live` to prevent JAWS+Firefox from announcing the message twice.


    ariaEl.setAttribute('aria-live', 'off'); // Temporarily clear `textContent` to force a DOM mutation event that will be detected by screen readers.
    // `aria-live` elements are only announced when the element's `textContent` *changes*, so snackbars
    // sent to the browser in the initial HTML response won't be read unless we clear the element's `textContent` first.
    // Similarly, displaying the same snackbar message twice in a row doesn't trigger a DOM mutation event,
    // so screen readers won't announce the second message unless we first clear `textContent`.
    //
    // We have to clear the label text two different ways to make it work in all browsers and screen readers:
    //
    //   1. `textContent = ''` is required for IE11 + JAWS
    //   2. `innerHTML = '&nbsp;'` is required for Chrome + JAWS and NVDA
    //
    // All other browser/screen reader combinations support both methods.
    //
    // The wrapper `<span>` visually hides the space character so that it doesn't cause jank when added/removed.
    // N.B.: Setting `position: absolute`, `opacity: 0`, or `height: 0` prevents Chrome from detecting the DOM change.
    //
    // This technique has been tested in:
    //
    //   * JAWS 2019:
    //       - Chrome 70
    //       - Firefox 60 (ESR)
    //       - IE 11
    //   * NVDA 2018:
    //       - Chrome 70
    //       - Firefox 60 (ESR)
    //       - IE 11
    //   * ChromeVox 53

    labelEl.textContent = '';
    labelEl.innerHTML = '<span style="display: inline-block; width: 0; height: 1px;">&nbsp;</span>'; // Prevent visual jank by temporarily displaying the label text in the ::before pseudo-element.
    // CSS generated content is normally announced by screen readers
    // (except in IE 11; see https://tink.uk/accessibility-support-for-css-generated-content/);
    // however, `aria-live` is turned off, so this DOM update will be ignored by screen readers.

    labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);
    setTimeout(function () {
      // Allow screen readers to announce changes to the DOM again.
      ariaEl.setAttribute('aria-live', priority); // Remove the message from the ::before pseudo-element.

      labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR); // Restore the original label text, which will be announced by screen readers.

      labelEl.textContent = labelText;
    }, ARIA_LIVE_DELAY_MS);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Snackbar. Provides an interface for managing:
   * - CSS classes
   * - Event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCSnackbarAdapter =
  /*#__PURE__*/
  function () {
    function MDCSnackbarAdapter() {
      _classCallCheck(this, MDCSnackbarAdapter);
    }

    _createClass(MDCSnackbarAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
    }, {
      key: "announce",
      value: function announce() {}
    }, {
      key: "notifyOpening",
      value: function notifyOpening() {}
    }, {
      key: "notifyOpened",
      value: function notifyOpened() {}
      /**
       * @param {string} reason
       */

    }, {
      key: "notifyClosing",
      value: function notifyClosing(reason) {}
      /**
       * @param {string} reason
       */

    }, {
      key: "notifyClosed",
      value: function notifyClosed(reason) {}
    }]);

    return MDCSnackbarAdapter;
  }();

  var OPENING = cssClasses.OPENING,
      OPEN = cssClasses.OPEN,
      CLOSING = cssClasses.CLOSING;
  var REASON_ACTION = strings.REASON_ACTION,
      REASON_DISMISS = strings.REASON_DISMISS;

  var MDCSnackbarFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSnackbarFoundation, _MDCFoundation);

    _createClass(MDCSnackbarFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers;
      }
      /**
       * @return {!MDCSnackbarAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSnackbarAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            announce: function announce() {},
            notifyOpening: function notifyOpening() {},
            notifyOpened: function notifyOpened() {},
            notifyClosing: function notifyClosing()
            /* reason: string */
            {},
            notifyClosed: function notifyClosed()
            /* reason: string */
            {}
          }
        );
      }
      /**
       * @param {!MDCSnackbarAdapter=} adapter
       */

    }]);

    function MDCSnackbarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCSnackbarFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCSnackbarFoundation).call(this, Object.assign(MDCSnackbarFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.isOpen_ = false;
      /** @private {number} */

      _this.animationFrame_ = 0;
      /** @private {number} */

      _this.animationTimer_ = 0;
      /** @private {number} */

      _this.autoDismissTimer_ = 0;
      /** @private {number} */

      _this.autoDismissTimeoutMs_ = numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
      /** @private {boolean} */

      _this.closeOnEscape_ = true;
      return _this;
    }

    _createClass(MDCSnackbarFoundation, [{
      key: "destroy",
      value: function destroy() {
        this.clearAutoDismissTimer_();
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = 0;
        this.adapter_.removeClass(OPENING);
        this.adapter_.removeClass(OPEN);
        this.adapter_.removeClass(CLOSING);
      }
    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        this.clearAutoDismissTimer_();
        this.isOpen_ = true;
        this.adapter_.notifyOpening();
        this.adapter_.removeClass(CLOSING);
        this.adapter_.addClass(OPENING);
        this.adapter_.announce(); // Wait a frame once display is no longer "none", to establish basis for animation

        this.runNextAnimationFrame_(function () {
          _this2.adapter_.addClass(OPEN);

          _this2.animationTimer_ = setTimeout(function () {
            _this2.handleAnimationTimerEnd_();

            _this2.adapter_.notifyOpened();

            _this2.autoDismissTimer_ = setTimeout(function () {
              _this2.close(REASON_DISMISS);
            }, _this2.getTimeoutMs());
          }, numbers.SNACKBAR_ANIMATION_OPEN_TIME_MS);
        });
      }
      /**
       * @param {string=} reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
       *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
       *     client-specific values may also be used if desired.
       */

    }, {
      key: "close",
      value: function close() {
        var _this3 = this;

        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        if (!this.isOpen_) {
          // Avoid redundant close calls (and events), e.g. repeated interactions as the snackbar is animating closed
          return;
        }

        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        this.clearAutoDismissTimer_();
        this.isOpen_ = false;
        this.adapter_.notifyClosing(reason);
        this.adapter_.addClass(cssClasses.CLOSING);
        this.adapter_.removeClass(cssClasses.OPEN);
        this.adapter_.removeClass(cssClasses.OPENING);
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = setTimeout(function () {
          _this3.handleAnimationTimerEnd_();

          _this3.adapter_.notifyClosed(reason);
        }, numbers.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
      }
      /**
       * @return {boolean}
       */

    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.isOpen_;
      }
      /**
       * @return {number}
       */

    }, {
      key: "getTimeoutMs",
      value: function getTimeoutMs() {
        return this.autoDismissTimeoutMs_;
      }
      /**
       * @param {number} timeoutMs
       */

    }, {
      key: "setTimeoutMs",
      value: function setTimeoutMs(timeoutMs) {
        // Use shorter variable names to make the code more readable
        var minValue = numbers.MIN_AUTO_DISMISS_TIMEOUT_MS;
        var maxValue = numbers.MAX_AUTO_DISMISS_TIMEOUT_MS;

        if (timeoutMs <= maxValue && timeoutMs >= minValue) {
          this.autoDismissTimeoutMs_ = timeoutMs;
        } else {
          throw new Error("timeoutMs must be an integer in the range ".concat(minValue, "\u2013").concat(maxValue, ", but got '").concat(timeoutMs, "'"));
        }
      }
      /**
       * @return {boolean}
       */

    }, {
      key: "getCloseOnEscape",
      value: function getCloseOnEscape() {
        return this.closeOnEscape_;
      }
      /**
       * @param {boolean} closeOnEscape
       */

    }, {
      key: "setCloseOnEscape",
      value: function setCloseOnEscape(closeOnEscape) {
        this.closeOnEscape_ = closeOnEscape;
      }
      /**
       * @param {!KeyboardEvent} evt
       */

    }, {
      key: "handleKeyDown",
      value: function handleKeyDown(evt) {
        if (this.getCloseOnEscape() && (evt.key === 'Escape' || evt.keyCode === 27)) {
          this.close(REASON_DISMISS);
        }
      }
      /**
       * @param {!MouseEvent} evt
       */

    }, {
      key: "handleActionButtonClick",
      value: function handleActionButtonClick(evt) {
        this.close(REASON_ACTION);
      }
      /**
       * @param {!MouseEvent} evt
       */

    }, {
      key: "handleActionIconClick",
      value: function handleActionIconClick(evt) {
        this.close(REASON_DISMISS);
      }
      /** @private */

    }, {
      key: "clearAutoDismissTimer_",
      value: function clearAutoDismissTimer_() {
        clearTimeout(this.autoDismissTimer_);
        this.autoDismissTimer_ = 0;
      }
      /** @private */

    }, {
      key: "handleAnimationTimerEnd_",
      value: function handleAnimationTimerEnd_() {
        this.animationTimer_ = 0;
        this.adapter_.removeClass(cssClasses.OPENING);
        this.adapter_.removeClass(cssClasses.CLOSING);
      }
      /**
       * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
       * @param {Function} callback
       * @private
       */

    }, {
      key: "runNextAnimationFrame_",
      value: function runNextAnimationFrame_(callback) {
        var _this4 = this;

        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
          _this4.animationFrame_ = 0;
          clearTimeout(_this4.animationTimer_);
          _this4.animationTimer_ = setTimeout(callback, 0);
        });
      }
    }]);

    return MDCSnackbarFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
   * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
   */

  /**
   * @param {!Element} element
   * @param {string} selector
   * @return {?Element}
   */
  function closest(element, selector) {
    if (element.closest) {
      return element.closest(selector);
    }

    var el = element;

    while (el) {
      if (matches(el, selector)) {
        return el;
      }

      el = el.parentElement;
    }

    return null;
  }
  /**
   * @param {!Element} element
   * @param {string} selector
   * @return {boolean}
   */


  function matches(element, selector) {
    var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
    return nativeMatches.call(element, selector);
  }

  var SURFACE_SELECTOR = strings.SURFACE_SELECTOR,
      LABEL_SELECTOR = strings.LABEL_SELECTOR,
      ACTION_SELECTOR = strings.ACTION_SELECTOR,
      DISMISS_SELECTOR = strings.DISMISS_SELECTOR,
      OPENING_EVENT = strings.OPENING_EVENT,
      OPENED_EVENT = strings.OPENED_EVENT,
      CLOSING_EVENT = strings.CLOSING_EVENT,
      CLOSED_EVENT = strings.CLOSED_EVENT;

  var MDCSnackbar =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCSnackbar, _MDCComponent);

    _createClass(MDCSnackbar, null, [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCSnackbar(root);
      }
    }]);

    function MDCSnackbar() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCSnackbar);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCSnackbar)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @type {!HTMLElement} */

      _this.surfaceEl_;
      /** @type {!HTMLElement} */

      _this.labelEl_;
      /** @type {!HTMLElement} */

      _this.actionEl_;
      /** @type {function(!HTMLElement, !HTMLElement=): void} */

      _this.announce_;
      /** @private {!Function} */

      _this.handleKeyDown_;
      /** @private {!Function} */

      _this.handleSurfaceClick_;
      return _this;
    }
    /**
     * @param {function(): function(!HTMLElement, !HTMLElement=):void} announceFactory
     */


    _createClass(MDCSnackbar, [{
      key: "initialize",
      value: function initialize() {
        var announceFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {
          return announce;
        };
        this.announce_ = announceFactory();
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        var _this2 = this;

        this.surfaceEl_ =
        /** @type {!HTMLElement} */
        this.root_.querySelector(SURFACE_SELECTOR);
        this.labelEl_ =
        /** @type {!HTMLElement} */
        this.root_.querySelector(LABEL_SELECTOR);
        this.actionEl_ =
        /** @type {!HTMLElement} */
        this.root_.querySelector(ACTION_SELECTOR);

        this.handleKeyDown_ = function (evt) {
          return _this2.foundation_.handleKeyDown(evt);
        };

        this.handleSurfaceClick_ = function (evt) {
          if (_this2.isActionButton_(evt.target)) {
            _this2.foundation_.handleActionButtonClick(evt);
          } else if (_this2.isActionIcon_(evt.target)) {
            _this2.foundation_.handleActionIconClick(evt);
          }
        };

        this.registerKeyDownHandler_(this.handleKeyDown_);
        this.registerSurfaceClickHandler_(this.handleSurfaceClick_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(MDCSnackbar.prototype), "destroy", this).call(this);

        this.deregisterKeyDownHandler_(this.handleKeyDown_);
        this.deregisterSurfaceClickHandler_(this.handleSurfaceClick_);
      }
    }, {
      key: "open",
      value: function open() {
        this.foundation_.open();
      }
      /**
       * @param {string=} reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
       *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
       *     client-specific values may also be used if desired.
       */

    }, {
      key: "close",
      value: function close() {
        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        this.foundation_.close(reason);
      }
      /**
       * @return {!MDCSnackbarFoundation}
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        var _this3 = this;

        /* eslint brace-style: "off" */
        return new MDCSnackbarFoundation({
          addClass: function addClass(className) {
            return _this3.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this3.root_.classList.remove(className);
          },
          announce: function announce() {
            return _this3.announce_(_this3.labelEl_);
          },
          notifyOpening: function notifyOpening() {
            return _this3.emit(OPENING_EVENT, {});
          },
          notifyOpened: function notifyOpened() {
            return _this3.emit(OPENED_EVENT, {});
          },
          notifyClosing: function notifyClosing(reason) {
            return _this3.emit(CLOSING_EVENT, reason ? {
              reason: reason
            } : {});
          },
          notifyClosed: function notifyClosed(reason) {
            return _this3.emit(CLOSED_EVENT, reason ? {
              reason: reason
            } : {});
          }
        });
      }
      /**
       * @return {number}
       */

    }, {
      key: "registerKeyDownHandler_",

      /**
       * @param {!Function} handler
       * @private
       */
      value: function registerKeyDownHandler_(handler) {
        this.listen('keydown', handler);
      }
      /**
       * @param {!Function} handler
       * @private
       */

    }, {
      key: "deregisterKeyDownHandler_",
      value: function deregisterKeyDownHandler_(handler) {
        this.unlisten('keydown', handler);
      }
      /**
       * @param {!Function} handler
       * @private
       */

    }, {
      key: "registerSurfaceClickHandler_",
      value: function registerSurfaceClickHandler_(handler) {
        this.surfaceEl_.addEventListener('click', handler);
      }
      /**
       * @param {!Function} handler
       * @private
       */

    }, {
      key: "deregisterSurfaceClickHandler_",
      value: function deregisterSurfaceClickHandler_(handler) {
        this.surfaceEl_.removeEventListener('click', handler);
      }
      /**
       * @param {!Element} target
       * @return {boolean}
       * @private
       */

    }, {
      key: "isActionButton_",
      value: function isActionButton_(target) {
        return Boolean(closest(target, ACTION_SELECTOR));
      }
      /**
       * @param {!Element} target
       * @return {boolean}
       * @private
       */

    }, {
      key: "isActionIcon_",
      value: function isActionIcon_(target) {
        return Boolean(closest(target, DISMISS_SELECTOR));
      }
    }, {
      key: "timeoutMs",
      get: function get() {
        return this.foundation_.getTimeoutMs();
      }
      /**
       * @param {number} timeoutMs
       */
      ,
      set: function set(timeoutMs) {
        this.foundation_.setTimeoutMs(timeoutMs);
      }
      /**
       * @return {boolean}
       */

    }, {
      key: "closeOnEscape",
      get: function get() {
        return this.foundation_.getCloseOnEscape();
      }
      /**
       * @param {boolean} closeOnEscape
       */
      ,
      set: function set(closeOnEscape) {
        this.foundation_.setCloseOnEscape(closeOnEscape);
      }
      /**
       * @return {boolean}
       */

    }, {
      key: "isOpen",
      get: function get() {
        return this.foundation_.isOpen();
      }
      /**
       * @return {string}
       */

    }, {
      key: "labelText",
      get: function get() {
        return this.labelEl_.textContent;
      }
      /**
       * @param {string} labelText
       */
      ,
      set: function set(labelText) {
        this.labelEl_.textContent = labelText;
      }
      /**
       * @return {string}
       */

    }, {
      key: "actionButtonText",
      get: function get() {
        return this.actionEl_.textContent;
      }
      /**
       * @param {string} actionButtonText
       */
      ,
      set: function set(actionButtonText) {
        this.actionEl_.textContent = actionButtonText;
      }
    }]);

    return MDCSnackbar;
  }(MDCComponent);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcSnackbarComponent = /** @class */ (function () {
      function MdcSnackbarComponent(_changeDetectorRef, elementRef, snackbarRef, data) {
          this._changeDetectorRef = _changeDetectorRef;
          this.elementRef = elementRef;
          this.snackbarRef = snackbarRef;
          this.data = data;
          this._foundation = new MDCSnackbarFoundation(this._createAdapter());
      }
      Object.defineProperty(MdcSnackbarComponent.prototype, "config", {
          get: /**
           * @return {?}
           */
          function () { return this.snackbarRef.componentInstance.snackbarConfig; },
          enumerable: true,
          configurable: true
      });
      /**
       * @private
       * @return {?}
       */
      MdcSnackbarComponent.prototype._createAdapter = /**
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          return {
              addClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getHostElement().classList.add(className); }),
              removeClass: (/**
               * @param {?} className
               * @return {?}
               */
              function (className) { return _this._getHostElement().classList.remove(className); }),
              announce: (/**
               * @return {?}
               */
              function () { return announce(_this.label.nativeElement); }),
              notifyClosed: (/**
               * @param {?} reason
               * @return {?}
               */
              function (reason) { return _this.snackbarRef.dismiss(reason); })
          };
      };
      /**
       * @return {?}
       */
      MdcSnackbarComponent.prototype.ngOnInit = /**
       * @return {?}
       */
      function () {
          this._changeDetectorRef.detectChanges();
          this._applyClasses();
          this._applyConfig();
      };
      /**
       * @return {?}
       */
      MdcSnackbarComponent.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          if (this._foundation) {
              this._foundation.destroy();
          }
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcSnackbarComponent.prototype._onKeydown = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleKeyDown(evt);
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcSnackbarComponent.prototype._onActionClick = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleActionButtonClick(evt);
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcSnackbarComponent.prototype._onActionIconClick = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleActionIconClick(evt);
      };
      /**
       * @return {?}
       */
      MdcSnackbarComponent.prototype.open = /**
       * @return {?}
       */
      function () {
          this._foundation.open();
      };
      /**
       * @param {?=} reason
       * @return {?}
       */
      MdcSnackbarComponent.prototype.close = /**
       * @param {?=} reason
       * @return {?}
       */
      function (reason) {
          this._foundation.close(reason);
      };
      /**
       * @private
       * @return {?}
       */
      MdcSnackbarComponent.prototype._applyClasses = /**
       * @private
       * @return {?}
       */
      function () {
          var _a, _b, _c;
          /** @type {?} */
          var classes = this.config.classes;
          if (classes) {
              if (classes instanceof Array) {
                  (_a = this._getHostElement().classList).add.apply(_a, (/** @type {?} */ (this.config.classes)));
              }
              else {
                  this._getHostElement().classList.toggle(classes);
              }
          }
          /** @type {?} */
          var actionClasses = this.config.actionClasses;
          if (actionClasses && this.action) {
              if (actionClasses instanceof Array) {
                  (_b = this.action.nativeElement.classList).add.apply(_b, (/** @type {?} */ (this.config.actionClasses)));
              }
              else {
                  this.action.nativeElement.classList.toggle(actionClasses);
              }
          }
          if (this.dismiss) {
              /** @type {?} */
              var dismissClasses = this.config.dismissClasses;
              if (dismissClasses) {
                  if (dismissClasses instanceof Array) {
                      (_c = this.dismiss.nativeElement.classList).add.apply(_c, (/** @type {?} */ (this.config.dismissClasses)));
                  }
                  else {
                      this.dismiss.nativeElement.classList.toggle(dismissClasses);
                  }
              }
          }
      };
      /**
       * @private
       * @return {?}
       */
      MdcSnackbarComponent.prototype._applyConfig = /**
       * @private
       * @return {?}
       */
      function () {
          if (this.config.timeoutMs) {
              this._foundation.setTimeoutMs(this.config.timeoutMs);
          }
          if (this.config.dismiss) {
              this._foundation.setCloseOnEscape(this.config.closeOnEscape ? true : false);
          }
      };
      /** Retrieves the DOM element of the component host. */
      /**
       * Retrieves the DOM element of the component host.
       * @private
       * @return {?}
       */
      MdcSnackbarComponent.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @private
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      MdcSnackbarComponent.decorators = [
          { type: core.Component, args: [{selector: 'mdc-snackbar',
                      host: {
                          'class': 'mdc-snackbar',
                          '[dir]': 'this.config.direction',
                          '[class.mdc-snackbar--stacked]': 'config.stacked',
                          '[class.mdc-snackbar--leading]': 'config.leading',
                          '[class.ngx-mdc-snackbar--trailing]': 'config.trailing',
                          '(keydown)': '_onKeydown($event)'
                      },
                      template: "\n  <div #surface class=\"mdc-snackbar__surface\">\n    <div #label class=\"mdc-snackbar__label\"\n      role=\"status\"\n      aria-live=\"polite\">{{data.message}}</div>\n    <div class=\"mdc-snackbar__actions\" *ngIf=\"data.action\">\n      <button #action type=\"button\" class=\"mdc-button mdc-snackbar__action\"\n        (click)=\"_onActionClick($event)\">{{data.action}}</button>\n      <button #dismiss *ngIf=\"config.dismiss\"\n        class=\"mdc-icon-button mdc-snackbar__dismiss material-icons\"\n        title=\"Dismiss\" (click)=\"_onActionIconClick($event)\">close</button>\n    </div>\n  </div>",
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None
                  },] },
      ];
      /** @nocollapse */
      MdcSnackbarComponent.ctorParameters = function () { return [
          { type: core.ChangeDetectorRef },
          { type: core.ElementRef },
          { type: MdcSnackbarRef },
          { type: undefined, decorators: [{ type: core.Inject, args: [MDC_SNACKBAR_DATA,] }] }
      ]; };
      MdcSnackbarComponent.propDecorators = {
          label: [{ type: core.ViewChild, args: ['label',] }],
          action: [{ type: core.ViewChild, args: ['action',] }],
          dismiss: [{ type: core.ViewChild, args: ['dismiss',] }]
      };
      return MdcSnackbarComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcSnackbarContainer = /** @class */ (function (_super) {
      __extends(MdcSnackbarContainer, _super);
      function MdcSnackbarContainer(_ngZone, snackbarConfig) {
          var _this = _super.call(this) || this;
          _this._ngZone = _ngZone;
          _this.snackbarConfig = snackbarConfig;
          /**
           * Subject for notifying that the snackbar has exited from view.
           */
          _this._onExit = new rxjs.Subject();
          return _this;
      }
      /** Attach a component portal as content to this snackbar container. */
      /**
       * Attach a component portal as content to this snackbar container.
       * @template T
       * @param {?} portal
       * @return {?}
       */
      MdcSnackbarContainer.prototype.attachComponentPortal = /**
       * Attach a component portal as content to this snackbar container.
       * @template T
       * @param {?} portal
       * @return {?}
       */
      function (portal) {
          return this._portalOutlet.attachComponentPortal(portal);
      };
      /** Attach a template portal as content to this snackbar container. */
      /**
       * Attach a template portal as content to this snackbar container.
       * @template C
       * @param {?} portal
       * @return {?}
       */
      MdcSnackbarContainer.prototype.attachTemplatePortal = /**
       * Attach a template portal as content to this snackbar container.
       * @template C
       * @param {?} portal
       * @return {?}
       */
      function (portal) {
          return this._portalOutlet.attachTemplatePortal(portal);
      };
      /**
       * @return {?}
       */
      MdcSnackbarContainer.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._completeExit();
      };
      /**
       * Waits for the zone to settle before removing the element. Helps prevent
       * errors where we end up removing an element which is in the middle of an animation.
       */
      /**
       * Waits for the zone to settle before removing the element. Helps prevent
       * errors where we end up removing an element which is in the middle of an animation.
       * @private
       * @return {?}
       */
      MdcSnackbarContainer.prototype._completeExit = /**
       * Waits for the zone to settle before removing the element. Helps prevent
       * errors where we end up removing an element which is in the middle of an animation.
       * @private
       * @return {?}
       */
      function () {
          var _this = this;
          this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1)).subscribe((/**
           * @return {?}
           */
          function () {
              _this._onExit.next();
              _this._onExit.complete();
          }));
      };
      MdcSnackbarContainer.decorators = [
          { type: core.Component, args: [{selector: 'mdc-snackbar-container',
                      template: '<ng-template cdkPortalOutlet></ng-template>',
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None
                  },] },
      ];
      /** @nocollapse */
      MdcSnackbarContainer.ctorParameters = function () { return [
          { type: core.NgZone },
          { type: MdcSnackbarConfig }
      ]; };
      MdcSnackbarContainer.propDecorators = {
          _portalOutlet: [{ type: core.ViewChild, args: [portal.CdkPortalOutlet,] }]
      };
      return MdcSnackbarContainer;
  }(portal.BasePortalOutlet));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MdcSnackbarModule = /** @class */ (function () {
      function MdcSnackbarModule() {
      }
      MdcSnackbarModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          overlay.OverlayModule,
                          portal.PortalModule,
                          button.MdcButtonModule
                      ],
                      exports: [MdcSnackbarContainer],
                      declarations: [MdcSnackbarContainer, MdcSnackbarComponent],
                      entryComponents: [MdcSnackbarContainer, MdcSnackbarComponent]
                  },] },
      ];
      return MdcSnackbarModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to specify default snackbar.
   * @type {?}
   */
  var MDC_SNACKBAR_DEFAULT_OPTIONS = new core.InjectionToken('mdc-snackbar-default-options', {
      providedIn: 'root',
      factory: MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY() {
      return new MdcSnackbarConfig();
  }
  var MdcSnackbar = /** @class */ (function () {
      function MdcSnackbar(_overlay, _injector, _parentSnackBar, _defaultConfig) {
          this._overlay = _overlay;
          this._injector = _injector;
          this._parentSnackBar = _parentSnackBar;
          this._defaultConfig = _defaultConfig;
          /**
           * Reference to the current snackbar in the view *at this level* (in the Angular injector tree).
           * If there is a parent snack-bar service, all operations should delegate to that parent
           * via `_openedSnackBarRef`.
           */
          this._snackBarRefAtThisLevel = null;
      }
      Object.defineProperty(MdcSnackbar.prototype, "_openedSnackbarRef", {
          /** Reference to the currently opened snackbar at *any* level. */
          get: /**
           * Reference to the currently opened snackbar at *any* level.
           * @return {?}
           */
          function () {
              /** @type {?} */
              var parent = this._parentSnackBar;
              return parent ? parent._openedSnackbarRef : this._snackBarRefAtThisLevel;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              if (this._parentSnackBar) {
                  this._parentSnackBar._openedSnackbarRef = value;
              }
              else {
                  this._snackBarRefAtThisLevel = value;
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Creates and dispatches a snackbar with a custom component for the content, removing any
       * currently opened snackbars.
       *
       * @param component Component to be instantiated.
       * @param config Extra configuration for the snackbar.
       */
      /**
       * Creates and dispatches a snackbar with a custom component for the content, removing any
       * currently opened snackbars.
       *
       * @template T
       * @param {?} component Component to be instantiated.
       * @param {?=} config Extra configuration for the snackbar.
       * @return {?}
       */
      MdcSnackbar.prototype.openFromComponent = /**
       * Creates and dispatches a snackbar with a custom component for the content, removing any
       * currently opened snackbars.
       *
       * @template T
       * @param {?} component Component to be instantiated.
       * @param {?=} config Extra configuration for the snackbar.
       * @return {?}
       */
      function (component, config) {
          return (/** @type {?} */ (this._attach(component, config)));
      };
      /**
       * Opens a snackbar with a message and an optional action.
       * @param message Message text.
       * @param action The label for the snackbar action.
       * @param config Additional configuration options for the snackbar.
       */
      /**
       * Opens a snackbar with a message and an optional action.
       * @param {?} message Message text.
       * @param {?=} action The label for the snackbar action.
       * @param {?=} config Additional configuration options for the snackbar.
       * @return {?}
       */
      MdcSnackbar.prototype.open = /**
       * Opens a snackbar with a message and an optional action.
       * @param {?} message Message text.
       * @param {?=} action The label for the snackbar action.
       * @param {?=} config Additional configuration options for the snackbar.
       * @return {?}
       */
      function (message, action, config) {
          if (action === void 0) { action = ''; }
          /** @type {?} */
          var _config = _assign({}, this._defaultConfig, config);
          // Since the user doesn't have access to the component, we can
          // override the data to pass in our own message and action.
          _config.data = { message: message, action: action };
          return this.openFromComponent(MdcSnackbarComponent, _config);
      };
      /**
       * Dismisses the currently-visible snackbar.
       */
      /**
       * Dismisses the currently-visible snackbar.
       * @return {?}
       */
      MdcSnackbar.prototype.dismiss = /**
       * Dismisses the currently-visible snackbar.
       * @return {?}
       */
      function () {
          if (this._openedSnackbarRef) {
              if (this._openedSnackbarRef.instance instanceof MdcSnackbarComponent) {
                  ((/** @type {?} */ (this._openedSnackbarRef.instance))).close();
              }
              this._openedSnackbarRef.dismiss();
          }
      };
      /**
       * @return {?}
       */
      MdcSnackbar.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          // Only dismiss the snackbar at the current level on destroy.
          if (this._snackBarRefAtThisLevel) {
              this._snackBarRefAtThisLevel.dismiss();
          }
      };
      /**
       * Attaches the snackbar container component to the overlay.
       */
      /**
       * Attaches the snackbar container component to the overlay.
       * @private
       * @param {?} overlayRef
       * @param {?} config
       * @return {?}
       */
      MdcSnackbar.prototype._attachSnackbarContainer = /**
       * Attaches the snackbar container component to the overlay.
       * @private
       * @param {?} overlayRef
       * @param {?} config
       * @return {?}
       */
      function (overlayRef, config) {
          /** @type {?} */
          var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
          /** @type {?} */
          var injector = new portal.PortalInjector(userInjector || this._injector, new WeakMap([
              [MdcSnackbarConfig, config]
          ]));
          /** @type {?} */
          var containerPortal = new portal.ComponentPortal(MdcSnackbarContainer, config.viewContainerRef, injector);
          /** @type {?} */
          var containerRef = overlayRef.attach(containerPortal);
          containerRef.instance.snackbarConfig = config;
          return containerRef.instance;
      };
      /**
       * Places a new component or a template as the content of the snackbar container.
       */
      /**
       * Places a new component or a template as the content of the snackbar container.
       * @private
       * @template T
       * @param {?} content
       * @param {?=} userConfig
       * @return {?}
       */
      MdcSnackbar.prototype._attach = /**
       * Places a new component or a template as the content of the snackbar container.
       * @private
       * @template T
       * @param {?} content
       * @param {?=} userConfig
       * @return {?}
       */
      function (content, userConfig) {
          /** @type {?} */
          var config = _assign({}, new MdcSnackbarConfig(), this._defaultConfig, userConfig);
          /** @type {?} */
          var overlayRef = this._createOverlay();
          /** @type {?} */
          var container = this._attachSnackbarContainer(overlayRef, config);
          /** @type {?} */
          var snackbarRef = new MdcSnackbarRef(container, overlayRef);
          /** @type {?} */
          var injector = this._createInjector(config, snackbarRef);
          /** @type {?} */
          var portal$1 = new portal.ComponentPortal(content, undefined, injector);
          /** @type {?} */
          var contentRef = container.attachComponentPortal(portal$1);
          // We can't pass this via the injector, because the injector is created earlier.
          snackbarRef.instance = contentRef.instance;
          this._loadListeners(snackbarRef);
          this._openedSnackbarRef = snackbarRef;
          if (snackbarRef.instance instanceof MdcSnackbarComponent) {
              ((/** @type {?} */ (snackbarRef.instance))).open();
          }
          return this._openedSnackbarRef;
      };
      /**
       * @private
       * @param {?} snackbarRef
       * @return {?}
       */
      MdcSnackbar.prototype._loadListeners = /**
       * @private
       * @param {?} snackbarRef
       * @return {?}
       */
      function (snackbarRef) {
          var _this = this;
          // When the snackbar is dismissed, clear the reference to it.
          snackbarRef.afterDismiss().subscribe((/**
           * @return {?}
           */
          function () {
              // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
              if (_this._openedSnackbarRef === snackbarRef) {
                  _this._openedSnackbarRef = null;
              }
          }));
          if (this._openedSnackbarRef) {
              this._openedSnackbarRef.dismiss();
          }
      };
      /**
       * Creates a new overlay and places it in the correct location.
       * @param config The user-specified snackbar config.
       */
      /**
       * Creates a new overlay and places it in the correct location.
       * @private
       * @return {?}
       */
      MdcSnackbar.prototype._createOverlay = /**
       * Creates a new overlay and places it in the correct location.
       * @private
       * @return {?}
       */
      function () {
          return this._overlay.create();
      };
      /**
       * Creates an injector to be used inside of a snackbar component.
       * @param config Config that was used to create the snackbar.
       * @param snackbarRef Reference to the snackbar.
       */
      /**
       * Creates an injector to be used inside of a snackbar component.
       * @private
       * @template T
       * @param {?} config Config that was used to create the snackbar.
       * @param {?} snackbarRef Reference to the snackbar.
       * @return {?}
       */
      MdcSnackbar.prototype._createInjector = /**
       * Creates an injector to be used inside of a snackbar component.
       * @private
       * @template T
       * @param {?} config Config that was used to create the snackbar.
       * @param {?} snackbarRef Reference to the snackbar.
       * @return {?}
       */
      function (config, snackbarRef) {
          /** @type {?} */
          var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
          return new portal.PortalInjector(userInjector || this._injector, new WeakMap([
              [MdcSnackbarRef, snackbarRef],
              [MDC_SNACKBAR_DATA, config.data]
          ]));
      };
      MdcSnackbar.decorators = [
          { type: core.Injectable, args: [{ providedIn: MdcSnackbarModule },] },
      ];
      /** @nocollapse */
      MdcSnackbar.ctorParameters = function () { return [
          { type: overlay.Overlay },
          { type: core.Injector },
          { type: MdcSnackbar, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
          { type: MdcSnackbarConfig, decorators: [{ type: core.Inject, args: [MDC_SNACKBAR_DEFAULT_OPTIONS,] }] }
      ]; };
      /** @nocollapse */ MdcSnackbar.ngInjectableDef = core.defineInjectable({ factory: function MdcSnackbar_Factory() { return new MdcSnackbar(core.inject(overlay.Overlay), core.inject(core.INJECTOR), core.inject(MdcSnackbar, 12), core.inject(MDC_SNACKBAR_DEFAULT_OPTIONS)); }, token: MdcSnackbar, providedIn: MdcSnackbarModule });
      return MdcSnackbar;
  }());

  exports.MdcSnackbarModule = MdcSnackbarModule;
  exports.MdcSnackbarContainer = MdcSnackbarContainer;
  exports.MDC_SNACKBAR_DATA = MDC_SNACKBAR_DATA;
  exports.MdcSnackbarConfig = MdcSnackbarConfig;
  exports.MdcSnackbarRef = MdcSnackbarRef;
  exports.MdcSnackbarComponent = MdcSnackbarComponent;
  exports.MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY = MDC_SNACKBAR_DEFAULT_OPTIONS_FACTORY;
  exports.MDC_SNACKBAR_DEFAULT_OPTIONS = MDC_SNACKBAR_DEFAULT_OPTIONS;
  exports.MdcSnackbar = MdcSnackbar;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=web-snackbar.umd.js.map
