/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { isFunction } from './isFunction';
import { hasEntity } from './hasEntity';
import { isPlainObject } from './isPlainObject';
// @internal
/**
 * @template S, E
 * @param {?} __0
 * @return {?}
 */
export function updateEntities(_a) {
    var state = _a.state, ids = _a.ids, idKey = _a.idKey, newStateOrFn = _a.newStateOrFn, preUpdateEntity = _a.preUpdateEntity;
    var e_1, _b;
    /** @type {?} */
    var updatedEntities = {};
    /** @type {?} */
    var isUpdatingIdKey = false;
    /** @type {?} */
    var idToUpdate;
    try {
        for (var ids_1 = tslib_1.__values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            // if the entity doesn't exist don't do anything
            if (hasEntity(state.entities, id) === false) {
                continue;
            }
            /** @type {?} */
            var oldEntity = state.entities[id];
            /** @type {?} */
            var newState = isFunction(newStateOrFn) ? newStateOrFn(oldEntity) : newStateOrFn;
            /** @type {?} */
            var isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];
            /** @type {?} */
            var newEntity = void 0;
            idToUpdate = id;
            if (isIdChanged) {
                isUpdatingIdKey = true;
                idToUpdate = newState[idKey];
            }
            /** @type {?} */
            var merged = tslib_1.__assign({}, oldEntity, newState);
            if (isPlainObject(oldEntity)) {
                newEntity = merged;
            }
            else {
                /**
                 * In case that new state is class of it's own, there's
                 * a possibility that it will be different than the old
                 * class.
                 * For example, Old state is an instance of animal class
                 * and new state is instance of person class.
                 * To avoid run over new person class with the old animal
                 * class we check if the new state is a class of it's own.
                 * If so, use it. Otherwise, use the old state class
                 */
                if (isPlainObject(newState)) {
                    newEntity = new ((/** @type {?} */ (oldEntity))).constructor(merged);
                }
                else {
                    newEntity = new ((/** @type {?} */ (newState))).constructor(merged);
                }
            }
            updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ids_1_1 && !ids_1_1.done && (_b = ids_1.return)) _b.call(ids_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /** @type {?} */
    var updatedIds = state.ids;
    /** @type {?} */
    var stateEntities = state.entities;
    if (isUpdatingIdKey) {
        var _c = tslib_1.__read(ids, 1), id_1 = _c[0];
        var _d = state.entities, _e = id_1, deletedEntity = _d[_e], rest = tslib_1.__rest(_d, [typeof _e === "symbol" ? _e : _e + ""]);
        stateEntities = rest;
        updatedIds = state.ids.map((/**
         * @param {?} current
         * @return {?}
         */
        function (current) { return (current === id_1 ? idToUpdate : current); }));
    }
    return tslib_1.__assign({}, state, { entities: tslib_1.__assign({}, stateEntities, updatedEntities), ids: updatedIds });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlRW50aXRpZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZGF0b3JhbWEvYWtpdGEvIiwic291cmNlcyI6WyJzcmMvdXBkYXRlRW50aXRpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7O0FBV2hELE1BQU0sVUFBVSxjQUFjLENBQThCLEVBQWdGO1FBQTlFLGdCQUFLLEVBQUUsWUFBRyxFQUFFLGdCQUFLLEVBQUUsOEJBQVksRUFBRSxvQ0FBZTs7O1FBQ3RHLGVBQWUsR0FBRyxFQUFFOztRQUV0QixlQUFlLEdBQUcsS0FBSzs7UUFDdkIsVUFBYzs7UUFFbEIsS0FBaUIsSUFBQSxRQUFBLGlCQUFBLEdBQUcsQ0FBQSx3QkFBQSx5Q0FBRTtZQUFqQixJQUFNLEVBQUUsZ0JBQUE7WUFDWCxnREFBZ0Q7WUFDaEQsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsS0FBSyxLQUFLLEVBQUU7Z0JBQzNDLFNBQVM7YUFDVjs7Z0JBRUssU0FBUyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDOztnQkFDOUIsUUFBUSxHQUFHLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZOztnQkFFNUUsV0FBVyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUM7O2dCQUN0RixTQUFTLFNBQUc7WUFDaEIsVUFBVSxHQUFHLEVBQUUsQ0FBQztZQUVoQixJQUFJLFdBQVcsRUFBRTtnQkFDZixlQUFlLEdBQUcsSUFBSSxDQUFDO2dCQUN2QixVQUFVLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzlCOztnQkFFSyxNQUFNLHdCQUNQLFNBQVMsRUFDVCxRQUFRLENBQ1o7WUFFRCxJQUFJLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDNUIsU0FBUyxHQUFHLE1BQU0sQ0FBQzthQUNwQjtpQkFBTTtnQkFDTDs7Ozs7Ozs7O21CQVNHO2dCQUNILElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQyxFQUFFO29CQUMzQixTQUFTLEdBQUcsSUFBSSxDQUFDLG1CQUFBLFNBQVMsRUFBTyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUN4RDtxQkFBTTtvQkFDTCxTQUFTLEdBQUcsSUFBSSxDQUFDLG1CQUFBLFFBQVEsRUFBTyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUN2RDthQUNGO1lBRUQsZUFBZSxDQUFDLFVBQVUsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDckU7Ozs7Ozs7Ozs7UUFFRyxVQUFVLEdBQUcsS0FBSyxDQUFDLEdBQUc7O1FBQ3RCLGFBQWEsR0FBRyxLQUFLLENBQUMsUUFBUTtJQUVsQyxJQUFJLGVBQWUsRUFBRTtRQUNiLElBQUEsMkJBQVUsRUFBVCxZQUFTO1lBQ1YsbUJBQWlELEVBQS9DLFNBQUksRUFBSixzQkFBbUIsRUFBRSxrRUFBTztRQUNwQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLFVBQVUsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUc7Ozs7UUFBQyxVQUFBLE9BQU8sSUFBSSxPQUFBLENBQUMsT0FBTyxLQUFLLElBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBdkMsQ0FBdUMsRUFBQyxDQUFDO0tBQ2hGO0lBRUQsNEJBQ0ssS0FBSyxJQUNSLFFBQVEsdUJBQ0gsYUFBYSxFQUNiLGVBQWUsR0FFcEIsR0FBRyxFQUFFLFVBQVUsSUFDZjtBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnRpdHlTdGF0ZSwgSUQsIFByZVVwZGF0ZUVudGl0eSwgVXBkYXRlU3RhdGVDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBoYXNFbnRpdHkgfSBmcm9tICcuL2hhc0VudGl0eSc7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9pc1BsYWluT2JqZWN0JztcblxuZXhwb3J0IHR5cGUgVXBkYXRlRW50aXRpZXNQYXJhbXM8U3RhdGUsIEVudGl0eT4gPSB7XG4gIHN0YXRlOiBTdGF0ZTtcbiAgaWRzOiBhbnlbXTtcbiAgaWRLZXk6IHN0cmluZztcbiAgbmV3U3RhdGVPckZuOiBVcGRhdGVTdGF0ZUNhbGxiYWNrPEVudGl0eT4gfCBQYXJ0aWFsPEVudGl0eT4gfCBQYXJ0aWFsPFN0YXRlPjtcbiAgcHJlVXBkYXRlRW50aXR5OiBQcmVVcGRhdGVFbnRpdHk8RW50aXR5Pjtcbn07XG5cbi8vIEBpbnRlcm5hbFxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUVudGl0aWVzPFMgZXh0ZW5kcyBFbnRpdHlTdGF0ZTxFPiwgRT4oeyBzdGF0ZSwgaWRzLCBpZEtleSwgbmV3U3RhdGVPckZuLCBwcmVVcGRhdGVFbnRpdHkgfTogVXBkYXRlRW50aXRpZXNQYXJhbXM8UywgRT4pIHtcbiAgY29uc3QgdXBkYXRlZEVudGl0aWVzID0ge307XG5cbiAgbGV0IGlzVXBkYXRpbmdJZEtleSA9IGZhbHNlO1xuICBsZXQgaWRUb1VwZGF0ZTogSUQ7XG5cbiAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAvLyBpZiB0aGUgZW50aXR5IGRvZXNuJ3QgZXhpc3QgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiAoaGFzRW50aXR5KHN0YXRlLmVudGl0aWVzLCBpZCkgPT09IGZhbHNlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRFbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1tpZF07XG4gICAgY29uc3QgbmV3U3RhdGUgPSBpc0Z1bmN0aW9uKG5ld1N0YXRlT3JGbikgPyBuZXdTdGF0ZU9yRm4ob2xkRW50aXR5KSA6IG5ld1N0YXRlT3JGbjtcblxuICAgIGNvbnN0IGlzSWRDaGFuZ2VkID0gbmV3U3RhdGUuaGFzT3duUHJvcGVydHkoaWRLZXkpICYmIG5ld1N0YXRlW2lkS2V5XSAhPT0gb2xkRW50aXR5W2lkS2V5XTtcbiAgICBsZXQgbmV3RW50aXR5OiBFO1xuICAgIGlkVG9VcGRhdGUgPSBpZDtcblxuICAgIGlmIChpc0lkQ2hhbmdlZCkge1xuICAgICAgaXNVcGRhdGluZ0lkS2V5ID0gdHJ1ZTtcbiAgICAgIGlkVG9VcGRhdGUgPSBuZXdTdGF0ZVtpZEtleV07XG4gICAgfVxuXG4gICAgY29uc3QgbWVyZ2VkID0ge1xuICAgICAgLi4ub2xkRW50aXR5LFxuICAgICAgLi4ubmV3U3RhdGVcbiAgICB9O1xuXG4gICAgaWYgKGlzUGxhaW5PYmplY3Qob2xkRW50aXR5KSkge1xuICAgICAgbmV3RW50aXR5ID0gbWVyZ2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKipcbiAgICAgICAqIEluIGNhc2UgdGhhdCBuZXcgc3RhdGUgaXMgY2xhc3Mgb2YgaXQncyBvd24sIHRoZXJlJ3NcbiAgICAgICAqIGEgcG9zc2liaWxpdHkgdGhhdCBpdCB3aWxsIGJlIGRpZmZlcmVudCB0aGFuIHRoZSBvbGRcbiAgICAgICAqIGNsYXNzLlxuICAgICAgICogRm9yIGV4YW1wbGUsIE9sZCBzdGF0ZSBpcyBhbiBpbnN0YW5jZSBvZiBhbmltYWwgY2xhc3NcbiAgICAgICAqIGFuZCBuZXcgc3RhdGUgaXMgaW5zdGFuY2Ugb2YgcGVyc29uIGNsYXNzLlxuICAgICAgICogVG8gYXZvaWQgcnVuIG92ZXIgbmV3IHBlcnNvbiBjbGFzcyB3aXRoIHRoZSBvbGQgYW5pbWFsXG4gICAgICAgKiBjbGFzcyB3ZSBjaGVjayBpZiB0aGUgbmV3IHN0YXRlIGlzIGEgY2xhc3Mgb2YgaXQncyBvd24uXG4gICAgICAgKiBJZiBzbywgdXNlIGl0LiBPdGhlcndpc2UsIHVzZSB0aGUgb2xkIHN0YXRlIGNsYXNzXG4gICAgICAgKi9cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG5ld1N0YXRlKSkge1xuICAgICAgICBuZXdFbnRpdHkgPSBuZXcgKG9sZEVudGl0eSBhcyBhbnkpLmNvbnN0cnVjdG9yKG1lcmdlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdFbnRpdHkgPSBuZXcgKG5ld1N0YXRlIGFzIGFueSkuY29uc3RydWN0b3IobWVyZ2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVkRW50aXRpZXNbaWRUb1VwZGF0ZV0gPSBwcmVVcGRhdGVFbnRpdHkob2xkRW50aXR5LCBuZXdFbnRpdHkpO1xuICB9XG5cbiAgbGV0IHVwZGF0ZWRJZHMgPSBzdGF0ZS5pZHM7XG4gIGxldCBzdGF0ZUVudGl0aWVzID0gc3RhdGUuZW50aXRpZXM7XG5cbiAgaWYgKGlzVXBkYXRpbmdJZEtleSkge1xuICAgIGNvbnN0IFtpZF0gPSBpZHM7XG4gICAgY29uc3QgeyBbaWRdOiBkZWxldGVkRW50aXR5LCAuLi5yZXN0IH0gPSBzdGF0ZS5lbnRpdGllcztcbiAgICBzdGF0ZUVudGl0aWVzID0gcmVzdDtcbiAgICB1cGRhdGVkSWRzID0gc3RhdGUuaWRzLm1hcChjdXJyZW50ID0+IChjdXJyZW50ID09PSBpZCA/IGlkVG9VcGRhdGUgOiBjdXJyZW50KSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVudGl0aWVzOiB7XG4gICAgICAuLi5zdGF0ZUVudGl0aWVzLFxuICAgICAgLi4udXBkYXRlZEVudGl0aWVzXG4gICAgfSxcbiAgICBpZHM6IHVwZGF0ZWRJZHNcbiAgfTtcbn1cbiJdfQ==